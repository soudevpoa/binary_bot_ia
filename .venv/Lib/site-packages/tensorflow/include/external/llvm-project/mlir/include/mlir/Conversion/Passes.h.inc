/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ARITHTOAMDGPUCONVERSIONPASS
#define GEN_PASS_DECL_ARITHTOARMSMECONVERSIONPASS
#define GEN_PASS_DECL_ARITHTOLLVMCONVERSIONPASS
#define GEN_PASS_DECL_CONVERTAMDGPUTOROCDLPASS
#define GEN_PASS_DECL_CONVERTAFFINEFORTOGPUPASS
#define GEN_PASS_DECL_CONVERTARITHTOEMITC
#define GEN_PASS_DECL_CONVERTARITHTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTARMNEON2DTOINTRPASS
#define GEN_PASS_DECL_CONVERTARMSMETOLLVM
#define GEN_PASS_DECL_CONVERTARMSMETOSCFPASS
#define GEN_PASS_DECL_CONVERTASYNCTOLLVMPASS
#define GEN_PASS_DECL_CONVERTBUFFERIZATIONTOMEMREFPASS
#define GEN_PASS_DECL_CONVERTCOMPLEXTOLLVMPASS
#define GEN_PASS_DECL_CONVERTCOMPLEXTOLIBM
#define GEN_PASS_DECL_CONVERTCOMPLEXTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTCOMPLEXTOSTANDARDPASS
#define GEN_PASS_DECL_CONVERTCONTROLFLOWTOLLVMPASS
#define GEN_PASS_DECL_CONVERTCONTROLFLOWTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTFUNCTOEMITC
#define GEN_PASS_DECL_CONVERTFUNCTOLLVMPASS
#define GEN_PASS_DECL_CONVERTFUNCTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTGPUTOSPIRV
#define GEN_PASS_DECL_CONVERTGPUOPSTOLLVMSPVOPS
#define GEN_PASS_DECL_CONVERTGPUOPSTONVVMOPS
#define GEN_PASS_DECL_CONVERTGPUOPSTOROCDLOPS
#define GEN_PASS_DECL_CONVERTINDEXTOLLVMPASS
#define GEN_PASS_DECL_CONVERTINDEXTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTLINALGTOSTANDARDPASS
#define GEN_PASS_DECL_CONVERTMATHTOEMITC
#define GEN_PASS_DECL_CONVERTMATHTOFUNCS
#define GEN_PASS_DECL_CONVERTMATHTOLLVMPASS
#define GEN_PASS_DECL_CONVERTMATHTOLIBMPASS
#define GEN_PASS_DECL_CONVERTMATHTOROCDL
#define GEN_PASS_DECL_CONVERTMATHTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTMEMREFTOEMITC
#define GEN_PASS_DECL_CONVERTMEMREFTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTMESHTOMPIPASS
#define GEN_PASS_DECL_CONVERTNVGPUTONVVMPASS
#define GEN_PASS_DECL_CONVERTNVVMTOLLVMPASS
#define GEN_PASS_DECL_CONVERTOPENACCTOSCFPASS
#define GEN_PASS_DECL_CONVERTOPENMPTOLLVMPASS
#define GEN_PASS_DECL_CONVERTPDLTOPDLINTERPPASS
#define GEN_PASS_DECL_CONVERTPARALLELLOOPTOGPUPASS
#define GEN_PASS_DECL_CONVERTSCFTOOPENMPPASS
#define GEN_PASS_DECL_CONVERTSPIRVTOLLVMPASS
#define GEN_PASS_DECL_CONVERTSHAPECONSTRAINTSPASS
#define GEN_PASS_DECL_CONVERTSHAPETOSTANDARDPASS
#define GEN_PASS_DECL_CONVERTTENSORTOLINALGPASS
#define GEN_PASS_DECL_CONVERTTENSORTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTTOEMITC
#define GEN_PASS_DECL_CONVERTTOLLVMPASS
#define GEN_PASS_DECL_CONVERTVECTORTOARMSMEPASS
#define GEN_PASS_DECL_CONVERTVECTORTOGPU
#define GEN_PASS_DECL_CONVERTVECTORTOLLVMPASS
#define GEN_PASS_DECL_CONVERTVECTORTOSCF
#define GEN_PASS_DECL_CONVERTVECTORTOSPIRVPASS
#define GEN_PASS_DECL_CONVERTVECTORTOXEGPU
#define GEN_PASS_DECL_FINALIZEMEMREFTOLLVMCONVERSIONPASS
#define GEN_PASS_DECL_GPUTOLLVMCONVERSIONPASS
#define GEN_PASS_DECL_LIFTCONTROLFLOWTOSCFPASS
#define GEN_PASS_DECL_LOWERAFFINEPASS
#define GEN_PASS_DECL_LOWERHOSTCODETOLLVMPASS
#define GEN_PASS_DECL_MAPMEMREFSTORAGECLASS
#define GEN_PASS_DECL_RECONCILEUNREALIZEDCASTSPASS
#define GEN_PASS_DECL_SCFTOCONTROLFLOWPASS
#define GEN_PASS_DECL_SCFTOEMITC
#define GEN_PASS_DECL_SCFTOSPIRV
#define GEN_PASS_DECL_SETLLVMMODULEDATALAYOUTPASS
#define GEN_PASS_DECL_TOSATOARITHPASS
#define GEN_PASS_DECL_TOSATOLINALG
#define GEN_PASS_DECL_TOSATOLINALGNAMED
#define GEN_PASS_DECL_TOSATOMLPROGRAM
#define GEN_PASS_DECL_TOSATOSCFPASS
#define GEN_PASS_DECL_TOSATOTENSORPASS
#define GEN_PASS_DECL_UBTOLLVMCONVERSIONPASS
#define GEN_PASS_DECL_UBTOSPIRVCONVERSIONPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ArithToAMDGPUConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ARITHTOAMDGPUCONVERSIONPASS
struct ArithToAMDGPUConversionPassOptions {
  std::string chipset = "gfx000";
  bool saturateFP8Truncf = false;
  bool allowPackedF16Rtz = false;
};
std::unique_ptr<::mlir::Pass> createArithToAMDGPUConversionPass();
std::unique_ptr<::mlir::Pass> createArithToAMDGPUConversionPass(ArithToAMDGPUConversionPassOptions options);
#undef GEN_PASS_DECL_ARITHTOAMDGPUCONVERSIONPASS
#endif // GEN_PASS_DECL_ARITHTOAMDGPUCONVERSIONPASS
#ifdef GEN_PASS_DEF_ARITHTOAMDGPUCONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createArithToAMDGPUConversionPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createArithToAMDGPUConversionPass(ArithToAMDGPUConversionPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ArithToAMDGPUConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ArithToAMDGPUConversionPassBase;

  ArithToAMDGPUConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ArithToAMDGPUConversionPassBase(const ArithToAMDGPUConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  ArithToAMDGPUConversionPassBase& operator=(const ArithToAMDGPUConversionPassBase &) = delete;
  ArithToAMDGPUConversionPassBase(ArithToAMDGPUConversionPassBase &&) = delete;
  ArithToAMDGPUConversionPassBase& operator=(ArithToAMDGPUConversionPassBase &&) = delete;
  ~ArithToAMDGPUConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-amdgpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-amdgpu"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith operations to AMDGPU-specific implementations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArithToAMDGPUConversionPass");
  }
  ::llvm::StringRef getName() const override { return "ArithToAMDGPUConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<amdgpu::AMDGPUDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArithToAMDGPUConversionPassBase<DerivedT>)

  ArithToAMDGPUConversionPassBase(ArithToAMDGPUConversionPassOptions options) : ArithToAMDGPUConversionPassBase() {
    chipset = std::move(options.chipset);
    saturateFP8Truncf = std::move(options.saturateFP8Truncf);
    allowPackedF16Rtz = std::move(options.allowPackedF16Rtz);
  }
protected:
  ::mlir::Pass::Option<std::string> chipset{*this, "chipset", ::llvm::cl::desc("Chipset that these operations will run on"), ::llvm::cl::init("gfx000")};
  ::mlir::Pass::Option<bool> saturateFP8Truncf{*this, "saturate-fp8-truncf", ::llvm::cl::desc("Use saturating truncation for 8-bit float types"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> allowPackedF16Rtz{*this, "allow-packed-f16-round-to-zero", ::llvm::cl::desc("Whether we should allow f32->f16 packed round-to-zero conversion"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createArithToAMDGPUConversionPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createArithToAMDGPUConversionPass(ArithToAMDGPUConversionPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createArithToAMDGPUConversionPass() {
  return impl::createArithToAMDGPUConversionPass();
}

std::unique_ptr<::mlir::Pass> createArithToAMDGPUConversionPass(ArithToAMDGPUConversionPassOptions options) {
  return impl::createArithToAMDGPUConversionPass(std::move(options));
}
#undef GEN_PASS_DEF_ARITHTOAMDGPUCONVERSIONPASS
#endif // GEN_PASS_DEF_ARITHTOAMDGPUCONVERSIONPASS

//===----------------------------------------------------------------------===//
// ArithToArmSMEConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ARITHTOARMSMECONVERSIONPASS
std::unique_ptr<::mlir::Pass> createArithToArmSMEConversionPass();
#undef GEN_PASS_DECL_ARITHTOARMSMECONVERSIONPASS
#endif // GEN_PASS_DECL_ARITHTOARMSMECONVERSIONPASS
#ifdef GEN_PASS_DEF_ARITHTOARMSMECONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createArithToArmSMEConversionPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ArithToArmSMEConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ArithToArmSMEConversionPassBase;

  ArithToArmSMEConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ArithToArmSMEConversionPassBase(const ArithToArmSMEConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  ArithToArmSMEConversionPassBase& operator=(const ArithToArmSMEConversionPassBase &) = delete;
  ArithToArmSMEConversionPassBase(ArithToArmSMEConversionPassBase &&) = delete;
  ArithToArmSMEConversionPassBase& operator=(ArithToArmSMEConversionPassBase &&) = delete;
  ~ArithToArmSMEConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-arm-sme");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-arm-sme"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith dialect to ArmSME dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArithToArmSMEConversionPass");
  }
  ::llvm::StringRef getName() const override { return "ArithToArmSMEConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arm_sme::ArmSMEDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArithToArmSMEConversionPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createArithToArmSMEConversionPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createArithToArmSMEConversionPass() {
  return impl::createArithToArmSMEConversionPass();
}
#undef GEN_PASS_DEF_ARITHTOARMSMECONVERSIONPASS
#endif // GEN_PASS_DEF_ARITHTOARMSMECONVERSIONPASS

//===----------------------------------------------------------------------===//
// ArithToLLVMConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ARITHTOLLVMCONVERSIONPASS
struct ArithToLLVMConversionPassOptions {
  unsigned indexBitwidth = 0;
};
std::unique_ptr<::mlir::Pass> createArithToLLVMConversionPass();
std::unique_ptr<::mlir::Pass> createArithToLLVMConversionPass(ArithToLLVMConversionPassOptions options);
#undef GEN_PASS_DECL_ARITHTOLLVMCONVERSIONPASS
#endif // GEN_PASS_DECL_ARITHTOLLVMCONVERSIONPASS
#ifdef GEN_PASS_DEF_ARITHTOLLVMCONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createArithToLLVMConversionPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createArithToLLVMConversionPass(ArithToLLVMConversionPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ArithToLLVMConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ArithToLLVMConversionPassBase;

  ArithToLLVMConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ArithToLLVMConversionPassBase(const ArithToLLVMConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  ArithToLLVMConversionPassBase& operator=(const ArithToLLVMConversionPassBase &) = delete;
  ArithToLLVMConversionPassBase(ArithToLLVMConversionPassBase &&) = delete;
  ArithToLLVMConversionPassBase& operator=(ArithToLLVMConversionPassBase &&) = delete;
  ~ArithToLLVMConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArithToLLVMConversionPass");
  }
  ::llvm::StringRef getName() const override { return "ArithToLLVMConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArithToLLVMConversionPassBase<DerivedT>)

  ArithToLLVMConversionPassBase(ArithToLLVMConversionPassOptions options) : ArithToLLVMConversionPassBase() {
    indexBitwidth = std::move(options.indexBitwidth);
  }
protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createArithToLLVMConversionPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createArithToLLVMConversionPass(ArithToLLVMConversionPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createArithToLLVMConversionPass() {
  return impl::createArithToLLVMConversionPass();
}

std::unique_ptr<::mlir::Pass> createArithToLLVMConversionPass(ArithToLLVMConversionPassOptions options) {
  return impl::createArithToLLVMConversionPass(std::move(options));
}
#undef GEN_PASS_DEF_ARITHTOLLVMCONVERSIONPASS
#endif // GEN_PASS_DEF_ARITHTOLLVMCONVERSIONPASS

//===----------------------------------------------------------------------===//
// ConvertAMDGPUToROCDLPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTAMDGPUTOROCDLPASS
struct ConvertAMDGPUToROCDLPassOptions {
  std::string chipset = "gfx000";
};
std::unique_ptr<::mlir::Pass> createConvertAMDGPUToROCDLPass();
std::unique_ptr<::mlir::Pass> createConvertAMDGPUToROCDLPass(ConvertAMDGPUToROCDLPassOptions options);
#undef GEN_PASS_DECL_CONVERTAMDGPUTOROCDLPASS
#endif // GEN_PASS_DECL_CONVERTAMDGPUTOROCDLPASS
#ifdef GEN_PASS_DEF_CONVERTAMDGPUTOROCDLPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertAMDGPUToROCDLPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertAMDGPUToROCDLPass(ConvertAMDGPUToROCDLPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertAMDGPUToROCDLPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertAMDGPUToROCDLPassBase;

  ConvertAMDGPUToROCDLPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertAMDGPUToROCDLPassBase(const ConvertAMDGPUToROCDLPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertAMDGPUToROCDLPassBase& operator=(const ConvertAMDGPUToROCDLPassBase &) = delete;
  ConvertAMDGPUToROCDLPassBase(ConvertAMDGPUToROCDLPassBase &&) = delete;
  ConvertAMDGPUToROCDLPassBase& operator=(ConvertAMDGPUToROCDLPassBase &&) = delete;
  ~ConvertAMDGPUToROCDLPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-amdgpu-to-rocdl");
  }
  ::llvm::StringRef getArgument() const override { return "convert-amdgpu-to-rocdl"; }

  ::llvm::StringRef getDescription() const override { return "Convert AMDGPU dialect to ROCDL dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertAMDGPUToROCDLPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertAMDGPUToROCDLPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<ROCDL::ROCDLDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertAMDGPUToROCDLPassBase<DerivedT>)

  ConvertAMDGPUToROCDLPassBase(ConvertAMDGPUToROCDLPassOptions options) : ConvertAMDGPUToROCDLPassBase() {
    chipset = std::move(options.chipset);
  }
protected:
  ::mlir::Pass::Option<std::string> chipset{*this, "chipset", ::llvm::cl::desc("Chipset that these operations will run on"), ::llvm::cl::init("gfx000")};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertAMDGPUToROCDLPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertAMDGPUToROCDLPass(ConvertAMDGPUToROCDLPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertAMDGPUToROCDLPass() {
  return impl::createConvertAMDGPUToROCDLPass();
}

std::unique_ptr<::mlir::Pass> createConvertAMDGPUToROCDLPass(ConvertAMDGPUToROCDLPassOptions options) {
  return impl::createConvertAMDGPUToROCDLPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTAMDGPUTOROCDLPASS
#endif // GEN_PASS_DEF_CONVERTAMDGPUTOROCDLPASS

//===----------------------------------------------------------------------===//
// ConvertAffineForToGPUPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTAFFINEFORTOGPUPASS
struct ConvertAffineForToGPUPassOptions {
  unsigned numBlockDims = 1u;
  unsigned numThreadDims = 1u;
};
std::unique_ptr<::mlir::Pass> createConvertAffineForToGPUPass();
std::unique_ptr<::mlir::Pass> createConvertAffineForToGPUPass(ConvertAffineForToGPUPassOptions options);
#undef GEN_PASS_DECL_CONVERTAFFINEFORTOGPUPASS
#endif // GEN_PASS_DECL_CONVERTAFFINEFORTOGPUPASS
#ifdef GEN_PASS_DEF_CONVERTAFFINEFORTOGPUPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertAffineForToGPUPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertAffineForToGPUPass(ConvertAffineForToGPUPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertAffineForToGPUPassBase : public ::mlir::InterfacePass<FunctionOpInterface> {
public:
  using Base = ConvertAffineForToGPUPassBase;

  ConvertAffineForToGPUPassBase() : ::mlir::InterfacePass<FunctionOpInterface>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertAffineForToGPUPassBase(const ConvertAffineForToGPUPassBase &other) : ::mlir::InterfacePass<FunctionOpInterface>(other) {}
  ConvertAffineForToGPUPassBase& operator=(const ConvertAffineForToGPUPassBase &) = delete;
  ConvertAffineForToGPUPassBase(ConvertAffineForToGPUPassBase &&) = delete;
  ConvertAffineForToGPUPassBase& operator=(ConvertAffineForToGPUPassBase &&) = delete;
  ~ConvertAffineForToGPUPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-affine-for-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-affine-for-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Convert top-level AffineFor Ops to GPU kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertAffineForToGPUPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertAffineForToGPUPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<gpu::GPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertAffineForToGPUPassBase<DerivedT>)

  ConvertAffineForToGPUPassBase(ConvertAffineForToGPUPassOptions options) : ConvertAffineForToGPUPassBase() {
    numBlockDims = std::move(options.numBlockDims);
    numThreadDims = std::move(options.numThreadDims);
  }
protected:
  ::mlir::Pass::Option<unsigned> numBlockDims{*this, "gpu-block-dims", ::llvm::cl::desc("Number of GPU block dimensions for mapping"), ::llvm::cl::init(1u)};
  ::mlir::Pass::Option<unsigned> numThreadDims{*this, "gpu-thread-dims", ::llvm::cl::desc("Number of GPU thread dimensions for mapping"), ::llvm::cl::init(1u)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertAffineForToGPUPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertAffineForToGPUPass(ConvertAffineForToGPUPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertAffineForToGPUPass() {
  return impl::createConvertAffineForToGPUPass();
}

std::unique_ptr<::mlir::Pass> createConvertAffineForToGPUPass(ConvertAffineForToGPUPassOptions options) {
  return impl::createConvertAffineForToGPUPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTAFFINEFORTOGPUPASS
#endif // GEN_PASS_DEF_CONVERTAFFINEFORTOGPUPASS

//===----------------------------------------------------------------------===//
// ConvertArithToEmitC
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTARITHTOEMITC
std::unique_ptr<::mlir::Pass> createConvertArithToEmitC();
#undef GEN_PASS_DECL_CONVERTARITHTOEMITC
#endif // GEN_PASS_DECL_CONVERTARITHTOEMITC
#ifdef GEN_PASS_DEF_CONVERTARITHTOEMITC

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertArithToEmitC();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertArithToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertArithToEmitCBase;

  ConvertArithToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArithToEmitCBase(const ConvertArithToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertArithToEmitCBase& operator=(const ConvertArithToEmitCBase &) = delete;
  ConvertArithToEmitCBase(ConvertArithToEmitCBase &&) = delete;
  ConvertArithToEmitCBase& operator=(ConvertArithToEmitCBase &&) = delete;
  ~ConvertArithToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith dialect to EmitC dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArithToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertArithToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArithToEmitCBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertArithToEmitC() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertArithToEmitC() {
  return impl::createConvertArithToEmitC();
}
#undef GEN_PASS_DEF_CONVERTARITHTOEMITC
#endif // GEN_PASS_DEF_CONVERTARITHTOEMITC

//===----------------------------------------------------------------------===//
// ConvertArithToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTARITHTOSPIRVPASS
struct ConvertArithToSPIRVPassOptions {
  bool emulateLT32BitScalarTypes = true;
};
std::unique_ptr<::mlir::Pass> createConvertArithToSPIRVPass();
std::unique_ptr<::mlir::Pass> createConvertArithToSPIRVPass(ConvertArithToSPIRVPassOptions options);
#undef GEN_PASS_DECL_CONVERTARITHTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTARITHTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTARITHTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertArithToSPIRVPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertArithToSPIRVPass(ConvertArithToSPIRVPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertArithToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertArithToSPIRVPassBase;

  ConvertArithToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArithToSPIRVPassBase(const ConvertArithToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertArithToSPIRVPassBase& operator=(const ConvertArithToSPIRVPassBase &) = delete;
  ConvertArithToSPIRVPassBase(ConvertArithToSPIRVPassBase &&) = delete;
  ConvertArithToSPIRVPassBase& operator=(ConvertArithToSPIRVPassBase &&) = delete;
  ~ConvertArithToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArithToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertArithToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArithToSPIRVPassBase<DerivedT>)

  ConvertArithToSPIRVPassBase(ConvertArithToSPIRVPassOptions options) : ConvertArithToSPIRVPassBase() {
    emulateLT32BitScalarTypes = std::move(options.emulateLT32BitScalarTypes);
  }
protected:
  ::mlir::Pass::Option<bool> emulateLT32BitScalarTypes{*this, "emulate-lt-32-bit-scalar-types", ::llvm::cl::desc("Emulate narrower scalar types with 32-bit ones if not supported by the target"), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertArithToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertArithToSPIRVPass(ConvertArithToSPIRVPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertArithToSPIRVPass() {
  return impl::createConvertArithToSPIRVPass();
}

std::unique_ptr<::mlir::Pass> createConvertArithToSPIRVPass(ConvertArithToSPIRVPassOptions options) {
  return impl::createConvertArithToSPIRVPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTARITHTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTARITHTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertArmNeon2dToIntrPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTARMNEON2DTOINTRPASS
std::unique_ptr<::mlir::Pass> createConvertArmNeon2dToIntrPass();
#undef GEN_PASS_DECL_CONVERTARMNEON2DTOINTRPASS
#endif // GEN_PASS_DECL_CONVERTARMNEON2DTOINTRPASS
#ifdef GEN_PASS_DEF_CONVERTARMNEON2DTOINTRPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertArmNeon2dToIntrPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertArmNeon2dToIntrPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertArmNeon2dToIntrPassBase;

  ConvertArmNeon2dToIntrPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArmNeon2dToIntrPassBase(const ConvertArmNeon2dToIntrPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertArmNeon2dToIntrPassBase& operator=(const ConvertArmNeon2dToIntrPassBase &) = delete;
  ConvertArmNeon2dToIntrPassBase(ConvertArmNeon2dToIntrPassBase &&) = delete;
  ConvertArmNeon2dToIntrPassBase& operator=(ConvertArmNeon2dToIntrPassBase &&) = delete;
  ~ConvertArmNeon2dToIntrPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("arm-neon-2d-to-intr");
  }
  ::llvm::StringRef getArgument() const override { return "arm-neon-2d-to-intr"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arm NEON structured ops to intrinsics"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArmNeon2dToIntrPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertArmNeon2dToIntrPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arm_neon::ArmNeonDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArmNeon2dToIntrPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertArmNeon2dToIntrPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertArmNeon2dToIntrPass() {
  return impl::createConvertArmNeon2dToIntrPass();
}
#undef GEN_PASS_DEF_CONVERTARMNEON2DTOINTRPASS
#endif // GEN_PASS_DEF_CONVERTARMNEON2DTOINTRPASS

//===----------------------------------------------------------------------===//
// ConvertArmSMEToLLVM
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTARMSMETOLLVM
struct ConvertArmSMEToLLVMOptions {
  bool dumpTileLiveRanges = false;
};
#undef GEN_PASS_DECL_CONVERTARMSMETOLLVM
#endif // GEN_PASS_DECL_CONVERTARMSMETOLLVM
#ifdef GEN_PASS_DEF_CONVERTARMSMETOLLVM
namespace impl {

template <typename DerivedT>
class ConvertArmSMEToLLVMBase : public ::mlir::InterfacePass<FunctionOpInterface> {
public:
  using Base = ConvertArmSMEToLLVMBase;

  ConvertArmSMEToLLVMBase() : ::mlir::InterfacePass<FunctionOpInterface>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArmSMEToLLVMBase(const ConvertArmSMEToLLVMBase &other) : ::mlir::InterfacePass<FunctionOpInterface>(other) {}
  ConvertArmSMEToLLVMBase& operator=(const ConvertArmSMEToLLVMBase &) = delete;
  ConvertArmSMEToLLVMBase(ConvertArmSMEToLLVMBase &&) = delete;
  ConvertArmSMEToLLVMBase& operator=(ConvertArmSMEToLLVMBase &&) = delete;
  ~ConvertArmSMEToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arm-sme-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arm-sme-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the ArmSME dialect into the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArmSMEToLLVM");
  }
  ::llvm::StringRef getName() const override { return "ConvertArmSMEToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arm_sme::ArmSMEDialect>();
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArmSMEToLLVMBase<DerivedT>)

  ConvertArmSMEToLLVMBase(ConvertArmSMEToLLVMOptions options) : ConvertArmSMEToLLVMBase() {
    dumpTileLiveRanges = std::move(options.dumpTileLiveRanges);
  }
protected:
  ::mlir::Pass::Option<bool> dumpTileLiveRanges{*this, "dump-tile-live-ranges", ::llvm::cl::desc("Dump the live ranges of SME tiles (for debugging)"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTARMSMETOLLVM
#endif // GEN_PASS_DEF_CONVERTARMSMETOLLVM

//===----------------------------------------------------------------------===//
// ConvertArmSMEToSCFPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTARMSMETOSCFPASS
std::unique_ptr<::mlir::Pass> createConvertArmSMEToSCFPass();
#undef GEN_PASS_DECL_CONVERTARMSMETOSCFPASS
#endif // GEN_PASS_DECL_CONVERTARMSMETOSCFPASS
#ifdef GEN_PASS_DEF_CONVERTARMSMETOSCFPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertArmSMEToSCFPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertArmSMEToSCFPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertArmSMEToSCFPassBase;

  ConvertArmSMEToSCFPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArmSMEToSCFPassBase(const ConvertArmSMEToSCFPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertArmSMEToSCFPassBase& operator=(const ConvertArmSMEToSCFPassBase &) = delete;
  ConvertArmSMEToSCFPassBase(ConvertArmSMEToSCFPassBase &&) = delete;
  ConvertArmSMEToSCFPassBase& operator=(ConvertArmSMEToSCFPassBase &&) = delete;
  ~ConvertArmSMEToSCFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arm-sme-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arm-sme-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the ArmSME dialect into the SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArmSMEToSCFPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertArmSMEToSCFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<vector::VectorDialect>();
    registry.insert<arm_sme::ArmSMEDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArmSMEToSCFPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertArmSMEToSCFPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertArmSMEToSCFPass() {
  return impl::createConvertArmSMEToSCFPass();
}
#undef GEN_PASS_DEF_CONVERTARMSMETOSCFPASS
#endif // GEN_PASS_DEF_CONVERTARMSMETOSCFPASS

//===----------------------------------------------------------------------===//
// ConvertAsyncToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTASYNCTOLLVMPASS
std::unique_ptr<::mlir::Pass> createConvertAsyncToLLVMPass();
#undef GEN_PASS_DECL_CONVERTASYNCTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTASYNCTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTASYNCTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertAsyncToLLVMPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertAsyncToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertAsyncToLLVMPassBase;

  ConvertAsyncToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertAsyncToLLVMPassBase(const ConvertAsyncToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertAsyncToLLVMPassBase& operator=(const ConvertAsyncToLLVMPassBase &) = delete;
  ConvertAsyncToLLVMPassBase(ConvertAsyncToLLVMPassBase &&) = delete;
  ConvertAsyncToLLVMPassBase& operator=(ConvertAsyncToLLVMPassBase &&) = delete;
  ~ConvertAsyncToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-async-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-async-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert the operations from the async dialect into the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertAsyncToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertAsyncToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<async::AsyncDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertAsyncToLLVMPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertAsyncToLLVMPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertAsyncToLLVMPass() {
  return impl::createConvertAsyncToLLVMPass();
}
#undef GEN_PASS_DEF_CONVERTASYNCTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTASYNCTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertBufferizationToMemRefPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTBUFFERIZATIONTOMEMREFPASS
std::unique_ptr<::mlir::Pass> createConvertBufferizationToMemRefPass();
#undef GEN_PASS_DECL_CONVERTBUFFERIZATIONTOMEMREFPASS
#endif // GEN_PASS_DECL_CONVERTBUFFERIZATIONTOMEMREFPASS
#ifdef GEN_PASS_DEF_CONVERTBUFFERIZATIONTOMEMREFPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertBufferizationToMemRefPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertBufferizationToMemRefPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertBufferizationToMemRefPassBase;

  ConvertBufferizationToMemRefPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertBufferizationToMemRefPassBase(const ConvertBufferizationToMemRefPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertBufferizationToMemRefPassBase& operator=(const ConvertBufferizationToMemRefPassBase &) = delete;
  ConvertBufferizationToMemRefPassBase(ConvertBufferizationToMemRefPassBase &&) = delete;
  ConvertBufferizationToMemRefPassBase& operator=(ConvertBufferizationToMemRefPassBase &&) = delete;
  ~ConvertBufferizationToMemRefPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-bufferization-to-memref");
  }
  ::llvm::StringRef getArgument() const override { return "convert-bufferization-to-memref"; }

  ::llvm::StringRef getDescription() const override { return "Convert operations from the Bufferization dialect to the MemRef dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertBufferizationToMemRefPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertBufferizationToMemRefPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertBufferizationToMemRefPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertBufferizationToMemRefPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertBufferizationToMemRefPass() {
  return impl::createConvertBufferizationToMemRefPass();
}
#undef GEN_PASS_DEF_CONVERTBUFFERIZATIONTOMEMREFPASS
#endif // GEN_PASS_DEF_CONVERTBUFFERIZATIONTOMEMREFPASS

//===----------------------------------------------------------------------===//
// ConvertComplexToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTCOMPLEXTOLLVMPASS
struct ConvertComplexToLLVMPassOptions {
  ::mlir::complex::ComplexRangeFlags complexRange = ::mlir::complex::ComplexRangeFlags::basic;
};
std::unique_ptr<::mlir::Pass> createConvertComplexToLLVMPass();
std::unique_ptr<::mlir::Pass> createConvertComplexToLLVMPass(ConvertComplexToLLVMPassOptions options);
#undef GEN_PASS_DECL_CONVERTCOMPLEXTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTCOMPLEXTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTCOMPLEXTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertComplexToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertComplexToLLVMPass(ConvertComplexToLLVMPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertComplexToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertComplexToLLVMPassBase;

  ConvertComplexToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertComplexToLLVMPassBase(const ConvertComplexToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertComplexToLLVMPassBase& operator=(const ConvertComplexToLLVMPassBase &) = delete;
  ConvertComplexToLLVMPassBase(ConvertComplexToLLVMPassBase &&) = delete;
  ConvertComplexToLLVMPassBase& operator=(ConvertComplexToLLVMPassBase &&) = delete;
  ~ConvertComplexToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-complex-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-complex-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Complex dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertComplexToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertComplexToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertComplexToLLVMPassBase<DerivedT>)

  ConvertComplexToLLVMPassBase(ConvertComplexToLLVMPassOptions options) : ConvertComplexToLLVMPassBase() {
    complexRange = std::move(options.complexRange);
  }
protected:
  ::mlir::Pass::Option<::mlir::complex::ComplexRangeFlags> complexRange{*this, "complex-range", ::llvm::cl::desc("Control the intermediate calculation of complex number division"), ::llvm::cl::init(::mlir::complex::ComplexRangeFlags::basic), ::llvm::cl::values(
        clEnumValN(::mlir::complex::ComplexRangeFlags::improved, "improved", "improved"),
        clEnumValN(::mlir::complex::ComplexRangeFlags::basic, "basic", "basic (default)"),
        clEnumValN(::mlir::complex::ComplexRangeFlags::none, "none", "none")
      )};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertComplexToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertComplexToLLVMPass(ConvertComplexToLLVMPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertComplexToLLVMPass() {
  return impl::createConvertComplexToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createConvertComplexToLLVMPass(ConvertComplexToLLVMPassOptions options) {
  return impl::createConvertComplexToLLVMPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTCOMPLEXTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTCOMPLEXTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertComplexToLibm
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTCOMPLEXTOLIBM
std::unique_ptr<::mlir::Pass> createConvertComplexToLibm();
#undef GEN_PASS_DECL_CONVERTCOMPLEXTOLIBM
#endif // GEN_PASS_DECL_CONVERTCOMPLEXTOLIBM
#ifdef GEN_PASS_DEF_CONVERTCOMPLEXTOLIBM

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertComplexToLibm();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertComplexToLibmBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertComplexToLibmBase;

  ConvertComplexToLibmBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertComplexToLibmBase(const ConvertComplexToLibmBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertComplexToLibmBase& operator=(const ConvertComplexToLibmBase &) = delete;
  ConvertComplexToLibmBase(ConvertComplexToLibmBase &&) = delete;
  ConvertComplexToLibmBase& operator=(ConvertComplexToLibmBase &&) = delete;
  ~ConvertComplexToLibmBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-complex-to-libm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-complex-to-libm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Complex dialect to libm calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertComplexToLibm");
  }
  ::llvm::StringRef getName() const override { return "ConvertComplexToLibm"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertComplexToLibmBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertComplexToLibm() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertComplexToLibm() {
  return impl::createConvertComplexToLibm();
}
#undef GEN_PASS_DEF_CONVERTCOMPLEXTOLIBM
#endif // GEN_PASS_DEF_CONVERTCOMPLEXTOLIBM

//===----------------------------------------------------------------------===//
// ConvertComplexToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTCOMPLEXTOSPIRVPASS
std::unique_ptr<::mlir::Pass> createConvertComplexToSPIRVPass();
#undef GEN_PASS_DECL_CONVERTCOMPLEXTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTCOMPLEXTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTCOMPLEXTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertComplexToSPIRVPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertComplexToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertComplexToSPIRVPassBase;

  ConvertComplexToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertComplexToSPIRVPassBase(const ConvertComplexToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertComplexToSPIRVPassBase& operator=(const ConvertComplexToSPIRVPassBase &) = delete;
  ConvertComplexToSPIRVPassBase(ConvertComplexToSPIRVPassBase &&) = delete;
  ConvertComplexToSPIRVPassBase& operator=(ConvertComplexToSPIRVPassBase &&) = delete;
  ~ConvertComplexToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-complex-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-complex-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Complex dialect to SPIRV dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertComplexToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertComplexToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertComplexToSPIRVPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertComplexToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertComplexToSPIRVPass() {
  return impl::createConvertComplexToSPIRVPass();
}
#undef GEN_PASS_DEF_CONVERTCOMPLEXTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTCOMPLEXTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertComplexToStandardPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTCOMPLEXTOSTANDARDPASS
struct ConvertComplexToStandardPassOptions {
  ::mlir::complex::ComplexRangeFlags complexRange = ::mlir::complex::ComplexRangeFlags::improved;
};
std::unique_ptr<::mlir::Pass> createConvertComplexToStandardPass();
std::unique_ptr<::mlir::Pass> createConvertComplexToStandardPass(ConvertComplexToStandardPassOptions options);
#undef GEN_PASS_DECL_CONVERTCOMPLEXTOSTANDARDPASS
#endif // GEN_PASS_DECL_CONVERTCOMPLEXTOSTANDARDPASS
#ifdef GEN_PASS_DEF_CONVERTCOMPLEXTOSTANDARDPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertComplexToStandardPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertComplexToStandardPass(ConvertComplexToStandardPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertComplexToStandardPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertComplexToStandardPassBase;

  ConvertComplexToStandardPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertComplexToStandardPassBase(const ConvertComplexToStandardPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertComplexToStandardPassBase& operator=(const ConvertComplexToStandardPassBase &) = delete;
  ConvertComplexToStandardPassBase(ConvertComplexToStandardPassBase &&) = delete;
  ConvertComplexToStandardPassBase& operator=(ConvertComplexToStandardPassBase &&) = delete;
  ~ConvertComplexToStandardPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-complex-to-standard");
  }
  ::llvm::StringRef getArgument() const override { return "convert-complex-to-standard"; }

  ::llvm::StringRef getDescription() const override { return "Convert Complex dialect to standard dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertComplexToStandardPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertComplexToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<math::MathDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertComplexToStandardPassBase<DerivedT>)

  ConvertComplexToStandardPassBase(ConvertComplexToStandardPassOptions options) : ConvertComplexToStandardPassBase() {
    complexRange = std::move(options.complexRange);
  }
protected:
  ::mlir::Pass::Option<::mlir::complex::ComplexRangeFlags> complexRange{*this, "complex-range", ::llvm::cl::desc("Control the intermediate calculation of complex number division"), ::llvm::cl::init(::mlir::complex::ComplexRangeFlags::improved), ::llvm::cl::values(
        clEnumValN(::mlir::complex::ComplexRangeFlags::improved, "improved", "improved (default)"),
        clEnumValN(::mlir::complex::ComplexRangeFlags::basic, "basic", "basic"),
        clEnumValN(::mlir::complex::ComplexRangeFlags::none, "none", "none")
      )};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertComplexToStandardPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertComplexToStandardPass(ConvertComplexToStandardPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertComplexToStandardPass() {
  return impl::createConvertComplexToStandardPass();
}

std::unique_ptr<::mlir::Pass> createConvertComplexToStandardPass(ConvertComplexToStandardPassOptions options) {
  return impl::createConvertComplexToStandardPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTCOMPLEXTOSTANDARDPASS
#endif // GEN_PASS_DEF_CONVERTCOMPLEXTOSTANDARDPASS

//===----------------------------------------------------------------------===//
// ConvertControlFlowToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTCONTROLFLOWTOLLVMPASS
struct ConvertControlFlowToLLVMPassOptions {
  unsigned indexBitwidth = 0;
};
std::unique_ptr<::mlir::Pass> createConvertControlFlowToLLVMPass();
std::unique_ptr<::mlir::Pass> createConvertControlFlowToLLVMPass(ConvertControlFlowToLLVMPassOptions options);
#undef GEN_PASS_DECL_CONVERTCONTROLFLOWTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTCONTROLFLOWTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTCONTROLFLOWTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertControlFlowToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertControlFlowToLLVMPass(ConvertControlFlowToLLVMPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertControlFlowToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertControlFlowToLLVMPassBase;

  ConvertControlFlowToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertControlFlowToLLVMPassBase(const ConvertControlFlowToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertControlFlowToLLVMPassBase& operator=(const ConvertControlFlowToLLVMPassBase &) = delete;
  ConvertControlFlowToLLVMPassBase(ConvertControlFlowToLLVMPassBase &&) = delete;
  ConvertControlFlowToLLVMPassBase& operator=(ConvertControlFlowToLLVMPassBase &&) = delete;
  ~ConvertControlFlowToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-cf-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-cf-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert ControlFlow operations to the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertControlFlowToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertControlFlowToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertControlFlowToLLVMPassBase<DerivedT>)

  ConvertControlFlowToLLVMPassBase(ConvertControlFlowToLLVMPassOptions options) : ConvertControlFlowToLLVMPassBase() {
    indexBitwidth = std::move(options.indexBitwidth);
  }
protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertControlFlowToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertControlFlowToLLVMPass(ConvertControlFlowToLLVMPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertControlFlowToLLVMPass() {
  return impl::createConvertControlFlowToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createConvertControlFlowToLLVMPass(ConvertControlFlowToLLVMPassOptions options) {
  return impl::createConvertControlFlowToLLVMPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTCONTROLFLOWTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTCONTROLFLOWTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertControlFlowToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTCONTROLFLOWTOSPIRVPASS
struct ConvertControlFlowToSPIRVPassOptions {
  bool emulateLT32BitScalarTypes = true;
};
std::unique_ptr<::mlir::Pass> createConvertControlFlowToSPIRVPass();
std::unique_ptr<::mlir::Pass> createConvertControlFlowToSPIRVPass(ConvertControlFlowToSPIRVPassOptions options);
#undef GEN_PASS_DECL_CONVERTCONTROLFLOWTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTCONTROLFLOWTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTCONTROLFLOWTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertControlFlowToSPIRVPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertControlFlowToSPIRVPass(ConvertControlFlowToSPIRVPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertControlFlowToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertControlFlowToSPIRVPassBase;

  ConvertControlFlowToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertControlFlowToSPIRVPassBase(const ConvertControlFlowToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertControlFlowToSPIRVPassBase& operator=(const ConvertControlFlowToSPIRVPassBase &) = delete;
  ConvertControlFlowToSPIRVPassBase(ConvertControlFlowToSPIRVPassBase &&) = delete;
  ConvertControlFlowToSPIRVPassBase& operator=(ConvertControlFlowToSPIRVPassBase &&) = delete;
  ~ConvertControlFlowToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-cf-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-cf-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert ControlFlow dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertControlFlowToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertControlFlowToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertControlFlowToSPIRVPassBase<DerivedT>)

  ConvertControlFlowToSPIRVPassBase(ConvertControlFlowToSPIRVPassOptions options) : ConvertControlFlowToSPIRVPassBase() {
    emulateLT32BitScalarTypes = std::move(options.emulateLT32BitScalarTypes);
  }
protected:
  ::mlir::Pass::Option<bool> emulateLT32BitScalarTypes{*this, "emulate-lt-32-bit-scalar-types", ::llvm::cl::desc("Emulate narrower scalar types with 32-bit ones if not supported by the target"), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertControlFlowToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertControlFlowToSPIRVPass(ConvertControlFlowToSPIRVPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertControlFlowToSPIRVPass() {
  return impl::createConvertControlFlowToSPIRVPass();
}

std::unique_ptr<::mlir::Pass> createConvertControlFlowToSPIRVPass(ConvertControlFlowToSPIRVPassOptions options) {
  return impl::createConvertControlFlowToSPIRVPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTCONTROLFLOWTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTCONTROLFLOWTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertFuncToEmitC
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTFUNCTOEMITC
std::unique_ptr<::mlir::Pass> createConvertFuncToEmitC();
#undef GEN_PASS_DECL_CONVERTFUNCTOEMITC
#endif // GEN_PASS_DECL_CONVERTFUNCTOEMITC
#ifdef GEN_PASS_DEF_CONVERTFUNCTOEMITC

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertFuncToEmitC();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertFuncToEmitCBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertFuncToEmitCBase;

  ConvertFuncToEmitCBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFuncToEmitCBase(const ConvertFuncToEmitCBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertFuncToEmitCBase& operator=(const ConvertFuncToEmitCBase &) = delete;
  ConvertFuncToEmitCBase(ConvertFuncToEmitCBase &&) = delete;
  ConvertFuncToEmitCBase& operator=(ConvertFuncToEmitCBase &&) = delete;
  ~ConvertFuncToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-func-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-func-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert Func dialect to EmitC dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFuncToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertFuncToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFuncToEmitCBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertFuncToEmitC() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertFuncToEmitC() {
  return impl::createConvertFuncToEmitC();
}
#undef GEN_PASS_DEF_CONVERTFUNCTOEMITC
#endif // GEN_PASS_DEF_CONVERTFUNCTOEMITC

//===----------------------------------------------------------------------===//
// ConvertFuncToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTFUNCTOLLVMPASS
struct ConvertFuncToLLVMPassOptions {
  bool useBarePtrCallConv = false;
  unsigned indexBitwidth = 0;
};
std::unique_ptr<::mlir::Pass> createConvertFuncToLLVMPass();
std::unique_ptr<::mlir::Pass> createConvertFuncToLLVMPass(ConvertFuncToLLVMPassOptions options);
#undef GEN_PASS_DECL_CONVERTFUNCTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTFUNCTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTFUNCTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertFuncToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertFuncToLLVMPass(ConvertFuncToLLVMPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertFuncToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertFuncToLLVMPassBase;

  ConvertFuncToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFuncToLLVMPassBase(const ConvertFuncToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertFuncToLLVMPassBase& operator=(const ConvertFuncToLLVMPassBase &) = delete;
  ConvertFuncToLLVMPassBase(ConvertFuncToLLVMPassBase &&) = delete;
  ConvertFuncToLLVMPassBase& operator=(ConvertFuncToLLVMPassBase &&) = delete;
  ~ConvertFuncToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-func-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-func-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert from the Func dialect to the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFuncToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFuncToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFuncToLLVMPassBase<DerivedT>)

  ConvertFuncToLLVMPassBase(ConvertFuncToLLVMPassOptions options) : ConvertFuncToLLVMPassBase() {
    useBarePtrCallConv = std::move(options.useBarePtrCallConv);
    indexBitwidth = std::move(options.indexBitwidth);
  }
protected:
  ::mlir::Pass::Option<bool> useBarePtrCallConv{*this, "use-bare-ptr-memref-call-conv", ::llvm::cl::desc("Replace FuncOp's MemRef arguments with bare pointers to the MemRef element types"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertFuncToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertFuncToLLVMPass(ConvertFuncToLLVMPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertFuncToLLVMPass() {
  return impl::createConvertFuncToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createConvertFuncToLLVMPass(ConvertFuncToLLVMPassOptions options) {
  return impl::createConvertFuncToLLVMPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTFUNCTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTFUNCTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertFuncToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTFUNCTOSPIRVPASS
struct ConvertFuncToSPIRVPassOptions {
  bool emulateLT32BitScalarTypes = true;
};
std::unique_ptr<::mlir::Pass> createConvertFuncToSPIRVPass();
std::unique_ptr<::mlir::Pass> createConvertFuncToSPIRVPass(ConvertFuncToSPIRVPassOptions options);
#undef GEN_PASS_DECL_CONVERTFUNCTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTFUNCTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTFUNCTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertFuncToSPIRVPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertFuncToSPIRVPass(ConvertFuncToSPIRVPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertFuncToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertFuncToSPIRVPassBase;

  ConvertFuncToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFuncToSPIRVPassBase(const ConvertFuncToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertFuncToSPIRVPassBase& operator=(const ConvertFuncToSPIRVPassBase &) = delete;
  ConvertFuncToSPIRVPassBase(ConvertFuncToSPIRVPassBase &&) = delete;
  ConvertFuncToSPIRVPassBase& operator=(ConvertFuncToSPIRVPassBase &&) = delete;
  ~ConvertFuncToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-func-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-func-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Func dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFuncToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFuncToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFuncToSPIRVPassBase<DerivedT>)

  ConvertFuncToSPIRVPassBase(ConvertFuncToSPIRVPassOptions options) : ConvertFuncToSPIRVPassBase() {
    emulateLT32BitScalarTypes = std::move(options.emulateLT32BitScalarTypes);
  }
protected:
  ::mlir::Pass::Option<bool> emulateLT32BitScalarTypes{*this, "emulate-lt-32-bit-scalar-types", ::llvm::cl::desc("Emulate narrower scalar types with 32-bit ones if not supported by the target"), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertFuncToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertFuncToSPIRVPass(ConvertFuncToSPIRVPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertFuncToSPIRVPass() {
  return impl::createConvertFuncToSPIRVPass();
}

std::unique_ptr<::mlir::Pass> createConvertFuncToSPIRVPass(ConvertFuncToSPIRVPassOptions options) {
  return impl::createConvertFuncToSPIRVPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTFUNCTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTFUNCTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertGPUToSPIRV
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTGPUTOSPIRV
struct ConvertGPUToSPIRVOptions {
  bool use64bitIndex = false;
};
#undef GEN_PASS_DECL_CONVERTGPUTOSPIRV
#endif // GEN_PASS_DECL_CONVERTGPUTOSPIRV
#ifdef GEN_PASS_DEF_CONVERTGPUTOSPIRV
namespace impl {

template <typename DerivedT>
class ConvertGPUToSPIRVBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertGPUToSPIRVBase;

  ConvertGPUToSPIRVBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGPUToSPIRVBase(const ConvertGPUToSPIRVBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertGPUToSPIRVBase& operator=(const ConvertGPUToSPIRVBase &) = delete;
  ConvertGPUToSPIRVBase(ConvertGPUToSPIRVBase &&) = delete;
  ConvertGPUToSPIRVBase& operator=(ConvertGPUToSPIRVBase &&) = delete;
  ~ConvertGPUToSPIRVBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gpu-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gpu-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert GPU dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGPUToSPIRV");
  }
  ::llvm::StringRef getName() const override { return "ConvertGPUToSPIRV"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGPUToSPIRVBase<DerivedT>)

  ConvertGPUToSPIRVBase(ConvertGPUToSPIRVOptions options) : ConvertGPUToSPIRVBase() {
    use64bitIndex = std::move(options.use64bitIndex);
  }
protected:
  ::mlir::Pass::Option<bool> use64bitIndex{*this, "use-64bit-index", ::llvm::cl::desc("Use 64-bit integers to convert index types"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTGPUTOSPIRV
#endif // GEN_PASS_DEF_CONVERTGPUTOSPIRV

//===----------------------------------------------------------------------===//
// ConvertGpuOpsToLLVMSPVOps
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTGPUOPSTOLLVMSPVOPS
struct ConvertGpuOpsToLLVMSPVOpsOptions {
  bool use64bitIndex = false;
};
std::unique_ptr<::mlir::Pass> createConvertGpuOpsToLLVMSPVOps();
std::unique_ptr<::mlir::Pass> createConvertGpuOpsToLLVMSPVOps(ConvertGpuOpsToLLVMSPVOpsOptions options);
#undef GEN_PASS_DECL_CONVERTGPUOPSTOLLVMSPVOPS
#endif // GEN_PASS_DECL_CONVERTGPUOPSTOLLVMSPVOPS
#ifdef GEN_PASS_DEF_CONVERTGPUOPSTOLLVMSPVOPS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertGpuOpsToLLVMSPVOps();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertGpuOpsToLLVMSPVOps(ConvertGpuOpsToLLVMSPVOpsOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertGpuOpsToLLVMSPVOpsBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = ConvertGpuOpsToLLVMSPVOpsBase;

  ConvertGpuOpsToLLVMSPVOpsBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuOpsToLLVMSPVOpsBase(const ConvertGpuOpsToLLVMSPVOpsBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}
  ConvertGpuOpsToLLVMSPVOpsBase& operator=(const ConvertGpuOpsToLLVMSPVOpsBase &) = delete;
  ConvertGpuOpsToLLVMSPVOpsBase(ConvertGpuOpsToLLVMSPVOpsBase &&) = delete;
  ConvertGpuOpsToLLVMSPVOpsBase& operator=(ConvertGpuOpsToLLVMSPVOpsBase &&) = delete;
  ~ConvertGpuOpsToLLVMSPVOpsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gpu-to-llvm-spv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gpu-to-llvm-spv"; }

  ::llvm::StringRef getDescription() const override { return "Generate LLVM operations to be ingested by a SPIR-V backend for gpu operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuOpsToLLVMSPVOps");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuOpsToLLVMSPVOps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuOpsToLLVMSPVOpsBase<DerivedT>)

  ConvertGpuOpsToLLVMSPVOpsBase(ConvertGpuOpsToLLVMSPVOpsOptions options) : ConvertGpuOpsToLLVMSPVOpsBase() {
    use64bitIndex = std::move(options.use64bitIndex);
  }
protected:
  ::mlir::Pass::Option<bool> use64bitIndex{*this, "use-64bit-index", ::llvm::cl::desc("Use 64-bit integers to convert index types"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertGpuOpsToLLVMSPVOps() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertGpuOpsToLLVMSPVOps(ConvertGpuOpsToLLVMSPVOpsOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertGpuOpsToLLVMSPVOps() {
  return impl::createConvertGpuOpsToLLVMSPVOps();
}

std::unique_ptr<::mlir::Pass> createConvertGpuOpsToLLVMSPVOps(ConvertGpuOpsToLLVMSPVOpsOptions options) {
  return impl::createConvertGpuOpsToLLVMSPVOps(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTGPUOPSTOLLVMSPVOPS
#endif // GEN_PASS_DEF_CONVERTGPUOPSTOLLVMSPVOPS

//===----------------------------------------------------------------------===//
// ConvertGpuOpsToNVVMOps
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTGPUOPSTONVVMOPS
struct ConvertGpuOpsToNVVMOpsOptions {
  unsigned indexBitwidth = 0;
  bool hasRedux = false;
  bool useBarePtrCallConv = false;
  ::llvm::SmallVector<std::string> allowedDialects;
};
std::unique_ptr<::mlir::Pass> createConvertGpuOpsToNVVMOps();
std::unique_ptr<::mlir::Pass> createConvertGpuOpsToNVVMOps(ConvertGpuOpsToNVVMOpsOptions options);
#undef GEN_PASS_DECL_CONVERTGPUOPSTONVVMOPS
#endif // GEN_PASS_DECL_CONVERTGPUOPSTONVVMOPS
#ifdef GEN_PASS_DEF_CONVERTGPUOPSTONVVMOPS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertGpuOpsToNVVMOps();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertGpuOpsToNVVMOps(ConvertGpuOpsToNVVMOpsOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertGpuOpsToNVVMOpsBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = ConvertGpuOpsToNVVMOpsBase;

  ConvertGpuOpsToNVVMOpsBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuOpsToNVVMOpsBase(const ConvertGpuOpsToNVVMOpsBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}
  ConvertGpuOpsToNVVMOpsBase& operator=(const ConvertGpuOpsToNVVMOpsBase &) = delete;
  ConvertGpuOpsToNVVMOpsBase(ConvertGpuOpsToNVVMOpsBase &&) = delete;
  ConvertGpuOpsToNVVMOpsBase& operator=(ConvertGpuOpsToNVVMOpsBase &&) = delete;
  ~ConvertGpuOpsToNVVMOpsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gpu-to-nvvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gpu-to-nvvm"; }

  ::llvm::StringRef getDescription() const override { return "Generate NVVM operations for gpu operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuOpsToNVVMOps");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuOpsToNVVMOps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuOpsToNVVMOpsBase<DerivedT>)

  ConvertGpuOpsToNVVMOpsBase(ConvertGpuOpsToNVVMOpsOptions options) : ConvertGpuOpsToNVVMOpsBase() {
    indexBitwidth = std::move(options.indexBitwidth);
    hasRedux = std::move(options.hasRedux);
    useBarePtrCallConv = std::move(options.useBarePtrCallConv);
    allowedDialects = std::move(options.allowedDialects);
  }
protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> hasRedux{*this, "has-redux", ::llvm::cl::desc("Target gpu supports redux"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> useBarePtrCallConv{*this, "use-bare-ptr-memref-call-conv", ::llvm::cl::desc("Replace memref arguments in GPU functions with bare pointers. All memrefs must have static shape."), ::llvm::cl::init(false)};
  ::mlir::Pass::ListOption<std::string> allowedDialects{*this, "allowed-dialects", ::llvm::cl::desc("Run conversion patterns of only the specified dialects")};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertGpuOpsToNVVMOps() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertGpuOpsToNVVMOps(ConvertGpuOpsToNVVMOpsOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertGpuOpsToNVVMOps() {
  return impl::createConvertGpuOpsToNVVMOps();
}

std::unique_ptr<::mlir::Pass> createConvertGpuOpsToNVVMOps(ConvertGpuOpsToNVVMOpsOptions options) {
  return impl::createConvertGpuOpsToNVVMOps(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTGPUOPSTONVVMOPS
#endif // GEN_PASS_DEF_CONVERTGPUOPSTONVVMOPS

//===----------------------------------------------------------------------===//
// ConvertGpuOpsToROCDLOps
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTGPUOPSTOROCDLOPS
struct ConvertGpuOpsToROCDLOpsOptions {
  std::string chipset = "gfx000";
  unsigned indexBitwidth = 0;
  bool useBarePtrCallConv = false;
  ::mlir::gpu::amd::Runtime runtime = ::mlir::gpu::amd::Runtime::Unknown;
  ::llvm::SmallVector<std::string> allowedDialects;
};
#undef GEN_PASS_DECL_CONVERTGPUOPSTOROCDLOPS
#endif // GEN_PASS_DECL_CONVERTGPUOPSTOROCDLOPS
#ifdef GEN_PASS_DEF_CONVERTGPUOPSTOROCDLOPS
namespace impl {

template <typename DerivedT>
class ConvertGpuOpsToROCDLOpsBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = ConvertGpuOpsToROCDLOpsBase;

  ConvertGpuOpsToROCDLOpsBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuOpsToROCDLOpsBase(const ConvertGpuOpsToROCDLOpsBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}
  ConvertGpuOpsToROCDLOpsBase& operator=(const ConvertGpuOpsToROCDLOpsBase &) = delete;
  ConvertGpuOpsToROCDLOpsBase(ConvertGpuOpsToROCDLOpsBase &&) = delete;
  ConvertGpuOpsToROCDLOpsBase& operator=(ConvertGpuOpsToROCDLOpsBase &&) = delete;
  ~ConvertGpuOpsToROCDLOpsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gpu-to-rocdl");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gpu-to-rocdl"; }

  ::llvm::StringRef getDescription() const override { return "Generate ROCDL operations for gpu operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuOpsToROCDLOps");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuOpsToROCDLOps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<ROCDL::ROCDLDialect>();
    registry.insert<amdgpu::AMDGPUDialect>();
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuOpsToROCDLOpsBase<DerivedT>)

  ConvertGpuOpsToROCDLOpsBase(ConvertGpuOpsToROCDLOpsOptions options) : ConvertGpuOpsToROCDLOpsBase() {
    chipset = std::move(options.chipset);
    indexBitwidth = std::move(options.indexBitwidth);
    useBarePtrCallConv = std::move(options.useBarePtrCallConv);
    runtime = std::move(options.runtime);
    allowedDialects = std::move(options.allowedDialects);
  }
protected:
  ::mlir::Pass::Option<std::string> chipset{*this, "chipset", ::llvm::cl::desc("Chipset that these operations will run on"), ::llvm::cl::init("gfx000")};
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> useBarePtrCallConv{*this, "use-bare-ptr-memref-call-conv", ::llvm::cl::desc("Replace memref arguments in GPU functions with bare pointers.All memrefs must have static shape"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<::mlir::gpu::amd::Runtime> runtime{*this, "runtime", ::llvm::cl::desc("Runtime code will be run on (default is Unknown, can also use HIP or OpenCL)"), ::llvm::cl::init(::mlir::gpu::amd::Runtime::Unknown), ::llvm::cl::values(
               clEnumValN(::mlir::gpu::amd::Runtime::Unknown, "unknown",
                          "Unknown (default)"),
               clEnumValN(::mlir::gpu::amd::Runtime::HIP, "HIP", "HIP"),
               clEnumValN(::mlir::gpu::amd::Runtime::OpenCL, "OpenCL",
                          "OpenCL"))};
  ::mlir::Pass::ListOption<std::string> allowedDialects{*this, "allowed-dialects", ::llvm::cl::desc("Run conversion patterns of only the specified dialects")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTGPUOPSTOROCDLOPS
#endif // GEN_PASS_DEF_CONVERTGPUOPSTOROCDLOPS

//===----------------------------------------------------------------------===//
// ConvertIndexToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTINDEXTOLLVMPASS
struct ConvertIndexToLLVMPassOptions {
  unsigned indexBitwidth = 0;
};
std::unique_ptr<::mlir::Pass> createConvertIndexToLLVMPass();
std::unique_ptr<::mlir::Pass> createConvertIndexToLLVMPass(ConvertIndexToLLVMPassOptions options);
#undef GEN_PASS_DECL_CONVERTINDEXTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTINDEXTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTINDEXTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertIndexToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertIndexToLLVMPass(ConvertIndexToLLVMPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertIndexToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertIndexToLLVMPassBase;

  ConvertIndexToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertIndexToLLVMPassBase(const ConvertIndexToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertIndexToLLVMPassBase& operator=(const ConvertIndexToLLVMPassBase &) = delete;
  ConvertIndexToLLVMPassBase(ConvertIndexToLLVMPassBase &&) = delete;
  ConvertIndexToLLVMPassBase& operator=(ConvertIndexToLLVMPassBase &&) = delete;
  ~ConvertIndexToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-index-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-index-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lower the `index` dialect to the `llvm` dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertIndexToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertIndexToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertIndexToLLVMPassBase<DerivedT>)

  ConvertIndexToLLVMPassBase(ConvertIndexToLLVMPassOptions options) : ConvertIndexToLLVMPassBase() {
    indexBitwidth = std::move(options.indexBitwidth);
  }
protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertIndexToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertIndexToLLVMPass(ConvertIndexToLLVMPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertIndexToLLVMPass() {
  return impl::createConvertIndexToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createConvertIndexToLLVMPass(ConvertIndexToLLVMPassOptions options) {
  return impl::createConvertIndexToLLVMPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTINDEXTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTINDEXTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertIndexToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTINDEXTOSPIRVPASS
struct ConvertIndexToSPIRVPassOptions {
  bool use64bitIndex = false;
};
std::unique_ptr<::mlir::Pass> createConvertIndexToSPIRVPass();
std::unique_ptr<::mlir::Pass> createConvertIndexToSPIRVPass(ConvertIndexToSPIRVPassOptions options);
#undef GEN_PASS_DECL_CONVERTINDEXTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTINDEXTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTINDEXTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertIndexToSPIRVPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertIndexToSPIRVPass(ConvertIndexToSPIRVPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertIndexToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertIndexToSPIRVPassBase;

  ConvertIndexToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertIndexToSPIRVPassBase(const ConvertIndexToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertIndexToSPIRVPassBase& operator=(const ConvertIndexToSPIRVPassBase &) = delete;
  ConvertIndexToSPIRVPassBase(ConvertIndexToSPIRVPassBase &&) = delete;
  ConvertIndexToSPIRVPassBase& operator=(ConvertIndexToSPIRVPassBase &&) = delete;
  ~ConvertIndexToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-index-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-index-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Lower the `index` dialect to the `spirv` dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertIndexToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertIndexToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertIndexToSPIRVPassBase<DerivedT>)

  ConvertIndexToSPIRVPassBase(ConvertIndexToSPIRVPassOptions options) : ConvertIndexToSPIRVPassBase() {
    use64bitIndex = std::move(options.use64bitIndex);
  }
protected:
  ::mlir::Pass::Option<bool> use64bitIndex{*this, "use-64bit-index", ::llvm::cl::desc("Use 64-bit integers to convert index types"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertIndexToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertIndexToSPIRVPass(ConvertIndexToSPIRVPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertIndexToSPIRVPass() {
  return impl::createConvertIndexToSPIRVPass();
}

std::unique_ptr<::mlir::Pass> createConvertIndexToSPIRVPass(ConvertIndexToSPIRVPassOptions options) {
  return impl::createConvertIndexToSPIRVPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTINDEXTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTINDEXTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertLinalgToStandardPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLINALGTOSTANDARDPASS
std::unique_ptr<::mlir::Pass> createConvertLinalgToStandardPass();
#undef GEN_PASS_DECL_CONVERTLINALGTOSTANDARDPASS
#endif // GEN_PASS_DECL_CONVERTLINALGTOSTANDARDPASS
#ifdef GEN_PASS_DEF_CONVERTLINALGTOSTANDARDPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertLinalgToStandardPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertLinalgToStandardPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertLinalgToStandardPassBase;

  ConvertLinalgToStandardPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLinalgToStandardPassBase(const ConvertLinalgToStandardPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertLinalgToStandardPassBase& operator=(const ConvertLinalgToStandardPassBase &) = delete;
  ConvertLinalgToStandardPassBase(ConvertLinalgToStandardPassBase &&) = delete;
  ConvertLinalgToStandardPassBase& operator=(ConvertLinalgToStandardPassBase &&) = delete;
  ~ConvertLinalgToStandardPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-linalg-to-std");
  }
  ::llvm::StringRef getArgument() const override { return "convert-linalg-to-std"; }

  ::llvm::StringRef getDescription() const override { return "Convert the operations from the linalg dialect into the Standard dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLinalgToStandardPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLinalgToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLinalgToStandardPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertLinalgToStandardPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertLinalgToStandardPass() {
  return impl::createConvertLinalgToStandardPass();
}
#undef GEN_PASS_DEF_CONVERTLINALGTOSTANDARDPASS
#endif // GEN_PASS_DEF_CONVERTLINALGTOSTANDARDPASS

//===----------------------------------------------------------------------===//
// ConvertMathToEmitC
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMATHTOEMITC
struct ConvertMathToEmitCOptions {
  ::mlir::emitc::LanguageTarget languageTarget = ::mlir::emitc::LanguageTarget::c99;
};
std::unique_ptr<::mlir::Pass> createConvertMathToEmitC();
std::unique_ptr<::mlir::Pass> createConvertMathToEmitC(ConvertMathToEmitCOptions options);
#undef GEN_PASS_DECL_CONVERTMATHTOEMITC
#endif // GEN_PASS_DECL_CONVERTMATHTOEMITC
#ifdef GEN_PASS_DEF_CONVERTMATHTOEMITC

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToEmitC();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToEmitC(ConvertMathToEmitCOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMathToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMathToEmitCBase;

  ConvertMathToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToEmitCBase(const ConvertMathToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMathToEmitCBase& operator=(const ConvertMathToEmitCBase &) = delete;
  ConvertMathToEmitCBase(ConvertMathToEmitCBase &&) = delete;
  ConvertMathToEmitCBase& operator=(ConvertMathToEmitCBase &&) = delete;
  ~ConvertMathToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert some Math operations to EmitC call_opaque operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToEmitCBase<DerivedT>)

  ConvertMathToEmitCBase(ConvertMathToEmitCOptions options) : ConvertMathToEmitCBase() {
    languageTarget = std::move(options.languageTarget);
  }
protected:
  ::mlir::Pass::Option<::mlir::emitc::LanguageTarget> languageTarget{*this, "language-target", ::llvm::cl::desc("Select the language standard target for callees (c99 or cpp11)."), ::llvm::cl::init(::mlir::emitc::LanguageTarget::c99), ::llvm::cl::values(
            clEnumValN(::mlir::emitc::LanguageTarget::c99, "c99", "c99"),
            clEnumValN(::mlir::emitc::LanguageTarget::cpp11, "cpp11", "cpp11")
          )};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMathToEmitC() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertMathToEmitC(ConvertMathToEmitCOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMathToEmitC() {
  return impl::createConvertMathToEmitC();
}

std::unique_ptr<::mlir::Pass> createConvertMathToEmitC(ConvertMathToEmitCOptions options) {
  return impl::createConvertMathToEmitC(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTMATHTOEMITC
#endif // GEN_PASS_DEF_CONVERTMATHTOEMITC

//===----------------------------------------------------------------------===//
// ConvertMathToFuncs
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMATHTOFUNCS
struct ConvertMathToFuncsOptions {
  unsigned minWidthOfFPowIExponent = 1;
  bool convertCtlz = false;
};
std::unique_ptr<::mlir::Pass> createConvertMathToFuncs();
std::unique_ptr<::mlir::Pass> createConvertMathToFuncs(ConvertMathToFuncsOptions options);
#undef GEN_PASS_DECL_CONVERTMATHTOFUNCS
#endif // GEN_PASS_DECL_CONVERTMATHTOFUNCS
#ifdef GEN_PASS_DEF_CONVERTMATHTOFUNCS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToFuncs();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToFuncs(ConvertMathToFuncsOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMathToFuncsBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertMathToFuncsBase;

  ConvertMathToFuncsBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToFuncsBase(const ConvertMathToFuncsBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertMathToFuncsBase& operator=(const ConvertMathToFuncsBase &) = delete;
  ConvertMathToFuncsBase(ConvertMathToFuncsBase &&) = delete;
  ConvertMathToFuncsBase& operator=(ConvertMathToFuncsBase &&) = delete;
  ~ConvertMathToFuncsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-funcs");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-funcs"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math operations to calls of outlined implementations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToFuncs");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToFuncs"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<vector::VectorDialect>();
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToFuncsBase<DerivedT>)

  ConvertMathToFuncsBase(ConvertMathToFuncsOptions options) : ConvertMathToFuncsBase() {
    minWidthOfFPowIExponent = std::move(options.minWidthOfFPowIExponent);
    convertCtlz = std::move(options.convertCtlz);
  }
protected:
  ::mlir::Pass::Option<unsigned> minWidthOfFPowIExponent{*this, "min-width-of-fpowi-exponent", ::llvm::cl::desc("Convert FPowI only if the width of its exponent's integer type is greater than or equal to this value"), ::llvm::cl::init(1)};
  ::mlir::Pass::Option<bool> convertCtlz{*this, "convert-ctlz", ::llvm::cl::desc("Convert math.ctlz to a software implementation. Enable for targets that do not natively support ctlz."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMathToFuncs() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertMathToFuncs(ConvertMathToFuncsOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMathToFuncs() {
  return impl::createConvertMathToFuncs();
}

std::unique_ptr<::mlir::Pass> createConvertMathToFuncs(ConvertMathToFuncsOptions options) {
  return impl::createConvertMathToFuncs(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTMATHTOFUNCS
#endif // GEN_PASS_DEF_CONVERTMATHTOFUNCS

//===----------------------------------------------------------------------===//
// ConvertMathToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMATHTOLLVMPASS
struct ConvertMathToLLVMPassOptions {
  bool approximateLog1p = true;
};
std::unique_ptr<::mlir::Pass> createConvertMathToLLVMPass();
std::unique_ptr<::mlir::Pass> createConvertMathToLLVMPass(ConvertMathToLLVMPassOptions options);
#undef GEN_PASS_DECL_CONVERTMATHTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTMATHTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTMATHTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToLLVMPass(ConvertMathToLLVMPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMathToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMathToLLVMPassBase;

  ConvertMathToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToLLVMPassBase(const ConvertMathToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMathToLLVMPassBase& operator=(const ConvertMathToLLVMPassBase &) = delete;
  ConvertMathToLLVMPassBase(ConvertMathToLLVMPassBase &&) = delete;
  ConvertMathToLLVMPassBase& operator=(ConvertMathToLLVMPassBase &&) = delete;
  ~ConvertMathToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToLLVMPassBase<DerivedT>)

  ConvertMathToLLVMPassBase(ConvertMathToLLVMPassOptions options) : ConvertMathToLLVMPassBase() {
    approximateLog1p = std::move(options.approximateLog1p);
  }
protected:
  ::mlir::Pass::Option<bool> approximateLog1p{*this, "approximate-log1p", ::llvm::cl::desc("Enable approximation of Log1p."), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMathToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertMathToLLVMPass(ConvertMathToLLVMPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMathToLLVMPass() {
  return impl::createConvertMathToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createConvertMathToLLVMPass(ConvertMathToLLVMPassOptions options) {
  return impl::createConvertMathToLLVMPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTMATHTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTMATHTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertMathToLibmPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMATHTOLIBMPASS
std::unique_ptr<::mlir::Pass> createConvertMathToLibmPass();
#undef GEN_PASS_DECL_CONVERTMATHTOLIBMPASS
#endif // GEN_PASS_DECL_CONVERTMATHTOLIBMPASS
#ifdef GEN_PASS_DEF_CONVERTMATHTOLIBMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToLibmPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMathToLibmPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertMathToLibmPassBase;

  ConvertMathToLibmPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToLibmPassBase(const ConvertMathToLibmPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertMathToLibmPassBase& operator=(const ConvertMathToLibmPassBase &) = delete;
  ConvertMathToLibmPassBase(ConvertMathToLibmPassBase &&) = delete;
  ConvertMathToLibmPassBase& operator=(ConvertMathToLibmPassBase &&) = delete;
  ~ConvertMathToLibmPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-libm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-libm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math dialect to libm calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToLibmPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToLibmPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToLibmPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMathToLibmPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMathToLibmPass() {
  return impl::createConvertMathToLibmPass();
}
#undef GEN_PASS_DEF_CONVERTMATHTOLIBMPASS
#endif // GEN_PASS_DEF_CONVERTMATHTOLIBMPASS

//===----------------------------------------------------------------------===//
// ConvertMathToROCDL
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMATHTOROCDL
std::unique_ptr<::mlir::Pass> createConvertMathToROCDL();
#undef GEN_PASS_DECL_CONVERTMATHTOROCDL
#endif // GEN_PASS_DECL_CONVERTMATHTOROCDL
#ifdef GEN_PASS_DEF_CONVERTMATHTOROCDL

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToROCDL();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMathToROCDLBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertMathToROCDLBase;

  ConvertMathToROCDLBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToROCDLBase(const ConvertMathToROCDLBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertMathToROCDLBase& operator=(const ConvertMathToROCDLBase &) = delete;
  ConvertMathToROCDLBase(ConvertMathToROCDLBase &&) = delete;
  ConvertMathToROCDLBase& operator=(ConvertMathToROCDLBase &&) = delete;
  ~ConvertMathToROCDLBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-rocdl");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-rocdl"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math dialect to ROCDL library calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToROCDL");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToROCDL"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<ROCDL::ROCDLDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToROCDLBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMathToROCDL() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMathToROCDL() {
  return impl::createConvertMathToROCDL();
}
#undef GEN_PASS_DEF_CONVERTMATHTOROCDL
#endif // GEN_PASS_DEF_CONVERTMATHTOROCDL

//===----------------------------------------------------------------------===//
// ConvertMathToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMATHTOSPIRVPASS
std::unique_ptr<::mlir::Pass> createConvertMathToSPIRVPass();
#undef GEN_PASS_DECL_CONVERTMATHTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTMATHTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTMATHTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMathToSPIRVPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMathToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMathToSPIRVPassBase;

  ConvertMathToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToSPIRVPassBase(const ConvertMathToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMathToSPIRVPassBase& operator=(const ConvertMathToSPIRVPassBase &) = delete;
  ConvertMathToSPIRVPassBase(ConvertMathToSPIRVPassBase &&) = delete;
  ConvertMathToSPIRVPassBase& operator=(ConvertMathToSPIRVPassBase &&) = delete;
  ~ConvertMathToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToSPIRVPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMathToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMathToSPIRVPass() {
  return impl::createConvertMathToSPIRVPass();
}
#undef GEN_PASS_DEF_CONVERTMATHTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTMATHTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertMemRefToEmitC
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMEMREFTOEMITC
std::unique_ptr<::mlir::Pass> createConvertMemRefToEmitC();
#undef GEN_PASS_DECL_CONVERTMEMREFTOEMITC
#endif // GEN_PASS_DECL_CONVERTMEMREFTOEMITC
#ifdef GEN_PASS_DEF_CONVERTMEMREFTOEMITC

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMemRefToEmitC();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMemRefToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMemRefToEmitCBase;

  ConvertMemRefToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMemRefToEmitCBase(const ConvertMemRefToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMemRefToEmitCBase& operator=(const ConvertMemRefToEmitCBase &) = delete;
  ConvertMemRefToEmitCBase(ConvertMemRefToEmitCBase &&) = delete;
  ConvertMemRefToEmitCBase& operator=(ConvertMemRefToEmitCBase &&) = delete;
  ~ConvertMemRefToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-memref-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-memref-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert MemRef dialect to EmitC dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMemRefToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertMemRefToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMemRefToEmitCBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMemRefToEmitC() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMemRefToEmitC() {
  return impl::createConvertMemRefToEmitC();
}
#undef GEN_PASS_DEF_CONVERTMEMREFTOEMITC
#endif // GEN_PASS_DEF_CONVERTMEMREFTOEMITC

//===----------------------------------------------------------------------===//
// ConvertMemRefToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMEMREFTOSPIRVPASS
struct ConvertMemRefToSPIRVPassOptions {
  int boolNumBits = 8;
  bool use64bitIndex = false;
};
std::unique_ptr<::mlir::Pass> createConvertMemRefToSPIRVPass();
std::unique_ptr<::mlir::Pass> createConvertMemRefToSPIRVPass(ConvertMemRefToSPIRVPassOptions options);
#undef GEN_PASS_DECL_CONVERTMEMREFTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTMEMREFTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTMEMREFTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMemRefToSPIRVPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMemRefToSPIRVPass(ConvertMemRefToSPIRVPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMemRefToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMemRefToSPIRVPassBase;

  ConvertMemRefToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMemRefToSPIRVPassBase(const ConvertMemRefToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMemRefToSPIRVPassBase& operator=(const ConvertMemRefToSPIRVPassBase &) = delete;
  ConvertMemRefToSPIRVPassBase(ConvertMemRefToSPIRVPassBase &&) = delete;
  ConvertMemRefToSPIRVPassBase& operator=(ConvertMemRefToSPIRVPassBase &&) = delete;
  ~ConvertMemRefToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-memref-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-memref-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert MemRef dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMemRefToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMemRefToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMemRefToSPIRVPassBase<DerivedT>)

  ConvertMemRefToSPIRVPassBase(ConvertMemRefToSPIRVPassOptions options) : ConvertMemRefToSPIRVPassBase() {
    boolNumBits = std::move(options.boolNumBits);
    use64bitIndex = std::move(options.use64bitIndex);
  }
protected:
  ::mlir::Pass::Option<int> boolNumBits{*this, "bool-num-bits", ::llvm::cl::desc("The number of bits to store a boolean value"), ::llvm::cl::init(8)};
  ::mlir::Pass::Option<bool> use64bitIndex{*this, "use-64bit-index", ::llvm::cl::desc("Use 64-bit integers to convert index types"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMemRefToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertMemRefToSPIRVPass(ConvertMemRefToSPIRVPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMemRefToSPIRVPass() {
  return impl::createConvertMemRefToSPIRVPass();
}

std::unique_ptr<::mlir::Pass> createConvertMemRefToSPIRVPass(ConvertMemRefToSPIRVPassOptions options) {
  return impl::createConvertMemRefToSPIRVPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTMEMREFTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTMEMREFTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertMeshToMPIPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMESHTOMPIPASS
std::unique_ptr<::mlir::Pass> createConvertMeshToMPIPass();
#undef GEN_PASS_DECL_CONVERTMESHTOMPIPASS
#endif // GEN_PASS_DECL_CONVERTMESHTOMPIPASS
#ifdef GEN_PASS_DEF_CONVERTMESHTOMPIPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertMeshToMPIPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertMeshToMPIPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMeshToMPIPassBase;

  ConvertMeshToMPIPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMeshToMPIPassBase(const ConvertMeshToMPIPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMeshToMPIPassBase& operator=(const ConvertMeshToMPIPassBase &) = delete;
  ConvertMeshToMPIPassBase(ConvertMeshToMPIPassBase &&) = delete;
  ConvertMeshToMPIPassBase& operator=(ConvertMeshToMPIPassBase &&) = delete;
  ~ConvertMeshToMPIPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-mesh-to-mpi");
  }
  ::llvm::StringRef getArgument() const override { return "convert-mesh-to-mpi"; }

  ::llvm::StringRef getDescription() const override { return "Convert Mesh dialect to MPI dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMeshToMPIPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMeshToMPIPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<mpi::MPIDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<bufferization::BufferizationDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMeshToMPIPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertMeshToMPIPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertMeshToMPIPass() {
  return impl::createConvertMeshToMPIPass();
}
#undef GEN_PASS_DEF_CONVERTMESHTOMPIPASS
#endif // GEN_PASS_DEF_CONVERTMESHTOMPIPASS

//===----------------------------------------------------------------------===//
// ConvertNVGPUToNVVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTNVGPUTONVVMPASS
std::unique_ptr<::mlir::Pass> createConvertNVGPUToNVVMPass();
#undef GEN_PASS_DECL_CONVERTNVGPUTONVVMPASS
#endif // GEN_PASS_DECL_CONVERTNVGPUTONVVMPASS
#ifdef GEN_PASS_DEF_CONVERTNVGPUTONVVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertNVGPUToNVVMPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertNVGPUToNVVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertNVGPUToNVVMPassBase;

  ConvertNVGPUToNVVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertNVGPUToNVVMPassBase(const ConvertNVGPUToNVVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertNVGPUToNVVMPassBase& operator=(const ConvertNVGPUToNVVMPassBase &) = delete;
  ConvertNVGPUToNVVMPassBase(ConvertNVGPUToNVVMPassBase &&) = delete;
  ConvertNVGPUToNVVMPassBase& operator=(ConvertNVGPUToNVVMPassBase &&) = delete;
  ~ConvertNVGPUToNVVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-nvgpu-to-nvvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-nvgpu-to-nvvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert NVGPU dialect to NVVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertNVGPUToNVVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertNVGPUToNVVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertNVGPUToNVVMPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertNVGPUToNVVMPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertNVGPUToNVVMPass() {
  return impl::createConvertNVGPUToNVVMPass();
}
#undef GEN_PASS_DEF_CONVERTNVGPUTONVVMPASS
#endif // GEN_PASS_DEF_CONVERTNVGPUTONVVMPASS

//===----------------------------------------------------------------------===//
// ConvertNVVMToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTNVVMTOLLVMPASS
std::unique_ptr<::mlir::Pass> createConvertNVVMToLLVMPass();
#undef GEN_PASS_DECL_CONVERTNVVMTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTNVVMTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTNVVMTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertNVVMToLLVMPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertNVVMToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertNVVMToLLVMPassBase;

  ConvertNVVMToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertNVVMToLLVMPassBase(const ConvertNVVMToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertNVVMToLLVMPassBase& operator=(const ConvertNVVMToLLVMPassBase &) = delete;
  ConvertNVVMToLLVMPassBase(ConvertNVVMToLLVMPassBase &&) = delete;
  ConvertNVVMToLLVMPassBase& operator=(ConvertNVVMToLLVMPassBase &&) = delete;
  ~ConvertNVVMToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-nvvm-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-nvvm-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert NVVM to PTX with Inline Assembly in LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertNVVMToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertNVVMToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertNVVMToLLVMPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertNVVMToLLVMPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertNVVMToLLVMPass() {
  return impl::createConvertNVVMToLLVMPass();
}
#undef GEN_PASS_DEF_CONVERTNVVMTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTNVVMTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertOpenACCToSCFPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTOPENACCTOSCFPASS
std::unique_ptr<::mlir::Pass> createConvertOpenACCToSCFPass();
#undef GEN_PASS_DECL_CONVERTOPENACCTOSCFPASS
#endif // GEN_PASS_DECL_CONVERTOPENACCTOSCFPASS
#ifdef GEN_PASS_DEF_CONVERTOPENACCTOSCFPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertOpenACCToSCFPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertOpenACCToSCFPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertOpenACCToSCFPassBase;

  ConvertOpenACCToSCFPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertOpenACCToSCFPassBase(const ConvertOpenACCToSCFPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertOpenACCToSCFPassBase& operator=(const ConvertOpenACCToSCFPassBase &) = delete;
  ConvertOpenACCToSCFPassBase(ConvertOpenACCToSCFPassBase &&) = delete;
  ConvertOpenACCToSCFPassBase& operator=(ConvertOpenACCToSCFPassBase &&) = delete;
  ~ConvertOpenACCToSCFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-openacc-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-openacc-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Convert the OpenACC ops to OpenACC with SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertOpenACCToSCFPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertOpenACCToSCFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<acc::OpenACCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertOpenACCToSCFPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertOpenACCToSCFPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertOpenACCToSCFPass() {
  return impl::createConvertOpenACCToSCFPass();
}
#undef GEN_PASS_DEF_CONVERTOPENACCTOSCFPASS
#endif // GEN_PASS_DEF_CONVERTOPENACCTOSCFPASS

//===----------------------------------------------------------------------===//
// ConvertOpenMPToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTOPENMPTOLLVMPASS
std::unique_ptr<::mlir::Pass> createConvertOpenMPToLLVMPass();
#undef GEN_PASS_DECL_CONVERTOPENMPTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTOPENMPTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTOPENMPTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertOpenMPToLLVMPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertOpenMPToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertOpenMPToLLVMPassBase;

  ConvertOpenMPToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertOpenMPToLLVMPassBase(const ConvertOpenMPToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertOpenMPToLLVMPassBase& operator=(const ConvertOpenMPToLLVMPassBase &) = delete;
  ConvertOpenMPToLLVMPassBase(ConvertOpenMPToLLVMPassBase &&) = delete;
  ConvertOpenMPToLLVMPassBase& operator=(ConvertOpenMPToLLVMPassBase &&) = delete;
  ~ConvertOpenMPToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-openmp-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-openmp-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert the OpenMP ops to OpenMP ops with LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertOpenMPToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertOpenMPToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertOpenMPToLLVMPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertOpenMPToLLVMPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertOpenMPToLLVMPass() {
  return impl::createConvertOpenMPToLLVMPass();
}
#undef GEN_PASS_DEF_CONVERTOPENMPTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTOPENMPTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertPDLToPDLInterpPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTPDLTOPDLINTERPPASS
std::unique_ptr<::mlir::Pass> createConvertPDLToPDLInterpPass();
#undef GEN_PASS_DECL_CONVERTPDLTOPDLINTERPPASS
#endif // GEN_PASS_DECL_CONVERTPDLTOPDLINTERPPASS
#ifdef GEN_PASS_DEF_CONVERTPDLTOPDLINTERPPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertPDLToPDLInterpPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertPDLToPDLInterpPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertPDLToPDLInterpPassBase;

  ConvertPDLToPDLInterpPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertPDLToPDLInterpPassBase(const ConvertPDLToPDLInterpPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertPDLToPDLInterpPassBase& operator=(const ConvertPDLToPDLInterpPassBase &) = delete;
  ConvertPDLToPDLInterpPassBase(ConvertPDLToPDLInterpPassBase &&) = delete;
  ConvertPDLToPDLInterpPassBase& operator=(ConvertPDLToPDLInterpPassBase &&) = delete;
  ~ConvertPDLToPDLInterpPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-pdl-to-pdl-interp");
  }
  ::llvm::StringRef getArgument() const override { return "convert-pdl-to-pdl-interp"; }

  ::llvm::StringRef getDescription() const override { return "Convert PDL ops to PDL interpreter ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertPDLToPDLInterpPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertPDLToPDLInterpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<pdl_interp::PDLInterpDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertPDLToPDLInterpPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertPDLToPDLInterpPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertPDLToPDLInterpPass() {
  return impl::createConvertPDLToPDLInterpPass();
}
#undef GEN_PASS_DEF_CONVERTPDLTOPDLINTERPPASS
#endif // GEN_PASS_DEF_CONVERTPDLTOPDLINTERPPASS

//===----------------------------------------------------------------------===//
// ConvertParallelLoopToGpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTPARALLELLOOPTOGPUPASS
std::unique_ptr<::mlir::Pass> createConvertParallelLoopToGpuPass();
#undef GEN_PASS_DECL_CONVERTPARALLELLOOPTOGPUPASS
#endif // GEN_PASS_DECL_CONVERTPARALLELLOOPTOGPUPASS
#ifdef GEN_PASS_DEF_CONVERTPARALLELLOOPTOGPUPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertParallelLoopToGpuPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertParallelLoopToGpuPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertParallelLoopToGpuPassBase;

  ConvertParallelLoopToGpuPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertParallelLoopToGpuPassBase(const ConvertParallelLoopToGpuPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertParallelLoopToGpuPassBase& operator=(const ConvertParallelLoopToGpuPassBase &) = delete;
  ConvertParallelLoopToGpuPassBase(ConvertParallelLoopToGpuPassBase &&) = delete;
  ConvertParallelLoopToGpuPassBase& operator=(ConvertParallelLoopToGpuPassBase &&) = delete;
  ~ConvertParallelLoopToGpuPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-parallel-loops-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-parallel-loops-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Convert mapped scf.parallel ops to gpu launch operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertParallelLoopToGpuPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertParallelLoopToGpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<gpu::GPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertParallelLoopToGpuPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertParallelLoopToGpuPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertParallelLoopToGpuPass() {
  return impl::createConvertParallelLoopToGpuPass();
}
#undef GEN_PASS_DEF_CONVERTPARALLELLOOPTOGPUPASS
#endif // GEN_PASS_DEF_CONVERTPARALLELLOOPTOGPUPASS

//===----------------------------------------------------------------------===//
// ConvertSCFToOpenMPPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTSCFTOOPENMPPASS
struct ConvertSCFToOpenMPPassOptions {
  unsigned numThreads = 0;
};
std::unique_ptr<::mlir::Pass> createConvertSCFToOpenMPPass();
std::unique_ptr<::mlir::Pass> createConvertSCFToOpenMPPass(ConvertSCFToOpenMPPassOptions options);
#undef GEN_PASS_DECL_CONVERTSCFTOOPENMPPASS
#endif // GEN_PASS_DECL_CONVERTSCFTOOPENMPPASS
#ifdef GEN_PASS_DEF_CONVERTSCFTOOPENMPPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertSCFToOpenMPPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertSCFToOpenMPPass(ConvertSCFToOpenMPPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertSCFToOpenMPPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertSCFToOpenMPPassBase;

  ConvertSCFToOpenMPPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertSCFToOpenMPPassBase(const ConvertSCFToOpenMPPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertSCFToOpenMPPassBase& operator=(const ConvertSCFToOpenMPPassBase &) = delete;
  ConvertSCFToOpenMPPassBase(ConvertSCFToOpenMPPassBase &&) = delete;
  ConvertSCFToOpenMPPassBase& operator=(ConvertSCFToOpenMPPassBase &&) = delete;
  ~ConvertSCFToOpenMPPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-scf-to-openmp");
  }
  ::llvm::StringRef getArgument() const override { return "convert-scf-to-openmp"; }

  ::llvm::StringRef getDescription() const override { return "Convert SCF parallel loop to OpenMP parallel + workshare constructs."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertSCFToOpenMPPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertSCFToOpenMPPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<omp::OpenMPDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertSCFToOpenMPPassBase<DerivedT>)

  ConvertSCFToOpenMPPassBase(ConvertSCFToOpenMPPassOptions options) : ConvertSCFToOpenMPPassBase() {
    numThreads = std::move(options.numThreads);
  }
protected:
  ::mlir::Pass::Option<unsigned> numThreads{*this, "num-threads", ::llvm::cl::desc("Number of threads to use"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertSCFToOpenMPPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertSCFToOpenMPPass(ConvertSCFToOpenMPPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertSCFToOpenMPPass() {
  return impl::createConvertSCFToOpenMPPass();
}

std::unique_ptr<::mlir::Pass> createConvertSCFToOpenMPPass(ConvertSCFToOpenMPPassOptions options) {
  return impl::createConvertSCFToOpenMPPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTSCFTOOPENMPPASS
#endif // GEN_PASS_DEF_CONVERTSCFTOOPENMPPASS

//===----------------------------------------------------------------------===//
// ConvertSPIRVToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTSPIRVTOLLVMPASS
struct ConvertSPIRVToLLVMPassOptions {
  ::mlir::spirv::ClientAPI clientAPI = ::mlir::spirv::ClientAPI::Unknown;
};
std::unique_ptr<::mlir::Pass> createConvertSPIRVToLLVMPass();
std::unique_ptr<::mlir::Pass> createConvertSPIRVToLLVMPass(ConvertSPIRVToLLVMPassOptions options);
#undef GEN_PASS_DECL_CONVERTSPIRVTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTSPIRVTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTSPIRVTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertSPIRVToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertSPIRVToLLVMPass(ConvertSPIRVToLLVMPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertSPIRVToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertSPIRVToLLVMPassBase;

  ConvertSPIRVToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertSPIRVToLLVMPassBase(const ConvertSPIRVToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertSPIRVToLLVMPassBase& operator=(const ConvertSPIRVToLLVMPassBase &) = delete;
  ConvertSPIRVToLLVMPassBase(ConvertSPIRVToLLVMPassBase &&) = delete;
  ConvertSPIRVToLLVMPassBase& operator=(ConvertSPIRVToLLVMPassBase &&) = delete;
  ~ConvertSPIRVToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-spirv-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-spirv-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert SPIR-V dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertSPIRVToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertSPIRVToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertSPIRVToLLVMPassBase<DerivedT>)

  ConvertSPIRVToLLVMPassBase(ConvertSPIRVToLLVMPassOptions options) : ConvertSPIRVToLLVMPassBase() {
    clientAPI = std::move(options.clientAPI);
  }
protected:
  ::mlir::Pass::Option<::mlir::spirv::ClientAPI> clientAPI{*this, "client-api", ::llvm::cl::desc("Derive StorageClass to address space mapping from the client API"), ::llvm::cl::init(::mlir::spirv::ClientAPI::Unknown), ::llvm::cl::values(
	     clEnumValN(::mlir::spirv::ClientAPI::Unknown, "Unknown", "Unknown (default)"),
	     clEnumValN(::mlir::spirv::ClientAPI::Metal, "Metal", "Metal"),
	     clEnumValN(::mlir::spirv::ClientAPI::OpenCL, "OpenCL", "OpenCL"),
	     clEnumValN(::mlir::spirv::ClientAPI::Vulkan, "Vulkan", "Vulkan"),
	     clEnumValN(::mlir::spirv::ClientAPI::WebGPU, "WebGPU", "WebGPU")
	   )};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertSPIRVToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertSPIRVToLLVMPass(ConvertSPIRVToLLVMPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertSPIRVToLLVMPass() {
  return impl::createConvertSPIRVToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createConvertSPIRVToLLVMPass(ConvertSPIRVToLLVMPassOptions options) {
  return impl::createConvertSPIRVToLLVMPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTSPIRVTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTSPIRVTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertShapeConstraintsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTSHAPECONSTRAINTSPASS
std::unique_ptr<::mlir::Pass> createConvertShapeConstraintsPass();
#undef GEN_PASS_DECL_CONVERTSHAPECONSTRAINTSPASS
#endif // GEN_PASS_DECL_CONVERTSHAPECONSTRAINTSPASS
#ifdef GEN_PASS_DEF_CONVERTSHAPECONSTRAINTSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertShapeConstraintsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertShapeConstraintsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertShapeConstraintsPassBase;

  ConvertShapeConstraintsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertShapeConstraintsPassBase(const ConvertShapeConstraintsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertShapeConstraintsPassBase& operator=(const ConvertShapeConstraintsPassBase &) = delete;
  ConvertShapeConstraintsPassBase(ConvertShapeConstraintsPassBase &&) = delete;
  ConvertShapeConstraintsPassBase& operator=(ConvertShapeConstraintsPassBase &&) = delete;
  ~ConvertShapeConstraintsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-shape-constraints");
  }
  ::llvm::StringRef getArgument() const override { return "convert-shape-constraints"; }

  ::llvm::StringRef getDescription() const override { return "Convert shape constraint operations to the standard dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertShapeConstraintsPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertShapeConstraintsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertShapeConstraintsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertShapeConstraintsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertShapeConstraintsPass() {
  return impl::createConvertShapeConstraintsPass();
}
#undef GEN_PASS_DEF_CONVERTSHAPECONSTRAINTSPASS
#endif // GEN_PASS_DEF_CONVERTSHAPECONSTRAINTSPASS

//===----------------------------------------------------------------------===//
// ConvertShapeToStandardPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTSHAPETOSTANDARDPASS
std::unique_ptr<::mlir::Pass> createConvertShapeToStandardPass();
#undef GEN_PASS_DECL_CONVERTSHAPETOSTANDARDPASS
#endif // GEN_PASS_DECL_CONVERTSHAPETOSTANDARDPASS
#ifdef GEN_PASS_DEF_CONVERTSHAPETOSTANDARDPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertShapeToStandardPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertShapeToStandardPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertShapeToStandardPassBase;

  ConvertShapeToStandardPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertShapeToStandardPassBase(const ConvertShapeToStandardPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertShapeToStandardPassBase& operator=(const ConvertShapeToStandardPassBase &) = delete;
  ConvertShapeToStandardPassBase(ConvertShapeToStandardPassBase &&) = delete;
  ConvertShapeToStandardPassBase& operator=(ConvertShapeToStandardPassBase &&) = delete;
  ~ConvertShapeToStandardPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-shape-to-std");
  }
  ::llvm::StringRef getArgument() const override { return "convert-shape-to-std"; }

  ::llvm::StringRef getDescription() const override { return "Convert operations from the shape dialect into the standard dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertShapeToStandardPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertShapeToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertShapeToStandardPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertShapeToStandardPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertShapeToStandardPass() {
  return impl::createConvertShapeToStandardPass();
}
#undef GEN_PASS_DEF_CONVERTSHAPETOSTANDARDPASS
#endif // GEN_PASS_DEF_CONVERTSHAPETOSTANDARDPASS

//===----------------------------------------------------------------------===//
// ConvertTensorToLinalgPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTENSORTOLINALGPASS
std::unique_ptr<::mlir::Pass> createConvertTensorToLinalgPass();
#undef GEN_PASS_DECL_CONVERTTENSORTOLINALGPASS
#endif // GEN_PASS_DECL_CONVERTTENSORTOLINALGPASS
#ifdef GEN_PASS_DEF_CONVERTTENSORTOLINALGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertTensorToLinalgPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertTensorToLinalgPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertTensorToLinalgPassBase;

  ConvertTensorToLinalgPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTensorToLinalgPassBase(const ConvertTensorToLinalgPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertTensorToLinalgPassBase& operator=(const ConvertTensorToLinalgPassBase &) = delete;
  ConvertTensorToLinalgPassBase(ConvertTensorToLinalgPassBase &&) = delete;
  ConvertTensorToLinalgPassBase& operator=(ConvertTensorToLinalgPassBase &&) = delete;
  ~ConvertTensorToLinalgPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tensor-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tensor-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Convert some Tensor dialect ops to Linalg dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTensorToLinalgPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTensorToLinalgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<linalg::LinalgDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTensorToLinalgPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertTensorToLinalgPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertTensorToLinalgPass() {
  return impl::createConvertTensorToLinalgPass();
}
#undef GEN_PASS_DEF_CONVERTTENSORTOLINALGPASS
#endif // GEN_PASS_DEF_CONVERTTENSORTOLINALGPASS

//===----------------------------------------------------------------------===//
// ConvertTensorToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTENSORTOSPIRVPASS
struct ConvertTensorToSPIRVPassOptions {
  bool emulateLT32BitScalarTypes = true;
};
std::unique_ptr<::mlir::Pass> createConvertTensorToSPIRVPass();
std::unique_ptr<::mlir::Pass> createConvertTensorToSPIRVPass(ConvertTensorToSPIRVPassOptions options);
#undef GEN_PASS_DECL_CONVERTTENSORTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTTENSORTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTTENSORTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertTensorToSPIRVPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertTensorToSPIRVPass(ConvertTensorToSPIRVPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertTensorToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertTensorToSPIRVPassBase;

  ConvertTensorToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTensorToSPIRVPassBase(const ConvertTensorToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertTensorToSPIRVPassBase& operator=(const ConvertTensorToSPIRVPassBase &) = delete;
  ConvertTensorToSPIRVPassBase(ConvertTensorToSPIRVPassBase &&) = delete;
  ConvertTensorToSPIRVPassBase& operator=(ConvertTensorToSPIRVPassBase &&) = delete;
  ~ConvertTensorToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tensor-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tensor-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Tensor dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTensorToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTensorToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTensorToSPIRVPassBase<DerivedT>)

  ConvertTensorToSPIRVPassBase(ConvertTensorToSPIRVPassOptions options) : ConvertTensorToSPIRVPassBase() {
    emulateLT32BitScalarTypes = std::move(options.emulateLT32BitScalarTypes);
  }
protected:
  ::mlir::Pass::Option<bool> emulateLT32BitScalarTypes{*this, "emulate-lt-32-bit-scalar-types", ::llvm::cl::desc("Emulate narrower scalar types with 32-bit ones if not supported by the target"), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertTensorToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertTensorToSPIRVPass(ConvertTensorToSPIRVPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertTensorToSPIRVPass() {
  return impl::createConvertTensorToSPIRVPass();
}

std::unique_ptr<::mlir::Pass> createConvertTensorToSPIRVPass(ConvertTensorToSPIRVPassOptions options) {
  return impl::createConvertTensorToSPIRVPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTTENSORTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTTENSORTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertToEmitC
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTOEMITC
struct ConvertToEmitCOptions {
  ::llvm::SmallVector<std::string> filterDialects;
};
std::unique_ptr<::mlir::Pass> createConvertToEmitC();
std::unique_ptr<::mlir::Pass> createConvertToEmitC(ConvertToEmitCOptions options);
#undef GEN_PASS_DECL_CONVERTTOEMITC
#endif // GEN_PASS_DECL_CONVERTTOEMITC
#ifdef GEN_PASS_DEF_CONVERTTOEMITC

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertToEmitC();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertToEmitC(ConvertToEmitCOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertToEmitCBase;

  ConvertToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToEmitCBase(const ConvertToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertToEmitCBase& operator=(const ConvertToEmitCBase &) = delete;
  ConvertToEmitCBase(ConvertToEmitCBase &&) = delete;
  ConvertToEmitCBase& operator=(ConvertToEmitCBase &&) = delete;
  ~ConvertToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert to EmitC dialect via dialect interfaces"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToEmitCBase<DerivedT>)

  ConvertToEmitCBase(ConvertToEmitCOptions options) : ConvertToEmitCBase() {
    filterDialects = std::move(options.filterDialects);
  }
protected:
  ::mlir::Pass::ListOption<std::string> filterDialects{*this, "filter-dialects", ::llvm::cl::desc("Test conversion patterns of only the specified dialects")};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertToEmitC() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertToEmitC(ConvertToEmitCOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertToEmitC() {
  return impl::createConvertToEmitC();
}

std::unique_ptr<::mlir::Pass> createConvertToEmitC(ConvertToEmitCOptions options) {
  return impl::createConvertToEmitC(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTTOEMITC
#endif // GEN_PASS_DEF_CONVERTTOEMITC

//===----------------------------------------------------------------------===//
// ConvertToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTOLLVMPASS
struct ConvertToLLVMPassOptions {
  ::llvm::SmallVector<std::string> filterDialects;
  bool useDynamic = false;
};
std::unique_ptr<::mlir::Pass> createConvertToLLVMPass();
std::unique_ptr<::mlir::Pass> createConvertToLLVMPass(ConvertToLLVMPassOptions options);
#undef GEN_PASS_DECL_CONVERTTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertToLLVMPass(ConvertToLLVMPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertToLLVMPassBase;

  ConvertToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToLLVMPassBase(const ConvertToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertToLLVMPassBase& operator=(const ConvertToLLVMPassBase &) = delete;
  ConvertToLLVMPassBase(ConvertToLLVMPassBase &&) = delete;
  ConvertToLLVMPassBase& operator=(ConvertToLLVMPassBase &&) = delete;
  ~ConvertToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert to LLVM via dialect interfaces found in the input IR"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToLLVMPassBase<DerivedT>)

  ConvertToLLVMPassBase(ConvertToLLVMPassOptions options) : ConvertToLLVMPassBase() {
    filterDialects = std::move(options.filterDialects);
    useDynamic = std::move(options.useDynamic);
  }
protected:
  ::mlir::Pass::ListOption<std::string> filterDialects{*this, "filter-dialects", ::llvm::cl::desc("Test conversion patterns of only the specified dialects")};
  ::mlir::Pass::Option<bool> useDynamic{*this, "dynamic", ::llvm::cl::desc("Use op conversion attributes to configure the conversion"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertToLLVMPass(ConvertToLLVMPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertToLLVMPass() {
  return impl::createConvertToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createConvertToLLVMPass(ConvertToLLVMPassOptions options) {
  return impl::createConvertToLLVMPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertVectorToArmSMEPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTVECTORTOARMSMEPASS
std::unique_ptr<::mlir::Pass> createConvertVectorToArmSMEPass();
#undef GEN_PASS_DECL_CONVERTVECTORTOARMSMEPASS
#endif // GEN_PASS_DECL_CONVERTVECTORTOARMSMEPASS
#ifdef GEN_PASS_DEF_CONVERTVECTORTOARMSMEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertVectorToArmSMEPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertVectorToArmSMEPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToArmSMEPassBase;

  ConvertVectorToArmSMEPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToArmSMEPassBase(const ConvertVectorToArmSMEPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToArmSMEPassBase& operator=(const ConvertVectorToArmSMEPassBase &) = delete;
  ConvertVectorToArmSMEPassBase(ConvertVectorToArmSMEPassBase &&) = delete;
  ConvertVectorToArmSMEPassBase& operator=(ConvertVectorToArmSMEPassBase &&) = delete;
  ~ConvertVectorToArmSMEPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-arm-sme");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-arm-sme"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the ArmSME dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToArmSMEPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToArmSMEPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arm_sme::ArmSMEDialect>();
    registry.insert<arm_sve::ArmSVEDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToArmSMEPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertVectorToArmSMEPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertVectorToArmSMEPass() {
  return impl::createConvertVectorToArmSMEPass();
}
#undef GEN_PASS_DEF_CONVERTVECTORTOARMSMEPASS
#endif // GEN_PASS_DEF_CONVERTVECTORTOARMSMEPASS

//===----------------------------------------------------------------------===//
// ConvertVectorToGPU
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTVECTORTOGPU
struct ConvertVectorToGPUOptions {
  bool useNvGpu = false;
};
#undef GEN_PASS_DECL_CONVERTVECTORTOGPU
#endif // GEN_PASS_DECL_CONVERTVECTORTOGPU
#ifdef GEN_PASS_DEF_CONVERTVECTORTOGPU
namespace impl {

template <typename DerivedT>
class ConvertVectorToGPUBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToGPUBase;

  ConvertVectorToGPUBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToGPUBase(const ConvertVectorToGPUBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToGPUBase& operator=(const ConvertVectorToGPUBase &) = delete;
  ConvertVectorToGPUBase(ConvertVectorToGPUBase &&) = delete;
  ConvertVectorToGPUBase& operator=(ConvertVectorToGPUBase &&) = delete;
  ~ConvertVectorToGPUBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the GPU dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToGPU");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToGPU"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<gpu::GPUDialect>();
    registry.insert<affine::AffineDialect>();
    registry.insert<vector::VectorDialect>();
    registry.insert<nvgpu::NVGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToGPUBase<DerivedT>)

  ConvertVectorToGPUBase(ConvertVectorToGPUOptions options) : ConvertVectorToGPUBase() {
    useNvGpu = std::move(options.useNvGpu);
  }
protected:
  ::mlir::Pass::Option<bool> useNvGpu{*this, "use-nvgpu", ::llvm::cl::desc("convert to NvGPU ops instead of GPU dialect ops"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTVECTORTOGPU
#endif // GEN_PASS_DEF_CONVERTVECTORTOGPU

//===----------------------------------------------------------------------===//
// ConvertVectorToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTVECTORTOLLVMPASS
struct ConvertVectorToLLVMPassOptions {
  bool reassociateFPReductions = false;
  bool force32BitVectorIndices = true;
  bool useVectorAlignment = false;
  bool amx = false;
  bool armNeon = false;
  bool armSVE = false;
  bool armI8MM = false;
  bool x86Vector = false;
  vector::VectorContractLowering vectorContractLowering = vector::VectorContractLowering::Dot;
  vector::VectorTransposeLowering vectorTransposeLowering = vector::VectorTransposeLowering::EltWise;
};
std::unique_ptr<::mlir::Pass> createConvertVectorToLLVMPass();
std::unique_ptr<::mlir::Pass> createConvertVectorToLLVMPass(ConvertVectorToLLVMPassOptions options);
#undef GEN_PASS_DECL_CONVERTVECTORTOLLVMPASS
#endif // GEN_PASS_DECL_CONVERTVECTORTOLLVMPASS
#ifdef GEN_PASS_DEF_CONVERTVECTORTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertVectorToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertVectorToLLVMPass(ConvertVectorToLLVMPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertVectorToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToLLVMPassBase;

  ConvertVectorToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToLLVMPassBase(const ConvertVectorToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToLLVMPassBase& operator=(const ConvertVectorToLLVMPassBase &) = delete;
  ConvertVectorToLLVMPassBase(ConvertVectorToLLVMPassBase &&) = delete;
  ConvertVectorToLLVMPassBase& operator=(ConvertVectorToLLVMPassBase &&) = delete;
  ~ConvertVectorToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToLLVMPassBase<DerivedT>)

  ConvertVectorToLLVMPassBase(ConvertVectorToLLVMPassOptions options) : ConvertVectorToLLVMPassBase() {
    reassociateFPReductions = std::move(options.reassociateFPReductions);
    force32BitVectorIndices = std::move(options.force32BitVectorIndices);
    useVectorAlignment = std::move(options.useVectorAlignment);
    amx = std::move(options.amx);
    armNeon = std::move(options.armNeon);
    armSVE = std::move(options.armSVE);
    armI8MM = std::move(options.armI8MM);
    x86Vector = std::move(options.x86Vector);
    vectorContractLowering = std::move(options.vectorContractLowering);
    vectorTransposeLowering = std::move(options.vectorTransposeLowering);
  }
protected:
  ::mlir::Pass::Option<bool> reassociateFPReductions{*this, "reassociate-fp-reductions", ::llvm::cl::desc("Allows llvm to reassociate floating-point reductions for speed"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> force32BitVectorIndices{*this, "force-32bit-vector-indices", ::llvm::cl::desc("Allows compiler to assume vector indices fit in 32-bit if that yields faster code"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> useVectorAlignment{*this, "use-vector-alignment", ::llvm::cl::desc("Use the preferred alignment of a vector type in load/store operations instead of the alignment of the element type of the memref. This flag is intended for use with hardware which requiresvector alignment, or in application contexts where it is known all vector access are naturally aligned. "), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> amx{*this, "enable-amx", ::llvm::cl::desc("Enables the use of AMX dialect while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> armNeon{*this, "enable-arm-neon", ::llvm::cl::desc("Enables the use of ArmNeon dialect while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> armSVE{*this, "enable-arm-sve", ::llvm::cl::desc("Enables the use of ArmSVE dialect while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> armI8MM{*this, "enable-arm-i8mm", ::llvm::cl::desc("Enables the use of Arm FEAT_I8MM instructions while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> x86Vector{*this, "enable-x86vector", ::llvm::cl::desc("Enables the use of X86Vector dialect while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<vector::VectorContractLowering> vectorContractLowering{*this, "vector-contract-lowering", ::llvm::cl::desc("control the lowering of `vector.contract` operations."), ::llvm::cl::init(vector::VectorContractLowering::Dot), ::llvm::cl::values(
           clEnumValN(::mlir::vector::VectorContractLowering::Dot, "dot",
            "Progressively lower to finer grained `vector.contract` and dot-products. (default)"),
           clEnumValN(::mlir::vector::VectorContractLowering::Matmul, "matmul",
            "Lower to `vector.matrix_multiply`, maps 1-1 to LLVM matrix intrinsics."),
           clEnumValN(::mlir::vector::VectorContractLowering::OuterProduct, "outerproduct",
            "Lower to `vector.outerproduct`."),
           clEnumValN(::mlir::vector::VectorContractLowering::ParallelArith, "parallelarith",
            "Lower contract with all reduction dimensions unrolled to 1 to a vector elementwise operations.")
	        )};
  ::mlir::Pass::Option<vector::VectorTransposeLowering> vectorTransposeLowering{*this, "vector-transpose-lowering", ::llvm::cl::desc("control the lowering of `vector.transpose` operations."), ::llvm::cl::init(vector::VectorTransposeLowering::EltWise), ::llvm::cl::values(
           clEnumValN(::mlir::vector::VectorTransposeLowering::EltWise, "eltwise",
            "Lower transpose into element-wise extract and inserts (default)"),
           clEnumValN(::mlir::vector::VectorTransposeLowering::Flat, "flat",
            "Lower 2-D transpose to `vector.flat_transpose`, maps 1-1 to LLVM matrix intrinsics"),
           clEnumValN(::mlir::vector::VectorTransposeLowering::Shuffle1D, "shuffle1d",
            "Lower 2-D transpose to `vector.shuffle` on 1-D vector."),
           clEnumValN(::mlir::vector::VectorTransposeLowering::Shuffle16x16, "shuffle16x16",
            "Lower 2-D transpose to `vector.shuffle` on 16x16 vector.")
          )};
private:

  friend std::unique_ptr<::mlir::Pass> createConvertVectorToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createConvertVectorToLLVMPass(ConvertVectorToLLVMPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertVectorToLLVMPass() {
  return impl::createConvertVectorToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createConvertVectorToLLVMPass(ConvertVectorToLLVMPassOptions options) {
  return impl::createConvertVectorToLLVMPass(std::move(options));
}
#undef GEN_PASS_DEF_CONVERTVECTORTOLLVMPASS
#endif // GEN_PASS_DEF_CONVERTVECTORTOLLVMPASS

//===----------------------------------------------------------------------===//
// ConvertVectorToSCF
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTVECTORTOSCF
struct ConvertVectorToSCFOptions {
  bool fullUnroll = false;
  unsigned targetRank = 1;
  bool lowerTensors = false;
  bool lowerScalable = false;
};
#undef GEN_PASS_DECL_CONVERTVECTORTOSCF
#endif // GEN_PASS_DECL_CONVERTVECTORTOSCF
#ifdef GEN_PASS_DEF_CONVERTVECTORTOSCF
namespace impl {

template <typename DerivedT>
class ConvertVectorToSCFBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToSCFBase;

  ConvertVectorToSCFBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToSCFBase(const ConvertVectorToSCFBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToSCFBase& operator=(const ConvertVectorToSCFBase &) = delete;
  ConvertVectorToSCFBase(ConvertVectorToSCFBase &&) = delete;
  ConvertVectorToSCFBase& operator=(ConvertVectorToSCFBase &&) = delete;
  ~ConvertVectorToSCFBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToSCF");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToSCF"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToSCFBase<DerivedT>)

  ConvertVectorToSCFBase(ConvertVectorToSCFOptions options) : ConvertVectorToSCFBase() {
    fullUnroll = std::move(options.fullUnroll);
    targetRank = std::move(options.targetRank);
    lowerTensors = std::move(options.lowerTensors);
    lowerScalable = std::move(options.lowerScalable);
  }
protected:
  ::mlir::Pass::Option<bool> fullUnroll{*this, "full-unroll", ::llvm::cl::desc("Perform full unrolling when converting vector transfers to SCF"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<unsigned> targetRank{*this, "target-rank", ::llvm::cl::desc("Target vector rank to which transfer ops should be lowered"), ::llvm::cl::init(1)};
  ::mlir::Pass::Option<bool> lowerTensors{*this, "lower-tensors", ::llvm::cl::desc("Lower transfer ops that operate on tensors"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> lowerScalable{*this, "lower-scalable", ::llvm::cl::desc("Add scalable vector specific lowerings (that introduce loops)"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTVECTORTOSCF
#endif // GEN_PASS_DEF_CONVERTVECTORTOSCF

//===----------------------------------------------------------------------===//
// ConvertVectorToSPIRVPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTVECTORTOSPIRVPASS
std::unique_ptr<::mlir::Pass> createConvertVectorToSPIRVPass();
#undef GEN_PASS_DECL_CONVERTVECTORTOSPIRVPASS
#endif // GEN_PASS_DECL_CONVERTVECTORTOSPIRVPASS
#ifdef GEN_PASS_DEF_CONVERTVECTORTOSPIRVPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertVectorToSPIRVPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertVectorToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToSPIRVPassBase;

  ConvertVectorToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToSPIRVPassBase(const ConvertVectorToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToSPIRVPassBase& operator=(const ConvertVectorToSPIRVPassBase &) = delete;
  ConvertVectorToSPIRVPassBase(ConvertVectorToSPIRVPassBase &&) = delete;
  ConvertVectorToSPIRVPassBase& operator=(ConvertVectorToSPIRVPassBase &&) = delete;
  ~ConvertVectorToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Vector dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
    registry.insert<ub::UBDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToSPIRVPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertVectorToSPIRVPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertVectorToSPIRVPass() {
  return impl::createConvertVectorToSPIRVPass();
}
#undef GEN_PASS_DEF_CONVERTVECTORTOSPIRVPASS
#endif // GEN_PASS_DEF_CONVERTVECTORTOSPIRVPASS

//===----------------------------------------------------------------------===//
// ConvertVectorToXeGPU
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTVECTORTOXEGPU
std::unique_ptr<::mlir::Pass> createConvertVectorToXeGPU();
#undef GEN_PASS_DECL_CONVERTVECTORTOXEGPU
#endif // GEN_PASS_DECL_CONVERTVECTORTOXEGPU
#ifdef GEN_PASS_DEF_CONVERTVECTORTOXEGPU

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertVectorToXeGPU();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertVectorToXeGPUBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToXeGPUBase;

  ConvertVectorToXeGPUBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToXeGPUBase(const ConvertVectorToXeGPUBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToXeGPUBase& operator=(const ConvertVectorToXeGPUBase &) = delete;
  ConvertVectorToXeGPUBase(ConvertVectorToXeGPUBase &&) = delete;
  ConvertVectorToXeGPUBase& operator=(ConvertVectorToXeGPUBase &&) = delete;
  ~ConvertVectorToXeGPUBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-xegpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-xegpu"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the XeGPU dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToXeGPU");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToXeGPU"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<vector::VectorDialect>();
    registry.insert<xegpu::XeGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToXeGPUBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertVectorToXeGPU() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertVectorToXeGPU() {
  return impl::createConvertVectorToXeGPU();
}
#undef GEN_PASS_DEF_CONVERTVECTORTOXEGPU
#endif // GEN_PASS_DEF_CONVERTVECTORTOXEGPU

//===----------------------------------------------------------------------===//
// FinalizeMemRefToLLVMConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FINALIZEMEMREFTOLLVMCONVERSIONPASS
struct FinalizeMemRefToLLVMConversionPassOptions {
  bool useAlignedAlloc = false;
  unsigned indexBitwidth = 0;
  bool useGenericFunctions = false;
};
std::unique_ptr<::mlir::Pass> createFinalizeMemRefToLLVMConversionPass();
std::unique_ptr<::mlir::Pass> createFinalizeMemRefToLLVMConversionPass(FinalizeMemRefToLLVMConversionPassOptions options);
#undef GEN_PASS_DECL_FINALIZEMEMREFTOLLVMCONVERSIONPASS
#endif // GEN_PASS_DECL_FINALIZEMEMREFTOLLVMCONVERSIONPASS
#ifdef GEN_PASS_DEF_FINALIZEMEMREFTOLLVMCONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createFinalizeMemRefToLLVMConversionPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createFinalizeMemRefToLLVMConversionPass(FinalizeMemRefToLLVMConversionPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class FinalizeMemRefToLLVMConversionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FinalizeMemRefToLLVMConversionPassBase;

  FinalizeMemRefToLLVMConversionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FinalizeMemRefToLLVMConversionPassBase(const FinalizeMemRefToLLVMConversionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  FinalizeMemRefToLLVMConversionPassBase& operator=(const FinalizeMemRefToLLVMConversionPassBase &) = delete;
  FinalizeMemRefToLLVMConversionPassBase(FinalizeMemRefToLLVMConversionPassBase &&) = delete;
  FinalizeMemRefToLLVMConversionPassBase& operator=(FinalizeMemRefToLLVMConversionPassBase &&) = delete;
  ~FinalizeMemRefToLLVMConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("finalize-memref-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "finalize-memref-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Finalize MemRef dialect to LLVM dialect conversion"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FinalizeMemRefToLLVMConversionPass");
  }
  ::llvm::StringRef getName() const override { return "FinalizeMemRefToLLVMConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FinalizeMemRefToLLVMConversionPassBase<DerivedT>)

  FinalizeMemRefToLLVMConversionPassBase(FinalizeMemRefToLLVMConversionPassOptions options) : FinalizeMemRefToLLVMConversionPassBase() {
    useAlignedAlloc = std::move(options.useAlignedAlloc);
    indexBitwidth = std::move(options.indexBitwidth);
    useGenericFunctions = std::move(options.useGenericFunctions);
  }
protected:
  ::mlir::Pass::Option<bool> useAlignedAlloc{*this, "use-aligned-alloc", ::llvm::cl::desc("Use aligned_alloc in place of malloc for heap allocations"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> useGenericFunctions{*this, "use-generic-functions", ::llvm::cl::desc("Use generic allocation and deallocation functions instead of the classic 'malloc', 'aligned_alloc' and 'free' functions"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createFinalizeMemRefToLLVMConversionPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createFinalizeMemRefToLLVMConversionPass(FinalizeMemRefToLLVMConversionPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createFinalizeMemRefToLLVMConversionPass() {
  return impl::createFinalizeMemRefToLLVMConversionPass();
}

std::unique_ptr<::mlir::Pass> createFinalizeMemRefToLLVMConversionPass(FinalizeMemRefToLLVMConversionPassOptions options) {
  return impl::createFinalizeMemRefToLLVMConversionPass(std::move(options));
}
#undef GEN_PASS_DEF_FINALIZEMEMREFTOLLVMCONVERSIONPASS
#endif // GEN_PASS_DEF_FINALIZEMEMREFTOLLVMCONVERSIONPASS

//===----------------------------------------------------------------------===//
// GpuToLLVMConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GPUTOLLVMCONVERSIONPASS
struct GpuToLLVMConversionPassOptions {
  bool hostBarePtrCallConv = false;
  bool kernelBarePtrCallConv = false;
  bool kernelIntersperseSizeCallConv = false;
};
std::unique_ptr<::mlir::Pass> createGpuToLLVMConversionPass();
std::unique_ptr<::mlir::Pass> createGpuToLLVMConversionPass(GpuToLLVMConversionPassOptions options);
#undef GEN_PASS_DECL_GPUTOLLVMCONVERSIONPASS
#endif // GEN_PASS_DECL_GPUTOLLVMCONVERSIONPASS
#ifdef GEN_PASS_DEF_GPUTOLLVMCONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createGpuToLLVMConversionPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createGpuToLLVMConversionPass(GpuToLLVMConversionPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class GpuToLLVMConversionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GpuToLLVMConversionPassBase;

  GpuToLLVMConversionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GpuToLLVMConversionPassBase(const GpuToLLVMConversionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  GpuToLLVMConversionPassBase& operator=(const GpuToLLVMConversionPassBase &) = delete;
  GpuToLLVMConversionPassBase(GpuToLLVMConversionPassBase &&) = delete;
  GpuToLLVMConversionPassBase& operator=(GpuToLLVMConversionPassBase &&) = delete;
  ~GpuToLLVMConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gpu-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "gpu-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert GPU dialect to LLVM dialect with GPU runtime calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GpuToLLVMConversionPass");
  }
  ::llvm::StringRef getName() const override { return "GpuToLLVMConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GpuToLLVMConversionPassBase<DerivedT>)

  GpuToLLVMConversionPassBase(GpuToLLVMConversionPassOptions options) : GpuToLLVMConversionPassBase() {
    hostBarePtrCallConv = std::move(options.hostBarePtrCallConv);
    kernelBarePtrCallConv = std::move(options.kernelBarePtrCallConv);
    kernelIntersperseSizeCallConv = std::move(options.kernelIntersperseSizeCallConv);
  }
protected:
  ::mlir::Pass::Option<bool> hostBarePtrCallConv{*this, "use-bare-pointers-for-host", ::llvm::cl::desc("Use bare pointers to pass memref arguments to host functions. All memrefs must have static shape."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> kernelBarePtrCallConv{*this, "use-bare-pointers-for-kernels", ::llvm::cl::desc("Use bare pointers to pass memref arguments to kernels. The kernel must use the same setting for this option."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> kernelIntersperseSizeCallConv{*this, "intersperse-sizes-for-kernels", ::llvm::cl::desc("Inserts a size_t argument following each memref argument, containing the static size in bytes of the buffer. Incompatible arguments are rejected. This is intended for use by the Vulkan runtime with the kernel bare pointer calling convention, to enable dynamic binding of buffers as arguments without static type info."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createGpuToLLVMConversionPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createGpuToLLVMConversionPass(GpuToLLVMConversionPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGpuToLLVMConversionPass() {
  return impl::createGpuToLLVMConversionPass();
}

std::unique_ptr<::mlir::Pass> createGpuToLLVMConversionPass(GpuToLLVMConversionPassOptions options) {
  return impl::createGpuToLLVMConversionPass(std::move(options));
}
#undef GEN_PASS_DEF_GPUTOLLVMCONVERSIONPASS
#endif // GEN_PASS_DEF_GPUTOLLVMCONVERSIONPASS

//===----------------------------------------------------------------------===//
// LiftControlFlowToSCFPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LIFTCONTROLFLOWTOSCFPASS
std::unique_ptr<::mlir::Pass> createLiftControlFlowToSCFPass();
#undef GEN_PASS_DECL_LIFTCONTROLFLOWTOSCFPASS
#endif // GEN_PASS_DECL_LIFTCONTROLFLOWTOSCFPASS
#ifdef GEN_PASS_DEF_LIFTCONTROLFLOWTOSCFPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createLiftControlFlowToSCFPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class LiftControlFlowToSCFPassBase : public ::mlir::OperationPass<> {
public:
  using Base = LiftControlFlowToSCFPassBase;

  LiftControlFlowToSCFPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LiftControlFlowToSCFPassBase(const LiftControlFlowToSCFPassBase &other) : ::mlir::OperationPass<>(other) {}
  LiftControlFlowToSCFPassBase& operator=(const LiftControlFlowToSCFPassBase &) = delete;
  LiftControlFlowToSCFPassBase(LiftControlFlowToSCFPassBase &&) = delete;
  LiftControlFlowToSCFPassBase& operator=(LiftControlFlowToSCFPassBase &&) = delete;
  ~LiftControlFlowToSCFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lift-cf-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "lift-cf-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lift ControlFlow dialect to SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LiftControlFlowToSCFPass");
  }
  ::llvm::StringRef getName() const override { return "LiftControlFlowToSCFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<ub::UBDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LiftControlFlowToSCFPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createLiftControlFlowToSCFPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createLiftControlFlowToSCFPass() {
  return impl::createLiftControlFlowToSCFPass();
}
#undef GEN_PASS_DEF_LIFTCONTROLFLOWTOSCFPASS
#endif // GEN_PASS_DEF_LIFTCONTROLFLOWTOSCFPASS

//===----------------------------------------------------------------------===//
// LowerAffinePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERAFFINEPASS
std::unique_ptr<::mlir::Pass> createLowerAffinePass();
#undef GEN_PASS_DECL_LOWERAFFINEPASS
#endif // GEN_PASS_DECL_LOWERAFFINEPASS
#ifdef GEN_PASS_DEF_LOWERAFFINEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createLowerAffinePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class LowerAffinePassBase : public ::mlir::OperationPass<> {
public:
  using Base = LowerAffinePassBase;

  LowerAffinePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LowerAffinePassBase(const LowerAffinePassBase &other) : ::mlir::OperationPass<>(other) {}
  LowerAffinePassBase& operator=(const LowerAffinePassBase &) = delete;
  LowerAffinePassBase(LowerAffinePassBase &&) = delete;
  LowerAffinePassBase& operator=(LowerAffinePassBase &&) = delete;
  ~LowerAffinePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-affine");
  }
  ::llvm::StringRef getArgument() const override { return "lower-affine"; }

  ::llvm::StringRef getDescription() const override { return "Lower Affine operations to a combination of Arith and SCF operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerAffinePass");
  }
  ::llvm::StringRef getName() const override { return "LowerAffinePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerAffinePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createLowerAffinePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createLowerAffinePass() {
  return impl::createLowerAffinePass();
}
#undef GEN_PASS_DEF_LOWERAFFINEPASS
#endif // GEN_PASS_DEF_LOWERAFFINEPASS

//===----------------------------------------------------------------------===//
// LowerHostCodeToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERHOSTCODETOLLVMPASS
std::unique_ptr<::mlir::Pass> createLowerHostCodeToLLVMPass();
#undef GEN_PASS_DECL_LOWERHOSTCODETOLLVMPASS
#endif // GEN_PASS_DECL_LOWERHOSTCODETOLLVMPASS
#ifdef GEN_PASS_DEF_LOWERHOSTCODETOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createLowerHostCodeToLLVMPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class LowerHostCodeToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LowerHostCodeToLLVMPassBase;

  LowerHostCodeToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerHostCodeToLLVMPassBase(const LowerHostCodeToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LowerHostCodeToLLVMPassBase& operator=(const LowerHostCodeToLLVMPassBase &) = delete;
  LowerHostCodeToLLVMPassBase(LowerHostCodeToLLVMPassBase &&) = delete;
  LowerHostCodeToLLVMPassBase& operator=(LowerHostCodeToLLVMPassBase &&) = delete;
  ~LowerHostCodeToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-host-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "lower-host-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lowers the host module code and `gpu.launch_func` to LLVM"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerHostCodeToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "LowerHostCodeToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerHostCodeToLLVMPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createLowerHostCodeToLLVMPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createLowerHostCodeToLLVMPass() {
  return impl::createLowerHostCodeToLLVMPass();
}
#undef GEN_PASS_DEF_LOWERHOSTCODETOLLVMPASS
#endif // GEN_PASS_DEF_LOWERHOSTCODETOLLVMPASS

//===----------------------------------------------------------------------===//
// MapMemRefStorageClass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MAPMEMREFSTORAGECLASS
struct MapMemRefStorageClassOptions {
  std::string clientAPI = "vulkan";
};
#undef GEN_PASS_DECL_MAPMEMREFSTORAGECLASS
#endif // GEN_PASS_DECL_MAPMEMREFSTORAGECLASS
#ifdef GEN_PASS_DEF_MAPMEMREFSTORAGECLASS
namespace impl {

template <typename DerivedT>
class MapMemRefStorageClassBase : public ::mlir::OperationPass<> {
public:
  using Base = MapMemRefStorageClassBase;

  MapMemRefStorageClassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  MapMemRefStorageClassBase(const MapMemRefStorageClassBase &other) : ::mlir::OperationPass<>(other) {}
  MapMemRefStorageClassBase& operator=(const MapMemRefStorageClassBase &) = delete;
  MapMemRefStorageClassBase(MapMemRefStorageClassBase &&) = delete;
  MapMemRefStorageClassBase& operator=(MapMemRefStorageClassBase &&) = delete;
  ~MapMemRefStorageClassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("map-memref-spirv-storage-class");
  }
  ::llvm::StringRef getArgument() const override { return "map-memref-spirv-storage-class"; }

  ::llvm::StringRef getDescription() const override { return "Map numeric MemRef memory spaces to SPIR-V storage classes"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MapMemRefStorageClass");
  }
  ::llvm::StringRef getName() const override { return "MapMemRefStorageClass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MapMemRefStorageClassBase<DerivedT>)

  MapMemRefStorageClassBase(MapMemRefStorageClassOptions options) : MapMemRefStorageClassBase() {
    clientAPI = std::move(options.clientAPI);
  }
protected:
  ::mlir::Pass::Option<std::string> clientAPI{*this, "client-api", ::llvm::cl::desc("The client API to use for populating mappings"), ::llvm::cl::init("vulkan")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MAPMEMREFSTORAGECLASS
#endif // GEN_PASS_DEF_MAPMEMREFSTORAGECLASS

//===----------------------------------------------------------------------===//
// ReconcileUnrealizedCastsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_RECONCILEUNREALIZEDCASTSPASS
std::unique_ptr<::mlir::Pass> createReconcileUnrealizedCastsPass();
#undef GEN_PASS_DECL_RECONCILEUNREALIZEDCASTSPASS
#endif // GEN_PASS_DECL_RECONCILEUNREALIZEDCASTSPASS
#ifdef GEN_PASS_DEF_RECONCILEUNREALIZEDCASTSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createReconcileUnrealizedCastsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ReconcileUnrealizedCastsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ReconcileUnrealizedCastsPassBase;

  ReconcileUnrealizedCastsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ReconcileUnrealizedCastsPassBase(const ReconcileUnrealizedCastsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ReconcileUnrealizedCastsPassBase& operator=(const ReconcileUnrealizedCastsPassBase &) = delete;
  ReconcileUnrealizedCastsPassBase(ReconcileUnrealizedCastsPassBase &&) = delete;
  ReconcileUnrealizedCastsPassBase& operator=(ReconcileUnrealizedCastsPassBase &&) = delete;
  ~ReconcileUnrealizedCastsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("reconcile-unrealized-casts");
  }
  ::llvm::StringRef getArgument() const override { return "reconcile-unrealized-casts"; }

  ::llvm::StringRef getDescription() const override { return "Simplify and eliminate unrealized conversion casts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReconcileUnrealizedCastsPass");
  }
  ::llvm::StringRef getName() const override { return "ReconcileUnrealizedCastsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReconcileUnrealizedCastsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createReconcileUnrealizedCastsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createReconcileUnrealizedCastsPass() {
  return impl::createReconcileUnrealizedCastsPass();
}
#undef GEN_PASS_DEF_RECONCILEUNREALIZEDCASTSPASS
#endif // GEN_PASS_DEF_RECONCILEUNREALIZEDCASTSPASS

//===----------------------------------------------------------------------===//
// SCFToControlFlowPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SCFTOCONTROLFLOWPASS
std::unique_ptr<::mlir::Pass> createSCFToControlFlowPass();
#undef GEN_PASS_DECL_SCFTOCONTROLFLOWPASS
#endif // GEN_PASS_DECL_SCFTOCONTROLFLOWPASS
#ifdef GEN_PASS_DEF_SCFTOCONTROLFLOWPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createSCFToControlFlowPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class SCFToControlFlowPassBase : public ::mlir::OperationPass<> {
public:
  using Base = SCFToControlFlowPassBase;

  SCFToControlFlowPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SCFToControlFlowPassBase(const SCFToControlFlowPassBase &other) : ::mlir::OperationPass<>(other) {}
  SCFToControlFlowPassBase& operator=(const SCFToControlFlowPassBase &) = delete;
  SCFToControlFlowPassBase(SCFToControlFlowPassBase &&) = delete;
  SCFToControlFlowPassBase& operator=(SCFToControlFlowPassBase &&) = delete;
  ~SCFToControlFlowPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-scf-to-cf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-scf-to-cf"; }

  ::llvm::StringRef getDescription() const override { return "Convert SCF dialect to ControlFlow dialect, replacing structured control flow with a CFG"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SCFToControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "SCFToControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SCFToControlFlowPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createSCFToControlFlowPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createSCFToControlFlowPass() {
  return impl::createSCFToControlFlowPass();
}
#undef GEN_PASS_DEF_SCFTOCONTROLFLOWPASS
#endif // GEN_PASS_DEF_SCFTOCONTROLFLOWPASS

//===----------------------------------------------------------------------===//
// SCFToEmitC
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SCFTOEMITC
std::unique_ptr<::mlir::Pass> createSCFToEmitC();
#undef GEN_PASS_DECL_SCFTOEMITC
#endif // GEN_PASS_DECL_SCFTOEMITC
#ifdef GEN_PASS_DEF_SCFTOEMITC

namespace impl {
  std::unique_ptr<::mlir::Pass> createSCFToEmitC();
} // namespace impl
namespace impl {

template <typename DerivedT>
class SCFToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = SCFToEmitCBase;

  SCFToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SCFToEmitCBase(const SCFToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  SCFToEmitCBase& operator=(const SCFToEmitCBase &) = delete;
  SCFToEmitCBase(SCFToEmitCBase &&) = delete;
  SCFToEmitCBase& operator=(SCFToEmitCBase &&) = delete;
  ~SCFToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-scf-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-scf-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert SCF dialect to EmitC dialect, maintaining structured control flow"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SCFToEmitC");
  }
  ::llvm::StringRef getName() const override { return "SCFToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SCFToEmitCBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createSCFToEmitC() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createSCFToEmitC() {
  return impl::createSCFToEmitC();
}
#undef GEN_PASS_DEF_SCFTOEMITC
#endif // GEN_PASS_DEF_SCFTOEMITC

//===----------------------------------------------------------------------===//
// SCFToSPIRV
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SCFTOSPIRV
std::unique_ptr<::mlir::Pass> createSCFToSPIRV();
#undef GEN_PASS_DECL_SCFTOSPIRV
#endif // GEN_PASS_DECL_SCFTOSPIRV
#ifdef GEN_PASS_DEF_SCFTOSPIRV

namespace impl {
  std::unique_ptr<::mlir::Pass> createSCFToSPIRV();
} // namespace impl
namespace impl {

template <typename DerivedT>
class SCFToSPIRVBase : public ::mlir::OperationPass<> {
public:
  using Base = SCFToSPIRVBase;

  SCFToSPIRVBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SCFToSPIRVBase(const SCFToSPIRVBase &other) : ::mlir::OperationPass<>(other) {}
  SCFToSPIRVBase& operator=(const SCFToSPIRVBase &) = delete;
  SCFToSPIRVBase(SCFToSPIRVBase &&) = delete;
  SCFToSPIRVBase& operator=(SCFToSPIRVBase &&) = delete;
  ~SCFToSPIRVBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-scf-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-scf-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert SCF dialect to SPIR-V dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SCFToSPIRV");
  }
  ::llvm::StringRef getName() const override { return "SCFToSPIRV"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SCFToSPIRVBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createSCFToSPIRV() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createSCFToSPIRV() {
  return impl::createSCFToSPIRV();
}
#undef GEN_PASS_DEF_SCFTOSPIRV
#endif // GEN_PASS_DEF_SCFTOSPIRV

//===----------------------------------------------------------------------===//
// SetLLVMModuleDataLayoutPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SETLLVMMODULEDATALAYOUTPASS
struct SetLLVMModuleDataLayoutPassOptions {
  std::string dataLayout = "";
};
std::unique_ptr<::mlir::Pass> createSetLLVMModuleDataLayoutPass();
std::unique_ptr<::mlir::Pass> createSetLLVMModuleDataLayoutPass(SetLLVMModuleDataLayoutPassOptions options);
#undef GEN_PASS_DECL_SETLLVMMODULEDATALAYOUTPASS
#endif // GEN_PASS_DECL_SETLLVMMODULEDATALAYOUTPASS
#ifdef GEN_PASS_DEF_SETLLVMMODULEDATALAYOUTPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createSetLLVMModuleDataLayoutPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createSetLLVMModuleDataLayoutPass(SetLLVMModuleDataLayoutPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class SetLLVMModuleDataLayoutPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SetLLVMModuleDataLayoutPassBase;

  SetLLVMModuleDataLayoutPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SetLLVMModuleDataLayoutPassBase(const SetLLVMModuleDataLayoutPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  SetLLVMModuleDataLayoutPassBase& operator=(const SetLLVMModuleDataLayoutPassBase &) = delete;
  SetLLVMModuleDataLayoutPassBase(SetLLVMModuleDataLayoutPassBase &&) = delete;
  SetLLVMModuleDataLayoutPassBase& operator=(SetLLVMModuleDataLayoutPassBase &&) = delete;
  ~SetLLVMModuleDataLayoutPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("set-llvm-module-datalayout");
  }
  ::llvm::StringRef getArgument() const override { return "set-llvm-module-datalayout"; }

  ::llvm::StringRef getDescription() const override { return "Attach a datalayout string as a module attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SetLLVMModuleDataLayoutPass");
  }
  ::llvm::StringRef getName() const override { return "SetLLVMModuleDataLayoutPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SetLLVMModuleDataLayoutPassBase<DerivedT>)

  SetLLVMModuleDataLayoutPassBase(SetLLVMModuleDataLayoutPassOptions options) : SetLLVMModuleDataLayoutPassBase() {
    dataLayout = std::move(options.dataLayout);
  }
protected:
  ::mlir::Pass::Option<std::string> dataLayout{*this, "data-layout", ::llvm::cl::desc("String description (LLVM format) of the data layout that is expected on the produced module"), ::llvm::cl::init("")};
private:

  friend std::unique_ptr<::mlir::Pass> createSetLLVMModuleDataLayoutPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createSetLLVMModuleDataLayoutPass(SetLLVMModuleDataLayoutPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createSetLLVMModuleDataLayoutPass() {
  return impl::createSetLLVMModuleDataLayoutPass();
}

std::unique_ptr<::mlir::Pass> createSetLLVMModuleDataLayoutPass(SetLLVMModuleDataLayoutPassOptions options) {
  return impl::createSetLLVMModuleDataLayoutPass(std::move(options));
}
#undef GEN_PASS_DEF_SETLLVMMODULEDATALAYOUTPASS
#endif // GEN_PASS_DEF_SETLLVMMODULEDATALAYOUTPASS

//===----------------------------------------------------------------------===//
// TosaToArithPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSATOARITHPASS
struct TosaToArithPassOptions {
  bool includeApplyRescale = false;
  bool use32Bit = false;
};
std::unique_ptr<::mlir::Pass> createTosaToArithPass();
std::unique_ptr<::mlir::Pass> createTosaToArithPass(TosaToArithPassOptions options);
#undef GEN_PASS_DECL_TOSATOARITHPASS
#endif // GEN_PASS_DECL_TOSATOARITHPASS
#ifdef GEN_PASS_DEF_TOSATOARITHPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaToArithPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaToArithPass(TosaToArithPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaToArithPassBase : public ::mlir::OperationPass<> {
public:
  using Base = TosaToArithPassBase;

  TosaToArithPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToArithPassBase(const TosaToArithPassBase &other) : ::mlir::OperationPass<>(other) {}
  TosaToArithPassBase& operator=(const TosaToArithPassBase &) = delete;
  TosaToArithPassBase(TosaToArithPassBase &&) = delete;
  TosaToArithPassBase& operator=(TosaToArithPassBase &&) = delete;
  ~TosaToArithPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-arith");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-arith"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to the Arith dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToArithPass");
  }
  ::llvm::StringRef getName() const override { return "TosaToArithPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToArithPassBase<DerivedT>)

  TosaToArithPassBase(TosaToArithPassOptions options) : TosaToArithPassBase() {
    includeApplyRescale = std::move(options.includeApplyRescale);
    use32Bit = std::move(options.use32Bit);
  }
protected:
  ::mlir::Pass::Option<bool> includeApplyRescale{*this, "include-apply-rescale", ::llvm::cl::desc("Whether to include the lowering for tosa.apply_rescale to arith"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> use32Bit{*this, "use-32-bit", ::llvm::cl::desc("Whether to prioritze lowering to 32-bit operations"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaToArithPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaToArithPass(TosaToArithPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaToArithPass() {
  return impl::createTosaToArithPass();
}

std::unique_ptr<::mlir::Pass> createTosaToArithPass(TosaToArithPassOptions options) {
  return impl::createTosaToArithPass(std::move(options));
}
#undef GEN_PASS_DEF_TOSATOARITHPASS
#endif // GEN_PASS_DEF_TOSATOARITHPASS

//===----------------------------------------------------------------------===//
// TosaToLinalg
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSATOLINALG
struct TosaToLinalgOptions {
  bool disableTosaDecompositions = false;
  bool aggressiveReduceConstant = false;
};
#undef GEN_PASS_DECL_TOSATOLINALG
#endif // GEN_PASS_DECL_TOSATOLINALG
#ifdef GEN_PASS_DEF_TOSATOLINALG
namespace impl {

template <typename DerivedT>
class TosaToLinalgBase : public ::mlir::InterfacePass<FunctionOpInterface> {
public:
  using Base = TosaToLinalgBase;

  TosaToLinalgBase() : ::mlir::InterfacePass<FunctionOpInterface>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToLinalgBase(const TosaToLinalgBase &other) : ::mlir::InterfacePass<FunctionOpInterface>(other) {}
  TosaToLinalgBase& operator=(const TosaToLinalgBase &) = delete;
  TosaToLinalgBase(TosaToLinalgBase &&) = delete;
  TosaToLinalgBase& operator=(TosaToLinalgBase &&) = delete;
  ~TosaToLinalgBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to LinAlg on tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToLinalg");
  }
  ::llvm::StringRef getName() const override { return "TosaToLinalg"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToLinalgBase<DerivedT>)

  TosaToLinalgBase(TosaToLinalgOptions options) : TosaToLinalgBase() {
    disableTosaDecompositions = std::move(options.disableTosaDecompositions);
    aggressiveReduceConstant = std::move(options.aggressiveReduceConstant);
  }
protected:
  ::mlir::Pass::Option<bool> disableTosaDecompositions{*this, "disable-tosa-decompositions", ::llvm::cl::desc("Disable tosa decompositions pass"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> aggressiveReduceConstant{*this, "aggressive-reduce-constant", ::llvm::cl::desc("Always perform the reduce constant optimization"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TOSATOLINALG
#endif // GEN_PASS_DEF_TOSATOLINALG

//===----------------------------------------------------------------------===//
// TosaToLinalgNamed
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSATOLINALGNAMED
struct TosaToLinalgNamedOptions {
  bool preferConv2DKernelLayoutHWCF = false;
};
#undef GEN_PASS_DECL_TOSATOLINALGNAMED
#endif // GEN_PASS_DECL_TOSATOLINALGNAMED
#ifdef GEN_PASS_DEF_TOSATOLINALGNAMED
namespace impl {

template <typename DerivedT>
class TosaToLinalgNamedBase : public ::mlir::InterfacePass<FunctionOpInterface> {
public:
  using Base = TosaToLinalgNamedBase;

  TosaToLinalgNamedBase() : ::mlir::InterfacePass<FunctionOpInterface>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToLinalgNamedBase(const TosaToLinalgNamedBase &other) : ::mlir::InterfacePass<FunctionOpInterface>(other) {}
  TosaToLinalgNamedBase& operator=(const TosaToLinalgNamedBase &) = delete;
  TosaToLinalgNamedBase(TosaToLinalgNamedBase &&) = delete;
  TosaToLinalgNamedBase& operator=(TosaToLinalgNamedBase &&) = delete;
  ~TosaToLinalgNamedBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-linalg-named");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-linalg-named"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to LinAlg named operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToLinalgNamed");
  }
  ::llvm::StringRef getName() const override { return "TosaToLinalgNamed"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToLinalgNamedBase<DerivedT>)

  TosaToLinalgNamedBase(TosaToLinalgNamedOptions options) : TosaToLinalgNamedBase() {
    preferConv2DKernelLayoutHWCF = std::move(options.preferConv2DKernelLayoutHWCF);
  }
protected:
  ::mlir::Pass::Option<bool> preferConv2DKernelLayoutHWCF{*this, "prefer-conv2d-kernel-layout-hwcf", ::llvm::cl::desc("Prefer generating linalg.conv_2d_nhwc_hwcf over linalg.conv_2d_nhwc_fhwc"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TOSATOLINALGNAMED
#endif // GEN_PASS_DEF_TOSATOLINALGNAMED

//===----------------------------------------------------------------------===//
// TosaToMLProgram
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSATOMLPROGRAM
std::unique_ptr<::mlir::Pass> createTosaToMLProgram();
#undef GEN_PASS_DECL_TOSATOMLPROGRAM
#endif // GEN_PASS_DECL_TOSATOMLPROGRAM
#ifdef GEN_PASS_DEF_TOSATOMLPROGRAM

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaToMLProgram();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaToMLProgramBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TosaToMLProgramBase;

  TosaToMLProgramBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToMLProgramBase(const TosaToMLProgramBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TosaToMLProgramBase& operator=(const TosaToMLProgramBase &) = delete;
  TosaToMLProgramBase(TosaToMLProgramBase &&) = delete;
  TosaToMLProgramBase& operator=(TosaToMLProgramBase &&) = delete;
  ~TosaToMLProgramBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-mlprogram");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-mlprogram"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to the MLProgram dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToMLProgram");
  }
  ::llvm::StringRef getName() const override { return "TosaToMLProgram"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<ml_program::MLProgramDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToMLProgramBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaToMLProgram() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaToMLProgram() {
  return impl::createTosaToMLProgram();
}
#undef GEN_PASS_DEF_TOSATOMLPROGRAM
#endif // GEN_PASS_DEF_TOSATOMLPROGRAM

//===----------------------------------------------------------------------===//
// TosaToSCFPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSATOSCFPASS
std::unique_ptr<::mlir::Pass> createTosaToSCFPass();
#undef GEN_PASS_DECL_TOSATOSCFPASS
#endif // GEN_PASS_DECL_TOSATOSCFPASS
#ifdef GEN_PASS_DEF_TOSATOSCFPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaToSCFPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaToSCFPassBase : public ::mlir::OperationPass<> {
public:
  using Base = TosaToSCFPassBase;

  TosaToSCFPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToSCFPassBase(const TosaToSCFPassBase &other) : ::mlir::OperationPass<>(other) {}
  TosaToSCFPassBase& operator=(const TosaToSCFPassBase &) = delete;
  TosaToSCFPassBase(TosaToSCFPassBase &&) = delete;
  TosaToSCFPassBase& operator=(TosaToSCFPassBase &&) = delete;
  ~TosaToSCFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to the SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToSCFPass");
  }
  ::llvm::StringRef getName() const override { return "TosaToSCFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect, scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToSCFPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaToSCFPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaToSCFPass() {
  return impl::createTosaToSCFPass();
}
#undef GEN_PASS_DEF_TOSATOSCFPASS
#endif // GEN_PASS_DEF_TOSATOSCFPASS

//===----------------------------------------------------------------------===//
// TosaToTensorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSATOTENSORPASS
std::unique_ptr<::mlir::Pass> createTosaToTensorPass();
#undef GEN_PASS_DECL_TOSATOTENSORPASS
#endif // GEN_PASS_DECL_TOSATOTENSORPASS
#ifdef GEN_PASS_DEF_TOSATOTENSORPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaToTensorPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaToTensorPassBase : public ::mlir::OperationPass<> {
public:
  using Base = TosaToTensorPassBase;

  TosaToTensorPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToTensorPassBase(const TosaToTensorPassBase &other) : ::mlir::OperationPass<>(other) {}
  TosaToTensorPassBase& operator=(const TosaToTensorPassBase &) = delete;
  TosaToTensorPassBase(TosaToTensorPassBase &&) = delete;
  TosaToTensorPassBase& operator=(TosaToTensorPassBase &&) = delete;
  ~TosaToTensorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-tensor");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-tensor"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to the Tensor dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToTensorPass");
  }
  ::llvm::StringRef getName() const override { return "TosaToTensorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToTensorPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaToTensorPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaToTensorPass() {
  return impl::createTosaToTensorPass();
}
#undef GEN_PASS_DEF_TOSATOTENSORPASS
#endif // GEN_PASS_DEF_TOSATOTENSORPASS

//===----------------------------------------------------------------------===//
// UBToLLVMConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_UBTOLLVMCONVERSIONPASS
struct UBToLLVMConversionPassOptions {
  unsigned indexBitwidth = 0;
};
std::unique_ptr<::mlir::Pass> createUBToLLVMConversionPass();
std::unique_ptr<::mlir::Pass> createUBToLLVMConversionPass(UBToLLVMConversionPassOptions options);
#undef GEN_PASS_DECL_UBTOLLVMCONVERSIONPASS
#endif // GEN_PASS_DECL_UBTOLLVMCONVERSIONPASS
#ifdef GEN_PASS_DEF_UBTOLLVMCONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createUBToLLVMConversionPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createUBToLLVMConversionPass(UBToLLVMConversionPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class UBToLLVMConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = UBToLLVMConversionPassBase;

  UBToLLVMConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  UBToLLVMConversionPassBase(const UBToLLVMConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  UBToLLVMConversionPassBase& operator=(const UBToLLVMConversionPassBase &) = delete;
  UBToLLVMConversionPassBase(UBToLLVMConversionPassBase &&) = delete;
  UBToLLVMConversionPassBase& operator=(UBToLLVMConversionPassBase &&) = delete;
  ~UBToLLVMConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-ub-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-ub-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert UB dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UBToLLVMConversionPass");
  }
  ::llvm::StringRef getName() const override { return "UBToLLVMConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UBToLLVMConversionPassBase<DerivedT>)

  UBToLLVMConversionPassBase(UBToLLVMConversionPassOptions options) : UBToLLVMConversionPassBase() {
    indexBitwidth = std::move(options.indexBitwidth);
  }
protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createUBToLLVMConversionPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createUBToLLVMConversionPass(UBToLLVMConversionPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createUBToLLVMConversionPass() {
  return impl::createUBToLLVMConversionPass();
}

std::unique_ptr<::mlir::Pass> createUBToLLVMConversionPass(UBToLLVMConversionPassOptions options) {
  return impl::createUBToLLVMConversionPass(std::move(options));
}
#undef GEN_PASS_DEF_UBTOLLVMCONVERSIONPASS
#endif // GEN_PASS_DEF_UBTOLLVMCONVERSIONPASS

//===----------------------------------------------------------------------===//
// UBToSPIRVConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_UBTOSPIRVCONVERSIONPASS
std::unique_ptr<::mlir::Pass> createUBToSPIRVConversionPass();
#undef GEN_PASS_DECL_UBTOSPIRVCONVERSIONPASS
#endif // GEN_PASS_DECL_UBTOSPIRVCONVERSIONPASS
#ifdef GEN_PASS_DEF_UBTOSPIRVCONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createUBToSPIRVConversionPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class UBToSPIRVConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = UBToSPIRVConversionPassBase;

  UBToSPIRVConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  UBToSPIRVConversionPassBase(const UBToSPIRVConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  UBToSPIRVConversionPassBase& operator=(const UBToSPIRVConversionPassBase &) = delete;
  UBToSPIRVConversionPassBase(UBToSPIRVConversionPassBase &&) = delete;
  UBToSPIRVConversionPassBase& operator=(UBToSPIRVConversionPassBase &&) = delete;
  ~UBToSPIRVConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-ub-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-ub-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert UB dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UBToSPIRVConversionPass");
  }
  ::llvm::StringRef getName() const override { return "UBToSPIRVConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UBToSPIRVConversionPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createUBToSPIRVConversionPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createUBToSPIRVConversionPass() {
  return impl::createUBToSPIRVConversionPass();
}
#undef GEN_PASS_DEF_UBTOSPIRVCONVERSIONPASS
#endif // GEN_PASS_DEF_UBTOSPIRVCONVERSIONPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ArithToAMDGPUConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerArithToAMDGPUConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createArithToAMDGPUConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerArithToAMDGPUConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createArithToAMDGPUConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// ArithToArmSMEConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerArithToArmSMEConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createArithToArmSMEConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerArithToArmSMEConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createArithToArmSMEConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// ArithToLLVMConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerArithToLLVMConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createArithToLLVMConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerArithToLLVMConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createArithToLLVMConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertAMDGPUToROCDLPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertAMDGPUToROCDLPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertAMDGPUToROCDLPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertAMDGPUToROCDLPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertAMDGPUToROCDLPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertAffineForToGPUPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertAffineForToGPUPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertAffineForToGPUPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertAffineForToGPUPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertAffineForToGPUPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertArithToEmitC Registration
//===----------------------------------------------------------------------===//

inline void registerConvertArithToEmitC() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertArithToEmitC();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertArithToEmitCPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertArithToEmitC();
  });
}

//===----------------------------------------------------------------------===//
// ConvertArithToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertArithToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertArithToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertArithToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertArithToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertArmNeon2dToIntrPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertArmNeon2dToIntrPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertArmNeon2dToIntrPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertArmNeon2dToIntrPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertArmNeon2dToIntrPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertArmSMEToLLVM Registration
//===----------------------------------------------------------------------===//

inline void registerConvertArmSMEToLLVM() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertArmSMEToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertArmSMEToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertArmSMEToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertArmSMEToSCFPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertArmSMEToSCFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertArmSMEToSCFPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertArmSMEToSCFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertArmSMEToSCFPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertAsyncToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertAsyncToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertAsyncToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertAsyncToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertAsyncToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertBufferizationToMemRefPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertBufferizationToMemRefPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertBufferizationToMemRefPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertBufferizationToMemRefPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertBufferizationToMemRefPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertComplexToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertComplexToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertComplexToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertComplexToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertComplexToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertComplexToLibm Registration
//===----------------------------------------------------------------------===//

inline void registerConvertComplexToLibm() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertComplexToLibm();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertComplexToLibmPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertComplexToLibm();
  });
}

//===----------------------------------------------------------------------===//
// ConvertComplexToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertComplexToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertComplexToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertComplexToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertComplexToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertComplexToStandardPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertComplexToStandardPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertComplexToStandardPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertComplexToStandardPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertComplexToStandardPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertControlFlowToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertControlFlowToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertControlFlowToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertControlFlowToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertControlFlowToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertControlFlowToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertControlFlowToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertControlFlowToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertControlFlowToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertControlFlowToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertFuncToEmitC Registration
//===----------------------------------------------------------------------===//

inline void registerConvertFuncToEmitC() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertFuncToEmitC();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertFuncToEmitCPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertFuncToEmitC();
  });
}

//===----------------------------------------------------------------------===//
// ConvertFuncToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertFuncToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertFuncToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertFuncToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertFuncToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertFuncToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertFuncToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertFuncToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertFuncToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertFuncToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertGPUToSPIRV Registration
//===----------------------------------------------------------------------===//

inline void registerConvertGPUToSPIRV() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertGPUToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertGPUToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertGPUToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertGpuOpsToLLVMSPVOps Registration
//===----------------------------------------------------------------------===//

inline void registerConvertGpuOpsToLLVMSPVOps() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertGpuOpsToLLVMSPVOps();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertGpuOpsToLLVMSPVOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertGpuOpsToLLVMSPVOps();
  });
}

//===----------------------------------------------------------------------===//
// ConvertGpuOpsToNVVMOps Registration
//===----------------------------------------------------------------------===//

inline void registerConvertGpuOpsToNVVMOps() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertGpuOpsToNVVMOps();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertGpuOpsToNVVMOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertGpuOpsToNVVMOps();
  });
}

//===----------------------------------------------------------------------===//
// ConvertGpuOpsToROCDLOps Registration
//===----------------------------------------------------------------------===//

inline void registerConvertGpuOpsToROCDLOps() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLowerGpuOpsToROCDLOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertGpuOpsToROCDLOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLowerGpuOpsToROCDLOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertIndexToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertIndexToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertIndexToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertIndexToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertIndexToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertIndexToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertIndexToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertIndexToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertIndexToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertIndexToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLinalgToStandardPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLinalgToStandardPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLinalgToStandardPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLinalgToStandardPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLinalgToStandardPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMathToEmitC Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMathToEmitC() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToEmitC();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMathToEmitCPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToEmitC();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMathToFuncs Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMathToFuncs() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToFuncs();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMathToFuncsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToFuncs();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMathToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMathToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMathToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMathToLibmPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMathToLibmPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToLibmPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMathToLibmPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToLibmPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMathToROCDL Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMathToROCDL() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToROCDL();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMathToROCDLPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToROCDL();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMathToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMathToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMathToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMathToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMemRefToEmitC Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMemRefToEmitC() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMemRefToEmitC();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMemRefToEmitCPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMemRefToEmitC();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMemRefToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMemRefToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMemRefToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMemRefToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMemRefToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMeshToMPIPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMeshToMPIPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMeshToMPIPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMeshToMPIPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMeshToMPIPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertNVGPUToNVVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertNVGPUToNVVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertNVGPUToNVVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertNVGPUToNVVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertNVGPUToNVVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertNVVMToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertNVVMToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertNVVMToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertNVVMToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertNVVMToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertOpenACCToSCFPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertOpenACCToSCFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertOpenACCToSCFPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertOpenACCToSCFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertOpenACCToSCFPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertOpenMPToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertOpenMPToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertOpenMPToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertOpenMPToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertOpenMPToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertPDLToPDLInterpPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertPDLToPDLInterpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertPDLToPDLInterpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertPDLToPDLInterpPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertPDLToPDLInterpPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertParallelLoopToGpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertParallelLoopToGpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertParallelLoopToGpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertParallelLoopToGpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertParallelLoopToGpuPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertSCFToOpenMPPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertSCFToOpenMPPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertSCFToOpenMPPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertSCFToOpenMPPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertSCFToOpenMPPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertSPIRVToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertSPIRVToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertSPIRVToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertSPIRVToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertSPIRVToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertShapeConstraintsPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertShapeConstraintsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertShapeConstraintsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertShapeConstraintsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertShapeConstraintsPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertShapeToStandardPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertShapeToStandardPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertShapeToStandardPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertShapeToStandardPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertShapeToStandardPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertTensorToLinalgPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertTensorToLinalgPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertTensorToLinalgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertTensorToLinalgPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertTensorToLinalgPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertTensorToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertTensorToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertTensorToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertTensorToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertTensorToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertToEmitC Registration
//===----------------------------------------------------------------------===//

inline void registerConvertToEmitC() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertToEmitC();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertToEmitCPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertToEmitC();
  });
}

//===----------------------------------------------------------------------===//
// ConvertToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertVectorToArmSMEPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertVectorToArmSMEPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertVectorToArmSMEPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertVectorToArmSMEPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertVectorToArmSMEPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertVectorToGPU Registration
//===----------------------------------------------------------------------===//

inline void registerConvertVectorToGPU() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertVectorToGPUPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertVectorToGPUPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertVectorToGPUPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertVectorToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertVectorToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertVectorToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertVectorToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertVectorToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertVectorToSCF Registration
//===----------------------------------------------------------------------===//

inline void registerConvertVectorToSCF() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertVectorToSCFPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertVectorToSCFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertVectorToSCFPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertVectorToSPIRVPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertVectorToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertVectorToSPIRVPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertVectorToSPIRVPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertVectorToSPIRVPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertVectorToXeGPU Registration
//===----------------------------------------------------------------------===//

inline void registerConvertVectorToXeGPU() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertVectorToXeGPU();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertVectorToXeGPUPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertVectorToXeGPU();
  });
}

//===----------------------------------------------------------------------===//
// FinalizeMemRefToLLVMConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerFinalizeMemRefToLLVMConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFinalizeMemRefToLLVMConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFinalizeMemRefToLLVMConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFinalizeMemRefToLLVMConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// GpuToLLVMConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerGpuToLLVMConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGpuToLLVMConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGpuToLLVMConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGpuToLLVMConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// LiftControlFlowToSCFPass Registration
//===----------------------------------------------------------------------===//

inline void registerLiftControlFlowToSCFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLiftControlFlowToSCFPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLiftControlFlowToSCFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLiftControlFlowToSCFPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerAffinePass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerAffinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerAffinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerAffinePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerAffinePass();
  });
}

//===----------------------------------------------------------------------===//
// LowerHostCodeToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerHostCodeToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerHostCodeToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerHostCodeToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerHostCodeToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// MapMemRefStorageClass Registration
//===----------------------------------------------------------------------===//

inline void registerMapMemRefStorageClass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createMapMemRefStorageClassPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMapMemRefStorageClassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createMapMemRefStorageClassPass();
  });
}

//===----------------------------------------------------------------------===//
// ReconcileUnrealizedCastsPass Registration
//===----------------------------------------------------------------------===//

inline void registerReconcileUnrealizedCastsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createReconcileUnrealizedCastsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerReconcileUnrealizedCastsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createReconcileUnrealizedCastsPass();
  });
}

//===----------------------------------------------------------------------===//
// SCFToControlFlowPass Registration
//===----------------------------------------------------------------------===//

inline void registerSCFToControlFlowPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSCFToControlFlowPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSCFToControlFlowPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSCFToControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// SCFToEmitC Registration
//===----------------------------------------------------------------------===//

inline void registerSCFToEmitC() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSCFToEmitC();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSCFToEmitCPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSCFToEmitC();
  });
}

//===----------------------------------------------------------------------===//
// SCFToSPIRV Registration
//===----------------------------------------------------------------------===//

inline void registerSCFToSPIRV() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSCFToSPIRV();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSCFToSPIRVPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSCFToSPIRV();
  });
}

//===----------------------------------------------------------------------===//
// SetLLVMModuleDataLayoutPass Registration
//===----------------------------------------------------------------------===//

inline void registerSetLLVMModuleDataLayoutPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSetLLVMModuleDataLayoutPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSetLLVMModuleDataLayoutPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSetLLVMModuleDataLayoutPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaToArithPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaToArithPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaToArithPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaToArithPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaToArithPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaToLinalg Registration
//===----------------------------------------------------------------------===//

inline void registerTosaToLinalg() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tosa::createTosaToLinalg();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaToLinalgPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tosa::createTosaToLinalg();
  });
}

//===----------------------------------------------------------------------===//
// TosaToLinalgNamed Registration
//===----------------------------------------------------------------------===//

inline void registerTosaToLinalgNamed() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tosa::createTosaToLinalgNamed();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaToLinalgNamedPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tosa::createTosaToLinalgNamed();
  });
}

//===----------------------------------------------------------------------===//
// TosaToMLProgram Registration
//===----------------------------------------------------------------------===//

inline void registerTosaToMLProgram() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaToMLProgram();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaToMLProgramPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaToMLProgram();
  });
}

//===----------------------------------------------------------------------===//
// TosaToSCFPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaToSCFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaToSCFPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaToSCFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaToSCFPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaToTensorPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaToTensorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaToTensorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaToTensorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaToTensorPass();
  });
}

//===----------------------------------------------------------------------===//
// UBToLLVMConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerUBToLLVMConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createUBToLLVMConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerUBToLLVMConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createUBToLLVMConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// UBToSPIRVConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerUBToSPIRVConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createUBToSPIRVConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerUBToSPIRVConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createUBToSPIRVConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// Conversion Registration
//===----------------------------------------------------------------------===//

inline void registerConversionPasses() {
  registerArithToAMDGPUConversionPass();
  registerArithToArmSMEConversionPass();
  registerArithToLLVMConversionPass();
  registerConvertAMDGPUToROCDLPass();
  registerConvertAffineForToGPUPass();
  registerConvertArithToEmitC();
  registerConvertArithToSPIRVPass();
  registerConvertArmNeon2dToIntrPass();
  registerConvertArmSMEToLLVM();
  registerConvertArmSMEToSCFPass();
  registerConvertAsyncToLLVMPass();
  registerConvertBufferizationToMemRefPass();
  registerConvertComplexToLLVMPass();
  registerConvertComplexToLibm();
  registerConvertComplexToSPIRVPass();
  registerConvertComplexToStandardPass();
  registerConvertControlFlowToLLVMPass();
  registerConvertControlFlowToSPIRVPass();
  registerConvertFuncToEmitC();
  registerConvertFuncToLLVMPass();
  registerConvertFuncToSPIRVPass();
  registerConvertGPUToSPIRV();
  registerConvertGpuOpsToLLVMSPVOps();
  registerConvertGpuOpsToNVVMOps();
  registerConvertGpuOpsToROCDLOps();
  registerConvertIndexToLLVMPass();
  registerConvertIndexToSPIRVPass();
  registerConvertLinalgToStandardPass();
  registerConvertMathToEmitC();
  registerConvertMathToFuncs();
  registerConvertMathToLLVMPass();
  registerConvertMathToLibmPass();
  registerConvertMathToROCDL();
  registerConvertMathToSPIRVPass();
  registerConvertMemRefToEmitC();
  registerConvertMemRefToSPIRVPass();
  registerConvertMeshToMPIPass();
  registerConvertNVGPUToNVVMPass();
  registerConvertNVVMToLLVMPass();
  registerConvertOpenACCToSCFPass();
  registerConvertOpenMPToLLVMPass();
  registerConvertPDLToPDLInterpPass();
  registerConvertParallelLoopToGpuPass();
  registerConvertSCFToOpenMPPass();
  registerConvertSPIRVToLLVMPass();
  registerConvertShapeConstraintsPass();
  registerConvertShapeToStandardPass();
  registerConvertTensorToLinalgPass();
  registerConvertTensorToSPIRVPass();
  registerConvertToEmitC();
  registerConvertToLLVMPass();
  registerConvertVectorToArmSMEPass();
  registerConvertVectorToGPU();
  registerConvertVectorToLLVMPass();
  registerConvertVectorToSCF();
  registerConvertVectorToSPIRVPass();
  registerConvertVectorToXeGPU();
  registerFinalizeMemRefToLLVMConversionPass();
  registerGpuToLLVMConversionPass();
  registerLiftControlFlowToSCFPass();
  registerLowerAffinePass();
  registerLowerHostCodeToLLVMPass();
  registerMapMemRefStorageClass();
  registerReconcileUnrealizedCastsPass();
  registerSCFToControlFlowPass();
  registerSCFToEmitC();
  registerSCFToSPIRV();
  registerSetLLVMModuleDataLayoutPass();
  registerTosaToArithPass();
  registerTosaToLinalg();
  registerTosaToLinalgNamed();
  registerTosaToMLProgram();
  registerTosaToSCFPass();
  registerTosaToTensorPass();
  registerUBToLLVMConversionPass();
  registerUBToSPIRVConversionPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ArithToAMDGPUConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ArithToAMDGPUConversionPassBase;

  ArithToAMDGPUConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ArithToAMDGPUConversionPassBase(const ArithToAMDGPUConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  ArithToAMDGPUConversionPassBase& operator=(const ArithToAMDGPUConversionPassBase &) = delete;
  ArithToAMDGPUConversionPassBase(ArithToAMDGPUConversionPassBase &&) = delete;
  ArithToAMDGPUConversionPassBase& operator=(ArithToAMDGPUConversionPassBase &&) = delete;
  ~ArithToAMDGPUConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-amdgpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-amdgpu"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith operations to AMDGPU-specific implementations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArithToAMDGPUConversionPass");
  }
  ::llvm::StringRef getName() const override { return "ArithToAMDGPUConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<amdgpu::AMDGPUDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArithToAMDGPUConversionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> chipset{*this, "chipset", ::llvm::cl::desc("Chipset that these operations will run on"), ::llvm::cl::init("gfx000")};
  ::mlir::Pass::Option<bool> saturateFP8Truncf{*this, "saturate-fp8-truncf", ::llvm::cl::desc("Use saturating truncation for 8-bit float types"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> allowPackedF16Rtz{*this, "allow-packed-f16-round-to-zero", ::llvm::cl::desc("Whether we should allow f32->f16 packed round-to-zero conversion"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ArithToArmSMEConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ArithToArmSMEConversionPassBase;

  ArithToArmSMEConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ArithToArmSMEConversionPassBase(const ArithToArmSMEConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  ArithToArmSMEConversionPassBase& operator=(const ArithToArmSMEConversionPassBase &) = delete;
  ArithToArmSMEConversionPassBase(ArithToArmSMEConversionPassBase &&) = delete;
  ArithToArmSMEConversionPassBase& operator=(ArithToArmSMEConversionPassBase &&) = delete;
  ~ArithToArmSMEConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-arm-sme");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-arm-sme"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith dialect to ArmSME dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArithToArmSMEConversionPass");
  }
  ::llvm::StringRef getName() const override { return "ArithToArmSMEConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arm_sme::ArmSMEDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArithToArmSMEConversionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ArithToLLVMConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ArithToLLVMConversionPassBase;

  ArithToLLVMConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ArithToLLVMConversionPassBase(const ArithToLLVMConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  ArithToLLVMConversionPassBase& operator=(const ArithToLLVMConversionPassBase &) = delete;
  ArithToLLVMConversionPassBase(ArithToLLVMConversionPassBase &&) = delete;
  ArithToLLVMConversionPassBase& operator=(ArithToLLVMConversionPassBase &&) = delete;
  ~ArithToLLVMConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArithToLLVMConversionPass");
  }
  ::llvm::StringRef getName() const override { return "ArithToLLVMConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArithToLLVMConversionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class ConvertAMDGPUToROCDLPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertAMDGPUToROCDLPassBase;

  ConvertAMDGPUToROCDLPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertAMDGPUToROCDLPassBase(const ConvertAMDGPUToROCDLPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertAMDGPUToROCDLPassBase& operator=(const ConvertAMDGPUToROCDLPassBase &) = delete;
  ConvertAMDGPUToROCDLPassBase(ConvertAMDGPUToROCDLPassBase &&) = delete;
  ConvertAMDGPUToROCDLPassBase& operator=(ConvertAMDGPUToROCDLPassBase &&) = delete;
  ~ConvertAMDGPUToROCDLPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-amdgpu-to-rocdl");
  }
  ::llvm::StringRef getArgument() const override { return "convert-amdgpu-to-rocdl"; }

  ::llvm::StringRef getDescription() const override { return "Convert AMDGPU dialect to ROCDL dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertAMDGPUToROCDLPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertAMDGPUToROCDLPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<ROCDL::ROCDLDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertAMDGPUToROCDLPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> chipset{*this, "chipset", ::llvm::cl::desc("Chipset that these operations will run on"), ::llvm::cl::init("gfx000")};
};

template <typename DerivedT>
class ConvertAffineForToGPUPassBase : public ::mlir::InterfacePass<FunctionOpInterface> {
public:
  using Base = ConvertAffineForToGPUPassBase;

  ConvertAffineForToGPUPassBase() : ::mlir::InterfacePass<FunctionOpInterface>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertAffineForToGPUPassBase(const ConvertAffineForToGPUPassBase &other) : ::mlir::InterfacePass<FunctionOpInterface>(other) {}
  ConvertAffineForToGPUPassBase& operator=(const ConvertAffineForToGPUPassBase &) = delete;
  ConvertAffineForToGPUPassBase(ConvertAffineForToGPUPassBase &&) = delete;
  ConvertAffineForToGPUPassBase& operator=(ConvertAffineForToGPUPassBase &&) = delete;
  ~ConvertAffineForToGPUPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-affine-for-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-affine-for-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Convert top-level AffineFor Ops to GPU kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertAffineForToGPUPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertAffineForToGPUPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<gpu::GPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertAffineForToGPUPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> numBlockDims{*this, "gpu-block-dims", ::llvm::cl::desc("Number of GPU block dimensions for mapping"), ::llvm::cl::init(1u)};
  ::mlir::Pass::Option<unsigned> numThreadDims{*this, "gpu-thread-dims", ::llvm::cl::desc("Number of GPU thread dimensions for mapping"), ::llvm::cl::init(1u)};
};

template <typename DerivedT>
class ConvertArithToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertArithToEmitCBase;

  ConvertArithToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArithToEmitCBase(const ConvertArithToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertArithToEmitCBase& operator=(const ConvertArithToEmitCBase &) = delete;
  ConvertArithToEmitCBase(ConvertArithToEmitCBase &&) = delete;
  ConvertArithToEmitCBase& operator=(ConvertArithToEmitCBase &&) = delete;
  ~ConvertArithToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith dialect to EmitC dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArithToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertArithToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArithToEmitCBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertArithToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertArithToSPIRVPassBase;

  ConvertArithToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArithToSPIRVPassBase(const ConvertArithToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertArithToSPIRVPassBase& operator=(const ConvertArithToSPIRVPassBase &) = delete;
  ConvertArithToSPIRVPassBase(ConvertArithToSPIRVPassBase &&) = delete;
  ConvertArithToSPIRVPassBase& operator=(ConvertArithToSPIRVPassBase &&) = delete;
  ~ConvertArithToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arith-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arith-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arith dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArithToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertArithToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArithToSPIRVPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> emulateLT32BitScalarTypes{*this, "emulate-lt-32-bit-scalar-types", ::llvm::cl::desc("Emulate narrower scalar types with 32-bit ones if not supported by the target"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class ConvertArmNeon2dToIntrPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertArmNeon2dToIntrPassBase;

  ConvertArmNeon2dToIntrPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArmNeon2dToIntrPassBase(const ConvertArmNeon2dToIntrPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertArmNeon2dToIntrPassBase& operator=(const ConvertArmNeon2dToIntrPassBase &) = delete;
  ConvertArmNeon2dToIntrPassBase(ConvertArmNeon2dToIntrPassBase &&) = delete;
  ConvertArmNeon2dToIntrPassBase& operator=(ConvertArmNeon2dToIntrPassBase &&) = delete;
  ~ConvertArmNeon2dToIntrPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("arm-neon-2d-to-intr");
  }
  ::llvm::StringRef getArgument() const override { return "arm-neon-2d-to-intr"; }

  ::llvm::StringRef getDescription() const override { return "Convert Arm NEON structured ops to intrinsics"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArmNeon2dToIntrPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertArmNeon2dToIntrPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arm_neon::ArmNeonDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArmNeon2dToIntrPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertArmSMEToLLVMBase : public ::mlir::InterfacePass<FunctionOpInterface> {
public:
  using Base = ConvertArmSMEToLLVMBase;

  ConvertArmSMEToLLVMBase() : ::mlir::InterfacePass<FunctionOpInterface>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArmSMEToLLVMBase(const ConvertArmSMEToLLVMBase &other) : ::mlir::InterfacePass<FunctionOpInterface>(other) {}
  ConvertArmSMEToLLVMBase& operator=(const ConvertArmSMEToLLVMBase &) = delete;
  ConvertArmSMEToLLVMBase(ConvertArmSMEToLLVMBase &&) = delete;
  ConvertArmSMEToLLVMBase& operator=(ConvertArmSMEToLLVMBase &&) = delete;
  ~ConvertArmSMEToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arm-sme-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arm-sme-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the ArmSME dialect into the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArmSMEToLLVM");
  }
  ::llvm::StringRef getName() const override { return "ConvertArmSMEToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arm_sme::ArmSMEDialect>();
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArmSMEToLLVMBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> dumpTileLiveRanges{*this, "dump-tile-live-ranges", ::llvm::cl::desc("Dump the live ranges of SME tiles (for debugging)"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertArmSMEToSCFPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertArmSMEToSCFPassBase;

  ConvertArmSMEToSCFPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertArmSMEToSCFPassBase(const ConvertArmSMEToSCFPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertArmSMEToSCFPassBase& operator=(const ConvertArmSMEToSCFPassBase &) = delete;
  ConvertArmSMEToSCFPassBase(ConvertArmSMEToSCFPassBase &&) = delete;
  ConvertArmSMEToSCFPassBase& operator=(ConvertArmSMEToSCFPassBase &&) = delete;
  ~ConvertArmSMEToSCFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-arm-sme-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-arm-sme-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the ArmSME dialect into the SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertArmSMEToSCFPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertArmSMEToSCFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<vector::VectorDialect>();
    registry.insert<arm_sme::ArmSMEDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertArmSMEToSCFPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertAsyncToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertAsyncToLLVMPassBase;

  ConvertAsyncToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertAsyncToLLVMPassBase(const ConvertAsyncToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertAsyncToLLVMPassBase& operator=(const ConvertAsyncToLLVMPassBase &) = delete;
  ConvertAsyncToLLVMPassBase(ConvertAsyncToLLVMPassBase &&) = delete;
  ConvertAsyncToLLVMPassBase& operator=(ConvertAsyncToLLVMPassBase &&) = delete;
  ~ConvertAsyncToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-async-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-async-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert the operations from the async dialect into the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertAsyncToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertAsyncToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<async::AsyncDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertAsyncToLLVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertBufferizationToMemRefPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertBufferizationToMemRefPassBase;

  ConvertBufferizationToMemRefPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertBufferizationToMemRefPassBase(const ConvertBufferizationToMemRefPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertBufferizationToMemRefPassBase& operator=(const ConvertBufferizationToMemRefPassBase &) = delete;
  ConvertBufferizationToMemRefPassBase(ConvertBufferizationToMemRefPassBase &&) = delete;
  ConvertBufferizationToMemRefPassBase& operator=(ConvertBufferizationToMemRefPassBase &&) = delete;
  ~ConvertBufferizationToMemRefPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-bufferization-to-memref");
  }
  ::llvm::StringRef getArgument() const override { return "convert-bufferization-to-memref"; }

  ::llvm::StringRef getDescription() const override { return "Convert operations from the Bufferization dialect to the MemRef dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertBufferizationToMemRefPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertBufferizationToMemRefPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertBufferizationToMemRefPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertComplexToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertComplexToLLVMPassBase;

  ConvertComplexToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertComplexToLLVMPassBase(const ConvertComplexToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertComplexToLLVMPassBase& operator=(const ConvertComplexToLLVMPassBase &) = delete;
  ConvertComplexToLLVMPassBase(ConvertComplexToLLVMPassBase &&) = delete;
  ConvertComplexToLLVMPassBase& operator=(ConvertComplexToLLVMPassBase &&) = delete;
  ~ConvertComplexToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-complex-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-complex-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Complex dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertComplexToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertComplexToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertComplexToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<::mlir::complex::ComplexRangeFlags> complexRange{*this, "complex-range", ::llvm::cl::desc("Control the intermediate calculation of complex number division"), ::llvm::cl::init(::mlir::complex::ComplexRangeFlags::basic), ::llvm::cl::values(
        clEnumValN(::mlir::complex::ComplexRangeFlags::improved, "improved", "improved"),
        clEnumValN(::mlir::complex::ComplexRangeFlags::basic, "basic", "basic (default)"),
        clEnumValN(::mlir::complex::ComplexRangeFlags::none, "none", "none")
      )};
};

template <typename DerivedT>
class ConvertComplexToLibmBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertComplexToLibmBase;

  ConvertComplexToLibmBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertComplexToLibmBase(const ConvertComplexToLibmBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertComplexToLibmBase& operator=(const ConvertComplexToLibmBase &) = delete;
  ConvertComplexToLibmBase(ConvertComplexToLibmBase &&) = delete;
  ConvertComplexToLibmBase& operator=(ConvertComplexToLibmBase &&) = delete;
  ~ConvertComplexToLibmBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-complex-to-libm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-complex-to-libm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Complex dialect to libm calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertComplexToLibm");
  }
  ::llvm::StringRef getName() const override { return "ConvertComplexToLibm"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertComplexToLibmBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertComplexToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertComplexToSPIRVPassBase;

  ConvertComplexToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertComplexToSPIRVPassBase(const ConvertComplexToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertComplexToSPIRVPassBase& operator=(const ConvertComplexToSPIRVPassBase &) = delete;
  ConvertComplexToSPIRVPassBase(ConvertComplexToSPIRVPassBase &&) = delete;
  ConvertComplexToSPIRVPassBase& operator=(ConvertComplexToSPIRVPassBase &&) = delete;
  ~ConvertComplexToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-complex-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-complex-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Complex dialect to SPIRV dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertComplexToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertComplexToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertComplexToSPIRVPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertComplexToStandardPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertComplexToStandardPassBase;

  ConvertComplexToStandardPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertComplexToStandardPassBase(const ConvertComplexToStandardPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertComplexToStandardPassBase& operator=(const ConvertComplexToStandardPassBase &) = delete;
  ConvertComplexToStandardPassBase(ConvertComplexToStandardPassBase &&) = delete;
  ConvertComplexToStandardPassBase& operator=(ConvertComplexToStandardPassBase &&) = delete;
  ~ConvertComplexToStandardPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-complex-to-standard");
  }
  ::llvm::StringRef getArgument() const override { return "convert-complex-to-standard"; }

  ::llvm::StringRef getDescription() const override { return "Convert Complex dialect to standard dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertComplexToStandardPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertComplexToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<math::MathDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertComplexToStandardPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<::mlir::complex::ComplexRangeFlags> complexRange{*this, "complex-range", ::llvm::cl::desc("Control the intermediate calculation of complex number division"), ::llvm::cl::init(::mlir::complex::ComplexRangeFlags::improved), ::llvm::cl::values(
        clEnumValN(::mlir::complex::ComplexRangeFlags::improved, "improved", "improved (default)"),
        clEnumValN(::mlir::complex::ComplexRangeFlags::basic, "basic", "basic"),
        clEnumValN(::mlir::complex::ComplexRangeFlags::none, "none", "none")
      )};
};

template <typename DerivedT>
class ConvertControlFlowToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertControlFlowToLLVMPassBase;

  ConvertControlFlowToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertControlFlowToLLVMPassBase(const ConvertControlFlowToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertControlFlowToLLVMPassBase& operator=(const ConvertControlFlowToLLVMPassBase &) = delete;
  ConvertControlFlowToLLVMPassBase(ConvertControlFlowToLLVMPassBase &&) = delete;
  ConvertControlFlowToLLVMPassBase& operator=(ConvertControlFlowToLLVMPassBase &&) = delete;
  ~ConvertControlFlowToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-cf-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-cf-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert ControlFlow operations to the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertControlFlowToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertControlFlowToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertControlFlowToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class ConvertControlFlowToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertControlFlowToSPIRVPassBase;

  ConvertControlFlowToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertControlFlowToSPIRVPassBase(const ConvertControlFlowToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertControlFlowToSPIRVPassBase& operator=(const ConvertControlFlowToSPIRVPassBase &) = delete;
  ConvertControlFlowToSPIRVPassBase(ConvertControlFlowToSPIRVPassBase &&) = delete;
  ConvertControlFlowToSPIRVPassBase& operator=(ConvertControlFlowToSPIRVPassBase &&) = delete;
  ~ConvertControlFlowToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-cf-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-cf-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert ControlFlow dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertControlFlowToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertControlFlowToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertControlFlowToSPIRVPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> emulateLT32BitScalarTypes{*this, "emulate-lt-32-bit-scalar-types", ::llvm::cl::desc("Emulate narrower scalar types with 32-bit ones if not supported by the target"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class ConvertFuncToEmitCBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertFuncToEmitCBase;

  ConvertFuncToEmitCBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFuncToEmitCBase(const ConvertFuncToEmitCBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertFuncToEmitCBase& operator=(const ConvertFuncToEmitCBase &) = delete;
  ConvertFuncToEmitCBase(ConvertFuncToEmitCBase &&) = delete;
  ConvertFuncToEmitCBase& operator=(ConvertFuncToEmitCBase &&) = delete;
  ~ConvertFuncToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-func-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-func-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert Func dialect to EmitC dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFuncToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertFuncToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFuncToEmitCBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertFuncToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertFuncToLLVMPassBase;

  ConvertFuncToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFuncToLLVMPassBase(const ConvertFuncToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertFuncToLLVMPassBase& operator=(const ConvertFuncToLLVMPassBase &) = delete;
  ConvertFuncToLLVMPassBase(ConvertFuncToLLVMPassBase &&) = delete;
  ConvertFuncToLLVMPassBase& operator=(ConvertFuncToLLVMPassBase &&) = delete;
  ~ConvertFuncToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-func-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-func-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert from the Func dialect to the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFuncToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFuncToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFuncToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> useBarePtrCallConv{*this, "use-bare-ptr-memref-call-conv", ::llvm::cl::desc("Replace FuncOp's MemRef arguments with bare pointers to the MemRef element types"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class ConvertFuncToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertFuncToSPIRVPassBase;

  ConvertFuncToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFuncToSPIRVPassBase(const ConvertFuncToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertFuncToSPIRVPassBase& operator=(const ConvertFuncToSPIRVPassBase &) = delete;
  ConvertFuncToSPIRVPassBase(ConvertFuncToSPIRVPassBase &&) = delete;
  ConvertFuncToSPIRVPassBase& operator=(ConvertFuncToSPIRVPassBase &&) = delete;
  ~ConvertFuncToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-func-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-func-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Func dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFuncToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFuncToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFuncToSPIRVPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> emulateLT32BitScalarTypes{*this, "emulate-lt-32-bit-scalar-types", ::llvm::cl::desc("Emulate narrower scalar types with 32-bit ones if not supported by the target"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class ConvertGPUToSPIRVBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertGPUToSPIRVBase;

  ConvertGPUToSPIRVBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGPUToSPIRVBase(const ConvertGPUToSPIRVBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertGPUToSPIRVBase& operator=(const ConvertGPUToSPIRVBase &) = delete;
  ConvertGPUToSPIRVBase(ConvertGPUToSPIRVBase &&) = delete;
  ConvertGPUToSPIRVBase& operator=(ConvertGPUToSPIRVBase &&) = delete;
  ~ConvertGPUToSPIRVBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gpu-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gpu-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert GPU dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGPUToSPIRV");
  }
  ::llvm::StringRef getName() const override { return "ConvertGPUToSPIRV"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGPUToSPIRVBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> use64bitIndex{*this, "use-64bit-index", ::llvm::cl::desc("Use 64-bit integers to convert index types"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertGpuOpsToLLVMSPVOpsBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = ConvertGpuOpsToLLVMSPVOpsBase;

  ConvertGpuOpsToLLVMSPVOpsBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuOpsToLLVMSPVOpsBase(const ConvertGpuOpsToLLVMSPVOpsBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}
  ConvertGpuOpsToLLVMSPVOpsBase& operator=(const ConvertGpuOpsToLLVMSPVOpsBase &) = delete;
  ConvertGpuOpsToLLVMSPVOpsBase(ConvertGpuOpsToLLVMSPVOpsBase &&) = delete;
  ConvertGpuOpsToLLVMSPVOpsBase& operator=(ConvertGpuOpsToLLVMSPVOpsBase &&) = delete;
  ~ConvertGpuOpsToLLVMSPVOpsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gpu-to-llvm-spv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gpu-to-llvm-spv"; }

  ::llvm::StringRef getDescription() const override { return "Generate LLVM operations to be ingested by a SPIR-V backend for gpu operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuOpsToLLVMSPVOps");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuOpsToLLVMSPVOps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuOpsToLLVMSPVOpsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> use64bitIndex{*this, "use-64bit-index", ::llvm::cl::desc("Use 64-bit integers to convert index types"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertGpuOpsToNVVMOpsBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = ConvertGpuOpsToNVVMOpsBase;

  ConvertGpuOpsToNVVMOpsBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuOpsToNVVMOpsBase(const ConvertGpuOpsToNVVMOpsBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}
  ConvertGpuOpsToNVVMOpsBase& operator=(const ConvertGpuOpsToNVVMOpsBase &) = delete;
  ConvertGpuOpsToNVVMOpsBase(ConvertGpuOpsToNVVMOpsBase &&) = delete;
  ConvertGpuOpsToNVVMOpsBase& operator=(ConvertGpuOpsToNVVMOpsBase &&) = delete;
  ~ConvertGpuOpsToNVVMOpsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gpu-to-nvvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gpu-to-nvvm"; }

  ::llvm::StringRef getDescription() const override { return "Generate NVVM operations for gpu operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuOpsToNVVMOps");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuOpsToNVVMOps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuOpsToNVVMOpsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> hasRedux{*this, "has-redux", ::llvm::cl::desc("Target gpu supports redux"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> useBarePtrCallConv{*this, "use-bare-ptr-memref-call-conv", ::llvm::cl::desc("Replace memref arguments in GPU functions with bare pointers. All memrefs must have static shape."), ::llvm::cl::init(false)};
  ::mlir::Pass::ListOption<std::string> allowedDialects{*this, "allowed-dialects", ::llvm::cl::desc("Run conversion patterns of only the specified dialects")};
};

template <typename DerivedT>
class ConvertGpuOpsToROCDLOpsBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = ConvertGpuOpsToROCDLOpsBase;

  ConvertGpuOpsToROCDLOpsBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuOpsToROCDLOpsBase(const ConvertGpuOpsToROCDLOpsBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}
  ConvertGpuOpsToROCDLOpsBase& operator=(const ConvertGpuOpsToROCDLOpsBase &) = delete;
  ConvertGpuOpsToROCDLOpsBase(ConvertGpuOpsToROCDLOpsBase &&) = delete;
  ConvertGpuOpsToROCDLOpsBase& operator=(ConvertGpuOpsToROCDLOpsBase &&) = delete;
  ~ConvertGpuOpsToROCDLOpsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gpu-to-rocdl");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gpu-to-rocdl"; }

  ::llvm::StringRef getDescription() const override { return "Generate ROCDL operations for gpu operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuOpsToROCDLOps");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuOpsToROCDLOps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<ROCDL::ROCDLDialect>();
    registry.insert<amdgpu::AMDGPUDialect>();
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuOpsToROCDLOpsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> chipset{*this, "chipset", ::llvm::cl::desc("Chipset that these operations will run on"), ::llvm::cl::init("gfx000")};
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> useBarePtrCallConv{*this, "use-bare-ptr-memref-call-conv", ::llvm::cl::desc("Replace memref arguments in GPU functions with bare pointers.All memrefs must have static shape"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<::mlir::gpu::amd::Runtime> runtime{*this, "runtime", ::llvm::cl::desc("Runtime code will be run on (default is Unknown, can also use HIP or OpenCL)"), ::llvm::cl::init(::mlir::gpu::amd::Runtime::Unknown), ::llvm::cl::values(
               clEnumValN(::mlir::gpu::amd::Runtime::Unknown, "unknown",
                          "Unknown (default)"),
               clEnumValN(::mlir::gpu::amd::Runtime::HIP, "HIP", "HIP"),
               clEnumValN(::mlir::gpu::amd::Runtime::OpenCL, "OpenCL",
                          "OpenCL"))};
  ::mlir::Pass::ListOption<std::string> allowedDialects{*this, "allowed-dialects", ::llvm::cl::desc("Run conversion patterns of only the specified dialects")};
};

template <typename DerivedT>
class ConvertIndexToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertIndexToLLVMPassBase;

  ConvertIndexToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertIndexToLLVMPassBase(const ConvertIndexToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertIndexToLLVMPassBase& operator=(const ConvertIndexToLLVMPassBase &) = delete;
  ConvertIndexToLLVMPassBase(ConvertIndexToLLVMPassBase &&) = delete;
  ConvertIndexToLLVMPassBase& operator=(ConvertIndexToLLVMPassBase &&) = delete;
  ~ConvertIndexToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-index-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-index-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lower the `index` dialect to the `llvm` dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertIndexToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertIndexToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertIndexToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class ConvertIndexToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertIndexToSPIRVPassBase;

  ConvertIndexToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertIndexToSPIRVPassBase(const ConvertIndexToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertIndexToSPIRVPassBase& operator=(const ConvertIndexToSPIRVPassBase &) = delete;
  ConvertIndexToSPIRVPassBase(ConvertIndexToSPIRVPassBase &&) = delete;
  ConvertIndexToSPIRVPassBase& operator=(ConvertIndexToSPIRVPassBase &&) = delete;
  ~ConvertIndexToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-index-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-index-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Lower the `index` dialect to the `spirv` dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertIndexToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertIndexToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertIndexToSPIRVPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> use64bitIndex{*this, "use-64bit-index", ::llvm::cl::desc("Use 64-bit integers to convert index types"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertLinalgToStandardPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertLinalgToStandardPassBase;

  ConvertLinalgToStandardPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLinalgToStandardPassBase(const ConvertLinalgToStandardPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertLinalgToStandardPassBase& operator=(const ConvertLinalgToStandardPassBase &) = delete;
  ConvertLinalgToStandardPassBase(ConvertLinalgToStandardPassBase &&) = delete;
  ConvertLinalgToStandardPassBase& operator=(ConvertLinalgToStandardPassBase &&) = delete;
  ~ConvertLinalgToStandardPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-linalg-to-std");
  }
  ::llvm::StringRef getArgument() const override { return "convert-linalg-to-std"; }

  ::llvm::StringRef getDescription() const override { return "Convert the operations from the linalg dialect into the Standard dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLinalgToStandardPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLinalgToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLinalgToStandardPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertMathToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMathToEmitCBase;

  ConvertMathToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToEmitCBase(const ConvertMathToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMathToEmitCBase& operator=(const ConvertMathToEmitCBase &) = delete;
  ConvertMathToEmitCBase(ConvertMathToEmitCBase &&) = delete;
  ConvertMathToEmitCBase& operator=(ConvertMathToEmitCBase &&) = delete;
  ~ConvertMathToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert some Math operations to EmitC call_opaque operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToEmitCBase<DerivedT>)

protected:
  ::mlir::Pass::Option<::mlir::emitc::LanguageTarget> languageTarget{*this, "language-target", ::llvm::cl::desc("Select the language standard target for callees (c99 or cpp11)."), ::llvm::cl::init(::mlir::emitc::LanguageTarget::c99), ::llvm::cl::values(
            clEnumValN(::mlir::emitc::LanguageTarget::c99, "c99", "c99"),
            clEnumValN(::mlir::emitc::LanguageTarget::cpp11, "cpp11", "cpp11")
          )};
};

template <typename DerivedT>
class ConvertMathToFuncsBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertMathToFuncsBase;

  ConvertMathToFuncsBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToFuncsBase(const ConvertMathToFuncsBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertMathToFuncsBase& operator=(const ConvertMathToFuncsBase &) = delete;
  ConvertMathToFuncsBase(ConvertMathToFuncsBase &&) = delete;
  ConvertMathToFuncsBase& operator=(ConvertMathToFuncsBase &&) = delete;
  ~ConvertMathToFuncsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-funcs");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-funcs"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math operations to calls of outlined implementations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToFuncs");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToFuncs"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<vector::VectorDialect>();
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToFuncsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> minWidthOfFPowIExponent{*this, "min-width-of-fpowi-exponent", ::llvm::cl::desc("Convert FPowI only if the width of its exponent's integer type is greater than or equal to this value"), ::llvm::cl::init(1)};
  ::mlir::Pass::Option<bool> convertCtlz{*this, "convert-ctlz", ::llvm::cl::desc("Convert math.ctlz to a software implementation. Enable for targets that do not natively support ctlz."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertMathToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMathToLLVMPassBase;

  ConvertMathToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToLLVMPassBase(const ConvertMathToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMathToLLVMPassBase& operator=(const ConvertMathToLLVMPassBase &) = delete;
  ConvertMathToLLVMPassBase(ConvertMathToLLVMPassBase &&) = delete;
  ConvertMathToLLVMPassBase& operator=(ConvertMathToLLVMPassBase &&) = delete;
  ~ConvertMathToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> approximateLog1p{*this, "approximate-log1p", ::llvm::cl::desc("Enable approximation of Log1p."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class ConvertMathToLibmPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertMathToLibmPassBase;

  ConvertMathToLibmPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToLibmPassBase(const ConvertMathToLibmPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertMathToLibmPassBase& operator=(const ConvertMathToLibmPassBase &) = delete;
  ConvertMathToLibmPassBase(ConvertMathToLibmPassBase &&) = delete;
  ConvertMathToLibmPassBase& operator=(ConvertMathToLibmPassBase &&) = delete;
  ~ConvertMathToLibmPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-libm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-libm"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math dialect to libm calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToLibmPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToLibmPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToLibmPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertMathToROCDLBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertMathToROCDLBase;

  ConvertMathToROCDLBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToROCDLBase(const ConvertMathToROCDLBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertMathToROCDLBase& operator=(const ConvertMathToROCDLBase &) = delete;
  ConvertMathToROCDLBase(ConvertMathToROCDLBase &&) = delete;
  ConvertMathToROCDLBase& operator=(ConvertMathToROCDLBase &&) = delete;
  ~ConvertMathToROCDLBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-rocdl");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-rocdl"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math dialect to ROCDL library calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToROCDL");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToROCDL"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<ROCDL::ROCDLDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToROCDLBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertMathToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMathToSPIRVPassBase;

  ConvertMathToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMathToSPIRVPassBase(const ConvertMathToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMathToSPIRVPassBase& operator=(const ConvertMathToSPIRVPassBase &) = delete;
  ConvertMathToSPIRVPassBase(ConvertMathToSPIRVPassBase &&) = delete;
  ConvertMathToSPIRVPassBase& operator=(ConvertMathToSPIRVPassBase &&) = delete;
  ~ConvertMathToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-math-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-math-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Math dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMathToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMathToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMathToSPIRVPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertMemRefToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMemRefToEmitCBase;

  ConvertMemRefToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMemRefToEmitCBase(const ConvertMemRefToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMemRefToEmitCBase& operator=(const ConvertMemRefToEmitCBase &) = delete;
  ConvertMemRefToEmitCBase(ConvertMemRefToEmitCBase &&) = delete;
  ConvertMemRefToEmitCBase& operator=(ConvertMemRefToEmitCBase &&) = delete;
  ~ConvertMemRefToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-memref-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-memref-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert MemRef dialect to EmitC dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMemRefToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertMemRefToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMemRefToEmitCBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertMemRefToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMemRefToSPIRVPassBase;

  ConvertMemRefToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMemRefToSPIRVPassBase(const ConvertMemRefToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMemRefToSPIRVPassBase& operator=(const ConvertMemRefToSPIRVPassBase &) = delete;
  ConvertMemRefToSPIRVPassBase(ConvertMemRefToSPIRVPassBase &&) = delete;
  ConvertMemRefToSPIRVPassBase& operator=(ConvertMemRefToSPIRVPassBase &&) = delete;
  ~ConvertMemRefToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-memref-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-memref-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert MemRef dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMemRefToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMemRefToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMemRefToSPIRVPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int> boolNumBits{*this, "bool-num-bits", ::llvm::cl::desc("The number of bits to store a boolean value"), ::llvm::cl::init(8)};
  ::mlir::Pass::Option<bool> use64bitIndex{*this, "use-64bit-index", ::llvm::cl::desc("Use 64-bit integers to convert index types"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertMeshToMPIPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertMeshToMPIPassBase;

  ConvertMeshToMPIPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMeshToMPIPassBase(const ConvertMeshToMPIPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertMeshToMPIPassBase& operator=(const ConvertMeshToMPIPassBase &) = delete;
  ConvertMeshToMPIPassBase(ConvertMeshToMPIPassBase &&) = delete;
  ConvertMeshToMPIPassBase& operator=(ConvertMeshToMPIPassBase &&) = delete;
  ~ConvertMeshToMPIPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-mesh-to-mpi");
  }
  ::llvm::StringRef getArgument() const override { return "convert-mesh-to-mpi"; }

  ::llvm::StringRef getDescription() const override { return "Convert Mesh dialect to MPI dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMeshToMPIPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMeshToMPIPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<mpi::MPIDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<bufferization::BufferizationDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMeshToMPIPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertNVGPUToNVVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertNVGPUToNVVMPassBase;

  ConvertNVGPUToNVVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertNVGPUToNVVMPassBase(const ConvertNVGPUToNVVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertNVGPUToNVVMPassBase& operator=(const ConvertNVGPUToNVVMPassBase &) = delete;
  ConvertNVGPUToNVVMPassBase(ConvertNVGPUToNVVMPassBase &&) = delete;
  ConvertNVGPUToNVVMPassBase& operator=(ConvertNVGPUToNVVMPassBase &&) = delete;
  ~ConvertNVGPUToNVVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-nvgpu-to-nvvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-nvgpu-to-nvvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert NVGPU dialect to NVVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertNVGPUToNVVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertNVGPUToNVVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertNVGPUToNVVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertNVVMToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertNVVMToLLVMPassBase;

  ConvertNVVMToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertNVVMToLLVMPassBase(const ConvertNVVMToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertNVVMToLLVMPassBase& operator=(const ConvertNVVMToLLVMPassBase &) = delete;
  ConvertNVVMToLLVMPassBase(ConvertNVVMToLLVMPassBase &&) = delete;
  ConvertNVVMToLLVMPassBase& operator=(ConvertNVVMToLLVMPassBase &&) = delete;
  ~ConvertNVVMToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-nvvm-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-nvvm-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert NVVM to PTX with Inline Assembly in LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertNVVMToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertNVVMToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertNVVMToLLVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertOpenACCToSCFPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertOpenACCToSCFPassBase;

  ConvertOpenACCToSCFPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertOpenACCToSCFPassBase(const ConvertOpenACCToSCFPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertOpenACCToSCFPassBase& operator=(const ConvertOpenACCToSCFPassBase &) = delete;
  ConvertOpenACCToSCFPassBase(ConvertOpenACCToSCFPassBase &&) = delete;
  ConvertOpenACCToSCFPassBase& operator=(ConvertOpenACCToSCFPassBase &&) = delete;
  ~ConvertOpenACCToSCFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-openacc-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-openacc-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Convert the OpenACC ops to OpenACC with SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertOpenACCToSCFPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertOpenACCToSCFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<acc::OpenACCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertOpenACCToSCFPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertOpenMPToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertOpenMPToLLVMPassBase;

  ConvertOpenMPToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertOpenMPToLLVMPassBase(const ConvertOpenMPToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertOpenMPToLLVMPassBase& operator=(const ConvertOpenMPToLLVMPassBase &) = delete;
  ConvertOpenMPToLLVMPassBase(ConvertOpenMPToLLVMPassBase &&) = delete;
  ConvertOpenMPToLLVMPassBase& operator=(ConvertOpenMPToLLVMPassBase &&) = delete;
  ~ConvertOpenMPToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-openmp-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-openmp-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert the OpenMP ops to OpenMP ops with LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertOpenMPToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertOpenMPToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertOpenMPToLLVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertPDLToPDLInterpPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertPDLToPDLInterpPassBase;

  ConvertPDLToPDLInterpPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertPDLToPDLInterpPassBase(const ConvertPDLToPDLInterpPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertPDLToPDLInterpPassBase& operator=(const ConvertPDLToPDLInterpPassBase &) = delete;
  ConvertPDLToPDLInterpPassBase(ConvertPDLToPDLInterpPassBase &&) = delete;
  ConvertPDLToPDLInterpPassBase& operator=(ConvertPDLToPDLInterpPassBase &&) = delete;
  ~ConvertPDLToPDLInterpPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-pdl-to-pdl-interp");
  }
  ::llvm::StringRef getArgument() const override { return "convert-pdl-to-pdl-interp"; }

  ::llvm::StringRef getDescription() const override { return "Convert PDL ops to PDL interpreter ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertPDLToPDLInterpPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertPDLToPDLInterpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<pdl_interp::PDLInterpDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertPDLToPDLInterpPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertParallelLoopToGpuPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertParallelLoopToGpuPassBase;

  ConvertParallelLoopToGpuPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertParallelLoopToGpuPassBase(const ConvertParallelLoopToGpuPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertParallelLoopToGpuPassBase& operator=(const ConvertParallelLoopToGpuPassBase &) = delete;
  ConvertParallelLoopToGpuPassBase(ConvertParallelLoopToGpuPassBase &&) = delete;
  ConvertParallelLoopToGpuPassBase& operator=(ConvertParallelLoopToGpuPassBase &&) = delete;
  ~ConvertParallelLoopToGpuPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-parallel-loops-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-parallel-loops-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Convert mapped scf.parallel ops to gpu launch operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertParallelLoopToGpuPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertParallelLoopToGpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<gpu::GPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertParallelLoopToGpuPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertSCFToOpenMPPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertSCFToOpenMPPassBase;

  ConvertSCFToOpenMPPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertSCFToOpenMPPassBase(const ConvertSCFToOpenMPPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertSCFToOpenMPPassBase& operator=(const ConvertSCFToOpenMPPassBase &) = delete;
  ConvertSCFToOpenMPPassBase(ConvertSCFToOpenMPPassBase &&) = delete;
  ConvertSCFToOpenMPPassBase& operator=(ConvertSCFToOpenMPPassBase &&) = delete;
  ~ConvertSCFToOpenMPPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-scf-to-openmp");
  }
  ::llvm::StringRef getArgument() const override { return "convert-scf-to-openmp"; }

  ::llvm::StringRef getDescription() const override { return "Convert SCF parallel loop to OpenMP parallel + workshare constructs."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertSCFToOpenMPPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertSCFToOpenMPPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<omp::OpenMPDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertSCFToOpenMPPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> numThreads{*this, "num-threads", ::llvm::cl::desc("Number of threads to use"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class ConvertSPIRVToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertSPIRVToLLVMPassBase;

  ConvertSPIRVToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertSPIRVToLLVMPassBase(const ConvertSPIRVToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertSPIRVToLLVMPassBase& operator=(const ConvertSPIRVToLLVMPassBase &) = delete;
  ConvertSPIRVToLLVMPassBase(ConvertSPIRVToLLVMPassBase &&) = delete;
  ConvertSPIRVToLLVMPassBase& operator=(ConvertSPIRVToLLVMPassBase &&) = delete;
  ~ConvertSPIRVToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-spirv-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-spirv-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert SPIR-V dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertSPIRVToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertSPIRVToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertSPIRVToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<::mlir::spirv::ClientAPI> clientAPI{*this, "client-api", ::llvm::cl::desc("Derive StorageClass to address space mapping from the client API"), ::llvm::cl::init(::mlir::spirv::ClientAPI::Unknown), ::llvm::cl::values(
	     clEnumValN(::mlir::spirv::ClientAPI::Unknown, "Unknown", "Unknown (default)"),
	     clEnumValN(::mlir::spirv::ClientAPI::Metal, "Metal", "Metal"),
	     clEnumValN(::mlir::spirv::ClientAPI::OpenCL, "OpenCL", "OpenCL"),
	     clEnumValN(::mlir::spirv::ClientAPI::Vulkan, "Vulkan", "Vulkan"),
	     clEnumValN(::mlir::spirv::ClientAPI::WebGPU, "WebGPU", "WebGPU")
	   )};
};

template <typename DerivedT>
class ConvertShapeConstraintsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertShapeConstraintsPassBase;

  ConvertShapeConstraintsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertShapeConstraintsPassBase(const ConvertShapeConstraintsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertShapeConstraintsPassBase& operator=(const ConvertShapeConstraintsPassBase &) = delete;
  ConvertShapeConstraintsPassBase(ConvertShapeConstraintsPassBase &&) = delete;
  ConvertShapeConstraintsPassBase& operator=(ConvertShapeConstraintsPassBase &&) = delete;
  ~ConvertShapeConstraintsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-shape-constraints");
  }
  ::llvm::StringRef getArgument() const override { return "convert-shape-constraints"; }

  ::llvm::StringRef getDescription() const override { return "Convert shape constraint operations to the standard dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertShapeConstraintsPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertShapeConstraintsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertShapeConstraintsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertShapeToStandardPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertShapeToStandardPassBase;

  ConvertShapeToStandardPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertShapeToStandardPassBase(const ConvertShapeToStandardPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertShapeToStandardPassBase& operator=(const ConvertShapeToStandardPassBase &) = delete;
  ConvertShapeToStandardPassBase(ConvertShapeToStandardPassBase &&) = delete;
  ConvertShapeToStandardPassBase& operator=(ConvertShapeToStandardPassBase &&) = delete;
  ~ConvertShapeToStandardPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-shape-to-std");
  }
  ::llvm::StringRef getArgument() const override { return "convert-shape-to-std"; }

  ::llvm::StringRef getDescription() const override { return "Convert operations from the shape dialect into the standard dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertShapeToStandardPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertShapeToStandardPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertShapeToStandardPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertTensorToLinalgPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertTensorToLinalgPassBase;

  ConvertTensorToLinalgPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTensorToLinalgPassBase(const ConvertTensorToLinalgPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ConvertTensorToLinalgPassBase& operator=(const ConvertTensorToLinalgPassBase &) = delete;
  ConvertTensorToLinalgPassBase(ConvertTensorToLinalgPassBase &&) = delete;
  ConvertTensorToLinalgPassBase& operator=(ConvertTensorToLinalgPassBase &&) = delete;
  ~ConvertTensorToLinalgPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tensor-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tensor-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Convert some Tensor dialect ops to Linalg dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTensorToLinalgPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTensorToLinalgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<linalg::LinalgDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTensorToLinalgPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertTensorToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertTensorToSPIRVPassBase;

  ConvertTensorToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTensorToSPIRVPassBase(const ConvertTensorToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertTensorToSPIRVPassBase& operator=(const ConvertTensorToSPIRVPassBase &) = delete;
  ConvertTensorToSPIRVPassBase(ConvertTensorToSPIRVPassBase &&) = delete;
  ConvertTensorToSPIRVPassBase& operator=(ConvertTensorToSPIRVPassBase &&) = delete;
  ~ConvertTensorToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tensor-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tensor-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Tensor dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTensorToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTensorToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTensorToSPIRVPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> emulateLT32BitScalarTypes{*this, "emulate-lt-32-bit-scalar-types", ::llvm::cl::desc("Emulate narrower scalar types with 32-bit ones if not supported by the target"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class ConvertToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertToEmitCBase;

  ConvertToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToEmitCBase(const ConvertToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertToEmitCBase& operator=(const ConvertToEmitCBase &) = delete;
  ConvertToEmitCBase(ConvertToEmitCBase &&) = delete;
  ConvertToEmitCBase& operator=(ConvertToEmitCBase &&) = delete;
  ~ConvertToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert to EmitC dialect via dialect interfaces"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToEmitC");
  }
  ::llvm::StringRef getName() const override { return "ConvertToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToEmitCBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> filterDialects{*this, "filter-dialects", ::llvm::cl::desc("Test conversion patterns of only the specified dialects")};
};

template <typename DerivedT>
class ConvertToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertToLLVMPassBase;

  ConvertToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToLLVMPassBase(const ConvertToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertToLLVMPassBase& operator=(const ConvertToLLVMPassBase &) = delete;
  ConvertToLLVMPassBase(ConvertToLLVMPassBase &&) = delete;
  ConvertToLLVMPassBase& operator=(ConvertToLLVMPassBase &&) = delete;
  ~ConvertToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert to LLVM via dialect interfaces found in the input IR"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> filterDialects{*this, "filter-dialects", ::llvm::cl::desc("Test conversion patterns of only the specified dialects")};
  ::mlir::Pass::Option<bool> useDynamic{*this, "dynamic", ::llvm::cl::desc("Use op conversion attributes to configure the conversion"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertVectorToArmSMEPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToArmSMEPassBase;

  ConvertVectorToArmSMEPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToArmSMEPassBase(const ConvertVectorToArmSMEPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToArmSMEPassBase& operator=(const ConvertVectorToArmSMEPassBase &) = delete;
  ConvertVectorToArmSMEPassBase(ConvertVectorToArmSMEPassBase &&) = delete;
  ConvertVectorToArmSMEPassBase& operator=(ConvertVectorToArmSMEPassBase &&) = delete;
  ~ConvertVectorToArmSMEPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-arm-sme");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-arm-sme"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the ArmSME dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToArmSMEPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToArmSMEPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arm_sme::ArmSMEDialect>();
    registry.insert<arm_sve::ArmSVEDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToArmSMEPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertVectorToGPUBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToGPUBase;

  ConvertVectorToGPUBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToGPUBase(const ConvertVectorToGPUBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToGPUBase& operator=(const ConvertVectorToGPUBase &) = delete;
  ConvertVectorToGPUBase(ConvertVectorToGPUBase &&) = delete;
  ConvertVectorToGPUBase& operator=(ConvertVectorToGPUBase &&) = delete;
  ~ConvertVectorToGPUBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the GPU dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToGPU");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToGPU"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<gpu::GPUDialect>();
    registry.insert<affine::AffineDialect>();
    registry.insert<vector::VectorDialect>();
    registry.insert<nvgpu::NVGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToGPUBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> useNvGpu{*this, "use-nvgpu", ::llvm::cl::desc("convert to NvGPU ops instead of GPU dialect ops"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertVectorToLLVMPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToLLVMPassBase;

  ConvertVectorToLLVMPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToLLVMPassBase(const ConvertVectorToLLVMPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToLLVMPassBase& operator=(const ConvertVectorToLLVMPassBase &) = delete;
  ConvertVectorToLLVMPassBase(ConvertVectorToLLVMPassBase &&) = delete;
  ConvertVectorToLLVMPassBase& operator=(ConvertVectorToLLVMPassBase &&) = delete;
  ~ConvertVectorToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> reassociateFPReductions{*this, "reassociate-fp-reductions", ::llvm::cl::desc("Allows llvm to reassociate floating-point reductions for speed"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> force32BitVectorIndices{*this, "force-32bit-vector-indices", ::llvm::cl::desc("Allows compiler to assume vector indices fit in 32-bit if that yields faster code"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> useVectorAlignment{*this, "use-vector-alignment", ::llvm::cl::desc("Use the preferred alignment of a vector type in load/store operations instead of the alignment of the element type of the memref. This flag is intended for use with hardware which requiresvector alignment, or in application contexts where it is known all vector access are naturally aligned. "), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> amx{*this, "enable-amx", ::llvm::cl::desc("Enables the use of AMX dialect while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> armNeon{*this, "enable-arm-neon", ::llvm::cl::desc("Enables the use of ArmNeon dialect while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> armSVE{*this, "enable-arm-sve", ::llvm::cl::desc("Enables the use of ArmSVE dialect while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> armI8MM{*this, "enable-arm-i8mm", ::llvm::cl::desc("Enables the use of Arm FEAT_I8MM instructions while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> x86Vector{*this, "enable-x86vector", ::llvm::cl::desc("Enables the use of X86Vector dialect while lowering the vector dialect."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<vector::VectorContractLowering> vectorContractLowering{*this, "vector-contract-lowering", ::llvm::cl::desc("control the lowering of `vector.contract` operations."), ::llvm::cl::init(vector::VectorContractLowering::Dot), ::llvm::cl::values(
           clEnumValN(::mlir::vector::VectorContractLowering::Dot, "dot",
            "Progressively lower to finer grained `vector.contract` and dot-products. (default)"),
           clEnumValN(::mlir::vector::VectorContractLowering::Matmul, "matmul",
            "Lower to `vector.matrix_multiply`, maps 1-1 to LLVM matrix intrinsics."),
           clEnumValN(::mlir::vector::VectorContractLowering::OuterProduct, "outerproduct",
            "Lower to `vector.outerproduct`."),
           clEnumValN(::mlir::vector::VectorContractLowering::ParallelArith, "parallelarith",
            "Lower contract with all reduction dimensions unrolled to 1 to a vector elementwise operations.")
	        )};
  ::mlir::Pass::Option<vector::VectorTransposeLowering> vectorTransposeLowering{*this, "vector-transpose-lowering", ::llvm::cl::desc("control the lowering of `vector.transpose` operations."), ::llvm::cl::init(vector::VectorTransposeLowering::EltWise), ::llvm::cl::values(
           clEnumValN(::mlir::vector::VectorTransposeLowering::EltWise, "eltwise",
            "Lower transpose into element-wise extract and inserts (default)"),
           clEnumValN(::mlir::vector::VectorTransposeLowering::Flat, "flat",
            "Lower 2-D transpose to `vector.flat_transpose`, maps 1-1 to LLVM matrix intrinsics"),
           clEnumValN(::mlir::vector::VectorTransposeLowering::Shuffle1D, "shuffle1d",
            "Lower 2-D transpose to `vector.shuffle` on 1-D vector."),
           clEnumValN(::mlir::vector::VectorTransposeLowering::Shuffle16x16, "shuffle16x16",
            "Lower 2-D transpose to `vector.shuffle` on 16x16 vector.")
          )};
};

template <typename DerivedT>
class ConvertVectorToSCFBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToSCFBase;

  ConvertVectorToSCFBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToSCFBase(const ConvertVectorToSCFBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToSCFBase& operator=(const ConvertVectorToSCFBase &) = delete;
  ConvertVectorToSCFBase(ConvertVectorToSCFBase &&) = delete;
  ConvertVectorToSCFBase& operator=(ConvertVectorToSCFBase &&) = delete;
  ~ConvertVectorToSCFBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToSCF");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToSCF"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToSCFBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> fullUnroll{*this, "full-unroll", ::llvm::cl::desc("Perform full unrolling when converting vector transfers to SCF"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<unsigned> targetRank{*this, "target-rank", ::llvm::cl::desc("Target vector rank to which transfer ops should be lowered"), ::llvm::cl::init(1)};
  ::mlir::Pass::Option<bool> lowerTensors{*this, "lower-tensors", ::llvm::cl::desc("Lower transfer ops that operate on tensors"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> lowerScalable{*this, "lower-scalable", ::llvm::cl::desc("Add scalable vector specific lowerings (that introduce loops)"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class ConvertVectorToSPIRVPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToSPIRVPassBase;

  ConvertVectorToSPIRVPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToSPIRVPassBase(const ConvertVectorToSPIRVPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToSPIRVPassBase& operator=(const ConvertVectorToSPIRVPassBase &) = delete;
  ConvertVectorToSPIRVPassBase(ConvertVectorToSPIRVPassBase &&) = delete;
  ConvertVectorToSPIRVPassBase& operator=(ConvertVectorToSPIRVPassBase &&) = delete;
  ~ConvertVectorToSPIRVPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert Vector dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToSPIRVPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToSPIRVPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
    registry.insert<ub::UBDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToSPIRVPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertVectorToXeGPUBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertVectorToXeGPUBase;

  ConvertVectorToXeGPUBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertVectorToXeGPUBase(const ConvertVectorToXeGPUBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertVectorToXeGPUBase& operator=(const ConvertVectorToXeGPUBase &) = delete;
  ConvertVectorToXeGPUBase(ConvertVectorToXeGPUBase &&) = delete;
  ConvertVectorToXeGPUBase& operator=(ConvertVectorToXeGPUBase &&) = delete;
  ~ConvertVectorToXeGPUBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-vector-to-xegpu");
  }
  ::llvm::StringRef getArgument() const override { return "convert-vector-to-xegpu"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the vector dialect into the XeGPU dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertVectorToXeGPU");
  }
  ::llvm::StringRef getName() const override { return "ConvertVectorToXeGPU"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<vector::VectorDialect>();
    registry.insert<xegpu::XeGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertVectorToXeGPUBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FinalizeMemRefToLLVMConversionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FinalizeMemRefToLLVMConversionPassBase;

  FinalizeMemRefToLLVMConversionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FinalizeMemRefToLLVMConversionPassBase(const FinalizeMemRefToLLVMConversionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  FinalizeMemRefToLLVMConversionPassBase& operator=(const FinalizeMemRefToLLVMConversionPassBase &) = delete;
  FinalizeMemRefToLLVMConversionPassBase(FinalizeMemRefToLLVMConversionPassBase &&) = delete;
  FinalizeMemRefToLLVMConversionPassBase& operator=(FinalizeMemRefToLLVMConversionPassBase &&) = delete;
  ~FinalizeMemRefToLLVMConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("finalize-memref-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "finalize-memref-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Finalize MemRef dialect to LLVM dialect conversion"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FinalizeMemRefToLLVMConversionPass");
  }
  ::llvm::StringRef getName() const override { return "FinalizeMemRefToLLVMConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FinalizeMemRefToLLVMConversionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> useAlignedAlloc{*this, "use-aligned-alloc", ::llvm::cl::desc("Use aligned_alloc in place of malloc for heap allocations"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> useGenericFunctions{*this, "use-generic-functions", ::llvm::cl::desc("Use generic allocation and deallocation functions instead of the classic 'malloc', 'aligned_alloc' and 'free' functions"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class GpuToLLVMConversionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GpuToLLVMConversionPassBase;

  GpuToLLVMConversionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GpuToLLVMConversionPassBase(const GpuToLLVMConversionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  GpuToLLVMConversionPassBase& operator=(const GpuToLLVMConversionPassBase &) = delete;
  GpuToLLVMConversionPassBase(GpuToLLVMConversionPassBase &&) = delete;
  GpuToLLVMConversionPassBase& operator=(GpuToLLVMConversionPassBase &&) = delete;
  ~GpuToLLVMConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gpu-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "gpu-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert GPU dialect to LLVM dialect with GPU runtime calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GpuToLLVMConversionPass");
  }
  ::llvm::StringRef getName() const override { return "GpuToLLVMConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GpuToLLVMConversionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> hostBarePtrCallConv{*this, "use-bare-pointers-for-host", ::llvm::cl::desc("Use bare pointers to pass memref arguments to host functions. All memrefs must have static shape."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> kernelBarePtrCallConv{*this, "use-bare-pointers-for-kernels", ::llvm::cl::desc("Use bare pointers to pass memref arguments to kernels. The kernel must use the same setting for this option."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> kernelIntersperseSizeCallConv{*this, "intersperse-sizes-for-kernels", ::llvm::cl::desc("Inserts a size_t argument following each memref argument, containing the static size in bytes of the buffer. Incompatible arguments are rejected. This is intended for use by the Vulkan runtime with the kernel bare pointer calling convention, to enable dynamic binding of buffers as arguments without static type info."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class LiftControlFlowToSCFPassBase : public ::mlir::OperationPass<> {
public:
  using Base = LiftControlFlowToSCFPassBase;

  LiftControlFlowToSCFPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LiftControlFlowToSCFPassBase(const LiftControlFlowToSCFPassBase &other) : ::mlir::OperationPass<>(other) {}
  LiftControlFlowToSCFPassBase& operator=(const LiftControlFlowToSCFPassBase &) = delete;
  LiftControlFlowToSCFPassBase(LiftControlFlowToSCFPassBase &&) = delete;
  LiftControlFlowToSCFPassBase& operator=(LiftControlFlowToSCFPassBase &&) = delete;
  ~LiftControlFlowToSCFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lift-cf-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "lift-cf-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lift ControlFlow dialect to SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LiftControlFlowToSCFPass");
  }
  ::llvm::StringRef getName() const override { return "LiftControlFlowToSCFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<ub::UBDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LiftControlFlowToSCFPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerAffinePassBase : public ::mlir::OperationPass<> {
public:
  using Base = LowerAffinePassBase;

  LowerAffinePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LowerAffinePassBase(const LowerAffinePassBase &other) : ::mlir::OperationPass<>(other) {}
  LowerAffinePassBase& operator=(const LowerAffinePassBase &) = delete;
  LowerAffinePassBase(LowerAffinePassBase &&) = delete;
  LowerAffinePassBase& operator=(LowerAffinePassBase &&) = delete;
  ~LowerAffinePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-affine");
  }
  ::llvm::StringRef getArgument() const override { return "lower-affine"; }

  ::llvm::StringRef getDescription() const override { return "Lower Affine operations to a combination of Arith and SCF operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerAffinePass");
  }
  ::llvm::StringRef getName() const override { return "LowerAffinePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerAffinePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerHostCodeToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LowerHostCodeToLLVMPassBase;

  LowerHostCodeToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerHostCodeToLLVMPassBase(const LowerHostCodeToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LowerHostCodeToLLVMPassBase& operator=(const LowerHostCodeToLLVMPassBase &) = delete;
  LowerHostCodeToLLVMPassBase(LowerHostCodeToLLVMPassBase &&) = delete;
  LowerHostCodeToLLVMPassBase& operator=(LowerHostCodeToLLVMPassBase &&) = delete;
  ~LowerHostCodeToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-host-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "lower-host-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lowers the host module code and `gpu.launch_func` to LLVM"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerHostCodeToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "LowerHostCodeToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerHostCodeToLLVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MapMemRefStorageClassBase : public ::mlir::OperationPass<> {
public:
  using Base = MapMemRefStorageClassBase;

  MapMemRefStorageClassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  MapMemRefStorageClassBase(const MapMemRefStorageClassBase &other) : ::mlir::OperationPass<>(other) {}
  MapMemRefStorageClassBase& operator=(const MapMemRefStorageClassBase &) = delete;
  MapMemRefStorageClassBase(MapMemRefStorageClassBase &&) = delete;
  MapMemRefStorageClassBase& operator=(MapMemRefStorageClassBase &&) = delete;
  ~MapMemRefStorageClassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("map-memref-spirv-storage-class");
  }
  ::llvm::StringRef getArgument() const override { return "map-memref-spirv-storage-class"; }

  ::llvm::StringRef getDescription() const override { return "Map numeric MemRef memory spaces to SPIR-V storage classes"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MapMemRefStorageClass");
  }
  ::llvm::StringRef getName() const override { return "MapMemRefStorageClass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MapMemRefStorageClassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> clientAPI{*this, "client-api", ::llvm::cl::desc("The client API to use for populating mappings"), ::llvm::cl::init("vulkan")};
};

template <typename DerivedT>
class ReconcileUnrealizedCastsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ReconcileUnrealizedCastsPassBase;

  ReconcileUnrealizedCastsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ReconcileUnrealizedCastsPassBase(const ReconcileUnrealizedCastsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ReconcileUnrealizedCastsPassBase& operator=(const ReconcileUnrealizedCastsPassBase &) = delete;
  ReconcileUnrealizedCastsPassBase(ReconcileUnrealizedCastsPassBase &&) = delete;
  ReconcileUnrealizedCastsPassBase& operator=(ReconcileUnrealizedCastsPassBase &&) = delete;
  ~ReconcileUnrealizedCastsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("reconcile-unrealized-casts");
  }
  ::llvm::StringRef getArgument() const override { return "reconcile-unrealized-casts"; }

  ::llvm::StringRef getDescription() const override { return "Simplify and eliminate unrealized conversion casts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReconcileUnrealizedCastsPass");
  }
  ::llvm::StringRef getName() const override { return "ReconcileUnrealizedCastsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReconcileUnrealizedCastsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SCFToControlFlowPassBase : public ::mlir::OperationPass<> {
public:
  using Base = SCFToControlFlowPassBase;

  SCFToControlFlowPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SCFToControlFlowPassBase(const SCFToControlFlowPassBase &other) : ::mlir::OperationPass<>(other) {}
  SCFToControlFlowPassBase& operator=(const SCFToControlFlowPassBase &) = delete;
  SCFToControlFlowPassBase(SCFToControlFlowPassBase &&) = delete;
  SCFToControlFlowPassBase& operator=(SCFToControlFlowPassBase &&) = delete;
  ~SCFToControlFlowPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-scf-to-cf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-scf-to-cf"; }

  ::llvm::StringRef getDescription() const override { return "Convert SCF dialect to ControlFlow dialect, replacing structured control flow with a CFG"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SCFToControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "SCFToControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SCFToControlFlowPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SCFToEmitCBase : public ::mlir::OperationPass<> {
public:
  using Base = SCFToEmitCBase;

  SCFToEmitCBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SCFToEmitCBase(const SCFToEmitCBase &other) : ::mlir::OperationPass<>(other) {}
  SCFToEmitCBase& operator=(const SCFToEmitCBase &) = delete;
  SCFToEmitCBase(SCFToEmitCBase &&) = delete;
  SCFToEmitCBase& operator=(SCFToEmitCBase &&) = delete;
  ~SCFToEmitCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-scf-to-emitc");
  }
  ::llvm::StringRef getArgument() const override { return "convert-scf-to-emitc"; }

  ::llvm::StringRef getDescription() const override { return "Convert SCF dialect to EmitC dialect, maintaining structured control flow"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SCFToEmitC");
  }
  ::llvm::StringRef getName() const override { return "SCFToEmitC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<emitc::EmitCDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SCFToEmitCBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SCFToSPIRVBase : public ::mlir::OperationPass<> {
public:
  using Base = SCFToSPIRVBase;

  SCFToSPIRVBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SCFToSPIRVBase(const SCFToSPIRVBase &other) : ::mlir::OperationPass<>(other) {}
  SCFToSPIRVBase& operator=(const SCFToSPIRVBase &) = delete;
  SCFToSPIRVBase(SCFToSPIRVBase &&) = delete;
  SCFToSPIRVBase& operator=(SCFToSPIRVBase &&) = delete;
  ~SCFToSPIRVBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-scf-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-scf-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert SCF dialect to SPIR-V dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SCFToSPIRV");
  }
  ::llvm::StringRef getName() const override { return "SCFToSPIRV"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SCFToSPIRVBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SetLLVMModuleDataLayoutPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SetLLVMModuleDataLayoutPassBase;

  SetLLVMModuleDataLayoutPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SetLLVMModuleDataLayoutPassBase(const SetLLVMModuleDataLayoutPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  SetLLVMModuleDataLayoutPassBase& operator=(const SetLLVMModuleDataLayoutPassBase &) = delete;
  SetLLVMModuleDataLayoutPassBase(SetLLVMModuleDataLayoutPassBase &&) = delete;
  SetLLVMModuleDataLayoutPassBase& operator=(SetLLVMModuleDataLayoutPassBase &&) = delete;
  ~SetLLVMModuleDataLayoutPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("set-llvm-module-datalayout");
  }
  ::llvm::StringRef getArgument() const override { return "set-llvm-module-datalayout"; }

  ::llvm::StringRef getDescription() const override { return "Attach a datalayout string as a module attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SetLLVMModuleDataLayoutPass");
  }
  ::llvm::StringRef getName() const override { return "SetLLVMModuleDataLayoutPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SetLLVMModuleDataLayoutPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> dataLayout{*this, "data-layout", ::llvm::cl::desc("String description (LLVM format) of the data layout that is expected on the produced module"), ::llvm::cl::init("")};
};

template <typename DerivedT>
class TosaToArithPassBase : public ::mlir::OperationPass<> {
public:
  using Base = TosaToArithPassBase;

  TosaToArithPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToArithPassBase(const TosaToArithPassBase &other) : ::mlir::OperationPass<>(other) {}
  TosaToArithPassBase& operator=(const TosaToArithPassBase &) = delete;
  TosaToArithPassBase(TosaToArithPassBase &&) = delete;
  TosaToArithPassBase& operator=(TosaToArithPassBase &&) = delete;
  ~TosaToArithPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-arith");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-arith"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to the Arith dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToArithPass");
  }
  ::llvm::StringRef getName() const override { return "TosaToArithPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToArithPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> includeApplyRescale{*this, "include-apply-rescale", ::llvm::cl::desc("Whether to include the lowering for tosa.apply_rescale to arith"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> use32Bit{*this, "use-32-bit", ::llvm::cl::desc("Whether to prioritze lowering to 32-bit operations"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TosaToLinalgBase : public ::mlir::InterfacePass<FunctionOpInterface> {
public:
  using Base = TosaToLinalgBase;

  TosaToLinalgBase() : ::mlir::InterfacePass<FunctionOpInterface>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToLinalgBase(const TosaToLinalgBase &other) : ::mlir::InterfacePass<FunctionOpInterface>(other) {}
  TosaToLinalgBase& operator=(const TosaToLinalgBase &) = delete;
  TosaToLinalgBase(TosaToLinalgBase &&) = delete;
  TosaToLinalgBase& operator=(TosaToLinalgBase &&) = delete;
  ~TosaToLinalgBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to LinAlg on tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToLinalg");
  }
  ::llvm::StringRef getName() const override { return "TosaToLinalg"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToLinalgBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> disableTosaDecompositions{*this, "disable-tosa-decompositions", ::llvm::cl::desc("Disable tosa decompositions pass"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> aggressiveReduceConstant{*this, "aggressive-reduce-constant", ::llvm::cl::desc("Always perform the reduce constant optimization"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TosaToLinalgNamedBase : public ::mlir::InterfacePass<FunctionOpInterface> {
public:
  using Base = TosaToLinalgNamedBase;

  TosaToLinalgNamedBase() : ::mlir::InterfacePass<FunctionOpInterface>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToLinalgNamedBase(const TosaToLinalgNamedBase &other) : ::mlir::InterfacePass<FunctionOpInterface>(other) {}
  TosaToLinalgNamedBase& operator=(const TosaToLinalgNamedBase &) = delete;
  TosaToLinalgNamedBase(TosaToLinalgNamedBase &&) = delete;
  TosaToLinalgNamedBase& operator=(TosaToLinalgNamedBase &&) = delete;
  ~TosaToLinalgNamedBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-linalg-named");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-linalg-named"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to LinAlg named operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToLinalgNamed");
  }
  ::llvm::StringRef getName() const override { return "TosaToLinalgNamed"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToLinalgNamedBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> preferConv2DKernelLayoutHWCF{*this, "prefer-conv2d-kernel-layout-hwcf", ::llvm::cl::desc("Prefer generating linalg.conv_2d_nhwc_hwcf over linalg.conv_2d_nhwc_fhwc"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TosaToMLProgramBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TosaToMLProgramBase;

  TosaToMLProgramBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToMLProgramBase(const TosaToMLProgramBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TosaToMLProgramBase& operator=(const TosaToMLProgramBase &) = delete;
  TosaToMLProgramBase(TosaToMLProgramBase &&) = delete;
  TosaToMLProgramBase& operator=(TosaToMLProgramBase &&) = delete;
  ~TosaToMLProgramBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-mlprogram");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-mlprogram"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to the MLProgram dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToMLProgram");
  }
  ::llvm::StringRef getName() const override { return "TosaToMLProgram"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<ml_program::MLProgramDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToMLProgramBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaToSCFPassBase : public ::mlir::OperationPass<> {
public:
  using Base = TosaToSCFPassBase;

  TosaToSCFPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToSCFPassBase(const TosaToSCFPassBase &other) : ::mlir::OperationPass<>(other) {}
  TosaToSCFPassBase& operator=(const TosaToSCFPassBase &) = delete;
  TosaToSCFPassBase(TosaToSCFPassBase &&) = delete;
  TosaToSCFPassBase& operator=(TosaToSCFPassBase &&) = delete;
  ~TosaToSCFPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to the SCF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToSCFPass");
  }
  ::llvm::StringRef getName() const override { return "TosaToSCFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect, scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToSCFPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaToTensorPassBase : public ::mlir::OperationPass<> {
public:
  using Base = TosaToTensorPassBase;

  TosaToTensorPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  TosaToTensorPassBase(const TosaToTensorPassBase &other) : ::mlir::OperationPass<>(other) {}
  TosaToTensorPassBase& operator=(const TosaToTensorPassBase &) = delete;
  TosaToTensorPassBase(TosaToTensorPassBase &&) = delete;
  TosaToTensorPassBase& operator=(TosaToTensorPassBase &&) = delete;
  ~TosaToTensorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-to-tensor");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-to-tensor"; }

  ::llvm::StringRef getDescription() const override { return "Lower TOSA to the Tensor dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaToTensorPass");
  }
  ::llvm::StringRef getName() const override { return "TosaToTensorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaToTensorPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class UBToLLVMConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = UBToLLVMConversionPassBase;

  UBToLLVMConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  UBToLLVMConversionPassBase(const UBToLLVMConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  UBToLLVMConversionPassBase& operator=(const UBToLLVMConversionPassBase &) = delete;
  UBToLLVMConversionPassBase(UBToLLVMConversionPassBase &&) = delete;
  UBToLLVMConversionPassBase& operator=(UBToLLVMConversionPassBase &&) = delete;
  ~UBToLLVMConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-ub-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-ub-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Convert UB dialect to LLVM dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UBToLLVMConversionPass");
  }
  ::llvm::StringRef getName() const override { return "UBToLLVMConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UBToLLVMConversionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> indexBitwidth{*this, "index-bitwidth", ::llvm::cl::desc("Bitwidth of the index type, 0 to use size of machine word"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class UBToSPIRVConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = UBToSPIRVConversionPassBase;

  UBToSPIRVConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  UBToSPIRVConversionPassBase(const UBToSPIRVConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  UBToSPIRVConversionPassBase& operator=(const UBToSPIRVConversionPassBase &) = delete;
  UBToSPIRVConversionPassBase(UBToSPIRVConversionPassBase &&) = delete;
  UBToSPIRVConversionPassBase& operator=(UBToSPIRVConversionPassBase &&) = delete;
  ~UBToSPIRVConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-ub-to-spirv");
  }
  ::llvm::StringRef getArgument() const override { return "convert-ub-to-spirv"; }

  ::llvm::StringRef getDescription() const override { return "Convert UB dialect to SPIR-V dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UBToSPIRVConversionPass");
  }
  ::llvm::StringRef getName() const override { return "UBToSPIRVConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<spirv::SPIRVDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UBToSPIRVConversionPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
