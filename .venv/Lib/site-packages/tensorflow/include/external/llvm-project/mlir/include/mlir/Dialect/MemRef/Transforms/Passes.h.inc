/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_EXPANDOPSPASS
#define GEN_PASS_DECL_EXPANDREALLOCPASS
#define GEN_PASS_DECL_EXPANDSTRIDEDMETADATAPASS
#define GEN_PASS_DECL_FLATTENMEMREFSPASS
#define GEN_PASS_DECL_FOLDMEMREFALIASOPSPASS
#define GEN_PASS_DECL_MEMREFEMULATEWIDEINT
#define GEN_PASS_DECL_NORMALIZEMEMREFSPASS
#define GEN_PASS_DECL_RESOLVERANKEDSHAPETYPERESULTDIMSPASS
#define GEN_PASS_DECL_RESOLVESHAPEDTYPERESULTDIMSPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ExpandOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXPANDOPSPASS
std::unique_ptr<::mlir::Pass> createExpandOpsPass();
#undef GEN_PASS_DECL_EXPANDOPSPASS
#endif // GEN_PASS_DECL_EXPANDOPSPASS
#ifdef GEN_PASS_DEF_EXPANDOPSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createExpandOpsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ExpandOpsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ExpandOpsPassBase;

  ExpandOpsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandOpsPassBase(const ExpandOpsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ExpandOpsPassBase& operator=(const ExpandOpsPassBase &) = delete;
  ExpandOpsPassBase(ExpandOpsPassBase &&) = delete;
  ExpandOpsPassBase& operator=(ExpandOpsPassBase &&) = delete;
  ~ExpandOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memref-expand");
  }
  ::llvm::StringRef getArgument() const override { return "memref-expand"; }

  ::llvm::StringRef getDescription() const override { return "Legalize memref operations to be convertible to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandOpsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createExpandOpsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createExpandOpsPass() {
  return impl::createExpandOpsPass();
}
#undef GEN_PASS_DEF_EXPANDOPSPASS
#endif // GEN_PASS_DEF_EXPANDOPSPASS

//===----------------------------------------------------------------------===//
// ExpandReallocPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXPANDREALLOCPASS
struct ExpandReallocPassOptions {
  bool emitDeallocs = true;
};
std::unique_ptr<::mlir::Pass> createExpandReallocPass();
std::unique_ptr<::mlir::Pass> createExpandReallocPass(ExpandReallocPassOptions options);
#undef GEN_PASS_DECL_EXPANDREALLOCPASS
#endif // GEN_PASS_DECL_EXPANDREALLOCPASS
#ifdef GEN_PASS_DEF_EXPANDREALLOCPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createExpandReallocPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createExpandReallocPass(ExpandReallocPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ExpandReallocPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ExpandReallocPassBase;

  ExpandReallocPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandReallocPassBase(const ExpandReallocPassBase &other) : ::mlir::OperationPass<>(other) {}
  ExpandReallocPassBase& operator=(const ExpandReallocPassBase &) = delete;
  ExpandReallocPassBase(ExpandReallocPassBase &&) = delete;
  ExpandReallocPassBase& operator=(ExpandReallocPassBase &&) = delete;
  ~ExpandReallocPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("expand-realloc");
  }
  ::llvm::StringRef getArgument() const override { return "expand-realloc"; }

  ::llvm::StringRef getDescription() const override { return "Expand memref.realloc operations into its components"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandReallocPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandReallocPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandReallocPassBase<DerivedT>)

  ExpandReallocPassBase(ExpandReallocPassOptions options) : ExpandReallocPassBase() {
    emitDeallocs = std::move(options.emitDeallocs);
  }
protected:
  ::mlir::Pass::Option<bool> emitDeallocs{*this, "emit-deallocs", ::llvm::cl::desc("Emit deallocation operations for the original MemRef"), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createExpandReallocPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createExpandReallocPass(ExpandReallocPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createExpandReallocPass() {
  return impl::createExpandReallocPass();
}

std::unique_ptr<::mlir::Pass> createExpandReallocPass(ExpandReallocPassOptions options) {
  return impl::createExpandReallocPass(std::move(options));
}
#undef GEN_PASS_DEF_EXPANDREALLOCPASS
#endif // GEN_PASS_DEF_EXPANDREALLOCPASS

//===----------------------------------------------------------------------===//
// ExpandStridedMetadataPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXPANDSTRIDEDMETADATAPASS
std::unique_ptr<::mlir::Pass> createExpandStridedMetadataPass();
#undef GEN_PASS_DECL_EXPANDSTRIDEDMETADATAPASS
#endif // GEN_PASS_DECL_EXPANDSTRIDEDMETADATAPASS
#ifdef GEN_PASS_DEF_EXPANDSTRIDEDMETADATAPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createExpandStridedMetadataPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ExpandStridedMetadataPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ExpandStridedMetadataPassBase;

  ExpandStridedMetadataPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandStridedMetadataPassBase(const ExpandStridedMetadataPassBase &other) : ::mlir::OperationPass<>(other) {}
  ExpandStridedMetadataPassBase& operator=(const ExpandStridedMetadataPassBase &) = delete;
  ExpandStridedMetadataPassBase(ExpandStridedMetadataPassBase &&) = delete;
  ExpandStridedMetadataPassBase& operator=(ExpandStridedMetadataPassBase &&) = delete;
  ~ExpandStridedMetadataPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("expand-strided-metadata");
  }
  ::llvm::StringRef getArgument() const override { return "expand-strided-metadata"; }

  ::llvm::StringRef getDescription() const override { return "Expand memref operations into easier to analyze constructs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandStridedMetadataPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandStridedMetadataPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandStridedMetadataPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createExpandStridedMetadataPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createExpandStridedMetadataPass() {
  return impl::createExpandStridedMetadataPass();
}
#undef GEN_PASS_DEF_EXPANDSTRIDEDMETADATAPASS
#endif // GEN_PASS_DEF_EXPANDSTRIDEDMETADATAPASS

//===----------------------------------------------------------------------===//
// FlattenMemrefsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FLATTENMEMREFSPASS
std::unique_ptr<::mlir::Pass> createFlattenMemrefsPass();
#undef GEN_PASS_DECL_FLATTENMEMREFSPASS
#endif // GEN_PASS_DECL_FLATTENMEMREFSPASS
#ifdef GEN_PASS_DEF_FLATTENMEMREFSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createFlattenMemrefsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class FlattenMemrefsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = FlattenMemrefsPassBase;

  FlattenMemrefsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  FlattenMemrefsPassBase(const FlattenMemrefsPassBase &other) : ::mlir::OperationPass<>(other) {}
  FlattenMemrefsPassBase& operator=(const FlattenMemrefsPassBase &) = delete;
  FlattenMemrefsPassBase(FlattenMemrefsPassBase &&) = delete;
  FlattenMemrefsPassBase& operator=(FlattenMemrefsPassBase &&) = delete;
  ~FlattenMemrefsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("flatten-memref");
  }
  ::llvm::StringRef getArgument() const override { return "flatten-memref"; }

  ::llvm::StringRef getDescription() const override { return "Flatten a multiple dimensional memref to 1-dimensional"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FlattenMemrefsPass");
  }
  ::llvm::StringRef getName() const override { return "FlattenMemrefsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FlattenMemrefsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createFlattenMemrefsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createFlattenMemrefsPass() {
  return impl::createFlattenMemrefsPass();
}
#undef GEN_PASS_DEF_FLATTENMEMREFSPASS
#endif // GEN_PASS_DEF_FLATTENMEMREFSPASS

//===----------------------------------------------------------------------===//
// FoldMemRefAliasOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FOLDMEMREFALIASOPSPASS
std::unique_ptr<::mlir::Pass> createFoldMemRefAliasOpsPass();
#undef GEN_PASS_DECL_FOLDMEMREFALIASOPSPASS
#endif // GEN_PASS_DECL_FOLDMEMREFALIASOPSPASS
#ifdef GEN_PASS_DEF_FOLDMEMREFALIASOPSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createFoldMemRefAliasOpsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class FoldMemRefAliasOpsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = FoldMemRefAliasOpsPassBase;

  FoldMemRefAliasOpsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  FoldMemRefAliasOpsPassBase(const FoldMemRefAliasOpsPassBase &other) : ::mlir::OperationPass<>(other) {}
  FoldMemRefAliasOpsPassBase& operator=(const FoldMemRefAliasOpsPassBase &) = delete;
  FoldMemRefAliasOpsPassBase(FoldMemRefAliasOpsPassBase &&) = delete;
  FoldMemRefAliasOpsPassBase& operator=(FoldMemRefAliasOpsPassBase &&) = delete;
  ~FoldMemRefAliasOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fold-memref-alias-ops");
  }
  ::llvm::StringRef getArgument() const override { return "fold-memref-alias-ops"; }

  ::llvm::StringRef getDescription() const override { return "Fold memref alias ops into consumer load/store ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FoldMemRefAliasOpsPass");
  }
  ::llvm::StringRef getName() const override { return "FoldMemRefAliasOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FoldMemRefAliasOpsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createFoldMemRefAliasOpsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createFoldMemRefAliasOpsPass() {
  return impl::createFoldMemRefAliasOpsPass();
}
#undef GEN_PASS_DEF_FOLDMEMREFALIASOPSPASS
#endif // GEN_PASS_DEF_FOLDMEMREFALIASOPSPASS

//===----------------------------------------------------------------------===//
// MemRefEmulateWideInt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MEMREFEMULATEWIDEINT
struct MemRefEmulateWideIntOptions {
  unsigned widestIntSupported = 32;
};
std::unique_ptr<::mlir::Pass> createMemRefEmulateWideInt();
std::unique_ptr<::mlir::Pass> createMemRefEmulateWideInt(MemRefEmulateWideIntOptions options);
#undef GEN_PASS_DECL_MEMREFEMULATEWIDEINT
#endif // GEN_PASS_DECL_MEMREFEMULATEWIDEINT
#ifdef GEN_PASS_DEF_MEMREFEMULATEWIDEINT

namespace impl {
  std::unique_ptr<::mlir::Pass> createMemRefEmulateWideInt();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createMemRefEmulateWideInt(MemRefEmulateWideIntOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class MemRefEmulateWideIntBase : public ::mlir::OperationPass<> {
public:
  using Base = MemRefEmulateWideIntBase;

  MemRefEmulateWideIntBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  MemRefEmulateWideIntBase(const MemRefEmulateWideIntBase &other) : ::mlir::OperationPass<>(other) {}
  MemRefEmulateWideIntBase& operator=(const MemRefEmulateWideIntBase &) = delete;
  MemRefEmulateWideIntBase(MemRefEmulateWideIntBase &&) = delete;
  MemRefEmulateWideIntBase& operator=(MemRefEmulateWideIntBase &&) = delete;
  ~MemRefEmulateWideIntBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memref-emulate-wide-int");
  }
  ::llvm::StringRef getArgument() const override { return "memref-emulate-wide-int"; }

  ::llvm::StringRef getDescription() const override { return "Emulate 2*N-bit integer operations using N-bit operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemRefEmulateWideInt");
  }
  ::llvm::StringRef getName() const override { return "MemRefEmulateWideInt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemRefEmulateWideIntBase<DerivedT>)

  MemRefEmulateWideIntBase(MemRefEmulateWideIntOptions options) : MemRefEmulateWideIntBase() {
    widestIntSupported = std::move(options.widestIntSupported);
  }
protected:
  ::mlir::Pass::Option<unsigned> widestIntSupported{*this, "widest-int-supported", ::llvm::cl::desc("Widest integer type supported by the target"), ::llvm::cl::init(32)};
private:

  friend std::unique_ptr<::mlir::Pass> createMemRefEmulateWideInt() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createMemRefEmulateWideInt(MemRefEmulateWideIntOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createMemRefEmulateWideInt() {
  return impl::createMemRefEmulateWideInt();
}

std::unique_ptr<::mlir::Pass> createMemRefEmulateWideInt(MemRefEmulateWideIntOptions options) {
  return impl::createMemRefEmulateWideInt(std::move(options));
}
#undef GEN_PASS_DEF_MEMREFEMULATEWIDEINT
#endif // GEN_PASS_DEF_MEMREFEMULATEWIDEINT

//===----------------------------------------------------------------------===//
// NormalizeMemRefsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NORMALIZEMEMREFSPASS
std::unique_ptr<::mlir::Pass> createNormalizeMemRefsPass();
#undef GEN_PASS_DECL_NORMALIZEMEMREFSPASS
#endif // GEN_PASS_DECL_NORMALIZEMEMREFSPASS
#ifdef GEN_PASS_DEF_NORMALIZEMEMREFSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createNormalizeMemRefsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class NormalizeMemRefsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = NormalizeMemRefsPassBase;

  NormalizeMemRefsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NormalizeMemRefsPassBase(const NormalizeMemRefsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  NormalizeMemRefsPassBase& operator=(const NormalizeMemRefsPassBase &) = delete;
  NormalizeMemRefsPassBase(NormalizeMemRefsPassBase &&) = delete;
  NormalizeMemRefsPassBase& operator=(NormalizeMemRefsPassBase &&) = delete;
  ~NormalizeMemRefsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("normalize-memrefs");
  }
  ::llvm::StringRef getArgument() const override { return "normalize-memrefs"; }

  ::llvm::StringRef getDescription() const override { return "Normalize memrefs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NormalizeMemRefsPass");
  }
  ::llvm::StringRef getName() const override { return "NormalizeMemRefsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NormalizeMemRefsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createNormalizeMemRefsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createNormalizeMemRefsPass() {
  return impl::createNormalizeMemRefsPass();
}
#undef GEN_PASS_DEF_NORMALIZEMEMREFSPASS
#endif // GEN_PASS_DEF_NORMALIZEMEMREFSPASS

//===----------------------------------------------------------------------===//
// ResolveRankedShapeTypeResultDimsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_RESOLVERANKEDSHAPETYPERESULTDIMSPASS
std::unique_ptr<::mlir::Pass> createResolveRankedShapeTypeResultDimsPass();
#undef GEN_PASS_DECL_RESOLVERANKEDSHAPETYPERESULTDIMSPASS
#endif // GEN_PASS_DECL_RESOLVERANKEDSHAPETYPERESULTDIMSPASS
#ifdef GEN_PASS_DEF_RESOLVERANKEDSHAPETYPERESULTDIMSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createResolveRankedShapeTypeResultDimsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ResolveRankedShapeTypeResultDimsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ResolveRankedShapeTypeResultDimsPassBase;

  ResolveRankedShapeTypeResultDimsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ResolveRankedShapeTypeResultDimsPassBase(const ResolveRankedShapeTypeResultDimsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ResolveRankedShapeTypeResultDimsPassBase& operator=(const ResolveRankedShapeTypeResultDimsPassBase &) = delete;
  ResolveRankedShapeTypeResultDimsPassBase(ResolveRankedShapeTypeResultDimsPassBase &&) = delete;
  ResolveRankedShapeTypeResultDimsPassBase& operator=(ResolveRankedShapeTypeResultDimsPassBase &&) = delete;
  ~ResolveRankedShapeTypeResultDimsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("resolve-ranked-shaped-type-result-dims");
  }
  ::llvm::StringRef getArgument() const override { return "resolve-ranked-shaped-type-result-dims"; }

  ::llvm::StringRef getDescription() const override { return "Resolve memref.dim of result values of ranked shape type"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResolveRankedShapeTypeResultDimsPass");
  }
  ::llvm::StringRef getName() const override { return "ResolveRankedShapeTypeResultDimsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResolveRankedShapeTypeResultDimsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createResolveRankedShapeTypeResultDimsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createResolveRankedShapeTypeResultDimsPass() {
  return impl::createResolveRankedShapeTypeResultDimsPass();
}
#undef GEN_PASS_DEF_RESOLVERANKEDSHAPETYPERESULTDIMSPASS
#endif // GEN_PASS_DEF_RESOLVERANKEDSHAPETYPERESULTDIMSPASS

//===----------------------------------------------------------------------===//
// ResolveShapedTypeResultDimsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_RESOLVESHAPEDTYPERESULTDIMSPASS
std::unique_ptr<::mlir::Pass> createResolveShapedTypeResultDimsPass();
#undef GEN_PASS_DECL_RESOLVESHAPEDTYPERESULTDIMSPASS
#endif // GEN_PASS_DECL_RESOLVESHAPEDTYPERESULTDIMSPASS
#ifdef GEN_PASS_DEF_RESOLVESHAPEDTYPERESULTDIMSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createResolveShapedTypeResultDimsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ResolveShapedTypeResultDimsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ResolveShapedTypeResultDimsPassBase;

  ResolveShapedTypeResultDimsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ResolveShapedTypeResultDimsPassBase(const ResolveShapedTypeResultDimsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ResolveShapedTypeResultDimsPassBase& operator=(const ResolveShapedTypeResultDimsPassBase &) = delete;
  ResolveShapedTypeResultDimsPassBase(ResolveShapedTypeResultDimsPassBase &&) = delete;
  ResolveShapedTypeResultDimsPassBase& operator=(ResolveShapedTypeResultDimsPassBase &&) = delete;
  ~ResolveShapedTypeResultDimsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("resolve-shaped-type-result-dims");
  }
  ::llvm::StringRef getArgument() const override { return "resolve-shaped-type-result-dims"; }

  ::llvm::StringRef getDescription() const override { return "Resolve memref.dim of result values"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResolveShapedTypeResultDimsPass");
  }
  ::llvm::StringRef getName() const override { return "ResolveShapedTypeResultDimsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResolveShapedTypeResultDimsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createResolveShapedTypeResultDimsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createResolveShapedTypeResultDimsPass() {
  return impl::createResolveShapedTypeResultDimsPass();
}
#undef GEN_PASS_DEF_RESOLVESHAPEDTYPERESULTDIMSPASS
#endif // GEN_PASS_DEF_RESOLVESHAPEDTYPERESULTDIMSPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ExpandOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerExpandOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExpandOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// ExpandReallocPass Registration
//===----------------------------------------------------------------------===//

inline void registerExpandReallocPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandReallocPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExpandReallocPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandReallocPass();
  });
}

//===----------------------------------------------------------------------===//
// ExpandStridedMetadataPass Registration
//===----------------------------------------------------------------------===//

inline void registerExpandStridedMetadataPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandStridedMetadataPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExpandStridedMetadataPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandStridedMetadataPass();
  });
}

//===----------------------------------------------------------------------===//
// FlattenMemrefsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFlattenMemrefsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFlattenMemrefsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFlattenMemrefsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFlattenMemrefsPass();
  });
}

//===----------------------------------------------------------------------===//
// FoldMemRefAliasOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFoldMemRefAliasOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFoldMemRefAliasOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFoldMemRefAliasOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFoldMemRefAliasOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// MemRefEmulateWideInt Registration
//===----------------------------------------------------------------------===//

inline void registerMemRefEmulateWideInt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMemRefEmulateWideInt();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMemRefEmulateWideIntPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMemRefEmulateWideInt();
  });
}

//===----------------------------------------------------------------------===//
// NormalizeMemRefsPass Registration
//===----------------------------------------------------------------------===//

inline void registerNormalizeMemRefsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNormalizeMemRefsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNormalizeMemRefsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNormalizeMemRefsPass();
  });
}

//===----------------------------------------------------------------------===//
// ResolveRankedShapeTypeResultDimsPass Registration
//===----------------------------------------------------------------------===//

inline void registerResolveRankedShapeTypeResultDimsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createResolveRankedShapeTypeResultDimsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerResolveRankedShapeTypeResultDimsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createResolveRankedShapeTypeResultDimsPass();
  });
}

//===----------------------------------------------------------------------===//
// ResolveShapedTypeResultDimsPass Registration
//===----------------------------------------------------------------------===//

inline void registerResolveShapedTypeResultDimsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createResolveShapedTypeResultDimsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerResolveShapedTypeResultDimsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createResolveShapedTypeResultDimsPass();
  });
}

//===----------------------------------------------------------------------===//
// MemRef Registration
//===----------------------------------------------------------------------===//

inline void registerMemRefPasses() {
  registerExpandOpsPass();
  registerExpandReallocPass();
  registerExpandStridedMetadataPass();
  registerFlattenMemrefsPass();
  registerFoldMemRefAliasOpsPass();
  registerMemRefEmulateWideInt();
  registerNormalizeMemRefsPass();
  registerResolveRankedShapeTypeResultDimsPass();
  registerResolveShapedTypeResultDimsPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ExpandOpsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ExpandOpsPassBase;

  ExpandOpsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandOpsPassBase(const ExpandOpsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ExpandOpsPassBase& operator=(const ExpandOpsPassBase &) = delete;
  ExpandOpsPassBase(ExpandOpsPassBase &&) = delete;
  ExpandOpsPassBase& operator=(ExpandOpsPassBase &&) = delete;
  ~ExpandOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memref-expand");
  }
  ::llvm::StringRef getArgument() const override { return "memref-expand"; }

  ::llvm::StringRef getDescription() const override { return "Legalize memref operations to be convertible to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExpandReallocPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ExpandReallocPassBase;

  ExpandReallocPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandReallocPassBase(const ExpandReallocPassBase &other) : ::mlir::OperationPass<>(other) {}
  ExpandReallocPassBase& operator=(const ExpandReallocPassBase &) = delete;
  ExpandReallocPassBase(ExpandReallocPassBase &&) = delete;
  ExpandReallocPassBase& operator=(ExpandReallocPassBase &&) = delete;
  ~ExpandReallocPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("expand-realloc");
  }
  ::llvm::StringRef getArgument() const override { return "expand-realloc"; }

  ::llvm::StringRef getDescription() const override { return "Expand memref.realloc operations into its components"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandReallocPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandReallocPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandReallocPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> emitDeallocs{*this, "emit-deallocs", ::llvm::cl::desc("Emit deallocation operations for the original MemRef"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class ExpandStridedMetadataPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ExpandStridedMetadataPassBase;

  ExpandStridedMetadataPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandStridedMetadataPassBase(const ExpandStridedMetadataPassBase &other) : ::mlir::OperationPass<>(other) {}
  ExpandStridedMetadataPassBase& operator=(const ExpandStridedMetadataPassBase &) = delete;
  ExpandStridedMetadataPassBase(ExpandStridedMetadataPassBase &&) = delete;
  ExpandStridedMetadataPassBase& operator=(ExpandStridedMetadataPassBase &&) = delete;
  ~ExpandStridedMetadataPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("expand-strided-metadata");
  }
  ::llvm::StringRef getArgument() const override { return "expand-strided-metadata"; }

  ::llvm::StringRef getDescription() const override { return "Expand memref operations into easier to analyze constructs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandStridedMetadataPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandStridedMetadataPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandStridedMetadataPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FlattenMemrefsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = FlattenMemrefsPassBase;

  FlattenMemrefsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  FlattenMemrefsPassBase(const FlattenMemrefsPassBase &other) : ::mlir::OperationPass<>(other) {}
  FlattenMemrefsPassBase& operator=(const FlattenMemrefsPassBase &) = delete;
  FlattenMemrefsPassBase(FlattenMemrefsPassBase &&) = delete;
  FlattenMemrefsPassBase& operator=(FlattenMemrefsPassBase &&) = delete;
  ~FlattenMemrefsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("flatten-memref");
  }
  ::llvm::StringRef getArgument() const override { return "flatten-memref"; }

  ::llvm::StringRef getDescription() const override { return "Flatten a multiple dimensional memref to 1-dimensional"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FlattenMemrefsPass");
  }
  ::llvm::StringRef getName() const override { return "FlattenMemrefsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FlattenMemrefsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FoldMemRefAliasOpsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = FoldMemRefAliasOpsPassBase;

  FoldMemRefAliasOpsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  FoldMemRefAliasOpsPassBase(const FoldMemRefAliasOpsPassBase &other) : ::mlir::OperationPass<>(other) {}
  FoldMemRefAliasOpsPassBase& operator=(const FoldMemRefAliasOpsPassBase &) = delete;
  FoldMemRefAliasOpsPassBase(FoldMemRefAliasOpsPassBase &&) = delete;
  FoldMemRefAliasOpsPassBase& operator=(FoldMemRefAliasOpsPassBase &&) = delete;
  ~FoldMemRefAliasOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fold-memref-alias-ops");
  }
  ::llvm::StringRef getArgument() const override { return "fold-memref-alias-ops"; }

  ::llvm::StringRef getDescription() const override { return "Fold memref alias ops into consumer load/store ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FoldMemRefAliasOpsPass");
  }
  ::llvm::StringRef getName() const override { return "FoldMemRefAliasOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FoldMemRefAliasOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MemRefEmulateWideIntBase : public ::mlir::OperationPass<> {
public:
  using Base = MemRefEmulateWideIntBase;

  MemRefEmulateWideIntBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  MemRefEmulateWideIntBase(const MemRefEmulateWideIntBase &other) : ::mlir::OperationPass<>(other) {}
  MemRefEmulateWideIntBase& operator=(const MemRefEmulateWideIntBase &) = delete;
  MemRefEmulateWideIntBase(MemRefEmulateWideIntBase &&) = delete;
  MemRefEmulateWideIntBase& operator=(MemRefEmulateWideIntBase &&) = delete;
  ~MemRefEmulateWideIntBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memref-emulate-wide-int");
  }
  ::llvm::StringRef getArgument() const override { return "memref-emulate-wide-int"; }

  ::llvm::StringRef getDescription() const override { return "Emulate 2*N-bit integer operations using N-bit operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemRefEmulateWideInt");
  }
  ::llvm::StringRef getName() const override { return "MemRefEmulateWideInt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemRefEmulateWideIntBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> widestIntSupported{*this, "widest-int-supported", ::llvm::cl::desc("Widest integer type supported by the target"), ::llvm::cl::init(32)};
};

template <typename DerivedT>
class NormalizeMemRefsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = NormalizeMemRefsPassBase;

  NormalizeMemRefsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NormalizeMemRefsPassBase(const NormalizeMemRefsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  NormalizeMemRefsPassBase& operator=(const NormalizeMemRefsPassBase &) = delete;
  NormalizeMemRefsPassBase(NormalizeMemRefsPassBase &&) = delete;
  NormalizeMemRefsPassBase& operator=(NormalizeMemRefsPassBase &&) = delete;
  ~NormalizeMemRefsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("normalize-memrefs");
  }
  ::llvm::StringRef getArgument() const override { return "normalize-memrefs"; }

  ::llvm::StringRef getDescription() const override { return "Normalize memrefs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NormalizeMemRefsPass");
  }
  ::llvm::StringRef getName() const override { return "NormalizeMemRefsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NormalizeMemRefsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ResolveRankedShapeTypeResultDimsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ResolveRankedShapeTypeResultDimsPassBase;

  ResolveRankedShapeTypeResultDimsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ResolveRankedShapeTypeResultDimsPassBase(const ResolveRankedShapeTypeResultDimsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ResolveRankedShapeTypeResultDimsPassBase& operator=(const ResolveRankedShapeTypeResultDimsPassBase &) = delete;
  ResolveRankedShapeTypeResultDimsPassBase(ResolveRankedShapeTypeResultDimsPassBase &&) = delete;
  ResolveRankedShapeTypeResultDimsPassBase& operator=(ResolveRankedShapeTypeResultDimsPassBase &&) = delete;
  ~ResolveRankedShapeTypeResultDimsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("resolve-ranked-shaped-type-result-dims");
  }
  ::llvm::StringRef getArgument() const override { return "resolve-ranked-shaped-type-result-dims"; }

  ::llvm::StringRef getDescription() const override { return "Resolve memref.dim of result values of ranked shape type"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResolveRankedShapeTypeResultDimsPass");
  }
  ::llvm::StringRef getName() const override { return "ResolveRankedShapeTypeResultDimsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResolveRankedShapeTypeResultDimsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ResolveShapedTypeResultDimsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ResolveShapedTypeResultDimsPassBase;

  ResolveShapedTypeResultDimsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ResolveShapedTypeResultDimsPassBase(const ResolveShapedTypeResultDimsPassBase &other) : ::mlir::OperationPass<>(other) {}
  ResolveShapedTypeResultDimsPassBase& operator=(const ResolveShapedTypeResultDimsPassBase &) = delete;
  ResolveShapedTypeResultDimsPassBase(ResolveShapedTypeResultDimsPassBase &&) = delete;
  ResolveShapedTypeResultDimsPassBase& operator=(ResolveShapedTypeResultDimsPassBase &&) = delete;
  ~ResolveShapedTypeResultDimsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("resolve-shaped-type-result-dims");
  }
  ::llvm::StringRef getArgument() const override { return "resolve-shaped-type-result-dims"; }

  ::llvm::StringRef getDescription() const override { return "Resolve memref.dim of result values"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResolveShapedTypeResultDimsPass");
  }
  ::llvm::StringRef getName() const override { return "ResolveShapedTypeResultDimsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResolveShapedTypeResultDimsPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
