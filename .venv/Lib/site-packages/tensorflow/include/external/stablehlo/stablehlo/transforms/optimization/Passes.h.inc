/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_STABLEHLOAGGRESSIVEFOLDERPASS
#define GEN_PASS_DECL_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
#define GEN_PASS_DECL_STABLEHLOTARGETINDEPENDENTOPTIMIZATIONPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// StablehloAggressiveFolderPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOAGGRESSIVEFOLDERPASS
struct StablehloAggressiveFolderPassOptions {
  bool assumeNoUndeclaredSideEffects = false;
  int64_t foldOpElementLimit = 65536;
  bool optimizeFloat = true;
};
std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass();
std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass(StablehloAggressiveFolderPassOptions options);
#undef GEN_PASS_DECL_STABLEHLOAGGRESSIVEFOLDERPASS
#endif // GEN_PASS_DECL_STABLEHLOAGGRESSIVEFOLDERPASS
#ifdef GEN_PASS_DEF_STABLEHLOAGGRESSIVEFOLDERPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass(StablehloAggressiveFolderPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloAggressiveFolderPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloAggressiveFolderPassBase;

  StablehloAggressiveFolderPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloAggressiveFolderPassBase(const StablehloAggressiveFolderPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloAggressiveFolderPassBase& operator=(const StablehloAggressiveFolderPassBase &) = delete;
  StablehloAggressiveFolderPassBase(StablehloAggressiveFolderPassBase &&) = delete;
  StablehloAggressiveFolderPassBase& operator=(StablehloAggressiveFolderPassBase &&) = delete;
  ~StablehloAggressiveFolderPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-aggressive-folder");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-aggressive-folder"; }

  ::llvm::StringRef getDescription() const override { return "Folds StableHLO operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloAggressiveFolderPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloAggressiveFolderPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloAggressiveFolderPassBase<DerivedT>)

  StablehloAggressiveFolderPassBase(StablehloAggressiveFolderPassOptions options) : StablehloAggressiveFolderPassBase() {
    assumeNoUndeclaredSideEffects = std::move(options.assumeNoUndeclaredSideEffects);
    foldOpElementLimit = std::move(options.foldOpElementLimit);
    optimizeFloat = std::move(options.optimizeFloat);
  }
protected:
  ::mlir::Pass::Option<bool> assumeNoUndeclaredSideEffects{*this, "assume-no-undeclared-side-effects", ::llvm::cl::desc("Allow dead code to be eliminated in some situations (e.g. dead while loops) under the assumption that ops are pure unless declared with explicit MLIR `MemoryEffects`. Notably, this means `func.call` ops will be assumed pure."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<int64_t> foldOpElementLimit{*this, "fold-op-element-limit", ::llvm::cl::desc("Upper limit on how many elements may be folded by an op folder. This limit doesn't apply in certain special cases such as addition with 0, multiplication by 1, and some splat operations."), ::llvm::cl::init(65536)};
  ::mlir::Pass::Option<bool> optimizeFloat{*this, "optimize-float", ::llvm::cl::desc("Allow float optimizations that, though mathematically equivalent, may result in slightly different quantization of floating-point values (e.g. `log(sqrt(x))` -> `0.5 * log(x)`). Float optimizations that can't affect numerical results are always enabled."), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass(StablehloAggressiveFolderPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass() {
  return impl::createStablehloAggressiveFolderPass();
}

std::unique_ptr<::mlir::Pass> createStablehloAggressiveFolderPass(StablehloAggressiveFolderPassOptions options) {
  return impl::createStablehloAggressiveFolderPass(std::move(options));
}
#undef GEN_PASS_DEF_STABLEHLOAGGRESSIVEFOLDERPASS
#endif // GEN_PASS_DEF_STABLEHLOAGGRESSIVEFOLDERPASS

//===----------------------------------------------------------------------===//
// StablehloAggressiveSimplificationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
struct StablehloAggressiveSimplificationPassOptions {
  int64_t foldOpElementLimit = 65536;
};
std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass();
std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass(StablehloAggressiveSimplificationPassOptions options);
#undef GEN_PASS_DECL_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
#endif // GEN_PASS_DECL_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
#ifdef GEN_PASS_DEF_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass(StablehloAggressiveSimplificationPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloAggressiveSimplificationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloAggressiveSimplificationPassBase;

  StablehloAggressiveSimplificationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloAggressiveSimplificationPassBase(const StablehloAggressiveSimplificationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloAggressiveSimplificationPassBase& operator=(const StablehloAggressiveSimplificationPassBase &) = delete;
  StablehloAggressiveSimplificationPassBase(StablehloAggressiveSimplificationPassBase &&) = delete;
  StablehloAggressiveSimplificationPassBase& operator=(StablehloAggressiveSimplificationPassBase &&) = delete;
  ~StablehloAggressiveSimplificationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-aggressive-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-aggressive-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalizes StableHLO operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloAggressiveSimplificationPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloAggressiveSimplificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloAggressiveSimplificationPassBase<DerivedT>)

  StablehloAggressiveSimplificationPassBase(StablehloAggressiveSimplificationPassOptions options) : StablehloAggressiveSimplificationPassBase() {
    foldOpElementLimit = std::move(options.foldOpElementLimit);
  }
protected:
  ::mlir::Pass::Option<int64_t> foldOpElementLimit{*this, "fold-op-element-limit", ::llvm::cl::desc("Upper limit on how many elements may be folded by an op folder. This limit doesn't apply in certain special cases such as addition with 0, multiplication by 1, and some splat operations."), ::llvm::cl::init(65536)};
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass(StablehloAggressiveSimplificationPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass() {
  return impl::createStablehloAggressiveSimplificationPass();
}

std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass(StablehloAggressiveSimplificationPassOptions options) {
  return impl::createStablehloAggressiveSimplificationPass(std::move(options));
}
#undef GEN_PASS_DEF_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS
#endif // GEN_PASS_DEF_STABLEHLOAGGRESSIVESIMPLIFICATIONPASS

//===----------------------------------------------------------------------===//
// StablehloTargetIndependentOptimizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOTARGETINDEPENDENTOPTIMIZATIONPASS
struct StablehloTargetIndependentOptimizationPassOptions {
  bool assumeNoUndeclaredSideEffects = false;
  int64_t foldOpElementLimit = 65536;
  bool optimizeFloat = true;
};
std::unique_ptr<::mlir::Pass> createStablehloTargetIndependentOptimizationPass();
std::unique_ptr<::mlir::Pass> createStablehloTargetIndependentOptimizationPass(StablehloTargetIndependentOptimizationPassOptions options);
#undef GEN_PASS_DECL_STABLEHLOTARGETINDEPENDENTOPTIMIZATIONPASS
#endif // GEN_PASS_DECL_STABLEHLOTARGETINDEPENDENTOPTIMIZATIONPASS
#ifdef GEN_PASS_DEF_STABLEHLOTARGETINDEPENDENTOPTIMIZATIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloTargetIndependentOptimizationPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloTargetIndependentOptimizationPass(StablehloTargetIndependentOptimizationPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloTargetIndependentOptimizationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloTargetIndependentOptimizationPassBase;

  StablehloTargetIndependentOptimizationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloTargetIndependentOptimizationPassBase(const StablehloTargetIndependentOptimizationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloTargetIndependentOptimizationPassBase& operator=(const StablehloTargetIndependentOptimizationPassBase &) = delete;
  StablehloTargetIndependentOptimizationPassBase(StablehloTargetIndependentOptimizationPassBase &&) = delete;
  StablehloTargetIndependentOptimizationPassBase& operator=(StablehloTargetIndependentOptimizationPassBase &&) = delete;
  ~StablehloTargetIndependentOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-target-independent-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-target-independent-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Runs canonicalizers, folders, and other target-independent optimizations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloTargetIndependentOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloTargetIndependentOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloTargetIndependentOptimizationPassBase<DerivedT>)

  StablehloTargetIndependentOptimizationPassBase(StablehloTargetIndependentOptimizationPassOptions options) : StablehloTargetIndependentOptimizationPassBase() {
    assumeNoUndeclaredSideEffects = std::move(options.assumeNoUndeclaredSideEffects);
    foldOpElementLimit = std::move(options.foldOpElementLimit);
    optimizeFloat = std::move(options.optimizeFloat);
  }
protected:
  ::mlir::Pass::Option<bool> assumeNoUndeclaredSideEffects{*this, "assume-no-undeclared-side-effects", ::llvm::cl::desc("Allow dead code to be eliminated in some situations (e.g. dead while loops) under the assumption that ops are pure unless declared with explicit MLIR `MemoryEffects`. Notably, this means `func.call` ops will be assumed pure."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<int64_t> foldOpElementLimit{*this, "fold-op-element-limit", ::llvm::cl::desc("Upper limit on how many elements may be folded by an op folder. This limit doesn't apply in certain special cases such as addition with 0, multiplication by 1, and some splat operations."), ::llvm::cl::init(65536)};
  ::mlir::Pass::Option<bool> optimizeFloat{*this, "optimize-float", ::llvm::cl::desc("Allow float optimizations that, though mathematically equivalent, may result in slightly different quantization of floating-point values (e.g. `log(sqrt(x))` -> `0.5 * log(x)`). Float optimizations that can't affect numerical results are always enabled."), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloTargetIndependentOptimizationPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createStablehloTargetIndependentOptimizationPass(StablehloTargetIndependentOptimizationPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloTargetIndependentOptimizationPass() {
  return impl::createStablehloTargetIndependentOptimizationPass();
}

std::unique_ptr<::mlir::Pass> createStablehloTargetIndependentOptimizationPass(StablehloTargetIndependentOptimizationPassOptions options) {
  return impl::createStablehloTargetIndependentOptimizationPass(std::move(options));
}
#undef GEN_PASS_DEF_STABLEHLOTARGETINDEPENDENTOPTIMIZATIONPASS
#endif // GEN_PASS_DEF_STABLEHLOTARGETINDEPENDENTOPTIMIZATIONPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// StablehloAggressiveFolderPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloAggressiveFolderPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloAggressiveFolderPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloAggressiveFolderPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloAggressiveFolderPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloAggressiveSimplificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloAggressiveSimplificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloAggressiveSimplificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloAggressiveSimplificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloAggressiveSimplificationPass();
  });
}

//===----------------------------------------------------------------------===//
// StablehloTargetIndependentOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerStablehloTargetIndependentOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloTargetIndependentOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloTargetIndependentOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloTargetIndependentOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// Optimization Registration
//===----------------------------------------------------------------------===//

inline void registerOptimizationPasses() {
  registerStablehloAggressiveFolderPass();
  registerStablehloAggressiveSimplificationPass();
  registerStablehloTargetIndependentOptimizationPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class StablehloAggressiveFolderPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloAggressiveFolderPassBase;

  StablehloAggressiveFolderPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloAggressiveFolderPassBase(const StablehloAggressiveFolderPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloAggressiveFolderPassBase& operator=(const StablehloAggressiveFolderPassBase &) = delete;
  StablehloAggressiveFolderPassBase(StablehloAggressiveFolderPassBase &&) = delete;
  StablehloAggressiveFolderPassBase& operator=(StablehloAggressiveFolderPassBase &&) = delete;
  ~StablehloAggressiveFolderPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-aggressive-folder");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-aggressive-folder"; }

  ::llvm::StringRef getDescription() const override { return "Folds StableHLO operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloAggressiveFolderPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloAggressiveFolderPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloAggressiveFolderPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> assumeNoUndeclaredSideEffects{*this, "assume-no-undeclared-side-effects", ::llvm::cl::desc("Allow dead code to be eliminated in some situations (e.g. dead while loops) under the assumption that ops are pure unless declared with explicit MLIR `MemoryEffects`. Notably, this means `func.call` ops will be assumed pure."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<int64_t> foldOpElementLimit{*this, "fold-op-element-limit", ::llvm::cl::desc("Upper limit on how many elements may be folded by an op folder. This limit doesn't apply in certain special cases such as addition with 0, multiplication by 1, and some splat operations."), ::llvm::cl::init(65536)};
  ::mlir::Pass::Option<bool> optimizeFloat{*this, "optimize-float", ::llvm::cl::desc("Allow float optimizations that, though mathematically equivalent, may result in slightly different quantization of floating-point values (e.g. `log(sqrt(x))` -> `0.5 * log(x)`). Float optimizations that can't affect numerical results are always enabled."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class StablehloAggressiveSimplificationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloAggressiveSimplificationPassBase;

  StablehloAggressiveSimplificationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloAggressiveSimplificationPassBase(const StablehloAggressiveSimplificationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloAggressiveSimplificationPassBase& operator=(const StablehloAggressiveSimplificationPassBase &) = delete;
  StablehloAggressiveSimplificationPassBase(StablehloAggressiveSimplificationPassBase &&) = delete;
  StablehloAggressiveSimplificationPassBase& operator=(StablehloAggressiveSimplificationPassBase &&) = delete;
  ~StablehloAggressiveSimplificationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-aggressive-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-aggressive-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalizes StableHLO operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloAggressiveSimplificationPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloAggressiveSimplificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloAggressiveSimplificationPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> foldOpElementLimit{*this, "fold-op-element-limit", ::llvm::cl::desc("Upper limit on how many elements may be folded by an op folder. This limit doesn't apply in certain special cases such as addition with 0, multiplication by 1, and some splat operations."), ::llvm::cl::init(65536)};
};

template <typename DerivedT>
class StablehloTargetIndependentOptimizationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StablehloTargetIndependentOptimizationPassBase;

  StablehloTargetIndependentOptimizationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloTargetIndependentOptimizationPassBase(const StablehloTargetIndependentOptimizationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  StablehloTargetIndependentOptimizationPassBase& operator=(const StablehloTargetIndependentOptimizationPassBase &) = delete;
  StablehloTargetIndependentOptimizationPassBase(StablehloTargetIndependentOptimizationPassBase &&) = delete;
  StablehloTargetIndependentOptimizationPassBase& operator=(StablehloTargetIndependentOptimizationPassBase &&) = delete;
  ~StablehloTargetIndependentOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-target-independent-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-target-independent-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Runs canonicalizers, folders, and other target-independent optimizations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloTargetIndependentOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloTargetIndependentOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloTargetIndependentOptimizationPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> assumeNoUndeclaredSideEffects{*this, "assume-no-undeclared-side-effects", ::llvm::cl::desc("Allow dead code to be eliminated in some situations (e.g. dead while loops) under the assumption that ops are pure unless declared with explicit MLIR `MemoryEffects`. Notably, this means `func.call` ops will be assumed pure."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<int64_t> foldOpElementLimit{*this, "fold-op-element-limit", ::llvm::cl::desc("Upper limit on how many elements may be folded by an op folder. This limit doesn't apply in certain special cases such as addition with 0, multiplication by 1, and some splat operations."), ::llvm::cl::init(65536)};
  ::mlir::Pass::Option<bool> optimizeFloat{*this, "optimize-float", ::llvm::cl::desc("Allow float optimizations that, though mathematically equivalent, may result in slightly different quantization of floating-point values (e.g. `log(sqrt(x))` -> `0.5 * log(x)`). Float optimizations that can't affect numerical results are always enabled."), ::llvm::cl::init(true)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
