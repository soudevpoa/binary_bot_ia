// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: xla/backends/cpu/runtime/thunk.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "xla/backends/cpu/xnnpack_config.pb.h"
#include "xla/service/buffer_assignment.pb.h"
#include "xla/service/hlo.pb.h"
#include "xla/xla_data.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
namespace xla {
namespace cpu {
class AllGatherThunkProto;
struct AllGatherThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern AllGatherThunkProtoDefaultTypeInternal _AllGatherThunkProto_default_instance_;
class AllReduceThunkProto;
struct AllReduceThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern AllReduceThunkProtoDefaultTypeInternal _AllReduceThunkProto_default_instance_;
class AllToAllThunkProto;
struct AllToAllThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern AllToAllThunkProtoDefaultTypeInternal _AllToAllThunkProto_default_instance_;
class BoolOptional;
struct BoolOptionalDefaultTypeInternal;
PROTOBUF_EXPORT extern BoolOptionalDefaultTypeInternal _BoolOptional_default_instance_;
class CallThunkProto;
struct CallThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern CallThunkProtoDefaultTypeInternal _CallThunkProto_default_instance_;
class CollectivePermuteThunkProto;
struct CollectivePermuteThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectivePermuteThunkProtoDefaultTypeInternal _CollectivePermuteThunkProto_default_instance_;
class CollectivePermuteThunkProto_SourceTargetPairProto;
struct CollectivePermuteThunkProto_SourceTargetPairProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectivePermuteThunkProto_SourceTargetPairProtoDefaultTypeInternal _CollectivePermuteThunkProto_SourceTargetPairProto_default_instance_;
class CollectiveThunkProto;
struct CollectiveThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectiveThunkProtoDefaultTypeInternal _CollectiveThunkProto_default_instance_;
class ConditionalThunkProto;
struct ConditionalThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ConditionalThunkProtoDefaultTypeInternal _ConditionalThunkProto_default_instance_;
class ConvolutionThunkProto;
struct ConvolutionThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ConvolutionThunkProtoDefaultTypeInternal _ConvolutionThunkProto_default_instance_;
class ConvolutionThunkProto_Options;
struct ConvolutionThunkProto_OptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern ConvolutionThunkProto_OptionsDefaultTypeInternal _ConvolutionThunkProto_Options_default_instance_;
class CopyThunkProto;
struct CopyThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern CopyThunkProtoDefaultTypeInternal _CopyThunkProto_default_instance_;
class CustomCallThunkProto;
struct CustomCallThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern CustomCallThunkProtoDefaultTypeInternal _CustomCallThunkProto_default_instance_;
class CustomCallThunkProto_OpBuffers;
struct CustomCallThunkProto_OpBuffersDefaultTypeInternal;
PROTOBUF_EXPORT extern CustomCallThunkProto_OpBuffersDefaultTypeInternal _CustomCallThunkProto_OpBuffers_default_instance_;
class DotThunkProto;
struct DotThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern DotThunkProtoDefaultTypeInternal _DotThunkProto_default_instance_;
class FftThunkProto;
struct FftThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern FftThunkProtoDefaultTypeInternal _FftThunkProto_default_instance_;
class InfeedThunkProto;
struct InfeedThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern InfeedThunkProtoDefaultTypeInternal _InfeedThunkProto_default_instance_;
class InfeedThunkProto_InfeedResource;
struct InfeedThunkProto_InfeedResourceDefaultTypeInternal;
PROTOBUF_EXPORT extern InfeedThunkProto_InfeedResourceDefaultTypeInternal _InfeedThunkProto_InfeedResource_default_instance_;
class InfoProto;
struct InfoProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern InfoProtoDefaultTypeInternal _InfoProto_default_instance_;
class Int64Optional;
struct Int64OptionalDefaultTypeInternal;
PROTOBUF_EXPORT extern Int64OptionalDefaultTypeInternal _Int64Optional_default_instance_;
class KernelThunkProto;
struct KernelThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern KernelThunkProtoDefaultTypeInternal _KernelThunkProto_default_instance_;
class KernelThunkProto_NumWorkGroups;
struct KernelThunkProto_NumWorkGroupsDefaultTypeInternal;
PROTOBUF_EXPORT extern KernelThunkProto_NumWorkGroupsDefaultTypeInternal _KernelThunkProto_NumWorkGroups_default_instance_;
class OpBuffersProto;
struct OpBuffersProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OpBuffersProtoDefaultTypeInternal _OpBuffersProto_default_instance_;
class OpParamsProto;
struct OpParamsProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OpParamsProtoDefaultTypeInternal _OpParamsProto_default_instance_;
class OpResourcesProto;
struct OpResourcesProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OpResourcesProtoDefaultTypeInternal _OpResourcesProto_default_instance_;
class OutfeedThunkProto;
struct OutfeedThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OutfeedThunkProtoDefaultTypeInternal _OutfeedThunkProto_default_instance_;
class OutfeedThunkProto_OutfeedResource;
struct OutfeedThunkProto_OutfeedResourceDefaultTypeInternal;
PROTOBUF_EXPORT extern OutfeedThunkProto_OutfeedResourceDefaultTypeInternal _OutfeedThunkProto_OutfeedResource_default_instance_;
class PartitionIdThunkProto;
struct PartitionIdThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern PartitionIdThunkProtoDefaultTypeInternal _PartitionIdThunkProto_default_instance_;
class ReduceScatterThunkProto;
struct ReduceScatterThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ReduceScatterThunkProtoDefaultTypeInternal _ReduceScatterThunkProto_default_instance_;
class ReplicaIdThunkProto;
struct ReplicaIdThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ReplicaIdThunkProtoDefaultTypeInternal _ReplicaIdThunkProto_default_instance_;
class ResourceOptional;
struct ResourceOptionalDefaultTypeInternal;
PROTOBUF_EXPORT extern ResourceOptionalDefaultTypeInternal _ResourceOptional_default_instance_;
class ResourceProto;
struct ResourceProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ResourceProtoDefaultTypeInternal _ResourceProto_default_instance_;
class RngGetAndUpdateStateThunkProto;
struct RngGetAndUpdateStateThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern RngGetAndUpdateStateThunkProtoDefaultTypeInternal _RngGetAndUpdateStateThunkProto_default_instance_;
class ShapeBufferAllocationSliceProto;
struct ShapeBufferAllocationSliceProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ShapeBufferAllocationSliceProtoDefaultTypeInternal _ShapeBufferAllocationSliceProto_default_instance_;
class SortDirectionOptional;
struct SortDirectionOptionalDefaultTypeInternal;
PROTOBUF_EXPORT extern SortDirectionOptionalDefaultTypeInternal _SortDirectionOptional_default_instance_;
class SortThunkProto;
struct SortThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern SortThunkProtoDefaultTypeInternal _SortThunkProto_default_instance_;
class ThunkProto;
struct ThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ThunkProtoDefaultTypeInternal _ThunkProto_default_instance_;
class ThunkSequenceProto;
struct ThunkSequenceProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ThunkSequenceProtoDefaultTypeInternal _ThunkSequenceProto_default_instance_;
class ThunkSequenceProto_ResourceUsersProto;
struct ThunkSequenceProto_ResourceUsersProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern ThunkSequenceProto_ResourceUsersProtoDefaultTypeInternal _ThunkSequenceProto_ResourceUsersProto_default_instance_;
class TopKThunkProto;
struct TopKThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern TopKThunkProtoDefaultTypeInternal _TopKThunkProto_default_instance_;
class WhileThunkProto;
struct WhileThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern WhileThunkProtoDefaultTypeInternal _WhileThunkProto_default_instance_;
class XnnConvolutionThunkProto;
struct XnnConvolutionThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern XnnConvolutionThunkProtoDefaultTypeInternal _XnnConvolutionThunkProto_default_instance_;
class XnnDotThunkProto;
struct XnnDotThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern XnnDotThunkProtoDefaultTypeInternal _XnnDotThunkProto_default_instance_;
class XnnFusionThunkProto;
struct XnnFusionThunkProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern XnnFusionThunkProtoDefaultTypeInternal _XnnFusionThunkProto_default_instance_;
class XnnFusionThunkProtoImpl;
struct XnnFusionThunkProtoImplDefaultTypeInternal;
PROTOBUF_EXPORT extern XnnFusionThunkProtoImplDefaultTypeInternal _XnnFusionThunkProtoImpl_default_instance_;
}  // namespace cpu
}  // namespace xla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xla {
namespace cpu {
enum ResourceProto_Kind : int {
  ResourceProto_Kind_UNKNOWN = 0,
  ResourceProto_Kind_TOKEN = 1,
  ResourceProto_Kind_COLLECTIVE_COMMUNICATOR = 2,
  ResourceProto_Kind_ResourceProto_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResourceProto_Kind_ResourceProto_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool ResourceProto_Kind_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t ResourceProto_Kind_internal_data_[];
constexpr ResourceProto_Kind ResourceProto_Kind_Kind_MIN = static_cast<ResourceProto_Kind>(0);
constexpr ResourceProto_Kind ResourceProto_Kind_Kind_MAX = static_cast<ResourceProto_Kind>(2);
constexpr int ResourceProto_Kind_Kind_ARRAYSIZE = 2 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
ResourceProto_Kind_descriptor();
template <typename T>
const std::string& ResourceProto_Kind_Name(T value) {
  static_assert(std::is_same<T, ResourceProto_Kind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Kind_Name().");
  return ResourceProto_Kind_Name(static_cast<ResourceProto_Kind>(value));
}
template <>
inline const std::string& ResourceProto_Kind_Name(ResourceProto_Kind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ResourceProto_Kind_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ResourceProto_Kind_Parse(absl::string_view name, ResourceProto_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResourceProto_Kind>(
      ResourceProto_Kind_descriptor(), name, value);
}
enum SortDirectionProto : int {
  UNKNOWN = 0,
  ASCENDING = 1,
  DESCENDING = 2,
  SortDirectionProto_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SortDirectionProto_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool SortDirectionProto_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t SortDirectionProto_internal_data_[];
constexpr SortDirectionProto SortDirectionProto_MIN = static_cast<SortDirectionProto>(0);
constexpr SortDirectionProto SortDirectionProto_MAX = static_cast<SortDirectionProto>(2);
constexpr int SortDirectionProto_ARRAYSIZE = 2 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
SortDirectionProto_descriptor();
template <typename T>
const std::string& SortDirectionProto_Name(T value) {
  static_assert(std::is_same<T, SortDirectionProto>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SortDirectionProto_Name().");
  return SortDirectionProto_Name(static_cast<SortDirectionProto>(value));
}
template <>
inline const std::string& SortDirectionProto_Name(SortDirectionProto value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SortDirectionProto_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SortDirectionProto_Parse(absl::string_view name, SortDirectionProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SortDirectionProto>(
      SortDirectionProto_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT SortDirectionOptional final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.SortDirectionOptional) */ {
 public:
  inline SortDirectionOptional() : SortDirectionOptional(nullptr) {}
  ~SortDirectionOptional() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SortDirectionOptional(
      ::google::protobuf::internal::ConstantInitialized);

  inline SortDirectionOptional(const SortDirectionOptional& from) : SortDirectionOptional(nullptr, from) {}
  inline SortDirectionOptional(SortDirectionOptional&& from) noexcept
      : SortDirectionOptional(nullptr, std::move(from)) {}
  inline SortDirectionOptional& operator=(const SortDirectionOptional& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortDirectionOptional& operator=(SortDirectionOptional&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortDirectionOptional& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortDirectionOptional* internal_default_instance() {
    return reinterpret_cast<const SortDirectionOptional*>(
        &_SortDirectionOptional_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SortDirectionOptional& a, SortDirectionOptional& b) { a.Swap(&b); }
  inline void Swap(SortDirectionOptional* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortDirectionOptional* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortDirectionOptional* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SortDirectionOptional>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SortDirectionOptional& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SortDirectionOptional& from) { SortDirectionOptional::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SortDirectionOptional* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.SortDirectionOptional"; }

 protected:
  explicit SortDirectionOptional(::google::protobuf::Arena* arena);
  SortDirectionOptional(::google::protobuf::Arena* arena, const SortDirectionOptional& from);
  SortDirectionOptional(::google::protobuf::Arena* arena, SortDirectionOptional&& from) noexcept
      : SortDirectionOptional(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kContainsValueFieldNumber = 2,
  };
  // .xla.cpu.SortDirectionProto value = 1;
  void clear_value() ;
  ::xla::cpu::SortDirectionProto value() const;
  void set_value(::xla::cpu::SortDirectionProto value);

  private:
  ::xla::cpu::SortDirectionProto _internal_value() const;
  void _internal_set_value(::xla::cpu::SortDirectionProto value);

  public:
  // bool contains_value = 2;
  void clear_contains_value() ;
  bool contains_value() const;
  void set_contains_value(bool value);

  private:
  bool _internal_contains_value() const;
  void _internal_set_contains_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.SortDirectionOptional)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SortDirectionOptional& from_msg);
    int value_;
    bool contains_value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ResourceProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ResourceProto) */ {
 public:
  inline ResourceProto() : ResourceProto(nullptr) {}
  ~ResourceProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResourceProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResourceProto(const ResourceProto& from) : ResourceProto(nullptr, from) {}
  inline ResourceProto(ResourceProto&& from) noexcept
      : ResourceProto(nullptr, std::move(from)) {}
  inline ResourceProto& operator=(const ResourceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceProto& operator=(ResourceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceProto* internal_default_instance() {
    return reinterpret_cast<const ResourceProto*>(
        &_ResourceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ResourceProto& a, ResourceProto& b) { a.Swap(&b); }
  inline void Swap(ResourceProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ResourceProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResourceProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResourceProto& from) { ResourceProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResourceProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ResourceProto"; }

 protected:
  explicit ResourceProto(::google::protobuf::Arena* arena);
  ResourceProto(::google::protobuf::Arena* arena, const ResourceProto& from);
  ResourceProto(::google::protobuf::Arena* arena, ResourceProto&& from) noexcept
      : ResourceProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Kind = ResourceProto_Kind;
  static constexpr Kind UNKNOWN = ResourceProto_Kind_UNKNOWN;
  static constexpr Kind TOKEN = ResourceProto_Kind_TOKEN;
  static constexpr Kind COLLECTIVE_COMMUNICATOR = ResourceProto_Kind_COLLECTIVE_COMMUNICATOR;
  static inline bool Kind_IsValid(int value) {
    return ResourceProto_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN = ResourceProto_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX = ResourceProto_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE = ResourceProto_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Kind_descriptor() {
    return ResourceProto_Kind_descriptor();
  }
  template <typename T>
  static inline const std::string& Kind_Name(T value) {
    return ResourceProto_Kind_Name(value);
  }
  static inline bool Kind_Parse(absl::string_view name, Kind* value) {
    return ResourceProto_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kKindFieldNumber = 1,
  };
  // .xla.cpu.ResourceProto.Kind kind = 1;
  void clear_kind() ;
  ::xla::cpu::ResourceProto_Kind kind() const;
  void set_kind(::xla::cpu::ResourceProto_Kind value);

  private:
  ::xla::cpu::ResourceProto_Kind _internal_kind() const;
  void _internal_set_kind(::xla::cpu::ResourceProto_Kind value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ResourceProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResourceProto& from_msg);
    int kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ReduceScatterThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ReduceScatterThunkProto) */ {
 public:
  inline ReduceScatterThunkProto() : ReduceScatterThunkProto(nullptr) {}
  ~ReduceScatterThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReduceScatterThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReduceScatterThunkProto(const ReduceScatterThunkProto& from) : ReduceScatterThunkProto(nullptr, from) {}
  inline ReduceScatterThunkProto(ReduceScatterThunkProto&& from) noexcept
      : ReduceScatterThunkProto(nullptr, std::move(from)) {}
  inline ReduceScatterThunkProto& operator=(const ReduceScatterThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReduceScatterThunkProto& operator=(ReduceScatterThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReduceScatterThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReduceScatterThunkProto* internal_default_instance() {
    return reinterpret_cast<const ReduceScatterThunkProto*>(
        &_ReduceScatterThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ReduceScatterThunkProto& a, ReduceScatterThunkProto& b) { a.Swap(&b); }
  inline void Swap(ReduceScatterThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReduceScatterThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReduceScatterThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ReduceScatterThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReduceScatterThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReduceScatterThunkProto& from) { ReduceScatterThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReduceScatterThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ReduceScatterThunkProto"; }

 protected:
  explicit ReduceScatterThunkProto(::google::protobuf::Arena* arena);
  ReduceScatterThunkProto(::google::protobuf::Arena* arena, const ReduceScatterThunkProto& from);
  ReduceScatterThunkProto(::google::protobuf::Arena* arena, ReduceScatterThunkProto&& from) noexcept
      : ReduceScatterThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReductionKindFieldNumber = 1,
  };
  // string reduction_kind = 1;
  void clear_reduction_kind() ;
  const std::string& reduction_kind() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reduction_kind(Arg_&& arg, Args_... args);
  std::string* mutable_reduction_kind();
  PROTOBUF_NODISCARD std::string* release_reduction_kind();
  void set_allocated_reduction_kind(std::string* value);

  private:
  const std::string& _internal_reduction_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reduction_kind(
      const std::string& value);
  std::string* _internal_mutable_reduction_kind();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ReduceScatterThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      54, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReduceScatterThunkProto& from_msg);
    ::google::protobuf::internal::ArenaStringPtr reduction_kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT KernelThunkProto_NumWorkGroups final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.KernelThunkProto.NumWorkGroups) */ {
 public:
  inline KernelThunkProto_NumWorkGroups() : KernelThunkProto_NumWorkGroups(nullptr) {}
  ~KernelThunkProto_NumWorkGroups() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KernelThunkProto_NumWorkGroups(
      ::google::protobuf::internal::ConstantInitialized);

  inline KernelThunkProto_NumWorkGroups(const KernelThunkProto_NumWorkGroups& from) : KernelThunkProto_NumWorkGroups(nullptr, from) {}
  inline KernelThunkProto_NumWorkGroups(KernelThunkProto_NumWorkGroups&& from) noexcept
      : KernelThunkProto_NumWorkGroups(nullptr, std::move(from)) {}
  inline KernelThunkProto_NumWorkGroups& operator=(const KernelThunkProto_NumWorkGroups& from) {
    CopyFrom(from);
    return *this;
  }
  inline KernelThunkProto_NumWorkGroups& operator=(KernelThunkProto_NumWorkGroups&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KernelThunkProto_NumWorkGroups& default_instance() {
    return *internal_default_instance();
  }
  static inline const KernelThunkProto_NumWorkGroups* internal_default_instance() {
    return reinterpret_cast<const KernelThunkProto_NumWorkGroups*>(
        &_KernelThunkProto_NumWorkGroups_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(KernelThunkProto_NumWorkGroups& a, KernelThunkProto_NumWorkGroups& b) { a.Swap(&b); }
  inline void Swap(KernelThunkProto_NumWorkGroups* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KernelThunkProto_NumWorkGroups* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KernelThunkProto_NumWorkGroups* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KernelThunkProto_NumWorkGroups>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KernelThunkProto_NumWorkGroups& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KernelThunkProto_NumWorkGroups& from) { KernelThunkProto_NumWorkGroups::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KernelThunkProto_NumWorkGroups* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.KernelThunkProto.NumWorkGroups"; }

 protected:
  explicit KernelThunkProto_NumWorkGroups(::google::protobuf::Arena* arena);
  KernelThunkProto_NumWorkGroups(::google::protobuf::Arena* arena, const KernelThunkProto_NumWorkGroups& from);
  KernelThunkProto_NumWorkGroups(::google::protobuf::Arena* arena, KernelThunkProto_NumWorkGroups&& from) noexcept
      : KernelThunkProto_NumWorkGroups(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // int64 x = 1;
  void clear_x() ;
  ::int64_t x() const;
  void set_x(::int64_t value);

  private:
  ::int64_t _internal_x() const;
  void _internal_set_x(::int64_t value);

  public:
  // int64 y = 2;
  void clear_y() ;
  ::int64_t y() const;
  void set_y(::int64_t value);

  private:
  ::int64_t _internal_y() const;
  void _internal_set_y(::int64_t value);

  public:
  // int64 z = 3;
  void clear_z() ;
  ::int64_t z() const;
  void set_z(::int64_t value);

  private:
  ::int64_t _internal_z() const;
  void _internal_set_z(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.KernelThunkProto.NumWorkGroups)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KernelThunkProto_NumWorkGroups& from_msg);
    ::int64_t x_;
    ::int64_t y_;
    ::int64_t z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT Int64Optional final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.Int64Optional) */ {
 public:
  inline Int64Optional() : Int64Optional(nullptr) {}
  ~Int64Optional() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Int64Optional(
      ::google::protobuf::internal::ConstantInitialized);

  inline Int64Optional(const Int64Optional& from) : Int64Optional(nullptr, from) {}
  inline Int64Optional(Int64Optional&& from) noexcept
      : Int64Optional(nullptr, std::move(from)) {}
  inline Int64Optional& operator=(const Int64Optional& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64Optional& operator=(Int64Optional&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64Optional& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int64Optional* internal_default_instance() {
    return reinterpret_cast<const Int64Optional*>(
        &_Int64Optional_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Int64Optional& a, Int64Optional& b) { a.Swap(&b); }
  inline void Swap(Int64Optional* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64Optional* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64Optional* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Int64Optional>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int64Optional& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Int64Optional& from) { Int64Optional::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Int64Optional* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.Int64Optional"; }

 protected:
  explicit Int64Optional(::google::protobuf::Arena* arena);
  Int64Optional(::google::protobuf::Arena* arena, const Int64Optional& from);
  Int64Optional(::google::protobuf::Arena* arena, Int64Optional&& from) noexcept
      : Int64Optional(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kContainsValueFieldNumber = 2,
  };
  // int64 value = 1;
  void clear_value() ;
  ::int64_t value() const;
  void set_value(::int64_t value);

  private:
  ::int64_t _internal_value() const;
  void _internal_set_value(::int64_t value);

  public:
  // bool contains_value = 2;
  void clear_contains_value() ;
  bool contains_value() const;
  void set_contains_value(bool value);

  private:
  bool _internal_contains_value() const;
  void _internal_set_contains_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.Int64Optional)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Int64Optional& from_msg);
    ::int64_t value_;
    bool contains_value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT InfoProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.InfoProto) */ {
 public:
  inline InfoProto() : InfoProto(nullptr) {}
  ~InfoProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InfoProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline InfoProto(const InfoProto& from) : InfoProto(nullptr, from) {}
  inline InfoProto(InfoProto&& from) noexcept
      : InfoProto(nullptr, std::move(from)) {}
  inline InfoProto& operator=(const InfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoProto& operator=(InfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoProto* internal_default_instance() {
    return reinterpret_cast<const InfoProto*>(
        &_InfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(InfoProto& a, InfoProto& b) { a.Swap(&b); }
  inline void Swap(InfoProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InfoProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InfoProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InfoProto& from) { InfoProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InfoProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.InfoProto"; }

 protected:
  explicit InfoProto(::google::protobuf::Arena* arena);
  InfoProto(::google::protobuf::Arena* arena, const InfoProto& from);
  InfoProto(::google::protobuf::Arena* arena, InfoProto&& from) noexcept
      : InfoProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpNameFieldNumber = 1,
    kModuleNameFieldNumber = 2,
    kModuleIdFieldNumber = 3,
  };
  // string op_name = 1;
  void clear_op_name() ;
  const std::string& op_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_op_name(Arg_&& arg, Args_... args);
  std::string* mutable_op_name();
  PROTOBUF_NODISCARD std::string* release_op_name();
  void set_allocated_op_name(std::string* value);

  private:
  const std::string& _internal_op_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_name(
      const std::string& value);
  std::string* _internal_mutable_op_name();

  public:
  // string module_name = 2;
  void clear_module_name() ;
  const std::string& module_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_module_name(Arg_&& arg, Args_... args);
  std::string* mutable_module_name();
  PROTOBUF_NODISCARD std::string* release_module_name();
  void set_allocated_module_name(std::string* value);

  private:
  const std::string& _internal_module_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_name(
      const std::string& value);
  std::string* _internal_mutable_module_name();

  public:
  // int64 module_id = 3;
  void clear_module_id() ;
  ::int64_t module_id() const;
  void set_module_id(::int64_t value);

  private:
  ::int64_t _internal_module_id() const;
  void _internal_set_module_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.InfoProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      44, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InfoProto& from_msg);
    ::google::protobuf::internal::ArenaStringPtr op_name_;
    ::google::protobuf::internal::ArenaStringPtr module_name_;
    ::int64_t module_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ConvolutionThunkProto_Options final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ConvolutionThunkProto.Options) */ {
 public:
  inline ConvolutionThunkProto_Options() : ConvolutionThunkProto_Options(nullptr) {}
  ~ConvolutionThunkProto_Options() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConvolutionThunkProto_Options(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConvolutionThunkProto_Options(const ConvolutionThunkProto_Options& from) : ConvolutionThunkProto_Options(nullptr, from) {}
  inline ConvolutionThunkProto_Options(ConvolutionThunkProto_Options&& from) noexcept
      : ConvolutionThunkProto_Options(nullptr, std::move(from)) {}
  inline ConvolutionThunkProto_Options& operator=(const ConvolutionThunkProto_Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvolutionThunkProto_Options& operator=(ConvolutionThunkProto_Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvolutionThunkProto_Options& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConvolutionThunkProto_Options* internal_default_instance() {
    return reinterpret_cast<const ConvolutionThunkProto_Options*>(
        &_ConvolutionThunkProto_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ConvolutionThunkProto_Options& a, ConvolutionThunkProto_Options& b) { a.Swap(&b); }
  inline void Swap(ConvolutionThunkProto_Options* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvolutionThunkProto_Options* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvolutionThunkProto_Options* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ConvolutionThunkProto_Options>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConvolutionThunkProto_Options& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConvolutionThunkProto_Options& from) { ConvolutionThunkProto_Options::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConvolutionThunkProto_Options* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ConvolutionThunkProto.Options"; }

 protected:
  explicit ConvolutionThunkProto_Options(::google::protobuf::Arena* arena);
  ConvolutionThunkProto_Options(::google::protobuf::Arena* arena, const ConvolutionThunkProto_Options& from);
  ConvolutionThunkProto_Options(::google::protobuf::Arena* arena, ConvolutionThunkProto_Options&& from) noexcept
      : ConvolutionThunkProto_Options(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMultiThreadedFieldNumber = 1,
  };
  // bool multi_threaded = 1;
  void clear_multi_threaded() ;
  bool multi_threaded() const;
  void set_multi_threaded(bool value);

  private:
  bool _internal_multi_threaded() const;
  void _internal_set_multi_threaded(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ConvolutionThunkProto.Options)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConvolutionThunkProto_Options& from_msg);
    bool multi_threaded_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectivePermuteThunkProto_SourceTargetPairProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto) */ {
 public:
  inline CollectivePermuteThunkProto_SourceTargetPairProto() : CollectivePermuteThunkProto_SourceTargetPairProto(nullptr) {}
  ~CollectivePermuteThunkProto_SourceTargetPairProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectivePermuteThunkProto_SourceTargetPairProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectivePermuteThunkProto_SourceTargetPairProto(const CollectivePermuteThunkProto_SourceTargetPairProto& from) : CollectivePermuteThunkProto_SourceTargetPairProto(nullptr, from) {}
  inline CollectivePermuteThunkProto_SourceTargetPairProto(CollectivePermuteThunkProto_SourceTargetPairProto&& from) noexcept
      : CollectivePermuteThunkProto_SourceTargetPairProto(nullptr, std::move(from)) {}
  inline CollectivePermuteThunkProto_SourceTargetPairProto& operator=(const CollectivePermuteThunkProto_SourceTargetPairProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectivePermuteThunkProto_SourceTargetPairProto& operator=(CollectivePermuteThunkProto_SourceTargetPairProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectivePermuteThunkProto_SourceTargetPairProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectivePermuteThunkProto_SourceTargetPairProto* internal_default_instance() {
    return reinterpret_cast<const CollectivePermuteThunkProto_SourceTargetPairProto*>(
        &_CollectivePermuteThunkProto_SourceTargetPairProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(CollectivePermuteThunkProto_SourceTargetPairProto& a, CollectivePermuteThunkProto_SourceTargetPairProto& b) { a.Swap(&b); }
  inline void Swap(CollectivePermuteThunkProto_SourceTargetPairProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectivePermuteThunkProto_SourceTargetPairProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectivePermuteThunkProto_SourceTargetPairProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectivePermuteThunkProto_SourceTargetPairProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectivePermuteThunkProto_SourceTargetPairProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectivePermuteThunkProto_SourceTargetPairProto& from) { CollectivePermuteThunkProto_SourceTargetPairProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectivePermuteThunkProto_SourceTargetPairProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto"; }

 protected:
  explicit CollectivePermuteThunkProto_SourceTargetPairProto(::google::protobuf::Arena* arena);
  CollectivePermuteThunkProto_SourceTargetPairProto(::google::protobuf::Arena* arena, const CollectivePermuteThunkProto_SourceTargetPairProto& from);
  CollectivePermuteThunkProto_SourceTargetPairProto(::google::protobuf::Arena* arena, CollectivePermuteThunkProto_SourceTargetPairProto&& from) noexcept
      : CollectivePermuteThunkProto_SourceTargetPairProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // int64 source = 1;
  void clear_source() ;
  ::int64_t source() const;
  void set_source(::int64_t value);

  private:
  ::int64_t _internal_source() const;
  void _internal_set_source(::int64_t value);

  public:
  // int64 target = 2;
  void clear_target() ;
  ::int64_t target() const;
  void set_target(::int64_t value);

  private:
  ::int64_t _internal_target() const;
  void _internal_set_target(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectivePermuteThunkProto_SourceTargetPairProto& from_msg);
    ::int64_t source_;
    ::int64_t target_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BoolOptional final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.BoolOptional) */ {
 public:
  inline BoolOptional() : BoolOptional(nullptr) {}
  ~BoolOptional() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BoolOptional(
      ::google::protobuf::internal::ConstantInitialized);

  inline BoolOptional(const BoolOptional& from) : BoolOptional(nullptr, from) {}
  inline BoolOptional(BoolOptional&& from) noexcept
      : BoolOptional(nullptr, std::move(from)) {}
  inline BoolOptional& operator=(const BoolOptional& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolOptional& operator=(BoolOptional&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolOptional& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolOptional* internal_default_instance() {
    return reinterpret_cast<const BoolOptional*>(
        &_BoolOptional_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(BoolOptional& a, BoolOptional& b) { a.Swap(&b); }
  inline void Swap(BoolOptional* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolOptional* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolOptional* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BoolOptional>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolOptional& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BoolOptional& from) { BoolOptional::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoolOptional* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.BoolOptional"; }

 protected:
  explicit BoolOptional(::google::protobuf::Arena* arena);
  BoolOptional(::google::protobuf::Arena* arena, const BoolOptional& from);
  BoolOptional(::google::protobuf::Arena* arena, BoolOptional&& from) noexcept
      : BoolOptional(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kContainsValueFieldNumber = 2,
  };
  // bool value = 1;
  void clear_value() ;
  bool value() const;
  void set_value(bool value);

  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);

  public:
  // bool contains_value = 2;
  void clear_contains_value() ;
  bool contains_value() const;
  void set_contains_value(bool value);

  private:
  bool _internal_contains_value() const;
  void _internal_set_contains_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.BoolOptional)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BoolOptional& from_msg);
    bool value_;
    bool contains_value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT AllToAllThunkProto final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:xla.cpu.AllToAllThunkProto) */ {
 public:
  inline AllToAllThunkProto() : AllToAllThunkProto(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AllToAllThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline AllToAllThunkProto(const AllToAllThunkProto& from) : AllToAllThunkProto(nullptr, from) {}
  inline AllToAllThunkProto(AllToAllThunkProto&& from) noexcept
      : AllToAllThunkProto(nullptr, std::move(from)) {}
  inline AllToAllThunkProto& operator=(const AllToAllThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllToAllThunkProto& operator=(AllToAllThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllToAllThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllToAllThunkProto* internal_default_instance() {
    return reinterpret_cast<const AllToAllThunkProto*>(
        &_AllToAllThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(AllToAllThunkProto& a, AllToAllThunkProto& b) { a.Swap(&b); }
  inline void Swap(AllToAllThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllToAllThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllToAllThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<AllToAllThunkProto>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AllToAllThunkProto& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AllToAllThunkProto& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.AllToAllThunkProto"; }

 protected:
  explicit AllToAllThunkProto(::google::protobuf::Arena* arena);
  AllToAllThunkProto(::google::protobuf::Arena* arena, const AllToAllThunkProto& from);
  AllToAllThunkProto(::google::protobuf::Arena* arena, AllToAllThunkProto&& from) noexcept
      : AllToAllThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:xla.cpu.AllToAllThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AllToAllThunkProto& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT AllReduceThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.AllReduceThunkProto) */ {
 public:
  inline AllReduceThunkProto() : AllReduceThunkProto(nullptr) {}
  ~AllReduceThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AllReduceThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline AllReduceThunkProto(const AllReduceThunkProto& from) : AllReduceThunkProto(nullptr, from) {}
  inline AllReduceThunkProto(AllReduceThunkProto&& from) noexcept
      : AllReduceThunkProto(nullptr, std::move(from)) {}
  inline AllReduceThunkProto& operator=(const AllReduceThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllReduceThunkProto& operator=(AllReduceThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllReduceThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllReduceThunkProto* internal_default_instance() {
    return reinterpret_cast<const AllReduceThunkProto*>(
        &_AllReduceThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(AllReduceThunkProto& a, AllReduceThunkProto& b) { a.Swap(&b); }
  inline void Swap(AllReduceThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllReduceThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllReduceThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AllReduceThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllReduceThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AllReduceThunkProto& from) { AllReduceThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AllReduceThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.AllReduceThunkProto"; }

 protected:
  explicit AllReduceThunkProto(::google::protobuf::Arena* arena);
  AllReduceThunkProto(::google::protobuf::Arena* arena, const AllReduceThunkProto& from);
  AllReduceThunkProto(::google::protobuf::Arena* arena, AllReduceThunkProto&& from) noexcept
      : AllReduceThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReductionKindFieldNumber = 1,
    kSingleReplicaFieldNumber = 2,
  };
  // string reduction_kind = 1;
  void clear_reduction_kind() ;
  const std::string& reduction_kind() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reduction_kind(Arg_&& arg, Args_... args);
  std::string* mutable_reduction_kind();
  PROTOBUF_NODISCARD std::string* release_reduction_kind();
  void set_allocated_reduction_kind(std::string* value);

  private:
  const std::string& _internal_reduction_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reduction_kind(
      const std::string& value);
  std::string* _internal_mutable_reduction_kind();

  public:
  // bool single_replica = 2;
  void clear_single_replica() ;
  bool single_replica() const;
  void set_single_replica(bool value);

  private:
  bool _internal_single_replica() const;
  void _internal_set_single_replica(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.AllReduceThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AllReduceThunkProto& from_msg);
    ::google::protobuf::internal::ArenaStringPtr reduction_kind_;
    bool single_replica_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT AllGatherThunkProto final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:xla.cpu.AllGatherThunkProto) */ {
 public:
  inline AllGatherThunkProto() : AllGatherThunkProto(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AllGatherThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline AllGatherThunkProto(const AllGatherThunkProto& from) : AllGatherThunkProto(nullptr, from) {}
  inline AllGatherThunkProto(AllGatherThunkProto&& from) noexcept
      : AllGatherThunkProto(nullptr, std::move(from)) {}
  inline AllGatherThunkProto& operator=(const AllGatherThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllGatherThunkProto& operator=(AllGatherThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllGatherThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllGatherThunkProto* internal_default_instance() {
    return reinterpret_cast<const AllGatherThunkProto*>(
        &_AllGatherThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(AllGatherThunkProto& a, AllGatherThunkProto& b) { a.Swap(&b); }
  inline void Swap(AllGatherThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllGatherThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllGatherThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<AllGatherThunkProto>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AllGatherThunkProto& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AllGatherThunkProto& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.AllGatherThunkProto"; }

 protected:
  explicit AllGatherThunkProto(::google::protobuf::Arena* arena);
  AllGatherThunkProto(::google::protobuf::Arena* arena, const AllGatherThunkProto& from);
  AllGatherThunkProto(::google::protobuf::Arena* arena, AllGatherThunkProto&& from) noexcept
      : AllGatherThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:xla.cpu.AllGatherThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AllGatherThunkProto& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TopKThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.TopKThunkProto) */ {
 public:
  inline TopKThunkProto() : TopKThunkProto(nullptr) {}
  ~TopKThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TopKThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline TopKThunkProto(const TopKThunkProto& from) : TopKThunkProto(nullptr, from) {}
  inline TopKThunkProto(TopKThunkProto&& from) noexcept
      : TopKThunkProto(nullptr, std::move(from)) {}
  inline TopKThunkProto& operator=(const TopKThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopKThunkProto& operator=(TopKThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopKThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopKThunkProto* internal_default_instance() {
    return reinterpret_cast<const TopKThunkProto*>(
        &_TopKThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(TopKThunkProto& a, TopKThunkProto& b) { a.Swap(&b); }
  inline void Swap(TopKThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopKThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopKThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TopKThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopKThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TopKThunkProto& from) { TopKThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopKThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.TopKThunkProto"; }

 protected:
  explicit TopKThunkProto(::google::protobuf::Arena* arena);
  TopKThunkProto(::google::protobuf::Arena* arena, const TopKThunkProto& from);
  TopKThunkProto(::google::protobuf::Arena* arena, TopKThunkProto&& from) noexcept
      : TopKThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesBufferFieldNumber = 4,
    kOutputBufferFieldNumber = 5,
    kIndicesBufferFieldNumber = 6,
    kBatchSizeFieldNumber = 1,
    kInputSizeFieldNumber = 2,
    kKFieldNumber = 3,
  };
  // .xla.buffer_assignment.BufferAllocationSliceProto values_buffer = 4;
  bool has_values_buffer() const;
  void clear_values_buffer() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& values_buffer() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_values_buffer();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_values_buffer();
  void set_allocated_values_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_values_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_values_buffer();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_values_buffer() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_values_buffer();

  public:
  // .xla.buffer_assignment.BufferAllocationSliceProto output_buffer = 5;
  bool has_output_buffer() const;
  void clear_output_buffer() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& output_buffer() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_output_buffer();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_output_buffer();
  void set_allocated_output_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_output_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_output_buffer();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_output_buffer() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_output_buffer();

  public:
  // .xla.buffer_assignment.BufferAllocationSliceProto indices_buffer = 6;
  bool has_indices_buffer() const;
  void clear_indices_buffer() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& indices_buffer() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_indices_buffer();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_indices_buffer();
  void set_allocated_indices_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_indices_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_indices_buffer();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_indices_buffer() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_indices_buffer();

  public:
  // int64 batch_size = 1;
  void clear_batch_size() ;
  ::int64_t batch_size() const;
  void set_batch_size(::int64_t value);

  private:
  ::int64_t _internal_batch_size() const;
  void _internal_set_batch_size(::int64_t value);

  public:
  // int64 input_size = 2;
  void clear_input_size() ;
  ::int64_t input_size() const;
  void set_input_size(::int64_t value);

  private:
  ::int64_t _internal_input_size() const;
  void _internal_set_input_size(::int64_t value);

  public:
  // int64 k = 3;
  void clear_k() ;
  ::int64_t k() const;
  void set_k(::int64_t value);

  private:
  ::int64_t _internal_k() const;
  void _internal_set_k(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.TopKThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TopKThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* values_buffer_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* output_buffer_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* indices_buffer_;
    ::int64_t batch_size_;
    ::int64_t input_size_;
    ::int64_t k_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ThunkSequenceProto_ResourceUsersProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ThunkSequenceProto.ResourceUsersProto) */ {
 public:
  inline ThunkSequenceProto_ResourceUsersProto() : ThunkSequenceProto_ResourceUsersProto(nullptr) {}
  ~ThunkSequenceProto_ResourceUsersProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ThunkSequenceProto_ResourceUsersProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ThunkSequenceProto_ResourceUsersProto(const ThunkSequenceProto_ResourceUsersProto& from) : ThunkSequenceProto_ResourceUsersProto(nullptr, from) {}
  inline ThunkSequenceProto_ResourceUsersProto(ThunkSequenceProto_ResourceUsersProto&& from) noexcept
      : ThunkSequenceProto_ResourceUsersProto(nullptr, std::move(from)) {}
  inline ThunkSequenceProto_ResourceUsersProto& operator=(const ThunkSequenceProto_ResourceUsersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThunkSequenceProto_ResourceUsersProto& operator=(ThunkSequenceProto_ResourceUsersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThunkSequenceProto_ResourceUsersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThunkSequenceProto_ResourceUsersProto* internal_default_instance() {
    return reinterpret_cast<const ThunkSequenceProto_ResourceUsersProto*>(
        &_ThunkSequenceProto_ResourceUsersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(ThunkSequenceProto_ResourceUsersProto& a, ThunkSequenceProto_ResourceUsersProto& b) { a.Swap(&b); }
  inline void Swap(ThunkSequenceProto_ResourceUsersProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThunkSequenceProto_ResourceUsersProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThunkSequenceProto_ResourceUsersProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ThunkSequenceProto_ResourceUsersProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ThunkSequenceProto_ResourceUsersProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ThunkSequenceProto_ResourceUsersProto& from) { ThunkSequenceProto_ResourceUsersProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ThunkSequenceProto_ResourceUsersProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ThunkSequenceProto.ResourceUsersProto"; }

 protected:
  explicit ThunkSequenceProto_ResourceUsersProto(::google::protobuf::Arena* arena);
  ThunkSequenceProto_ResourceUsersProto(::google::protobuf::Arena* arena, const ThunkSequenceProto_ResourceUsersProto& from);
  ThunkSequenceProto_ResourceUsersProto(::google::protobuf::Arena* arena, ThunkSequenceProto_ResourceUsersProto&& from) noexcept
      : ThunkSequenceProto_ResourceUsersProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kThunkIndicesFieldNumber = 1,
    kResourceFieldNumber = 2,
  };
  // repeated int64 thunk_indices = 1;
  int thunk_indices_size() const;
  private:
  int _internal_thunk_indices_size() const;

  public:
  void clear_thunk_indices() ;
  ::int64_t thunk_indices(int index) const;
  void set_thunk_indices(int index, ::int64_t value);
  void add_thunk_indices(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& thunk_indices() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_thunk_indices();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_thunk_indices() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_thunk_indices();

  public:
  // .xla.cpu.ResourceProto resource = 2;
  bool has_resource() const;
  void clear_resource() ;
  const ::xla::cpu::ResourceProto& resource() const;
  PROTOBUF_NODISCARD ::xla::cpu::ResourceProto* release_resource();
  ::xla::cpu::ResourceProto* mutable_resource();
  void set_allocated_resource(::xla::cpu::ResourceProto* value);
  void unsafe_arena_set_allocated_resource(::xla::cpu::ResourceProto* value);
  ::xla::cpu::ResourceProto* unsafe_arena_release_resource();

  private:
  const ::xla::cpu::ResourceProto& _internal_resource() const;
  ::xla::cpu::ResourceProto* _internal_mutable_resource();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ThunkSequenceProto.ResourceUsersProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ThunkSequenceProto_ResourceUsersProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> thunk_indices_;
    mutable ::google::protobuf::internal::CachedSize _thunk_indices_cached_byte_size_;
    ::xla::cpu::ResourceProto* resource_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT RngGetAndUpdateStateThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.RngGetAndUpdateStateThunkProto) */ {
 public:
  inline RngGetAndUpdateStateThunkProto() : RngGetAndUpdateStateThunkProto(nullptr) {}
  ~RngGetAndUpdateStateThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RngGetAndUpdateStateThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline RngGetAndUpdateStateThunkProto(const RngGetAndUpdateStateThunkProto& from) : RngGetAndUpdateStateThunkProto(nullptr, from) {}
  inline RngGetAndUpdateStateThunkProto(RngGetAndUpdateStateThunkProto&& from) noexcept
      : RngGetAndUpdateStateThunkProto(nullptr, std::move(from)) {}
  inline RngGetAndUpdateStateThunkProto& operator=(const RngGetAndUpdateStateThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RngGetAndUpdateStateThunkProto& operator=(RngGetAndUpdateStateThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RngGetAndUpdateStateThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const RngGetAndUpdateStateThunkProto* internal_default_instance() {
    return reinterpret_cast<const RngGetAndUpdateStateThunkProto*>(
        &_RngGetAndUpdateStateThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(RngGetAndUpdateStateThunkProto& a, RngGetAndUpdateStateThunkProto& b) { a.Swap(&b); }
  inline void Swap(RngGetAndUpdateStateThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RngGetAndUpdateStateThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RngGetAndUpdateStateThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RngGetAndUpdateStateThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RngGetAndUpdateStateThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RngGetAndUpdateStateThunkProto& from) { RngGetAndUpdateStateThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RngGetAndUpdateStateThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.RngGetAndUpdateStateThunkProto"; }

 protected:
  explicit RngGetAndUpdateStateThunkProto(::google::protobuf::Arena* arena);
  RngGetAndUpdateStateThunkProto(::google::protobuf::Arena* arena, const RngGetAndUpdateStateThunkProto& from);
  RngGetAndUpdateStateThunkProto(::google::protobuf::Arena* arena, RngGetAndUpdateStateThunkProto&& from) noexcept
      : RngGetAndUpdateStateThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStateBufferFieldNumber = 2,
    kDeltaFieldNumber = 1,
  };
  // .xla.buffer_assignment.BufferAllocationSliceProto state_buffer = 2;
  bool has_state_buffer() const;
  void clear_state_buffer() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& state_buffer() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_state_buffer();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_state_buffer();
  void set_allocated_state_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_state_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_state_buffer();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_state_buffer() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_state_buffer();

  public:
  // int64 delta = 1;
  void clear_delta() ;
  ::int64_t delta() const;
  void set_delta(::int64_t value);

  private:
  ::int64_t _internal_delta() const;
  void _internal_set_delta(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.RngGetAndUpdateStateThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RngGetAndUpdateStateThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* state_buffer_;
    ::int64_t delta_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ResourceOptional final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ResourceOptional) */ {
 public:
  inline ResourceOptional() : ResourceOptional(nullptr) {}
  ~ResourceOptional() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResourceOptional(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResourceOptional(const ResourceOptional& from) : ResourceOptional(nullptr, from) {}
  inline ResourceOptional(ResourceOptional&& from) noexcept
      : ResourceOptional(nullptr, std::move(from)) {}
  inline ResourceOptional& operator=(const ResourceOptional& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceOptional& operator=(ResourceOptional&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceOptional& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceOptional* internal_default_instance() {
    return reinterpret_cast<const ResourceOptional*>(
        &_ResourceOptional_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ResourceOptional& a, ResourceOptional& b) { a.Swap(&b); }
  inline void Swap(ResourceOptional* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceOptional* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceOptional* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ResourceOptional>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResourceOptional& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResourceOptional& from) { ResourceOptional::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResourceOptional* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ResourceOptional"; }

 protected:
  explicit ResourceOptional(::google::protobuf::Arena* arena);
  ResourceOptional(::google::protobuf::Arena* arena, const ResourceOptional& from);
  ResourceOptional(::google::protobuf::Arena* arena, ResourceOptional&& from) noexcept
      : ResourceOptional(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kContainsValueFieldNumber = 2,
  };
  // .xla.cpu.ResourceProto value = 1;
  bool has_value() const;
  void clear_value() ;
  const ::xla::cpu::ResourceProto& value() const;
  PROTOBUF_NODISCARD ::xla::cpu::ResourceProto* release_value();
  ::xla::cpu::ResourceProto* mutable_value();
  void set_allocated_value(::xla::cpu::ResourceProto* value);
  void unsafe_arena_set_allocated_value(::xla::cpu::ResourceProto* value);
  ::xla::cpu::ResourceProto* unsafe_arena_release_value();

  private:
  const ::xla::cpu::ResourceProto& _internal_value() const;
  ::xla::cpu::ResourceProto* _internal_mutable_value();

  public:
  // bool contains_value = 2;
  void clear_contains_value() ;
  bool contains_value() const;
  void set_contains_value(bool value);

  private:
  bool _internal_contains_value() const;
  void _internal_set_contains_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ResourceOptional)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResourceOptional& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::ResourceProto* value_;
    bool contains_value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ReplicaIdThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ReplicaIdThunkProto) */ {
 public:
  inline ReplicaIdThunkProto() : ReplicaIdThunkProto(nullptr) {}
  ~ReplicaIdThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicaIdThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplicaIdThunkProto(const ReplicaIdThunkProto& from) : ReplicaIdThunkProto(nullptr, from) {}
  inline ReplicaIdThunkProto(ReplicaIdThunkProto&& from) noexcept
      : ReplicaIdThunkProto(nullptr, std::move(from)) {}
  inline ReplicaIdThunkProto& operator=(const ReplicaIdThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicaIdThunkProto& operator=(ReplicaIdThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicaIdThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicaIdThunkProto* internal_default_instance() {
    return reinterpret_cast<const ReplicaIdThunkProto*>(
        &_ReplicaIdThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(ReplicaIdThunkProto& a, ReplicaIdThunkProto& b) { a.Swap(&b); }
  inline void Swap(ReplicaIdThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicaIdThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicaIdThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ReplicaIdThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplicaIdThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplicaIdThunkProto& from) { ReplicaIdThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReplicaIdThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ReplicaIdThunkProto"; }

 protected:
  explicit ReplicaIdThunkProto(::google::protobuf::Arena* arena);
  ReplicaIdThunkProto(::google::protobuf::Arena* arena, const ReplicaIdThunkProto& from);
  ReplicaIdThunkProto(::google::protobuf::Arena* arena, ReplicaIdThunkProto&& from) noexcept
      : ReplicaIdThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalIdBufferFieldNumber = 1,
  };
  // .xla.buffer_assignment.BufferAllocationSliceProto logical_id_buffer = 1;
  bool has_logical_id_buffer() const;
  void clear_logical_id_buffer() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& logical_id_buffer() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_logical_id_buffer();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_logical_id_buffer();
  void set_allocated_logical_id_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_logical_id_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_logical_id_buffer();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_logical_id_buffer() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_logical_id_buffer();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ReplicaIdThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplicaIdThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* logical_id_buffer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PartitionIdThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.PartitionIdThunkProto) */ {
 public:
  inline PartitionIdThunkProto() : PartitionIdThunkProto(nullptr) {}
  ~PartitionIdThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PartitionIdThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline PartitionIdThunkProto(const PartitionIdThunkProto& from) : PartitionIdThunkProto(nullptr, from) {}
  inline PartitionIdThunkProto(PartitionIdThunkProto&& from) noexcept
      : PartitionIdThunkProto(nullptr, std::move(from)) {}
  inline PartitionIdThunkProto& operator=(const PartitionIdThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionIdThunkProto& operator=(PartitionIdThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionIdThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionIdThunkProto* internal_default_instance() {
    return reinterpret_cast<const PartitionIdThunkProto*>(
        &_PartitionIdThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(PartitionIdThunkProto& a, PartitionIdThunkProto& b) { a.Swap(&b); }
  inline void Swap(PartitionIdThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionIdThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionIdThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PartitionIdThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PartitionIdThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PartitionIdThunkProto& from) { PartitionIdThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PartitionIdThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.PartitionIdThunkProto"; }

 protected:
  explicit PartitionIdThunkProto(::google::protobuf::Arena* arena);
  PartitionIdThunkProto(::google::protobuf::Arena* arena, const PartitionIdThunkProto& from);
  PartitionIdThunkProto(::google::protobuf::Arena* arena, PartitionIdThunkProto&& from) noexcept
      : PartitionIdThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalIdBufferFieldNumber = 1,
  };
  // .xla.buffer_assignment.BufferAllocationSliceProto logical_id_buffer = 1;
  bool has_logical_id_buffer() const;
  void clear_logical_id_buffer() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& logical_id_buffer() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_logical_id_buffer();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_logical_id_buffer();
  void set_allocated_logical_id_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_logical_id_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_logical_id_buffer();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_logical_id_buffer() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_logical_id_buffer();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.PartitionIdThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PartitionIdThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* logical_id_buffer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OpParamsProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.OpParamsProto) */ {
 public:
  inline OpParamsProto() : OpParamsProto(nullptr) {}
  ~OpParamsProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpParamsProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline OpParamsProto(const OpParamsProto& from) : OpParamsProto(nullptr, from) {}
  inline OpParamsProto(OpParamsProto&& from) noexcept
      : OpParamsProto(nullptr, std::move(from)) {}
  inline OpParamsProto& operator=(const OpParamsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpParamsProto& operator=(OpParamsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpParamsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpParamsProto* internal_default_instance() {
    return reinterpret_cast<const OpParamsProto*>(
        &_OpParamsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(OpParamsProto& a, OpParamsProto& b) { a.Swap(&b); }
  inline void Swap(OpParamsProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpParamsProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpParamsProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<OpParamsProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpParamsProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpParamsProto& from) { OpParamsProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpParamsProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.OpParamsProto"; }

 protected:
  explicit OpParamsProto(::google::protobuf::Arena* arena);
  OpParamsProto(::google::protobuf::Arena* arena, const OpParamsProto& from);
  OpParamsProto(::google::protobuf::Arena* arena, OpParamsProto&& from) noexcept
      : OpParamsProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReplicaGroupFieldNumber = 4,
    kUseGlobalDeviceIdsFieldNumber = 3,
    kOpIdFieldNumber = 1,
    kHasChannelIdFieldNumber = 2,
  };
  // repeated .xla.ReplicaGroup replica_group = 4;
  int replica_group_size() const;
  private:
  int _internal_replica_group_size() const;

  public:
  void clear_replica_group() ;
  ::xla::ReplicaGroup* mutable_replica_group(int index);
  ::google::protobuf::RepeatedPtrField<::xla::ReplicaGroup>* mutable_replica_group();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::ReplicaGroup>& _internal_replica_group() const;
  ::google::protobuf::RepeatedPtrField<::xla::ReplicaGroup>* _internal_mutable_replica_group();
  public:
  const ::xla::ReplicaGroup& replica_group(int index) const;
  ::xla::ReplicaGroup* add_replica_group();
  const ::google::protobuf::RepeatedPtrField<::xla::ReplicaGroup>& replica_group() const;
  // .xla.cpu.BoolOptional use_global_device_ids = 3;
  bool has_use_global_device_ids() const;
  void clear_use_global_device_ids() ;
  const ::xla::cpu::BoolOptional& use_global_device_ids() const;
  PROTOBUF_NODISCARD ::xla::cpu::BoolOptional* release_use_global_device_ids();
  ::xla::cpu::BoolOptional* mutable_use_global_device_ids();
  void set_allocated_use_global_device_ids(::xla::cpu::BoolOptional* value);
  void unsafe_arena_set_allocated_use_global_device_ids(::xla::cpu::BoolOptional* value);
  ::xla::cpu::BoolOptional* unsafe_arena_release_use_global_device_ids();

  private:
  const ::xla::cpu::BoolOptional& _internal_use_global_device_ids() const;
  ::xla::cpu::BoolOptional* _internal_mutable_use_global_device_ids();

  public:
  // int64 op_id = 1;
  void clear_op_id() ;
  ::int64_t op_id() const;
  void set_op_id(::int64_t value);

  private:
  ::int64_t _internal_op_id() const;
  void _internal_set_op_id(::int64_t value);

  public:
  // bool has_channel_id = 2;
  void clear_has_channel_id() ;
  bool has_channel_id() const;
  void set_has_channel_id(bool value);

  private:
  bool _internal_has_channel_id() const;
  void _internal_set_has_channel_id(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.OpParamsProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OpParamsProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xla::ReplicaGroup > replica_group_;
    ::xla::cpu::BoolOptional* use_global_device_ids_;
    ::int64_t op_id_;
    bool has_channel_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT KernelThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.KernelThunkProto) */ {
 public:
  inline KernelThunkProto() : KernelThunkProto(nullptr) {}
  ~KernelThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KernelThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline KernelThunkProto(const KernelThunkProto& from) : KernelThunkProto(nullptr, from) {}
  inline KernelThunkProto(KernelThunkProto&& from) noexcept
      : KernelThunkProto(nullptr, std::move(from)) {}
  inline KernelThunkProto& operator=(const KernelThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline KernelThunkProto& operator=(KernelThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KernelThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const KernelThunkProto* internal_default_instance() {
    return reinterpret_cast<const KernelThunkProto*>(
        &_KernelThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(KernelThunkProto& a, KernelThunkProto& b) { a.Swap(&b); }
  inline void Swap(KernelThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KernelThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KernelThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KernelThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KernelThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KernelThunkProto& from) { KernelThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KernelThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.KernelThunkProto"; }

 protected:
  explicit KernelThunkProto(::google::protobuf::Arena* arena);
  KernelThunkProto(::google::protobuf::Arena* arena, const KernelThunkProto& from);
  KernelThunkProto(::google::protobuf::Arena* arena, KernelThunkProto&& from) noexcept
      : KernelThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NumWorkGroups = KernelThunkProto_NumWorkGroups;

  // accessors -------------------------------------------------------
  enum : int {
    kInvariantArgumentsFieldNumber = 3,
    kArgumentsBuffersFieldNumber = 5,
    kResultsBuffersFieldNumber = 6,
    kKernelNameFieldNumber = 1,
    kNumWorkgroupsFieldNumber = 2,
    kMinAlignmentFieldNumber = 4,
  };
  // repeated int64 invariant_arguments = 3;
  int invariant_arguments_size() const;
  private:
  int _internal_invariant_arguments_size() const;

  public:
  void clear_invariant_arguments() ;
  ::int64_t invariant_arguments(int index) const;
  void set_invariant_arguments(int index, ::int64_t value);
  void add_invariant_arguments(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& invariant_arguments() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_invariant_arguments();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_invariant_arguments() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_invariant_arguments();

  public:
  // repeated .xla.buffer_assignment.BufferAllocationSliceProto arguments_buffers = 5;
  int arguments_buffers_size() const;
  private:
  int _internal_arguments_buffers_size() const;

  public:
  void clear_arguments_buffers() ;
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_arguments_buffers(int index);
  ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>* mutable_arguments_buffers();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>& _internal_arguments_buffers() const;
  ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>* _internal_mutable_arguments_buffers();
  public:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& arguments_buffers(int index) const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* add_arguments_buffers();
  const ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>& arguments_buffers() const;
  // repeated .xla.buffer_assignment.BufferAllocationSliceProto results_buffers = 6;
  int results_buffers_size() const;
  private:
  int _internal_results_buffers_size() const;

  public:
  void clear_results_buffers() ;
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_results_buffers(int index);
  ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>* mutable_results_buffers();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>& _internal_results_buffers() const;
  ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>* _internal_mutable_results_buffers();
  public:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& results_buffers(int index) const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* add_results_buffers();
  const ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>& results_buffers() const;
  // string kernel_name = 1;
  void clear_kernel_name() ;
  const std::string& kernel_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_kernel_name(Arg_&& arg, Args_... args);
  std::string* mutable_kernel_name();
  PROTOBUF_NODISCARD std::string* release_kernel_name();
  void set_allocated_kernel_name(std::string* value);

  private:
  const std::string& _internal_kernel_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kernel_name(
      const std::string& value);
  std::string* _internal_mutable_kernel_name();

  public:
  // .xla.cpu.KernelThunkProto.NumWorkGroups num_workgroups = 2;
  bool has_num_workgroups() const;
  void clear_num_workgroups() ;
  const ::xla::cpu::KernelThunkProto_NumWorkGroups& num_workgroups() const;
  PROTOBUF_NODISCARD ::xla::cpu::KernelThunkProto_NumWorkGroups* release_num_workgroups();
  ::xla::cpu::KernelThunkProto_NumWorkGroups* mutable_num_workgroups();
  void set_allocated_num_workgroups(::xla::cpu::KernelThunkProto_NumWorkGroups* value);
  void unsafe_arena_set_allocated_num_workgroups(::xla::cpu::KernelThunkProto_NumWorkGroups* value);
  ::xla::cpu::KernelThunkProto_NumWorkGroups* unsafe_arena_release_num_workgroups();

  private:
  const ::xla::cpu::KernelThunkProto_NumWorkGroups& _internal_num_workgroups() const;
  ::xla::cpu::KernelThunkProto_NumWorkGroups* _internal_mutable_num_workgroups();

  public:
  // .xla.cpu.Int64Optional min_alignment = 4;
  bool has_min_alignment() const;
  void clear_min_alignment() ;
  const ::xla::cpu::Int64Optional& min_alignment() const;
  PROTOBUF_NODISCARD ::xla::cpu::Int64Optional* release_min_alignment();
  ::xla::cpu::Int64Optional* mutable_min_alignment();
  void set_allocated_min_alignment(::xla::cpu::Int64Optional* value);
  void unsafe_arena_set_allocated_min_alignment(::xla::cpu::Int64Optional* value);
  ::xla::cpu::Int64Optional* unsafe_arena_release_min_alignment();

  private:
  const ::xla::cpu::Int64Optional& _internal_min_alignment() const;
  ::xla::cpu::Int64Optional* _internal_mutable_min_alignment();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.KernelThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      44, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KernelThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> invariant_arguments_;
    mutable ::google::protobuf::internal::CachedSize _invariant_arguments_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::xla::buffer_assignment::BufferAllocationSliceProto > arguments_buffers_;
    ::google::protobuf::RepeatedPtrField< ::xla::buffer_assignment::BufferAllocationSliceProto > results_buffers_;
    ::google::protobuf::internal::ArenaStringPtr kernel_name_;
    ::xla::cpu::KernelThunkProto_NumWorkGroups* num_workgroups_;
    ::xla::cpu::Int64Optional* min_alignment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectivePermuteThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.CollectivePermuteThunkProto) */ {
 public:
  inline CollectivePermuteThunkProto() : CollectivePermuteThunkProto(nullptr) {}
  ~CollectivePermuteThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectivePermuteThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectivePermuteThunkProto(const CollectivePermuteThunkProto& from) : CollectivePermuteThunkProto(nullptr, from) {}
  inline CollectivePermuteThunkProto(CollectivePermuteThunkProto&& from) noexcept
      : CollectivePermuteThunkProto(nullptr, std::move(from)) {}
  inline CollectivePermuteThunkProto& operator=(const CollectivePermuteThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectivePermuteThunkProto& operator=(CollectivePermuteThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectivePermuteThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectivePermuteThunkProto* internal_default_instance() {
    return reinterpret_cast<const CollectivePermuteThunkProto*>(
        &_CollectivePermuteThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(CollectivePermuteThunkProto& a, CollectivePermuteThunkProto& b) { a.Swap(&b); }
  inline void Swap(CollectivePermuteThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectivePermuteThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectivePermuteThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectivePermuteThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectivePermuteThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectivePermuteThunkProto& from) { CollectivePermuteThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectivePermuteThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.CollectivePermuteThunkProto"; }

 protected:
  explicit CollectivePermuteThunkProto(::google::protobuf::Arena* arena);
  CollectivePermuteThunkProto(::google::protobuf::Arena* arena, const CollectivePermuteThunkProto& from);
  CollectivePermuteThunkProto(::google::protobuf::Arena* arena, CollectivePermuteThunkProto&& from) noexcept
      : CollectivePermuteThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using SourceTargetPairProto = CollectivePermuteThunkProto_SourceTargetPairProto;

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTargetPairsFieldNumber = 1,
  };
  // repeated .xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto source_target_pairs = 1;
  int source_target_pairs_size() const;
  private:
  int _internal_source_target_pairs_size() const;

  public:
  void clear_source_target_pairs() ;
  ::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto* mutable_source_target_pairs(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto>* mutable_source_target_pairs();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto>& _internal_source_target_pairs() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto>* _internal_mutable_source_target_pairs();
  public:
  const ::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto& source_target_pairs(int index) const;
  ::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto* add_source_target_pairs();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto>& source_target_pairs() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.CollectivePermuteThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectivePermuteThunkProto& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto > source_target_pairs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ShapeBufferAllocationSliceProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ShapeBufferAllocationSliceProto) */ {
 public:
  inline ShapeBufferAllocationSliceProto() : ShapeBufferAllocationSliceProto(nullptr) {}
  ~ShapeBufferAllocationSliceProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShapeBufferAllocationSliceProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ShapeBufferAllocationSliceProto(const ShapeBufferAllocationSliceProto& from) : ShapeBufferAllocationSliceProto(nullptr, from) {}
  inline ShapeBufferAllocationSliceProto(ShapeBufferAllocationSliceProto&& from) noexcept
      : ShapeBufferAllocationSliceProto(nullptr, std::move(from)) {}
  inline ShapeBufferAllocationSliceProto& operator=(const ShapeBufferAllocationSliceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeBufferAllocationSliceProto& operator=(ShapeBufferAllocationSliceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeBufferAllocationSliceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeBufferAllocationSliceProto* internal_default_instance() {
    return reinterpret_cast<const ShapeBufferAllocationSliceProto*>(
        &_ShapeBufferAllocationSliceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ShapeBufferAllocationSliceProto& a, ShapeBufferAllocationSliceProto& b) { a.Swap(&b); }
  inline void Swap(ShapeBufferAllocationSliceProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeBufferAllocationSliceProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeBufferAllocationSliceProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ShapeBufferAllocationSliceProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShapeBufferAllocationSliceProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ShapeBufferAllocationSliceProto& from) { ShapeBufferAllocationSliceProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ShapeBufferAllocationSliceProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ShapeBufferAllocationSliceProto"; }

 protected:
  explicit ShapeBufferAllocationSliceProto(::google::protobuf::Arena* arena);
  ShapeBufferAllocationSliceProto(::google::protobuf::Arena* arena, const ShapeBufferAllocationSliceProto& from);
  ShapeBufferAllocationSliceProto(::google::protobuf::Arena* arena, ShapeBufferAllocationSliceProto&& from) noexcept
      : ShapeBufferAllocationSliceProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShapeFieldNumber = 1,
    kSliceFieldNumber = 2,
  };
  // .xla.ShapeProto shape = 1;
  bool has_shape() const;
  void clear_shape() ;
  const ::xla::ShapeProto& shape() const;
  PROTOBUF_NODISCARD ::xla::ShapeProto* release_shape();
  ::xla::ShapeProto* mutable_shape();
  void set_allocated_shape(::xla::ShapeProto* value);
  void unsafe_arena_set_allocated_shape(::xla::ShapeProto* value);
  ::xla::ShapeProto* unsafe_arena_release_shape();

  private:
  const ::xla::ShapeProto& _internal_shape() const;
  ::xla::ShapeProto* _internal_mutable_shape();

  public:
  // .xla.buffer_assignment.BufferAllocationSliceProto slice = 2;
  bool has_slice() const;
  void clear_slice() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& slice() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_slice();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_slice();
  void set_allocated_slice(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_slice(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_slice();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_slice() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_slice();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ShapeBufferAllocationSliceProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ShapeBufferAllocationSliceProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::ShapeProto* shape_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* slice_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OutfeedThunkProto_OutfeedResource final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.OutfeedThunkProto.OutfeedResource) */ {
 public:
  inline OutfeedThunkProto_OutfeedResource() : OutfeedThunkProto_OutfeedResource(nullptr) {}
  ~OutfeedThunkProto_OutfeedResource() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OutfeedThunkProto_OutfeedResource(
      ::google::protobuf::internal::ConstantInitialized);

  inline OutfeedThunkProto_OutfeedResource(const OutfeedThunkProto_OutfeedResource& from) : OutfeedThunkProto_OutfeedResource(nullptr, from) {}
  inline OutfeedThunkProto_OutfeedResource(OutfeedThunkProto_OutfeedResource&& from) noexcept
      : OutfeedThunkProto_OutfeedResource(nullptr, std::move(from)) {}
  inline OutfeedThunkProto_OutfeedResource& operator=(const OutfeedThunkProto_OutfeedResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutfeedThunkProto_OutfeedResource& operator=(OutfeedThunkProto_OutfeedResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutfeedThunkProto_OutfeedResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutfeedThunkProto_OutfeedResource* internal_default_instance() {
    return reinterpret_cast<const OutfeedThunkProto_OutfeedResource*>(
        &_OutfeedThunkProto_OutfeedResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(OutfeedThunkProto_OutfeedResource& a, OutfeedThunkProto_OutfeedResource& b) { a.Swap(&b); }
  inline void Swap(OutfeedThunkProto_OutfeedResource* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutfeedThunkProto_OutfeedResource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutfeedThunkProto_OutfeedResource* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<OutfeedThunkProto_OutfeedResource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OutfeedThunkProto_OutfeedResource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OutfeedThunkProto_OutfeedResource& from) { OutfeedThunkProto_OutfeedResource::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OutfeedThunkProto_OutfeedResource* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.OutfeedThunkProto.OutfeedResource"; }

 protected:
  explicit OutfeedThunkProto_OutfeedResource(::google::protobuf::Arena* arena);
  OutfeedThunkProto_OutfeedResource(::google::protobuf::Arena* arena, const OutfeedThunkProto_OutfeedResource& from);
  OutfeedThunkProto_OutfeedResource(::google::protobuf::Arena* arena, OutfeedThunkProto_OutfeedResource&& from) noexcept
      : OutfeedThunkProto_OutfeedResource(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConsumeTokenFieldNumber = 1,
    kProduceTokenFieldNumber = 2,
  };
  // .xla.cpu.ResourceOptional consume_token = 1;
  bool has_consume_token() const;
  void clear_consume_token() ;
  const ::xla::cpu::ResourceOptional& consume_token() const;
  PROTOBUF_NODISCARD ::xla::cpu::ResourceOptional* release_consume_token();
  ::xla::cpu::ResourceOptional* mutable_consume_token();
  void set_allocated_consume_token(::xla::cpu::ResourceOptional* value);
  void unsafe_arena_set_allocated_consume_token(::xla::cpu::ResourceOptional* value);
  ::xla::cpu::ResourceOptional* unsafe_arena_release_consume_token();

  private:
  const ::xla::cpu::ResourceOptional& _internal_consume_token() const;
  ::xla::cpu::ResourceOptional* _internal_mutable_consume_token();

  public:
  // .xla.cpu.ResourceOptional produce_token = 2;
  bool has_produce_token() const;
  void clear_produce_token() ;
  const ::xla::cpu::ResourceOptional& produce_token() const;
  PROTOBUF_NODISCARD ::xla::cpu::ResourceOptional* release_produce_token();
  ::xla::cpu::ResourceOptional* mutable_produce_token();
  void set_allocated_produce_token(::xla::cpu::ResourceOptional* value);
  void unsafe_arena_set_allocated_produce_token(::xla::cpu::ResourceOptional* value);
  ::xla::cpu::ResourceOptional* unsafe_arena_release_produce_token();

  private:
  const ::xla::cpu::ResourceOptional& _internal_produce_token() const;
  ::xla::cpu::ResourceOptional* _internal_mutable_produce_token();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.OutfeedThunkProto.OutfeedResource)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OutfeedThunkProto_OutfeedResource& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::ResourceOptional* consume_token_;
    ::xla::cpu::ResourceOptional* produce_token_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OpResourcesProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.OpResourcesProto) */ {
 public:
  inline OpResourcesProto() : OpResourcesProto(nullptr) {}
  ~OpResourcesProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpResourcesProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline OpResourcesProto(const OpResourcesProto& from) : OpResourcesProto(nullptr, from) {}
  inline OpResourcesProto(OpResourcesProto&& from) noexcept
      : OpResourcesProto(nullptr, std::move(from)) {}
  inline OpResourcesProto& operator=(const OpResourcesProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpResourcesProto& operator=(OpResourcesProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpResourcesProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpResourcesProto* internal_default_instance() {
    return reinterpret_cast<const OpResourcesProto*>(
        &_OpResourcesProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(OpResourcesProto& a, OpResourcesProto& b) { a.Swap(&b); }
  inline void Swap(OpResourcesProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpResourcesProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpResourcesProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<OpResourcesProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpResourcesProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpResourcesProto& from) { OpResourcesProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpResourcesProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.OpResourcesProto"; }

 protected:
  explicit OpResourcesProto(::google::protobuf::Arena* arena);
  OpResourcesProto(::google::protobuf::Arena* arena, const OpResourcesProto& from);
  OpResourcesProto(::google::protobuf::Arena* arena, OpResourcesProto&& from) noexcept
      : OpResourcesProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommunicatorResourceFieldNumber = 1,
  };
  // .xla.cpu.ResourceOptional communicator_resource = 1;
  bool has_communicator_resource() const;
  void clear_communicator_resource() ;
  const ::xla::cpu::ResourceOptional& communicator_resource() const;
  PROTOBUF_NODISCARD ::xla::cpu::ResourceOptional* release_communicator_resource();
  ::xla::cpu::ResourceOptional* mutable_communicator_resource();
  void set_allocated_communicator_resource(::xla::cpu::ResourceOptional* value);
  void unsafe_arena_set_allocated_communicator_resource(::xla::cpu::ResourceOptional* value);
  ::xla::cpu::ResourceOptional* unsafe_arena_release_communicator_resource();

  private:
  const ::xla::cpu::ResourceOptional& _internal_communicator_resource() const;
  ::xla::cpu::ResourceOptional* _internal_mutable_communicator_resource();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.OpResourcesProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OpResourcesProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::ResourceOptional* communicator_resource_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT InfeedThunkProto_InfeedResource final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.InfeedThunkProto.InfeedResource) */ {
 public:
  inline InfeedThunkProto_InfeedResource() : InfeedThunkProto_InfeedResource(nullptr) {}
  ~InfeedThunkProto_InfeedResource() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InfeedThunkProto_InfeedResource(
      ::google::protobuf::internal::ConstantInitialized);

  inline InfeedThunkProto_InfeedResource(const InfeedThunkProto_InfeedResource& from) : InfeedThunkProto_InfeedResource(nullptr, from) {}
  inline InfeedThunkProto_InfeedResource(InfeedThunkProto_InfeedResource&& from) noexcept
      : InfeedThunkProto_InfeedResource(nullptr, std::move(from)) {}
  inline InfeedThunkProto_InfeedResource& operator=(const InfeedThunkProto_InfeedResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfeedThunkProto_InfeedResource& operator=(InfeedThunkProto_InfeedResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfeedThunkProto_InfeedResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfeedThunkProto_InfeedResource* internal_default_instance() {
    return reinterpret_cast<const InfeedThunkProto_InfeedResource*>(
        &_InfeedThunkProto_InfeedResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(InfeedThunkProto_InfeedResource& a, InfeedThunkProto_InfeedResource& b) { a.Swap(&b); }
  inline void Swap(InfeedThunkProto_InfeedResource* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfeedThunkProto_InfeedResource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfeedThunkProto_InfeedResource* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InfeedThunkProto_InfeedResource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InfeedThunkProto_InfeedResource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InfeedThunkProto_InfeedResource& from) { InfeedThunkProto_InfeedResource::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InfeedThunkProto_InfeedResource* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.InfeedThunkProto.InfeedResource"; }

 protected:
  explicit InfeedThunkProto_InfeedResource(::google::protobuf::Arena* arena);
  InfeedThunkProto_InfeedResource(::google::protobuf::Arena* arena, const InfeedThunkProto_InfeedResource& from);
  InfeedThunkProto_InfeedResource(::google::protobuf::Arena* arena, InfeedThunkProto_InfeedResource&& from) noexcept
      : InfeedThunkProto_InfeedResource(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConsumeTokenFieldNumber = 1,
    kProduceTokenFieldNumber = 2,
  };
  // .xla.cpu.ResourceOptional consume_token = 1;
  bool has_consume_token() const;
  void clear_consume_token() ;
  const ::xla::cpu::ResourceOptional& consume_token() const;
  PROTOBUF_NODISCARD ::xla::cpu::ResourceOptional* release_consume_token();
  ::xla::cpu::ResourceOptional* mutable_consume_token();
  void set_allocated_consume_token(::xla::cpu::ResourceOptional* value);
  void unsafe_arena_set_allocated_consume_token(::xla::cpu::ResourceOptional* value);
  ::xla::cpu::ResourceOptional* unsafe_arena_release_consume_token();

  private:
  const ::xla::cpu::ResourceOptional& _internal_consume_token() const;
  ::xla::cpu::ResourceOptional* _internal_mutable_consume_token();

  public:
  // .xla.cpu.ResourceOptional produce_token = 2;
  bool has_produce_token() const;
  void clear_produce_token() ;
  const ::xla::cpu::ResourceOptional& produce_token() const;
  PROTOBUF_NODISCARD ::xla::cpu::ResourceOptional* release_produce_token();
  ::xla::cpu::ResourceOptional* mutable_produce_token();
  void set_allocated_produce_token(::xla::cpu::ResourceOptional* value);
  void unsafe_arena_set_allocated_produce_token(::xla::cpu::ResourceOptional* value);
  ::xla::cpu::ResourceOptional* unsafe_arena_release_produce_token();

  private:
  const ::xla::cpu::ResourceOptional& _internal_produce_token() const;
  ::xla::cpu::ResourceOptional* _internal_mutable_produce_token();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.InfeedThunkProto.InfeedResource)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InfeedThunkProto_InfeedResource& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::ResourceOptional* consume_token_;
    ::xla::cpu::ResourceOptional* produce_token_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT XnnFusionThunkProtoImpl final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.XnnFusionThunkProtoImpl) */ {
 public:
  inline XnnFusionThunkProtoImpl() : XnnFusionThunkProtoImpl(nullptr) {}
  ~XnnFusionThunkProtoImpl() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XnnFusionThunkProtoImpl(
      ::google::protobuf::internal::ConstantInitialized);

  inline XnnFusionThunkProtoImpl(const XnnFusionThunkProtoImpl& from) : XnnFusionThunkProtoImpl(nullptr, from) {}
  inline XnnFusionThunkProtoImpl(XnnFusionThunkProtoImpl&& from) noexcept
      : XnnFusionThunkProtoImpl(nullptr, std::move(from)) {}
  inline XnnFusionThunkProtoImpl& operator=(const XnnFusionThunkProtoImpl& from) {
    CopyFrom(from);
    return *this;
  }
  inline XnnFusionThunkProtoImpl& operator=(XnnFusionThunkProtoImpl&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XnnFusionThunkProtoImpl& default_instance() {
    return *internal_default_instance();
  }
  static inline const XnnFusionThunkProtoImpl* internal_default_instance() {
    return reinterpret_cast<const XnnFusionThunkProtoImpl*>(
        &_XnnFusionThunkProtoImpl_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(XnnFusionThunkProtoImpl& a, XnnFusionThunkProtoImpl& b) { a.Swap(&b); }
  inline void Swap(XnnFusionThunkProtoImpl* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XnnFusionThunkProtoImpl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XnnFusionThunkProtoImpl* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<XnnFusionThunkProtoImpl>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XnnFusionThunkProtoImpl& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XnnFusionThunkProtoImpl& from) { XnnFusionThunkProtoImpl::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XnnFusionThunkProtoImpl* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.XnnFusionThunkProtoImpl"; }

 protected:
  explicit XnnFusionThunkProtoImpl(::google::protobuf::Arena* arena);
  XnnFusionThunkProtoImpl(::google::protobuf::Arena* arena, const XnnFusionThunkProtoImpl& from);
  XnnFusionThunkProtoImpl(::google::protobuf::Arena* arena, XnnFusionThunkProtoImpl&& from) noexcept
      : XnnFusionThunkProtoImpl(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArgumentsShapesFieldNumber = 1,
    kResultsShapesFieldNumber = 2,
  };
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto arguments_shapes = 1;
  int arguments_shapes_size() const;
  private:
  int _internal_arguments_shapes_size() const;

  public:
  void clear_arguments_shapes() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_arguments_shapes(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_arguments_shapes();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_arguments_shapes() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_arguments_shapes();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& arguments_shapes(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_arguments_shapes();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& arguments_shapes() const;
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto results_shapes = 2;
  int results_shapes_size() const;
  private:
  int _internal_results_shapes_size() const;

  public:
  void clear_results_shapes() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_results_shapes(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_results_shapes();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_results_shapes() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_results_shapes();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& results_shapes(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_results_shapes();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& results_shapes() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.XnnFusionThunkProtoImpl)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const XnnFusionThunkProtoImpl& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > arguments_shapes_;
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > results_shapes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT XnnDotThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.XnnDotThunkProto) */ {
 public:
  inline XnnDotThunkProto() : XnnDotThunkProto(nullptr) {}
  ~XnnDotThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XnnDotThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline XnnDotThunkProto(const XnnDotThunkProto& from) : XnnDotThunkProto(nullptr, from) {}
  inline XnnDotThunkProto(XnnDotThunkProto&& from) noexcept
      : XnnDotThunkProto(nullptr, std::move(from)) {}
  inline XnnDotThunkProto& operator=(const XnnDotThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline XnnDotThunkProto& operator=(XnnDotThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XnnDotThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const XnnDotThunkProto* internal_default_instance() {
    return reinterpret_cast<const XnnDotThunkProto*>(
        &_XnnDotThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(XnnDotThunkProto& a, XnnDotThunkProto& b) { a.Swap(&b); }
  inline void Swap(XnnDotThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XnnDotThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XnnDotThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<XnnDotThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XnnDotThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XnnDotThunkProto& from) { XnnDotThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XnnDotThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.XnnDotThunkProto"; }

 protected:
  explicit XnnDotThunkProto(::google::protobuf::Arena* arena);
  XnnDotThunkProto(::google::protobuf::Arena* arena, const XnnDotThunkProto& from);
  XnnDotThunkProto(::google::protobuf::Arena* arena, XnnDotThunkProto&& from) noexcept
      : XnnDotThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDotDimensionsFieldNumber = 1,
    kLhsBufferShapeFieldNumber = 2,
    kRhsBufferShapeFieldNumber = 3,
    kOutBufferShapeFieldNumber = 4,
    kCaptureRhsFieldNumber = 5,
  };
  // .xla.DotDimensionNumbers dot_dimensions = 1;
  bool has_dot_dimensions() const;
  void clear_dot_dimensions() ;
  const ::xla::DotDimensionNumbers& dot_dimensions() const;
  PROTOBUF_NODISCARD ::xla::DotDimensionNumbers* release_dot_dimensions();
  ::xla::DotDimensionNumbers* mutable_dot_dimensions();
  void set_allocated_dot_dimensions(::xla::DotDimensionNumbers* value);
  void unsafe_arena_set_allocated_dot_dimensions(::xla::DotDimensionNumbers* value);
  ::xla::DotDimensionNumbers* unsafe_arena_release_dot_dimensions();

  private:
  const ::xla::DotDimensionNumbers& _internal_dot_dimensions() const;
  ::xla::DotDimensionNumbers* _internal_mutable_dot_dimensions();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto lhs_buffer_shape = 2;
  bool has_lhs_buffer_shape() const;
  void clear_lhs_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& lhs_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_lhs_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_lhs_buffer_shape();
  void set_allocated_lhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_lhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_lhs_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_lhs_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_lhs_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto rhs_buffer_shape = 3;
  bool has_rhs_buffer_shape() const;
  void clear_rhs_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& rhs_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_rhs_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_rhs_buffer_shape();
  void set_allocated_rhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_rhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_rhs_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_rhs_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_rhs_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto out_buffer_shape = 4;
  bool has_out_buffer_shape() const;
  void clear_out_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& out_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_out_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_out_buffer_shape();
  void set_allocated_out_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_out_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_out_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_out_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_out_buffer_shape();

  public:
  // bool capture_rhs = 5;
  void clear_capture_rhs() ;
  bool capture_rhs() const;
  void set_capture_rhs(bool value);

  private:
  bool _internal_capture_rhs() const;
  void _internal_set_capture_rhs(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.XnnDotThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 4,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const XnnDotThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::DotDimensionNumbers* dot_dimensions_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* lhs_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* rhs_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* out_buffer_shape_;
    bool capture_rhs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT XnnConvolutionThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.XnnConvolutionThunkProto) */ {
 public:
  inline XnnConvolutionThunkProto() : XnnConvolutionThunkProto(nullptr) {}
  ~XnnConvolutionThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XnnConvolutionThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline XnnConvolutionThunkProto(const XnnConvolutionThunkProto& from) : XnnConvolutionThunkProto(nullptr, from) {}
  inline XnnConvolutionThunkProto(XnnConvolutionThunkProto&& from) noexcept
      : XnnConvolutionThunkProto(nullptr, std::move(from)) {}
  inline XnnConvolutionThunkProto& operator=(const XnnConvolutionThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline XnnConvolutionThunkProto& operator=(XnnConvolutionThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XnnConvolutionThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const XnnConvolutionThunkProto* internal_default_instance() {
    return reinterpret_cast<const XnnConvolutionThunkProto*>(
        &_XnnConvolutionThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(XnnConvolutionThunkProto& a, XnnConvolutionThunkProto& b) { a.Swap(&b); }
  inline void Swap(XnnConvolutionThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XnnConvolutionThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XnnConvolutionThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<XnnConvolutionThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XnnConvolutionThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XnnConvolutionThunkProto& from) { XnnConvolutionThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XnnConvolutionThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.XnnConvolutionThunkProto"; }

 protected:
  explicit XnnConvolutionThunkProto(::google::protobuf::Arena* arena);
  XnnConvolutionThunkProto(::google::protobuf::Arena* arena, const XnnConvolutionThunkProto& from);
  XnnConvolutionThunkProto(::google::protobuf::Arena* arena, XnnConvolutionThunkProto&& from) noexcept
      : XnnConvolutionThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDimensionNumbersFieldNumber = 1,
    kWindowFieldNumber = 2,
    kInputBufferShapeFieldNumber = 4,
    kKernelBufferShapeFieldNumber = 5,
    kOutputBufferShapeFieldNumber = 6,
    kFeatureGroupCountFieldNumber = 3,
  };
  // .xla.ConvolutionDimensionNumbers dimension_numbers = 1;
  bool has_dimension_numbers() const;
  void clear_dimension_numbers() ;
  const ::xla::ConvolutionDimensionNumbers& dimension_numbers() const;
  PROTOBUF_NODISCARD ::xla::ConvolutionDimensionNumbers* release_dimension_numbers();
  ::xla::ConvolutionDimensionNumbers* mutable_dimension_numbers();
  void set_allocated_dimension_numbers(::xla::ConvolutionDimensionNumbers* value);
  void unsafe_arena_set_allocated_dimension_numbers(::xla::ConvolutionDimensionNumbers* value);
  ::xla::ConvolutionDimensionNumbers* unsafe_arena_release_dimension_numbers();

  private:
  const ::xla::ConvolutionDimensionNumbers& _internal_dimension_numbers() const;
  ::xla::ConvolutionDimensionNumbers* _internal_mutable_dimension_numbers();

  public:
  // .xla.Window window = 2;
  bool has_window() const;
  void clear_window() ;
  const ::xla::Window& window() const;
  PROTOBUF_NODISCARD ::xla::Window* release_window();
  ::xla::Window* mutable_window();
  void set_allocated_window(::xla::Window* value);
  void unsafe_arena_set_allocated_window(::xla::Window* value);
  ::xla::Window* unsafe_arena_release_window();

  private:
  const ::xla::Window& _internal_window() const;
  ::xla::Window* _internal_mutable_window();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto input_buffer_shape = 4;
  bool has_input_buffer_shape() const;
  void clear_input_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& input_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_input_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_input_buffer_shape();
  void set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_input_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_input_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_input_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto kernel_buffer_shape = 5;
  bool has_kernel_buffer_shape() const;
  void clear_kernel_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& kernel_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_kernel_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_kernel_buffer_shape();
  void set_allocated_kernel_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_kernel_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_kernel_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_kernel_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_kernel_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto output_buffer_shape = 6;
  bool has_output_buffer_shape() const;
  void clear_output_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& output_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_output_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_output_buffer_shape();
  void set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_output_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_output_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_output_buffer_shape();

  public:
  // int64 feature_group_count = 3;
  void clear_feature_group_count() ;
  ::int64_t feature_group_count() const;
  void set_feature_group_count(::int64_t value);

  private:
  ::int64_t _internal_feature_group_count() const;
  void _internal_set_feature_group_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.XnnConvolutionThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 5,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const XnnConvolutionThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::ConvolutionDimensionNumbers* dimension_numbers_;
    ::xla::Window* window_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* input_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* kernel_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* output_buffer_shape_;
    ::int64_t feature_group_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SortThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.SortThunkProto) */ {
 public:
  inline SortThunkProto() : SortThunkProto(nullptr) {}
  ~SortThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SortThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline SortThunkProto(const SortThunkProto& from) : SortThunkProto(nullptr, from) {}
  inline SortThunkProto(SortThunkProto&& from) noexcept
      : SortThunkProto(nullptr, std::move(from)) {}
  inline SortThunkProto& operator=(const SortThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortThunkProto& operator=(SortThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortThunkProto* internal_default_instance() {
    return reinterpret_cast<const SortThunkProto*>(
        &_SortThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(SortThunkProto& a, SortThunkProto& b) { a.Swap(&b); }
  inline void Swap(SortThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SortThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SortThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SortThunkProto& from) { SortThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SortThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.SortThunkProto"; }

 protected:
  explicit SortThunkProto(::google::protobuf::Arena* arena);
  SortThunkProto(::google::protobuf::Arena* arena, const SortThunkProto& from);
  SortThunkProto(::google::protobuf::Arena* arena, SortThunkProto&& from) noexcept
      : SortThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsShapesFieldNumber = 5,
    kComparatorNameFieldNumber = 4,
    kDirectionFieldNumber = 3,
    kDimensionFieldNumber = 1,
    kIsStableFieldNumber = 2,
  };
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto inputs_shapes = 5;
  int inputs_shapes_size() const;
  private:
  int _internal_inputs_shapes_size() const;

  public:
  void clear_inputs_shapes() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_inputs_shapes(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_inputs_shapes();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_inputs_shapes() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_inputs_shapes();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& inputs_shapes(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_inputs_shapes();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& inputs_shapes() const;
  // string comparator_name = 4;
  void clear_comparator_name() ;
  const std::string& comparator_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comparator_name(Arg_&& arg, Args_... args);
  std::string* mutable_comparator_name();
  PROTOBUF_NODISCARD std::string* release_comparator_name();
  void set_allocated_comparator_name(std::string* value);

  private:
  const std::string& _internal_comparator_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comparator_name(
      const std::string& value);
  std::string* _internal_mutable_comparator_name();

  public:
  // .xla.cpu.SortDirectionOptional direction = 3;
  bool has_direction() const;
  void clear_direction() ;
  const ::xla::cpu::SortDirectionOptional& direction() const;
  PROTOBUF_NODISCARD ::xla::cpu::SortDirectionOptional* release_direction();
  ::xla::cpu::SortDirectionOptional* mutable_direction();
  void set_allocated_direction(::xla::cpu::SortDirectionOptional* value);
  void unsafe_arena_set_allocated_direction(::xla::cpu::SortDirectionOptional* value);
  ::xla::cpu::SortDirectionOptional* unsafe_arena_release_direction();

  private:
  const ::xla::cpu::SortDirectionOptional& _internal_direction() const;
  ::xla::cpu::SortDirectionOptional* _internal_mutable_direction();

  public:
  // int64 dimension = 1;
  void clear_dimension() ;
  ::int64_t dimension() const;
  void set_dimension(::int64_t value);

  private:
  ::int64_t _internal_dimension() const;
  void _internal_set_dimension(::int64_t value);

  public:
  // bool is_stable = 2;
  void clear_is_stable() ;
  bool is_stable() const;
  void set_is_stable(bool value);

  private:
  bool _internal_is_stable() const;
  void _internal_set_is_stable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.SortThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      46, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SortThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > inputs_shapes_;
    ::google::protobuf::internal::ArenaStringPtr comparator_name_;
    ::xla::cpu::SortDirectionOptional* direction_;
    ::int64_t dimension_;
    bool is_stable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OutfeedThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.OutfeedThunkProto) */ {
 public:
  inline OutfeedThunkProto() : OutfeedThunkProto(nullptr) {}
  ~OutfeedThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OutfeedThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline OutfeedThunkProto(const OutfeedThunkProto& from) : OutfeedThunkProto(nullptr, from) {}
  inline OutfeedThunkProto(OutfeedThunkProto&& from) noexcept
      : OutfeedThunkProto(nullptr, std::move(from)) {}
  inline OutfeedThunkProto& operator=(const OutfeedThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutfeedThunkProto& operator=(OutfeedThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutfeedThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutfeedThunkProto* internal_default_instance() {
    return reinterpret_cast<const OutfeedThunkProto*>(
        &_OutfeedThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(OutfeedThunkProto& a, OutfeedThunkProto& b) { a.Swap(&b); }
  inline void Swap(OutfeedThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutfeedThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutfeedThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<OutfeedThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OutfeedThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OutfeedThunkProto& from) { OutfeedThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OutfeedThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.OutfeedThunkProto"; }

 protected:
  explicit OutfeedThunkProto(::google::protobuf::Arena* arena);
  OutfeedThunkProto(::google::protobuf::Arena* arena, const OutfeedThunkProto& from);
  OutfeedThunkProto(::google::protobuf::Arena* arena, OutfeedThunkProto&& from) noexcept
      : OutfeedThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OutfeedResource = OutfeedThunkProto_OutfeedResource;

  // accessors -------------------------------------------------------
  enum : int {
    kOutfeedBuffersShapesFieldNumber = 2,
    kOutfeedResourcesFieldNumber = 1,
  };
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto outfeed_buffers_shapes = 2;
  int outfeed_buffers_shapes_size() const;
  private:
  int _internal_outfeed_buffers_shapes_size() const;

  public:
  void clear_outfeed_buffers_shapes() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_outfeed_buffers_shapes(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_outfeed_buffers_shapes();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_outfeed_buffers_shapes() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_outfeed_buffers_shapes();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& outfeed_buffers_shapes(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_outfeed_buffers_shapes();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& outfeed_buffers_shapes() const;
  // .xla.cpu.OutfeedThunkProto.OutfeedResource outfeed_resources = 1;
  bool has_outfeed_resources() const;
  void clear_outfeed_resources() ;
  const ::xla::cpu::OutfeedThunkProto_OutfeedResource& outfeed_resources() const;
  PROTOBUF_NODISCARD ::xla::cpu::OutfeedThunkProto_OutfeedResource* release_outfeed_resources();
  ::xla::cpu::OutfeedThunkProto_OutfeedResource* mutable_outfeed_resources();
  void set_allocated_outfeed_resources(::xla::cpu::OutfeedThunkProto_OutfeedResource* value);
  void unsafe_arena_set_allocated_outfeed_resources(::xla::cpu::OutfeedThunkProto_OutfeedResource* value);
  ::xla::cpu::OutfeedThunkProto_OutfeedResource* unsafe_arena_release_outfeed_resources();

  private:
  const ::xla::cpu::OutfeedThunkProto_OutfeedResource& _internal_outfeed_resources() const;
  ::xla::cpu::OutfeedThunkProto_OutfeedResource* _internal_mutable_outfeed_resources();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.OutfeedThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OutfeedThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > outfeed_buffers_shapes_;
    ::xla::cpu::OutfeedThunkProto_OutfeedResource* outfeed_resources_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OpBuffersProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.OpBuffersProto) */ {
 public:
  inline OpBuffersProto() : OpBuffersProto(nullptr) {}
  ~OpBuffersProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpBuffersProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline OpBuffersProto(const OpBuffersProto& from) : OpBuffersProto(nullptr, from) {}
  inline OpBuffersProto(OpBuffersProto&& from) noexcept
      : OpBuffersProto(nullptr, std::move(from)) {}
  inline OpBuffersProto& operator=(const OpBuffersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpBuffersProto& operator=(OpBuffersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpBuffersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpBuffersProto* internal_default_instance() {
    return reinterpret_cast<const OpBuffersProto*>(
        &_OpBuffersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(OpBuffersProto& a, OpBuffersProto& b) { a.Swap(&b); }
  inline void Swap(OpBuffersProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpBuffersProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpBuffersProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<OpBuffersProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpBuffersProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpBuffersProto& from) { OpBuffersProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpBuffersProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.OpBuffersProto"; }

 protected:
  explicit OpBuffersProto(::google::protobuf::Arena* arena);
  OpBuffersProto(::google::protobuf::Arena* arena, const OpBuffersProto& from);
  OpBuffersProto(::google::protobuf::Arena* arena, OpBuffersProto&& from) noexcept
      : OpBuffersProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceShapesBufferSlicesFieldNumber = 1,
    kDestinationShapesBufferSlicesFieldNumber = 2,
  };
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto source_shapes_buffer_slices = 1;
  int source_shapes_buffer_slices_size() const;
  private:
  int _internal_source_shapes_buffer_slices_size() const;

  public:
  void clear_source_shapes_buffer_slices() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_source_shapes_buffer_slices(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_source_shapes_buffer_slices();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_source_shapes_buffer_slices() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_source_shapes_buffer_slices();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& source_shapes_buffer_slices(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_source_shapes_buffer_slices();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& source_shapes_buffer_slices() const;
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto destination_shapes_buffer_slices = 2;
  int destination_shapes_buffer_slices_size() const;
  private:
  int _internal_destination_shapes_buffer_slices_size() const;

  public:
  void clear_destination_shapes_buffer_slices() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_destination_shapes_buffer_slices(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_destination_shapes_buffer_slices();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_destination_shapes_buffer_slices() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_destination_shapes_buffer_slices();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& destination_shapes_buffer_slices(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_destination_shapes_buffer_slices();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& destination_shapes_buffer_slices() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.OpBuffersProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OpBuffersProto& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > source_shapes_buffer_slices_;
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > destination_shapes_buffer_slices_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT InfeedThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.InfeedThunkProto) */ {
 public:
  inline InfeedThunkProto() : InfeedThunkProto(nullptr) {}
  ~InfeedThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InfeedThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline InfeedThunkProto(const InfeedThunkProto& from) : InfeedThunkProto(nullptr, from) {}
  inline InfeedThunkProto(InfeedThunkProto&& from) noexcept
      : InfeedThunkProto(nullptr, std::move(from)) {}
  inline InfeedThunkProto& operator=(const InfeedThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfeedThunkProto& operator=(InfeedThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfeedThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfeedThunkProto* internal_default_instance() {
    return reinterpret_cast<const InfeedThunkProto*>(
        &_InfeedThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(InfeedThunkProto& a, InfeedThunkProto& b) { a.Swap(&b); }
  inline void Swap(InfeedThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfeedThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfeedThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InfeedThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InfeedThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InfeedThunkProto& from) { InfeedThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InfeedThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.InfeedThunkProto"; }

 protected:
  explicit InfeedThunkProto(::google::protobuf::Arena* arena);
  InfeedThunkProto(::google::protobuf::Arena* arena, const InfeedThunkProto& from);
  InfeedThunkProto(::google::protobuf::Arena* arena, InfeedThunkProto&& from) noexcept
      : InfeedThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using InfeedResource = InfeedThunkProto_InfeedResource;

  // accessors -------------------------------------------------------
  enum : int {
    kInfeedBuffersShapesFieldNumber = 2,
    kInfeedResourcesFieldNumber = 1,
  };
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto infeed_buffers_shapes = 2;
  int infeed_buffers_shapes_size() const;
  private:
  int _internal_infeed_buffers_shapes_size() const;

  public:
  void clear_infeed_buffers_shapes() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_infeed_buffers_shapes(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_infeed_buffers_shapes();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_infeed_buffers_shapes() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_infeed_buffers_shapes();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& infeed_buffers_shapes(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_infeed_buffers_shapes();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& infeed_buffers_shapes() const;
  // .xla.cpu.InfeedThunkProto.InfeedResource infeed_resources = 1;
  bool has_infeed_resources() const;
  void clear_infeed_resources() ;
  const ::xla::cpu::InfeedThunkProto_InfeedResource& infeed_resources() const;
  PROTOBUF_NODISCARD ::xla::cpu::InfeedThunkProto_InfeedResource* release_infeed_resources();
  ::xla::cpu::InfeedThunkProto_InfeedResource* mutable_infeed_resources();
  void set_allocated_infeed_resources(::xla::cpu::InfeedThunkProto_InfeedResource* value);
  void unsafe_arena_set_allocated_infeed_resources(::xla::cpu::InfeedThunkProto_InfeedResource* value);
  ::xla::cpu::InfeedThunkProto_InfeedResource* unsafe_arena_release_infeed_resources();

  private:
  const ::xla::cpu::InfeedThunkProto_InfeedResource& _internal_infeed_resources() const;
  ::xla::cpu::InfeedThunkProto_InfeedResource* _internal_mutable_infeed_resources();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.InfeedThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InfeedThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > infeed_buffers_shapes_;
    ::xla::cpu::InfeedThunkProto_InfeedResource* infeed_resources_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT FftThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.FftThunkProto) */ {
 public:
  inline FftThunkProto() : FftThunkProto(nullptr) {}
  ~FftThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FftThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline FftThunkProto(const FftThunkProto& from) : FftThunkProto(nullptr, from) {}
  inline FftThunkProto(FftThunkProto&& from) noexcept
      : FftThunkProto(nullptr, std::move(from)) {}
  inline FftThunkProto& operator=(const FftThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FftThunkProto& operator=(FftThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FftThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const FftThunkProto* internal_default_instance() {
    return reinterpret_cast<const FftThunkProto*>(
        &_FftThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(FftThunkProto& a, FftThunkProto& b) { a.Swap(&b); }
  inline void Swap(FftThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FftThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FftThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<FftThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FftThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FftThunkProto& from) { FftThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FftThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.FftThunkProto"; }

 protected:
  explicit FftThunkProto(::google::protobuf::Arena* arena);
  FftThunkProto(::google::protobuf::Arena* arena, const FftThunkProto& from);
  FftThunkProto(::google::protobuf::Arena* arena, FftThunkProto&& from) noexcept
      : FftThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFftLengthFieldNumber = 3,
    kInputBufferShapeFieldNumber = 4,
    kOutputBufferShapeFieldNumber = 5,
    kIsMultiThreadEigenFieldNumber = 1,
    kFftTypeFieldNumber = 2,
  };
  // repeated int64 fft_length = 3;
  int fft_length_size() const;
  private:
  int _internal_fft_length_size() const;

  public:
  void clear_fft_length() ;
  ::int64_t fft_length(int index) const;
  void set_fft_length(int index, ::int64_t value);
  void add_fft_length(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& fft_length() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_fft_length();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_fft_length() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_fft_length();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto input_buffer_shape = 4;
  bool has_input_buffer_shape() const;
  void clear_input_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& input_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_input_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_input_buffer_shape();
  void set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_input_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_input_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_input_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto output_buffer_shape = 5;
  bool has_output_buffer_shape() const;
  void clear_output_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& output_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_output_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_output_buffer_shape();
  void set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_output_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_output_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_output_buffer_shape();

  public:
  // bool is_multi_thread_eigen = 1;
  void clear_is_multi_thread_eigen() ;
  bool is_multi_thread_eigen() const;
  void set_is_multi_thread_eigen(bool value);

  private:
  bool _internal_is_multi_thread_eigen() const;
  void _internal_set_is_multi_thread_eigen(bool value);

  public:
  // int32 fft_type = 2;
  void clear_fft_type() ;
  ::int32_t fft_type() const;
  void set_fft_type(::int32_t value);

  private:
  ::int32_t _internal_fft_type() const;
  void _internal_set_fft_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.FftThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FftThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> fft_length_;
    mutable ::google::protobuf::internal::CachedSize _fft_length_cached_byte_size_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* input_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* output_buffer_shape_;
    bool is_multi_thread_eigen_;
    ::int32_t fft_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DotThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.DotThunkProto) */ {
 public:
  inline DotThunkProto() : DotThunkProto(nullptr) {}
  ~DotThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DotThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline DotThunkProto(const DotThunkProto& from) : DotThunkProto(nullptr, from) {}
  inline DotThunkProto(DotThunkProto&& from) noexcept
      : DotThunkProto(nullptr, std::move(from)) {}
  inline DotThunkProto& operator=(const DotThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DotThunkProto& operator=(DotThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DotThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DotThunkProto* internal_default_instance() {
    return reinterpret_cast<const DotThunkProto*>(
        &_DotThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(DotThunkProto& a, DotThunkProto& b) { a.Swap(&b); }
  inline void Swap(DotThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DotThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DotThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DotThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DotThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DotThunkProto& from) { DotThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DotThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.DotThunkProto"; }

 protected:
  explicit DotThunkProto(::google::protobuf::Arena* arena);
  DotThunkProto(::google::protobuf::Arena* arena, const DotThunkProto& from);
  DotThunkProto(::google::protobuf::Arena* arena, DotThunkProto&& from) noexcept
      : DotThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDotDimensionsFieldNumber = 1,
    kLhsBufferShapeFieldNumber = 2,
    kRhsBufferShapeFieldNumber = 3,
    kOutBufferShapeFieldNumber = 4,
  };
  // .xla.DotDimensionNumbers dot_dimensions = 1;
  bool has_dot_dimensions() const;
  void clear_dot_dimensions() ;
  const ::xla::DotDimensionNumbers& dot_dimensions() const;
  PROTOBUF_NODISCARD ::xla::DotDimensionNumbers* release_dot_dimensions();
  ::xla::DotDimensionNumbers* mutable_dot_dimensions();
  void set_allocated_dot_dimensions(::xla::DotDimensionNumbers* value);
  void unsafe_arena_set_allocated_dot_dimensions(::xla::DotDimensionNumbers* value);
  ::xla::DotDimensionNumbers* unsafe_arena_release_dot_dimensions();

  private:
  const ::xla::DotDimensionNumbers& _internal_dot_dimensions() const;
  ::xla::DotDimensionNumbers* _internal_mutable_dot_dimensions();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto lhs_buffer_shape = 2;
  bool has_lhs_buffer_shape() const;
  void clear_lhs_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& lhs_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_lhs_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_lhs_buffer_shape();
  void set_allocated_lhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_lhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_lhs_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_lhs_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_lhs_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto rhs_buffer_shape = 3;
  bool has_rhs_buffer_shape() const;
  void clear_rhs_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& rhs_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_rhs_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_rhs_buffer_shape();
  void set_allocated_rhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_rhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_rhs_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_rhs_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_rhs_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto out_buffer_shape = 4;
  bool has_out_buffer_shape() const;
  void clear_out_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& out_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_out_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_out_buffer_shape();
  void set_allocated_out_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_out_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_out_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_out_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_out_buffer_shape();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.DotThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DotThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::DotDimensionNumbers* dot_dimensions_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* lhs_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* rhs_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* out_buffer_shape_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CustomCallThunkProto_OpBuffers final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.CustomCallThunkProto.OpBuffers) */ {
 public:
  inline CustomCallThunkProto_OpBuffers() : CustomCallThunkProto_OpBuffers(nullptr) {}
  ~CustomCallThunkProto_OpBuffers() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CustomCallThunkProto_OpBuffers(
      ::google::protobuf::internal::ConstantInitialized);

  inline CustomCallThunkProto_OpBuffers(const CustomCallThunkProto_OpBuffers& from) : CustomCallThunkProto_OpBuffers(nullptr, from) {}
  inline CustomCallThunkProto_OpBuffers(CustomCallThunkProto_OpBuffers&& from) noexcept
      : CustomCallThunkProto_OpBuffers(nullptr, std::move(from)) {}
  inline CustomCallThunkProto_OpBuffers& operator=(const CustomCallThunkProto_OpBuffers& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomCallThunkProto_OpBuffers& operator=(CustomCallThunkProto_OpBuffers&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomCallThunkProto_OpBuffers& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomCallThunkProto_OpBuffers* internal_default_instance() {
    return reinterpret_cast<const CustomCallThunkProto_OpBuffers*>(
        &_CustomCallThunkProto_OpBuffers_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(CustomCallThunkProto_OpBuffers& a, CustomCallThunkProto_OpBuffers& b) { a.Swap(&b); }
  inline void Swap(CustomCallThunkProto_OpBuffers* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomCallThunkProto_OpBuffers* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomCallThunkProto_OpBuffers* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CustomCallThunkProto_OpBuffers>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomCallThunkProto_OpBuffers& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CustomCallThunkProto_OpBuffers& from) { CustomCallThunkProto_OpBuffers::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomCallThunkProto_OpBuffers* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.CustomCallThunkProto.OpBuffers"; }

 protected:
  explicit CustomCallThunkProto_OpBuffers(::google::protobuf::Arena* arena);
  CustomCallThunkProto_OpBuffers(::google::protobuf::Arena* arena, const CustomCallThunkProto_OpBuffers& from);
  CustomCallThunkProto_OpBuffers(::google::protobuf::Arena* arena, CustomCallThunkProto_OpBuffers&& from) noexcept
      : CustomCallThunkProto_OpBuffers(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArgumentsShapesFieldNumber = 1,
    kResultsShapesFieldNumber = 2,
  };
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto arguments_shapes = 1;
  int arguments_shapes_size() const;
  private:
  int _internal_arguments_shapes_size() const;

  public:
  void clear_arguments_shapes() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_arguments_shapes(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_arguments_shapes();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_arguments_shapes() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_arguments_shapes();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& arguments_shapes(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_arguments_shapes();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& arguments_shapes() const;
  // repeated .xla.cpu.ShapeBufferAllocationSliceProto results_shapes = 2;
  int results_shapes_size() const;
  private:
  int _internal_results_shapes_size() const;

  public:
  void clear_results_shapes() ;
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_results_shapes(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* mutable_results_shapes();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& _internal_results_shapes() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* _internal_mutable_results_shapes();
  public:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& results_shapes(int index) const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* add_results_shapes();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& results_shapes() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.CustomCallThunkProto.OpBuffers)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CustomCallThunkProto_OpBuffers& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > arguments_shapes_;
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ShapeBufferAllocationSliceProto > results_shapes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CopyThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.CopyThunkProto) */ {
 public:
  inline CopyThunkProto() : CopyThunkProto(nullptr) {}
  ~CopyThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CopyThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CopyThunkProto(const CopyThunkProto& from) : CopyThunkProto(nullptr, from) {}
  inline CopyThunkProto(CopyThunkProto&& from) noexcept
      : CopyThunkProto(nullptr, std::move(from)) {}
  inline CopyThunkProto& operator=(const CopyThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyThunkProto& operator=(CopyThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyThunkProto* internal_default_instance() {
    return reinterpret_cast<const CopyThunkProto*>(
        &_CopyThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(CopyThunkProto& a, CopyThunkProto& b) { a.Swap(&b); }
  inline void Swap(CopyThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CopyThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CopyThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CopyThunkProto& from) { CopyThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CopyThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.CopyThunkProto"; }

 protected:
  explicit CopyThunkProto(::google::protobuf::Arena* arena);
  CopyThunkProto(::google::protobuf::Arena* arena, const CopyThunkProto& from);
  CopyThunkProto(::google::protobuf::Arena* arena, CopyThunkProto&& from) noexcept
      : CopyThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcBufferShapeFieldNumber = 1,
    kDstBufferShapeFieldNumber = 2,
  };
  // .xla.cpu.ShapeBufferAllocationSliceProto src_buffer_shape = 1;
  bool has_src_buffer_shape() const;
  void clear_src_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& src_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_src_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_src_buffer_shape();
  void set_allocated_src_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_src_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_src_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_src_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_src_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto dst_buffer_shape = 2;
  bool has_dst_buffer_shape() const;
  void clear_dst_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& dst_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_dst_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_dst_buffer_shape();
  void set_allocated_dst_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_dst_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_dst_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_dst_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_dst_buffer_shape();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.CopyThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CopyThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* src_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* dst_buffer_shape_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ConvolutionThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ConvolutionThunkProto) */ {
 public:
  inline ConvolutionThunkProto() : ConvolutionThunkProto(nullptr) {}
  ~ConvolutionThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConvolutionThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConvolutionThunkProto(const ConvolutionThunkProto& from) : ConvolutionThunkProto(nullptr, from) {}
  inline ConvolutionThunkProto(ConvolutionThunkProto&& from) noexcept
      : ConvolutionThunkProto(nullptr, std::move(from)) {}
  inline ConvolutionThunkProto& operator=(const ConvolutionThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvolutionThunkProto& operator=(ConvolutionThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvolutionThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConvolutionThunkProto* internal_default_instance() {
    return reinterpret_cast<const ConvolutionThunkProto*>(
        &_ConvolutionThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ConvolutionThunkProto& a, ConvolutionThunkProto& b) { a.Swap(&b); }
  inline void Swap(ConvolutionThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvolutionThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvolutionThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ConvolutionThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConvolutionThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConvolutionThunkProto& from) { ConvolutionThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConvolutionThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ConvolutionThunkProto"; }

 protected:
  explicit ConvolutionThunkProto(::google::protobuf::Arena* arena);
  ConvolutionThunkProto(::google::protobuf::Arena* arena, const ConvolutionThunkProto& from);
  ConvolutionThunkProto(::google::protobuf::Arena* arena, ConvolutionThunkProto&& from) noexcept
      : ConvolutionThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Options = ConvolutionThunkProto_Options;

  // accessors -------------------------------------------------------
  enum : int {
    kDimensionNumbersFieldNumber = 1,
    kWindowFieldNumber = 2,
    kInputBufferShapeFieldNumber = 4,
    kKernelBufferShapeFieldNumber = 5,
    kOutputBufferShapeFieldNumber = 6,
    kOptionsFieldNumber = 7,
    kFeatureGroupCountFieldNumber = 3,
  };
  // .xla.ConvolutionDimensionNumbers dimension_numbers = 1;
  bool has_dimension_numbers() const;
  void clear_dimension_numbers() ;
  const ::xla::ConvolutionDimensionNumbers& dimension_numbers() const;
  PROTOBUF_NODISCARD ::xla::ConvolutionDimensionNumbers* release_dimension_numbers();
  ::xla::ConvolutionDimensionNumbers* mutable_dimension_numbers();
  void set_allocated_dimension_numbers(::xla::ConvolutionDimensionNumbers* value);
  void unsafe_arena_set_allocated_dimension_numbers(::xla::ConvolutionDimensionNumbers* value);
  ::xla::ConvolutionDimensionNumbers* unsafe_arena_release_dimension_numbers();

  private:
  const ::xla::ConvolutionDimensionNumbers& _internal_dimension_numbers() const;
  ::xla::ConvolutionDimensionNumbers* _internal_mutable_dimension_numbers();

  public:
  // .xla.Window window = 2;
  bool has_window() const;
  void clear_window() ;
  const ::xla::Window& window() const;
  PROTOBUF_NODISCARD ::xla::Window* release_window();
  ::xla::Window* mutable_window();
  void set_allocated_window(::xla::Window* value);
  void unsafe_arena_set_allocated_window(::xla::Window* value);
  ::xla::Window* unsafe_arena_release_window();

  private:
  const ::xla::Window& _internal_window() const;
  ::xla::Window* _internal_mutable_window();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto input_buffer_shape = 4;
  bool has_input_buffer_shape() const;
  void clear_input_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& input_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_input_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_input_buffer_shape();
  void set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_input_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_input_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_input_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto kernel_buffer_shape = 5;
  bool has_kernel_buffer_shape() const;
  void clear_kernel_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& kernel_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_kernel_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_kernel_buffer_shape();
  void set_allocated_kernel_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_kernel_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_kernel_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_kernel_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_kernel_buffer_shape();

  public:
  // .xla.cpu.ShapeBufferAllocationSliceProto output_buffer_shape = 6;
  bool has_output_buffer_shape() const;
  void clear_output_buffer_shape() ;
  const ::xla::cpu::ShapeBufferAllocationSliceProto& output_buffer_shape() const;
  PROTOBUF_NODISCARD ::xla::cpu::ShapeBufferAllocationSliceProto* release_output_buffer_shape();
  ::xla::cpu::ShapeBufferAllocationSliceProto* mutable_output_buffer_shape();
  void set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value);
  ::xla::cpu::ShapeBufferAllocationSliceProto* unsafe_arena_release_output_buffer_shape();

  private:
  const ::xla::cpu::ShapeBufferAllocationSliceProto& _internal_output_buffer_shape() const;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _internal_mutable_output_buffer_shape();

  public:
  // .xla.cpu.ConvolutionThunkProto.Options options = 7;
  bool has_options() const;
  void clear_options() ;
  const ::xla::cpu::ConvolutionThunkProto_Options& options() const;
  PROTOBUF_NODISCARD ::xla::cpu::ConvolutionThunkProto_Options* release_options();
  ::xla::cpu::ConvolutionThunkProto_Options* mutable_options();
  void set_allocated_options(::xla::cpu::ConvolutionThunkProto_Options* value);
  void unsafe_arena_set_allocated_options(::xla::cpu::ConvolutionThunkProto_Options* value);
  ::xla::cpu::ConvolutionThunkProto_Options* unsafe_arena_release_options();

  private:
  const ::xla::cpu::ConvolutionThunkProto_Options& _internal_options() const;
  ::xla::cpu::ConvolutionThunkProto_Options* _internal_mutable_options();

  public:
  // int64 feature_group_count = 3;
  void clear_feature_group_count() ;
  ::int64_t feature_group_count() const;
  void set_feature_group_count(::int64_t value);

  private:
  ::int64_t _internal_feature_group_count() const;
  void _internal_set_feature_group_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ConvolutionThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 6,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConvolutionThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::ConvolutionDimensionNumbers* dimension_numbers_;
    ::xla::Window* window_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* input_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* kernel_buffer_shape_;
    ::xla::cpu::ShapeBufferAllocationSliceProto* output_buffer_shape_;
    ::xla::cpu::ConvolutionThunkProto_Options* options_;
    ::int64_t feature_group_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT XnnFusionThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.XnnFusionThunkProto) */ {
 public:
  inline XnnFusionThunkProto() : XnnFusionThunkProto(nullptr) {}
  ~XnnFusionThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XnnFusionThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline XnnFusionThunkProto(const XnnFusionThunkProto& from) : XnnFusionThunkProto(nullptr, from) {}
  inline XnnFusionThunkProto(XnnFusionThunkProto&& from) noexcept
      : XnnFusionThunkProto(nullptr, std::move(from)) {}
  inline XnnFusionThunkProto& operator=(const XnnFusionThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline XnnFusionThunkProto& operator=(XnnFusionThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XnnFusionThunkProto& default_instance() {
    return *internal_default_instance();
  }
  enum ImplCase {
    kXnnDotThunk = 2,
    kXnnConvolutionThunk = 3,
    kXnnFusionThunk = 4,
    IMPL_NOT_SET = 0,
  };
  static inline const XnnFusionThunkProto* internal_default_instance() {
    return reinterpret_cast<const XnnFusionThunkProto*>(
        &_XnnFusionThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(XnnFusionThunkProto& a, XnnFusionThunkProto& b) { a.Swap(&b); }
  inline void Swap(XnnFusionThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XnnFusionThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XnnFusionThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<XnnFusionThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XnnFusionThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XnnFusionThunkProto& from) { XnnFusionThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XnnFusionThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.XnnFusionThunkProto"; }

 protected:
  explicit XnnFusionThunkProto(::google::protobuf::Arena* arena);
  XnnFusionThunkProto(::google::protobuf::Arena* arena, const XnnFusionThunkProto& from);
  XnnFusionThunkProto(::google::protobuf::Arena* arena, XnnFusionThunkProto&& from) noexcept
      : XnnFusionThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOptionsFieldNumber = 1,
    kXnnDotThunkFieldNumber = 2,
    kXnnConvolutionThunkFieldNumber = 3,
    kXnnFusionThunkFieldNumber = 4,
  };
  // .xla.cpu.XnnFusionBackendConfig options = 1;
  bool has_options() const;
  void clear_options() ;
  const ::xla::cpu::XnnFusionBackendConfig& options() const;
  PROTOBUF_NODISCARD ::xla::cpu::XnnFusionBackendConfig* release_options();
  ::xla::cpu::XnnFusionBackendConfig* mutable_options();
  void set_allocated_options(::xla::cpu::XnnFusionBackendConfig* value);
  void unsafe_arena_set_allocated_options(::xla::cpu::XnnFusionBackendConfig* value);
  ::xla::cpu::XnnFusionBackendConfig* unsafe_arena_release_options();

  private:
  const ::xla::cpu::XnnFusionBackendConfig& _internal_options() const;
  ::xla::cpu::XnnFusionBackendConfig* _internal_mutable_options();

  public:
  // .xla.cpu.XnnDotThunkProto xnn_dot_thunk = 2;
  bool has_xnn_dot_thunk() const;
  private:
  bool _internal_has_xnn_dot_thunk() const;

  public:
  void clear_xnn_dot_thunk() ;
  const ::xla::cpu::XnnDotThunkProto& xnn_dot_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::XnnDotThunkProto* release_xnn_dot_thunk();
  ::xla::cpu::XnnDotThunkProto* mutable_xnn_dot_thunk();
  void set_allocated_xnn_dot_thunk(::xla::cpu::XnnDotThunkProto* value);
  void unsafe_arena_set_allocated_xnn_dot_thunk(::xla::cpu::XnnDotThunkProto* value);
  ::xla::cpu::XnnDotThunkProto* unsafe_arena_release_xnn_dot_thunk();

  private:
  const ::xla::cpu::XnnDotThunkProto& _internal_xnn_dot_thunk() const;
  ::xla::cpu::XnnDotThunkProto* _internal_mutable_xnn_dot_thunk();

  public:
  // .xla.cpu.XnnConvolutionThunkProto xnn_convolution_thunk = 3;
  bool has_xnn_convolution_thunk() const;
  private:
  bool _internal_has_xnn_convolution_thunk() const;

  public:
  void clear_xnn_convolution_thunk() ;
  const ::xla::cpu::XnnConvolutionThunkProto& xnn_convolution_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::XnnConvolutionThunkProto* release_xnn_convolution_thunk();
  ::xla::cpu::XnnConvolutionThunkProto* mutable_xnn_convolution_thunk();
  void set_allocated_xnn_convolution_thunk(::xla::cpu::XnnConvolutionThunkProto* value);
  void unsafe_arena_set_allocated_xnn_convolution_thunk(::xla::cpu::XnnConvolutionThunkProto* value);
  ::xla::cpu::XnnConvolutionThunkProto* unsafe_arena_release_xnn_convolution_thunk();

  private:
  const ::xla::cpu::XnnConvolutionThunkProto& _internal_xnn_convolution_thunk() const;
  ::xla::cpu::XnnConvolutionThunkProto* _internal_mutable_xnn_convolution_thunk();

  public:
  // .xla.cpu.XnnFusionThunkProtoImpl xnn_fusion_thunk = 4;
  bool has_xnn_fusion_thunk() const;
  private:
  bool _internal_has_xnn_fusion_thunk() const;

  public:
  void clear_xnn_fusion_thunk() ;
  const ::xla::cpu::XnnFusionThunkProtoImpl& xnn_fusion_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::XnnFusionThunkProtoImpl* release_xnn_fusion_thunk();
  ::xla::cpu::XnnFusionThunkProtoImpl* mutable_xnn_fusion_thunk();
  void set_allocated_xnn_fusion_thunk(::xla::cpu::XnnFusionThunkProtoImpl* value);
  void unsafe_arena_set_allocated_xnn_fusion_thunk(::xla::cpu::XnnFusionThunkProtoImpl* value);
  ::xla::cpu::XnnFusionThunkProtoImpl* unsafe_arena_release_xnn_fusion_thunk();

  private:
  const ::xla::cpu::XnnFusionThunkProtoImpl& _internal_xnn_fusion_thunk() const;
  ::xla::cpu::XnnFusionThunkProtoImpl* _internal_mutable_xnn_fusion_thunk();

  public:
  void clear_impl();
  ImplCase impl_case() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.XnnFusionThunkProto)
 private:
  class _Internal;
  void set_has_xnn_dot_thunk();
  void set_has_xnn_convolution_thunk();
  void set_has_xnn_fusion_thunk();
  inline bool has_impl() const;
  inline void clear_has_impl();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const XnnFusionThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::XnnFusionBackendConfig* options_;
    union ImplUnion {
      constexpr ImplUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::xla::cpu::XnnDotThunkProto* xnn_dot_thunk_;
      ::xla::cpu::XnnConvolutionThunkProto* xnn_convolution_thunk_;
      ::xla::cpu::XnnFusionThunkProtoImpl* xnn_fusion_thunk_;
    } impl_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CustomCallThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.CustomCallThunkProto) */ {
 public:
  inline CustomCallThunkProto() : CustomCallThunkProto(nullptr) {}
  ~CustomCallThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CustomCallThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CustomCallThunkProto(const CustomCallThunkProto& from) : CustomCallThunkProto(nullptr, from) {}
  inline CustomCallThunkProto(CustomCallThunkProto&& from) noexcept
      : CustomCallThunkProto(nullptr, std::move(from)) {}
  inline CustomCallThunkProto& operator=(const CustomCallThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomCallThunkProto& operator=(CustomCallThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomCallThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomCallThunkProto* internal_default_instance() {
    return reinterpret_cast<const CustomCallThunkProto*>(
        &_CustomCallThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(CustomCallThunkProto& a, CustomCallThunkProto& b) { a.Swap(&b); }
  inline void Swap(CustomCallThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomCallThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomCallThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CustomCallThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomCallThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CustomCallThunkProto& from) { CustomCallThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomCallThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.CustomCallThunkProto"; }

 protected:
  explicit CustomCallThunkProto(::google::protobuf::Arena* arena);
  CustomCallThunkProto(::google::protobuf::Arena* arena, const CustomCallThunkProto& from);
  CustomCallThunkProto(::google::protobuf::Arena* arena, CustomCallThunkProto&& from) noexcept
      : CustomCallThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OpBuffers = CustomCallThunkProto_OpBuffers;

  // accessors -------------------------------------------------------
  enum : int {
    kTargetNameFieldNumber = 2,
    kBackendConfigFieldNumber = 3,
    kOpBuffersFieldNumber = 4,
    kApiVersionFieldNumber = 1,
  };
  // string target_name = 2;
  void clear_target_name() ;
  const std::string& target_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_name(Arg_&& arg, Args_... args);
  std::string* mutable_target_name();
  PROTOBUF_NODISCARD std::string* release_target_name();
  void set_allocated_target_name(std::string* value);

  private:
  const std::string& _internal_target_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_name(
      const std::string& value);
  std::string* _internal_mutable_target_name();

  public:
  // string backend_config = 3;
  void clear_backend_config() ;
  const std::string& backend_config() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_backend_config(Arg_&& arg, Args_... args);
  std::string* mutable_backend_config();
  PROTOBUF_NODISCARD std::string* release_backend_config();
  void set_allocated_backend_config(std::string* value);

  private:
  const std::string& _internal_backend_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backend_config(
      const std::string& value);
  std::string* _internal_mutable_backend_config();

  public:
  // .xla.cpu.CustomCallThunkProto.OpBuffers op_buffers = 4;
  bool has_op_buffers() const;
  void clear_op_buffers() ;
  const ::xla::cpu::CustomCallThunkProto_OpBuffers& op_buffers() const;
  PROTOBUF_NODISCARD ::xla::cpu::CustomCallThunkProto_OpBuffers* release_op_buffers();
  ::xla::cpu::CustomCallThunkProto_OpBuffers* mutable_op_buffers();
  void set_allocated_op_buffers(::xla::cpu::CustomCallThunkProto_OpBuffers* value);
  void unsafe_arena_set_allocated_op_buffers(::xla::cpu::CustomCallThunkProto_OpBuffers* value);
  ::xla::cpu::CustomCallThunkProto_OpBuffers* unsafe_arena_release_op_buffers();

  private:
  const ::xla::cpu::CustomCallThunkProto_OpBuffers& _internal_op_buffers() const;
  ::xla::cpu::CustomCallThunkProto_OpBuffers* _internal_mutable_op_buffers();

  public:
  // .xla.CustomCallApiVersion api_version = 1;
  void clear_api_version() ;
  ::xla::CustomCallApiVersion api_version() const;
  void set_api_version(::xla::CustomCallApiVersion value);

  private:
  ::xla::CustomCallApiVersion _internal_api_version() const;
  void _internal_set_api_version(::xla::CustomCallApiVersion value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.CustomCallThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      62, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CustomCallThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr target_name_;
    ::google::protobuf::internal::ArenaStringPtr backend_config_;
    ::xla::cpu::CustomCallThunkProto_OpBuffers* op_buffers_;
    int api_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectiveThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.CollectiveThunkProto) */ {
 public:
  inline CollectiveThunkProto() : CollectiveThunkProto(nullptr) {}
  ~CollectiveThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectiveThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectiveThunkProto(const CollectiveThunkProto& from) : CollectiveThunkProto(nullptr, from) {}
  inline CollectiveThunkProto(CollectiveThunkProto&& from) noexcept
      : CollectiveThunkProto(nullptr, std::move(from)) {}
  inline CollectiveThunkProto& operator=(const CollectiveThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectiveThunkProto& operator=(CollectiveThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectiveThunkProto& default_instance() {
    return *internal_default_instance();
  }
  enum ImplCase {
    kAllGatherThunk = 4,
    kAllReduceThunk = 5,
    kAllToAllThunk = 6,
    kReduceScatterThunk = 7,
    kCollectivePermuteThunk = 8,
    IMPL_NOT_SET = 0,
  };
  static inline const CollectiveThunkProto* internal_default_instance() {
    return reinterpret_cast<const CollectiveThunkProto*>(
        &_CollectiveThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(CollectiveThunkProto& a, CollectiveThunkProto& b) { a.Swap(&b); }
  inline void Swap(CollectiveThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectiveThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectiveThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectiveThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectiveThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectiveThunkProto& from) { CollectiveThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectiveThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.CollectiveThunkProto"; }

 protected:
  explicit CollectiveThunkProto(::google::protobuf::Arena* arena);
  CollectiveThunkProto(::google::protobuf::Arena* arena, const CollectiveThunkProto& from);
  CollectiveThunkProto(::google::protobuf::Arena* arena, CollectiveThunkProto&& from) noexcept
      : CollectiveThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpParamsFieldNumber = 1,
    kOpBuffersFieldNumber = 2,
    kOpResourcesFieldNumber = 3,
    kAllGatherThunkFieldNumber = 4,
    kAllReduceThunkFieldNumber = 5,
    kAllToAllThunkFieldNumber = 6,
    kReduceScatterThunkFieldNumber = 7,
    kCollectivePermuteThunkFieldNumber = 8,
  };
  // .xla.cpu.OpParamsProto op_params = 1;
  bool has_op_params() const;
  void clear_op_params() ;
  const ::xla::cpu::OpParamsProto& op_params() const;
  PROTOBUF_NODISCARD ::xla::cpu::OpParamsProto* release_op_params();
  ::xla::cpu::OpParamsProto* mutable_op_params();
  void set_allocated_op_params(::xla::cpu::OpParamsProto* value);
  void unsafe_arena_set_allocated_op_params(::xla::cpu::OpParamsProto* value);
  ::xla::cpu::OpParamsProto* unsafe_arena_release_op_params();

  private:
  const ::xla::cpu::OpParamsProto& _internal_op_params() const;
  ::xla::cpu::OpParamsProto* _internal_mutable_op_params();

  public:
  // .xla.cpu.OpBuffersProto op_buffers = 2;
  bool has_op_buffers() const;
  void clear_op_buffers() ;
  const ::xla::cpu::OpBuffersProto& op_buffers() const;
  PROTOBUF_NODISCARD ::xla::cpu::OpBuffersProto* release_op_buffers();
  ::xla::cpu::OpBuffersProto* mutable_op_buffers();
  void set_allocated_op_buffers(::xla::cpu::OpBuffersProto* value);
  void unsafe_arena_set_allocated_op_buffers(::xla::cpu::OpBuffersProto* value);
  ::xla::cpu::OpBuffersProto* unsafe_arena_release_op_buffers();

  private:
  const ::xla::cpu::OpBuffersProto& _internal_op_buffers() const;
  ::xla::cpu::OpBuffersProto* _internal_mutable_op_buffers();

  public:
  // .xla.cpu.OpResourcesProto op_resources = 3;
  bool has_op_resources() const;
  void clear_op_resources() ;
  const ::xla::cpu::OpResourcesProto& op_resources() const;
  PROTOBUF_NODISCARD ::xla::cpu::OpResourcesProto* release_op_resources();
  ::xla::cpu::OpResourcesProto* mutable_op_resources();
  void set_allocated_op_resources(::xla::cpu::OpResourcesProto* value);
  void unsafe_arena_set_allocated_op_resources(::xla::cpu::OpResourcesProto* value);
  ::xla::cpu::OpResourcesProto* unsafe_arena_release_op_resources();

  private:
  const ::xla::cpu::OpResourcesProto& _internal_op_resources() const;
  ::xla::cpu::OpResourcesProto* _internal_mutable_op_resources();

  public:
  // .xla.cpu.AllGatherThunkProto all_gather_thunk = 4;
  bool has_all_gather_thunk() const;
  private:
  bool _internal_has_all_gather_thunk() const;

  public:
  void clear_all_gather_thunk() ;
  const ::xla::cpu::AllGatherThunkProto& all_gather_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::AllGatherThunkProto* release_all_gather_thunk();
  ::xla::cpu::AllGatherThunkProto* mutable_all_gather_thunk();
  void set_allocated_all_gather_thunk(::xla::cpu::AllGatherThunkProto* value);
  void unsafe_arena_set_allocated_all_gather_thunk(::xla::cpu::AllGatherThunkProto* value);
  ::xla::cpu::AllGatherThunkProto* unsafe_arena_release_all_gather_thunk();

  private:
  const ::xla::cpu::AllGatherThunkProto& _internal_all_gather_thunk() const;
  ::xla::cpu::AllGatherThunkProto* _internal_mutable_all_gather_thunk();

  public:
  // .xla.cpu.AllReduceThunkProto all_reduce_thunk = 5;
  bool has_all_reduce_thunk() const;
  private:
  bool _internal_has_all_reduce_thunk() const;

  public:
  void clear_all_reduce_thunk() ;
  const ::xla::cpu::AllReduceThunkProto& all_reduce_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::AllReduceThunkProto* release_all_reduce_thunk();
  ::xla::cpu::AllReduceThunkProto* mutable_all_reduce_thunk();
  void set_allocated_all_reduce_thunk(::xla::cpu::AllReduceThunkProto* value);
  void unsafe_arena_set_allocated_all_reduce_thunk(::xla::cpu::AllReduceThunkProto* value);
  ::xla::cpu::AllReduceThunkProto* unsafe_arena_release_all_reduce_thunk();

  private:
  const ::xla::cpu::AllReduceThunkProto& _internal_all_reduce_thunk() const;
  ::xla::cpu::AllReduceThunkProto* _internal_mutable_all_reduce_thunk();

  public:
  // .xla.cpu.AllToAllThunkProto all_to_all_thunk = 6;
  bool has_all_to_all_thunk() const;
  private:
  bool _internal_has_all_to_all_thunk() const;

  public:
  void clear_all_to_all_thunk() ;
  const ::xla::cpu::AllToAllThunkProto& all_to_all_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::AllToAllThunkProto* release_all_to_all_thunk();
  ::xla::cpu::AllToAllThunkProto* mutable_all_to_all_thunk();
  void set_allocated_all_to_all_thunk(::xla::cpu::AllToAllThunkProto* value);
  void unsafe_arena_set_allocated_all_to_all_thunk(::xla::cpu::AllToAllThunkProto* value);
  ::xla::cpu::AllToAllThunkProto* unsafe_arena_release_all_to_all_thunk();

  private:
  const ::xla::cpu::AllToAllThunkProto& _internal_all_to_all_thunk() const;
  ::xla::cpu::AllToAllThunkProto* _internal_mutable_all_to_all_thunk();

  public:
  // .xla.cpu.ReduceScatterThunkProto reduce_scatter_thunk = 7;
  bool has_reduce_scatter_thunk() const;
  private:
  bool _internal_has_reduce_scatter_thunk() const;

  public:
  void clear_reduce_scatter_thunk() ;
  const ::xla::cpu::ReduceScatterThunkProto& reduce_scatter_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::ReduceScatterThunkProto* release_reduce_scatter_thunk();
  ::xla::cpu::ReduceScatterThunkProto* mutable_reduce_scatter_thunk();
  void set_allocated_reduce_scatter_thunk(::xla::cpu::ReduceScatterThunkProto* value);
  void unsafe_arena_set_allocated_reduce_scatter_thunk(::xla::cpu::ReduceScatterThunkProto* value);
  ::xla::cpu::ReduceScatterThunkProto* unsafe_arena_release_reduce_scatter_thunk();

  private:
  const ::xla::cpu::ReduceScatterThunkProto& _internal_reduce_scatter_thunk() const;
  ::xla::cpu::ReduceScatterThunkProto* _internal_mutable_reduce_scatter_thunk();

  public:
  // .xla.cpu.CollectivePermuteThunkProto collective_permute_thunk = 8;
  bool has_collective_permute_thunk() const;
  private:
  bool _internal_has_collective_permute_thunk() const;

  public:
  void clear_collective_permute_thunk() ;
  const ::xla::cpu::CollectivePermuteThunkProto& collective_permute_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::CollectivePermuteThunkProto* release_collective_permute_thunk();
  ::xla::cpu::CollectivePermuteThunkProto* mutable_collective_permute_thunk();
  void set_allocated_collective_permute_thunk(::xla::cpu::CollectivePermuteThunkProto* value);
  void unsafe_arena_set_allocated_collective_permute_thunk(::xla::cpu::CollectivePermuteThunkProto* value);
  ::xla::cpu::CollectivePermuteThunkProto* unsafe_arena_release_collective_permute_thunk();

  private:
  const ::xla::cpu::CollectivePermuteThunkProto& _internal_collective_permute_thunk() const;
  ::xla::cpu::CollectivePermuteThunkProto* _internal_mutable_collective_permute_thunk();

  public:
  void clear_impl();
  ImplCase impl_case() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.CollectiveThunkProto)
 private:
  class _Internal;
  void set_has_all_gather_thunk();
  void set_has_all_reduce_thunk();
  void set_has_all_to_all_thunk();
  void set_has_reduce_scatter_thunk();
  void set_has_collective_permute_thunk();
  inline bool has_impl() const;
  inline void clear_has_impl();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 8,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectiveThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::OpParamsProto* op_params_;
    ::xla::cpu::OpBuffersProto* op_buffers_;
    ::xla::cpu::OpResourcesProto* op_resources_;
    union ImplUnion {
      constexpr ImplUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::xla::cpu::AllGatherThunkProto* all_gather_thunk_;
      ::xla::cpu::AllReduceThunkProto* all_reduce_thunk_;
      ::xla::cpu::AllToAllThunkProto* all_to_all_thunk_;
      ::xla::cpu::ReduceScatterThunkProto* reduce_scatter_thunk_;
      ::xla::cpu::CollectivePermuteThunkProto* collective_permute_thunk_;
    } impl_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CallThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.CallThunkProto) */ {
 public:
  inline CallThunkProto() : CallThunkProto(nullptr) {}
  ~CallThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CallThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CallThunkProto(const CallThunkProto& from) : CallThunkProto(nullptr, from) {}
  inline CallThunkProto(CallThunkProto&& from) noexcept
      : CallThunkProto(nullptr, std::move(from)) {}
  inline CallThunkProto& operator=(const CallThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallThunkProto& operator=(CallThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallThunkProto* internal_default_instance() {
    return reinterpret_cast<const CallThunkProto*>(
        &_CallThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(CallThunkProto& a, CallThunkProto& b) { a.Swap(&b); }
  inline void Swap(CallThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CallThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CallThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CallThunkProto& from) { CallThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CallThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.CallThunkProto"; }

 protected:
  explicit CallThunkProto(::google::protobuf::Arena* arena);
  CallThunkProto(::google::protobuf::Arena* arena, const CallThunkProto& from);
  CallThunkProto(::google::protobuf::Arena* arena, CallThunkProto&& from) noexcept
      : CallThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCalledSequenceFieldNumber = 1,
  };
  // .xla.cpu.ThunkSequenceProto called_sequence = 1;
  bool has_called_sequence() const;
  void clear_called_sequence() ;
  const ::xla::cpu::ThunkSequenceProto& called_sequence() const;
  PROTOBUF_NODISCARD ::xla::cpu::ThunkSequenceProto* release_called_sequence();
  ::xla::cpu::ThunkSequenceProto* mutable_called_sequence();
  void set_allocated_called_sequence(::xla::cpu::ThunkSequenceProto* value);
  void unsafe_arena_set_allocated_called_sequence(::xla::cpu::ThunkSequenceProto* value);
  ::xla::cpu::ThunkSequenceProto* unsafe_arena_release_called_sequence();

  private:
  const ::xla::cpu::ThunkSequenceProto& _internal_called_sequence() const;
  ::xla::cpu::ThunkSequenceProto* _internal_mutable_called_sequence();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.CallThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CallThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::ThunkSequenceProto* called_sequence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ConditionalThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ConditionalThunkProto) */ {
 public:
  inline ConditionalThunkProto() : ConditionalThunkProto(nullptr) {}
  ~ConditionalThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConditionalThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConditionalThunkProto(const ConditionalThunkProto& from) : ConditionalThunkProto(nullptr, from) {}
  inline ConditionalThunkProto(ConditionalThunkProto&& from) noexcept
      : ConditionalThunkProto(nullptr, std::move(from)) {}
  inline ConditionalThunkProto& operator=(const ConditionalThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionalThunkProto& operator=(ConditionalThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConditionalThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConditionalThunkProto* internal_default_instance() {
    return reinterpret_cast<const ConditionalThunkProto*>(
        &_ConditionalThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ConditionalThunkProto& a, ConditionalThunkProto& b) { a.Swap(&b); }
  inline void Swap(ConditionalThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConditionalThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConditionalThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ConditionalThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConditionalThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConditionalThunkProto& from) { ConditionalThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConditionalThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ConditionalThunkProto"; }

 protected:
  explicit ConditionalThunkProto(::google::protobuf::Arena* arena);
  ConditionalThunkProto(::google::protobuf::Arena* arena, const ConditionalThunkProto& from);
  ConditionalThunkProto(::google::protobuf::Arena* arena, ConditionalThunkProto&& from) noexcept
      : ConditionalThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBranchSequencesFieldNumber = 1,
    kBranchIndexBufferFieldNumber = 2,
  };
  // repeated .xla.cpu.ThunkSequenceProto branch_sequences = 1;
  int branch_sequences_size() const;
  private:
  int _internal_branch_sequences_size() const;

  public:
  void clear_branch_sequences() ;
  ::xla::cpu::ThunkSequenceProto* mutable_branch_sequences(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto>* mutable_branch_sequences();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto>& _internal_branch_sequences() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto>* _internal_mutable_branch_sequences();
  public:
  const ::xla::cpu::ThunkSequenceProto& branch_sequences(int index) const;
  ::xla::cpu::ThunkSequenceProto* add_branch_sequences();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto>& branch_sequences() const;
  // .xla.buffer_assignment.BufferAllocationSliceProto branch_index_buffer = 2;
  bool has_branch_index_buffer() const;
  void clear_branch_index_buffer() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& branch_index_buffer() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_branch_index_buffer();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_branch_index_buffer();
  void set_allocated_branch_index_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_branch_index_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_branch_index_buffer();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_branch_index_buffer() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_branch_index_buffer();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.ConditionalThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConditionalThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ThunkSequenceProto > branch_sequences_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* branch_index_buffer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ThunkProto) */ {
 public:
  inline ThunkProto() : ThunkProto(nullptr) {}
  ~ThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ThunkProto(const ThunkProto& from) : ThunkProto(nullptr, from) {}
  inline ThunkProto(ThunkProto&& from) noexcept
      : ThunkProto(nullptr, std::move(from)) {}
  inline ThunkProto& operator=(const ThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThunkProto& operator=(ThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThunkProto& default_instance() {
    return *internal_default_instance();
  }
  enum ImplCase {
    kCallThunk = 3,
    kConditionalThunk = 4,
    kSortThunk = 5,
    kXnnFusionThunk = 6,
    kDotThunk = 7,
    kRngGetAndUpdateStateThunk = 8,
    kTopKThunk = 9,
    kWhileThunk = 10,
    kKernelThunk = 11,
    kCopyThunk = 12,
    kFftThunk = 13,
    kInfeedThunk = 14,
    kOutfeedThunk = 15,
    kCustomCallThunk = 16,
    kConvolutionThunk = 17,
    kCollectiveThunk = 18,
    kPartitionIdThunk = 19,
    kReplicaIdThunk = 20,
    IMPL_NOT_SET = 0,
  };
  static inline const ThunkProto* internal_default_instance() {
    return reinterpret_cast<const ThunkProto*>(
        &_ThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(ThunkProto& a, ThunkProto& b) { a.Swap(&b); }
  inline void Swap(ThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ThunkProto& from) { ThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ThunkProto"; }

 protected:
  explicit ThunkProto(::google::protobuf::Arena* arena);
  ThunkProto(::google::protobuf::Arena* arena, const ThunkProto& from);
  ThunkProto(::google::protobuf::Arena* arena, ThunkProto&& from) noexcept
      : ThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKindFieldNumber = 1,
    kInfoFieldNumber = 2,
    kCallThunkFieldNumber = 3,
    kConditionalThunkFieldNumber = 4,
    kSortThunkFieldNumber = 5,
    kXnnFusionThunkFieldNumber = 6,
    kDotThunkFieldNumber = 7,
    kRngGetAndUpdateStateThunkFieldNumber = 8,
    kTopKThunkFieldNumber = 9,
    kWhileThunkFieldNumber = 10,
    kKernelThunkFieldNumber = 11,
    kCopyThunkFieldNumber = 12,
    kFftThunkFieldNumber = 13,
    kInfeedThunkFieldNumber = 14,
    kOutfeedThunkFieldNumber = 15,
    kCustomCallThunkFieldNumber = 16,
    kConvolutionThunkFieldNumber = 17,
    kCollectiveThunkFieldNumber = 18,
    kPartitionIdThunkFieldNumber = 19,
    kReplicaIdThunkFieldNumber = 20,
  };
  // string kind = 1;
  void clear_kind() ;
  const std::string& kind() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_kind(Arg_&& arg, Args_... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* value);

  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(
      const std::string& value);
  std::string* _internal_mutable_kind();

  public:
  // .xla.cpu.InfoProto info = 2;
  bool has_info() const;
  void clear_info() ;
  const ::xla::cpu::InfoProto& info() const;
  PROTOBUF_NODISCARD ::xla::cpu::InfoProto* release_info();
  ::xla::cpu::InfoProto* mutable_info();
  void set_allocated_info(::xla::cpu::InfoProto* value);
  void unsafe_arena_set_allocated_info(::xla::cpu::InfoProto* value);
  ::xla::cpu::InfoProto* unsafe_arena_release_info();

  private:
  const ::xla::cpu::InfoProto& _internal_info() const;
  ::xla::cpu::InfoProto* _internal_mutable_info();

  public:
  // .xla.cpu.CallThunkProto call_thunk = 3;
  bool has_call_thunk() const;
  private:
  bool _internal_has_call_thunk() const;

  public:
  void clear_call_thunk() ;
  const ::xla::cpu::CallThunkProto& call_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::CallThunkProto* release_call_thunk();
  ::xla::cpu::CallThunkProto* mutable_call_thunk();
  void set_allocated_call_thunk(::xla::cpu::CallThunkProto* value);
  void unsafe_arena_set_allocated_call_thunk(::xla::cpu::CallThunkProto* value);
  ::xla::cpu::CallThunkProto* unsafe_arena_release_call_thunk();

  private:
  const ::xla::cpu::CallThunkProto& _internal_call_thunk() const;
  ::xla::cpu::CallThunkProto* _internal_mutable_call_thunk();

  public:
  // .xla.cpu.ConditionalThunkProto conditional_thunk = 4;
  bool has_conditional_thunk() const;
  private:
  bool _internal_has_conditional_thunk() const;

  public:
  void clear_conditional_thunk() ;
  const ::xla::cpu::ConditionalThunkProto& conditional_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::ConditionalThunkProto* release_conditional_thunk();
  ::xla::cpu::ConditionalThunkProto* mutable_conditional_thunk();
  void set_allocated_conditional_thunk(::xla::cpu::ConditionalThunkProto* value);
  void unsafe_arena_set_allocated_conditional_thunk(::xla::cpu::ConditionalThunkProto* value);
  ::xla::cpu::ConditionalThunkProto* unsafe_arena_release_conditional_thunk();

  private:
  const ::xla::cpu::ConditionalThunkProto& _internal_conditional_thunk() const;
  ::xla::cpu::ConditionalThunkProto* _internal_mutable_conditional_thunk();

  public:
  // .xla.cpu.SortThunkProto sort_thunk = 5;
  bool has_sort_thunk() const;
  private:
  bool _internal_has_sort_thunk() const;

  public:
  void clear_sort_thunk() ;
  const ::xla::cpu::SortThunkProto& sort_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::SortThunkProto* release_sort_thunk();
  ::xla::cpu::SortThunkProto* mutable_sort_thunk();
  void set_allocated_sort_thunk(::xla::cpu::SortThunkProto* value);
  void unsafe_arena_set_allocated_sort_thunk(::xla::cpu::SortThunkProto* value);
  ::xla::cpu::SortThunkProto* unsafe_arena_release_sort_thunk();

  private:
  const ::xla::cpu::SortThunkProto& _internal_sort_thunk() const;
  ::xla::cpu::SortThunkProto* _internal_mutable_sort_thunk();

  public:
  // .xla.cpu.XnnFusionThunkProto xnn_fusion_thunk = 6;
  bool has_xnn_fusion_thunk() const;
  private:
  bool _internal_has_xnn_fusion_thunk() const;

  public:
  void clear_xnn_fusion_thunk() ;
  const ::xla::cpu::XnnFusionThunkProto& xnn_fusion_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::XnnFusionThunkProto* release_xnn_fusion_thunk();
  ::xla::cpu::XnnFusionThunkProto* mutable_xnn_fusion_thunk();
  void set_allocated_xnn_fusion_thunk(::xla::cpu::XnnFusionThunkProto* value);
  void unsafe_arena_set_allocated_xnn_fusion_thunk(::xla::cpu::XnnFusionThunkProto* value);
  ::xla::cpu::XnnFusionThunkProto* unsafe_arena_release_xnn_fusion_thunk();

  private:
  const ::xla::cpu::XnnFusionThunkProto& _internal_xnn_fusion_thunk() const;
  ::xla::cpu::XnnFusionThunkProto* _internal_mutable_xnn_fusion_thunk();

  public:
  // .xla.cpu.DotThunkProto dot_thunk = 7;
  bool has_dot_thunk() const;
  private:
  bool _internal_has_dot_thunk() const;

  public:
  void clear_dot_thunk() ;
  const ::xla::cpu::DotThunkProto& dot_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::DotThunkProto* release_dot_thunk();
  ::xla::cpu::DotThunkProto* mutable_dot_thunk();
  void set_allocated_dot_thunk(::xla::cpu::DotThunkProto* value);
  void unsafe_arena_set_allocated_dot_thunk(::xla::cpu::DotThunkProto* value);
  ::xla::cpu::DotThunkProto* unsafe_arena_release_dot_thunk();

  private:
  const ::xla::cpu::DotThunkProto& _internal_dot_thunk() const;
  ::xla::cpu::DotThunkProto* _internal_mutable_dot_thunk();

  public:
  // .xla.cpu.RngGetAndUpdateStateThunkProto rng_get_and_update_state_thunk = 8;
  bool has_rng_get_and_update_state_thunk() const;
  private:
  bool _internal_has_rng_get_and_update_state_thunk() const;

  public:
  void clear_rng_get_and_update_state_thunk() ;
  const ::xla::cpu::RngGetAndUpdateStateThunkProto& rng_get_and_update_state_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::RngGetAndUpdateStateThunkProto* release_rng_get_and_update_state_thunk();
  ::xla::cpu::RngGetAndUpdateStateThunkProto* mutable_rng_get_and_update_state_thunk();
  void set_allocated_rng_get_and_update_state_thunk(::xla::cpu::RngGetAndUpdateStateThunkProto* value);
  void unsafe_arena_set_allocated_rng_get_and_update_state_thunk(::xla::cpu::RngGetAndUpdateStateThunkProto* value);
  ::xla::cpu::RngGetAndUpdateStateThunkProto* unsafe_arena_release_rng_get_and_update_state_thunk();

  private:
  const ::xla::cpu::RngGetAndUpdateStateThunkProto& _internal_rng_get_and_update_state_thunk() const;
  ::xla::cpu::RngGetAndUpdateStateThunkProto* _internal_mutable_rng_get_and_update_state_thunk();

  public:
  // .xla.cpu.TopKThunkProto top_k_thunk = 9;
  bool has_top_k_thunk() const;
  private:
  bool _internal_has_top_k_thunk() const;

  public:
  void clear_top_k_thunk() ;
  const ::xla::cpu::TopKThunkProto& top_k_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::TopKThunkProto* release_top_k_thunk();
  ::xla::cpu::TopKThunkProto* mutable_top_k_thunk();
  void set_allocated_top_k_thunk(::xla::cpu::TopKThunkProto* value);
  void unsafe_arena_set_allocated_top_k_thunk(::xla::cpu::TopKThunkProto* value);
  ::xla::cpu::TopKThunkProto* unsafe_arena_release_top_k_thunk();

  private:
  const ::xla::cpu::TopKThunkProto& _internal_top_k_thunk() const;
  ::xla::cpu::TopKThunkProto* _internal_mutable_top_k_thunk();

  public:
  // .xla.cpu.WhileThunkProto while_thunk = 10;
  bool has_while_thunk() const;
  private:
  bool _internal_has_while_thunk() const;

  public:
  void clear_while_thunk() ;
  const ::xla::cpu::WhileThunkProto& while_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::WhileThunkProto* release_while_thunk();
  ::xla::cpu::WhileThunkProto* mutable_while_thunk();
  void set_allocated_while_thunk(::xla::cpu::WhileThunkProto* value);
  void unsafe_arena_set_allocated_while_thunk(::xla::cpu::WhileThunkProto* value);
  ::xla::cpu::WhileThunkProto* unsafe_arena_release_while_thunk();

  private:
  const ::xla::cpu::WhileThunkProto& _internal_while_thunk() const;
  ::xla::cpu::WhileThunkProto* _internal_mutable_while_thunk();

  public:
  // .xla.cpu.KernelThunkProto kernel_thunk = 11;
  bool has_kernel_thunk() const;
  private:
  bool _internal_has_kernel_thunk() const;

  public:
  void clear_kernel_thunk() ;
  const ::xla::cpu::KernelThunkProto& kernel_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::KernelThunkProto* release_kernel_thunk();
  ::xla::cpu::KernelThunkProto* mutable_kernel_thunk();
  void set_allocated_kernel_thunk(::xla::cpu::KernelThunkProto* value);
  void unsafe_arena_set_allocated_kernel_thunk(::xla::cpu::KernelThunkProto* value);
  ::xla::cpu::KernelThunkProto* unsafe_arena_release_kernel_thunk();

  private:
  const ::xla::cpu::KernelThunkProto& _internal_kernel_thunk() const;
  ::xla::cpu::KernelThunkProto* _internal_mutable_kernel_thunk();

  public:
  // .xla.cpu.CopyThunkProto copy_thunk = 12;
  bool has_copy_thunk() const;
  private:
  bool _internal_has_copy_thunk() const;

  public:
  void clear_copy_thunk() ;
  const ::xla::cpu::CopyThunkProto& copy_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::CopyThunkProto* release_copy_thunk();
  ::xla::cpu::CopyThunkProto* mutable_copy_thunk();
  void set_allocated_copy_thunk(::xla::cpu::CopyThunkProto* value);
  void unsafe_arena_set_allocated_copy_thunk(::xla::cpu::CopyThunkProto* value);
  ::xla::cpu::CopyThunkProto* unsafe_arena_release_copy_thunk();

  private:
  const ::xla::cpu::CopyThunkProto& _internal_copy_thunk() const;
  ::xla::cpu::CopyThunkProto* _internal_mutable_copy_thunk();

  public:
  // .xla.cpu.FftThunkProto fft_thunk = 13;
  bool has_fft_thunk() const;
  private:
  bool _internal_has_fft_thunk() const;

  public:
  void clear_fft_thunk() ;
  const ::xla::cpu::FftThunkProto& fft_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::FftThunkProto* release_fft_thunk();
  ::xla::cpu::FftThunkProto* mutable_fft_thunk();
  void set_allocated_fft_thunk(::xla::cpu::FftThunkProto* value);
  void unsafe_arena_set_allocated_fft_thunk(::xla::cpu::FftThunkProto* value);
  ::xla::cpu::FftThunkProto* unsafe_arena_release_fft_thunk();

  private:
  const ::xla::cpu::FftThunkProto& _internal_fft_thunk() const;
  ::xla::cpu::FftThunkProto* _internal_mutable_fft_thunk();

  public:
  // .xla.cpu.InfeedThunkProto infeed_thunk = 14;
  bool has_infeed_thunk() const;
  private:
  bool _internal_has_infeed_thunk() const;

  public:
  void clear_infeed_thunk() ;
  const ::xla::cpu::InfeedThunkProto& infeed_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::InfeedThunkProto* release_infeed_thunk();
  ::xla::cpu::InfeedThunkProto* mutable_infeed_thunk();
  void set_allocated_infeed_thunk(::xla::cpu::InfeedThunkProto* value);
  void unsafe_arena_set_allocated_infeed_thunk(::xla::cpu::InfeedThunkProto* value);
  ::xla::cpu::InfeedThunkProto* unsafe_arena_release_infeed_thunk();

  private:
  const ::xla::cpu::InfeedThunkProto& _internal_infeed_thunk() const;
  ::xla::cpu::InfeedThunkProto* _internal_mutable_infeed_thunk();

  public:
  // .xla.cpu.OutfeedThunkProto outfeed_thunk = 15;
  bool has_outfeed_thunk() const;
  private:
  bool _internal_has_outfeed_thunk() const;

  public:
  void clear_outfeed_thunk() ;
  const ::xla::cpu::OutfeedThunkProto& outfeed_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::OutfeedThunkProto* release_outfeed_thunk();
  ::xla::cpu::OutfeedThunkProto* mutable_outfeed_thunk();
  void set_allocated_outfeed_thunk(::xla::cpu::OutfeedThunkProto* value);
  void unsafe_arena_set_allocated_outfeed_thunk(::xla::cpu::OutfeedThunkProto* value);
  ::xla::cpu::OutfeedThunkProto* unsafe_arena_release_outfeed_thunk();

  private:
  const ::xla::cpu::OutfeedThunkProto& _internal_outfeed_thunk() const;
  ::xla::cpu::OutfeedThunkProto* _internal_mutable_outfeed_thunk();

  public:
  // .xla.cpu.CustomCallThunkProto custom_call_thunk = 16;
  bool has_custom_call_thunk() const;
  private:
  bool _internal_has_custom_call_thunk() const;

  public:
  void clear_custom_call_thunk() ;
  const ::xla::cpu::CustomCallThunkProto& custom_call_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::CustomCallThunkProto* release_custom_call_thunk();
  ::xla::cpu::CustomCallThunkProto* mutable_custom_call_thunk();
  void set_allocated_custom_call_thunk(::xla::cpu::CustomCallThunkProto* value);
  void unsafe_arena_set_allocated_custom_call_thunk(::xla::cpu::CustomCallThunkProto* value);
  ::xla::cpu::CustomCallThunkProto* unsafe_arena_release_custom_call_thunk();

  private:
  const ::xla::cpu::CustomCallThunkProto& _internal_custom_call_thunk() const;
  ::xla::cpu::CustomCallThunkProto* _internal_mutable_custom_call_thunk();

  public:
  // .xla.cpu.ConvolutionThunkProto convolution_thunk = 17;
  bool has_convolution_thunk() const;
  private:
  bool _internal_has_convolution_thunk() const;

  public:
  void clear_convolution_thunk() ;
  const ::xla::cpu::ConvolutionThunkProto& convolution_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::ConvolutionThunkProto* release_convolution_thunk();
  ::xla::cpu::ConvolutionThunkProto* mutable_convolution_thunk();
  void set_allocated_convolution_thunk(::xla::cpu::ConvolutionThunkProto* value);
  void unsafe_arena_set_allocated_convolution_thunk(::xla::cpu::ConvolutionThunkProto* value);
  ::xla::cpu::ConvolutionThunkProto* unsafe_arena_release_convolution_thunk();

  private:
  const ::xla::cpu::ConvolutionThunkProto& _internal_convolution_thunk() const;
  ::xla::cpu::ConvolutionThunkProto* _internal_mutable_convolution_thunk();

  public:
  // .xla.cpu.CollectiveThunkProto collective_thunk = 18;
  bool has_collective_thunk() const;
  private:
  bool _internal_has_collective_thunk() const;

  public:
  void clear_collective_thunk() ;
  const ::xla::cpu::CollectiveThunkProto& collective_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::CollectiveThunkProto* release_collective_thunk();
  ::xla::cpu::CollectiveThunkProto* mutable_collective_thunk();
  void set_allocated_collective_thunk(::xla::cpu::CollectiveThunkProto* value);
  void unsafe_arena_set_allocated_collective_thunk(::xla::cpu::CollectiveThunkProto* value);
  ::xla::cpu::CollectiveThunkProto* unsafe_arena_release_collective_thunk();

  private:
  const ::xla::cpu::CollectiveThunkProto& _internal_collective_thunk() const;
  ::xla::cpu::CollectiveThunkProto* _internal_mutable_collective_thunk();

  public:
  // .xla.cpu.PartitionIdThunkProto partition_id_thunk = 19;
  bool has_partition_id_thunk() const;
  private:
  bool _internal_has_partition_id_thunk() const;

  public:
  void clear_partition_id_thunk() ;
  const ::xla::cpu::PartitionIdThunkProto& partition_id_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::PartitionIdThunkProto* release_partition_id_thunk();
  ::xla::cpu::PartitionIdThunkProto* mutable_partition_id_thunk();
  void set_allocated_partition_id_thunk(::xla::cpu::PartitionIdThunkProto* value);
  void unsafe_arena_set_allocated_partition_id_thunk(::xla::cpu::PartitionIdThunkProto* value);
  ::xla::cpu::PartitionIdThunkProto* unsafe_arena_release_partition_id_thunk();

  private:
  const ::xla::cpu::PartitionIdThunkProto& _internal_partition_id_thunk() const;
  ::xla::cpu::PartitionIdThunkProto* _internal_mutable_partition_id_thunk();

  public:
  // .xla.cpu.ReplicaIdThunkProto replica_id_thunk = 20;
  bool has_replica_id_thunk() const;
  private:
  bool _internal_has_replica_id_thunk() const;

  public:
  void clear_replica_id_thunk() ;
  const ::xla::cpu::ReplicaIdThunkProto& replica_id_thunk() const;
  PROTOBUF_NODISCARD ::xla::cpu::ReplicaIdThunkProto* release_replica_id_thunk();
  ::xla::cpu::ReplicaIdThunkProto* mutable_replica_id_thunk();
  void set_allocated_replica_id_thunk(::xla::cpu::ReplicaIdThunkProto* value);
  void unsafe_arena_set_allocated_replica_id_thunk(::xla::cpu::ReplicaIdThunkProto* value);
  ::xla::cpu::ReplicaIdThunkProto* unsafe_arena_release_replica_id_thunk();

  private:
  const ::xla::cpu::ReplicaIdThunkProto& _internal_replica_id_thunk() const;
  ::xla::cpu::ReplicaIdThunkProto* _internal_mutable_replica_id_thunk();

  public:
  void clear_impl();
  ImplCase impl_case() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.ThunkProto)
 private:
  class _Internal;
  void set_has_call_thunk();
  void set_has_conditional_thunk();
  void set_has_sort_thunk();
  void set_has_xnn_fusion_thunk();
  void set_has_dot_thunk();
  void set_has_rng_get_and_update_state_thunk();
  void set_has_top_k_thunk();
  void set_has_while_thunk();
  void set_has_kernel_thunk();
  void set_has_copy_thunk();
  void set_has_fft_thunk();
  void set_has_infeed_thunk();
  void set_has_outfeed_thunk();
  void set_has_custom_call_thunk();
  void set_has_convolution_thunk();
  void set_has_collective_thunk();
  void set_has_partition_id_thunk();
  void set_has_replica_id_thunk();
  inline bool has_impl() const;
  inline void clear_has_impl();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 20, 19,
      47, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr kind_;
    ::xla::cpu::InfoProto* info_;
    union ImplUnion {
      constexpr ImplUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::xla::cpu::CallThunkProto* call_thunk_;
      ::xla::cpu::ConditionalThunkProto* conditional_thunk_;
      ::xla::cpu::SortThunkProto* sort_thunk_;
      ::xla::cpu::XnnFusionThunkProto* xnn_fusion_thunk_;
      ::xla::cpu::DotThunkProto* dot_thunk_;
      ::xla::cpu::RngGetAndUpdateStateThunkProto* rng_get_and_update_state_thunk_;
      ::xla::cpu::TopKThunkProto* top_k_thunk_;
      ::xla::cpu::WhileThunkProto* while_thunk_;
      ::xla::cpu::KernelThunkProto* kernel_thunk_;
      ::xla::cpu::CopyThunkProto* copy_thunk_;
      ::xla::cpu::FftThunkProto* fft_thunk_;
      ::xla::cpu::InfeedThunkProto* infeed_thunk_;
      ::xla::cpu::OutfeedThunkProto* outfeed_thunk_;
      ::xla::cpu::CustomCallThunkProto* custom_call_thunk_;
      ::xla::cpu::ConvolutionThunkProto* convolution_thunk_;
      ::xla::cpu::CollectiveThunkProto* collective_thunk_;
      ::xla::cpu::PartitionIdThunkProto* partition_id_thunk_;
      ::xla::cpu::ReplicaIdThunkProto* replica_id_thunk_;
    } impl_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ThunkSequenceProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.ThunkSequenceProto) */ {
 public:
  inline ThunkSequenceProto() : ThunkSequenceProto(nullptr) {}
  ~ThunkSequenceProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ThunkSequenceProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ThunkSequenceProto(const ThunkSequenceProto& from) : ThunkSequenceProto(nullptr, from) {}
  inline ThunkSequenceProto(ThunkSequenceProto&& from) noexcept
      : ThunkSequenceProto(nullptr, std::move(from)) {}
  inline ThunkSequenceProto& operator=(const ThunkSequenceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThunkSequenceProto& operator=(ThunkSequenceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThunkSequenceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThunkSequenceProto* internal_default_instance() {
    return reinterpret_cast<const ThunkSequenceProto*>(
        &_ThunkSequenceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(ThunkSequenceProto& a, ThunkSequenceProto& b) { a.Swap(&b); }
  inline void Swap(ThunkSequenceProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThunkSequenceProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThunkSequenceProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ThunkSequenceProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ThunkSequenceProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ThunkSequenceProto& from) { ThunkSequenceProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ThunkSequenceProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.ThunkSequenceProto"; }

 protected:
  explicit ThunkSequenceProto(::google::protobuf::Arena* arena);
  ThunkSequenceProto(::google::protobuf::Arena* arena, const ThunkSequenceProto& from);
  ThunkSequenceProto(::google::protobuf::Arena* arena, ThunkSequenceProto&& from) noexcept
      : ThunkSequenceProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ResourceUsersProto = ThunkSequenceProto_ResourceUsersProto;

  // accessors -------------------------------------------------------
  enum : int {
    kThunksFieldNumber = 1,
    kThunkResourcesFieldNumber = 2,
  };
  // repeated .xla.cpu.ThunkProto thunks = 1;
  int thunks_size() const;
  private:
  int _internal_thunks_size() const;

  public:
  void clear_thunks() ;
  ::xla::cpu::ThunkProto* mutable_thunks(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkProto>* mutable_thunks();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkProto>& _internal_thunks() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkProto>* _internal_mutable_thunks();
  public:
  const ::xla::cpu::ThunkProto& thunks(int index) const;
  ::xla::cpu::ThunkProto* add_thunks();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkProto>& thunks() const;
  // repeated .xla.cpu.ThunkSequenceProto.ResourceUsersProto thunk_resources = 2;
  int thunk_resources_size() const;
  private:
  int _internal_thunk_resources_size() const;

  public:
  void clear_thunk_resources() ;
  ::xla::cpu::ThunkSequenceProto_ResourceUsersProto* mutable_thunk_resources(int index);
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto_ResourceUsersProto>* mutable_thunk_resources();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto_ResourceUsersProto>& _internal_thunk_resources() const;
  ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto_ResourceUsersProto>* _internal_mutable_thunk_resources();
  public:
  const ::xla::cpu::ThunkSequenceProto_ResourceUsersProto& thunk_resources(int index) const;
  ::xla::cpu::ThunkSequenceProto_ResourceUsersProto* add_thunk_resources();
  const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto_ResourceUsersProto>& thunk_resources() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.ThunkSequenceProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ThunkSequenceProto& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ThunkProto > thunks_;
    ::google::protobuf::RepeatedPtrField< ::xla::cpu::ThunkSequenceProto_ResourceUsersProto > thunk_resources_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT WhileThunkProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.WhileThunkProto) */ {
 public:
  inline WhileThunkProto() : WhileThunkProto(nullptr) {}
  ~WhileThunkProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WhileThunkProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline WhileThunkProto(const WhileThunkProto& from) : WhileThunkProto(nullptr, from) {}
  inline WhileThunkProto(WhileThunkProto&& from) noexcept
      : WhileThunkProto(nullptr, std::move(from)) {}
  inline WhileThunkProto& operator=(const WhileThunkProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhileThunkProto& operator=(WhileThunkProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhileThunkProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhileThunkProto* internal_default_instance() {
    return reinterpret_cast<const WhileThunkProto*>(
        &_WhileThunkProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(WhileThunkProto& a, WhileThunkProto& b) { a.Swap(&b); }
  inline void Swap(WhileThunkProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhileThunkProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhileThunkProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WhileThunkProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WhileThunkProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WhileThunkProto& from) { WhileThunkProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WhileThunkProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.cpu.WhileThunkProto"; }

 protected:
  explicit WhileThunkProto(::google::protobuf::Arena* arena);
  WhileThunkProto(::google::protobuf::Arena* arena, const WhileThunkProto& from);
  WhileThunkProto(::google::protobuf::Arena* arena, WhileThunkProto&& from) noexcept
      : WhileThunkProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCondSequenceFieldNumber = 1,
    kBodySequenceFieldNumber = 2,
    kTripCountFieldNumber = 3,
    kCondBufferFieldNumber = 4,
  };
  // .xla.cpu.ThunkSequenceProto cond_sequence = 1;
  bool has_cond_sequence() const;
  void clear_cond_sequence() ;
  const ::xla::cpu::ThunkSequenceProto& cond_sequence() const;
  PROTOBUF_NODISCARD ::xla::cpu::ThunkSequenceProto* release_cond_sequence();
  ::xla::cpu::ThunkSequenceProto* mutable_cond_sequence();
  void set_allocated_cond_sequence(::xla::cpu::ThunkSequenceProto* value);
  void unsafe_arena_set_allocated_cond_sequence(::xla::cpu::ThunkSequenceProto* value);
  ::xla::cpu::ThunkSequenceProto* unsafe_arena_release_cond_sequence();

  private:
  const ::xla::cpu::ThunkSequenceProto& _internal_cond_sequence() const;
  ::xla::cpu::ThunkSequenceProto* _internal_mutable_cond_sequence();

  public:
  // .xla.cpu.ThunkSequenceProto body_sequence = 2;
  bool has_body_sequence() const;
  void clear_body_sequence() ;
  const ::xla::cpu::ThunkSequenceProto& body_sequence() const;
  PROTOBUF_NODISCARD ::xla::cpu::ThunkSequenceProto* release_body_sequence();
  ::xla::cpu::ThunkSequenceProto* mutable_body_sequence();
  void set_allocated_body_sequence(::xla::cpu::ThunkSequenceProto* value);
  void unsafe_arena_set_allocated_body_sequence(::xla::cpu::ThunkSequenceProto* value);
  ::xla::cpu::ThunkSequenceProto* unsafe_arena_release_body_sequence();

  private:
  const ::xla::cpu::ThunkSequenceProto& _internal_body_sequence() const;
  ::xla::cpu::ThunkSequenceProto* _internal_mutable_body_sequence();

  public:
  // .xla.cpu.Int64Optional trip_count = 3;
  bool has_trip_count() const;
  void clear_trip_count() ;
  const ::xla::cpu::Int64Optional& trip_count() const;
  PROTOBUF_NODISCARD ::xla::cpu::Int64Optional* release_trip_count();
  ::xla::cpu::Int64Optional* mutable_trip_count();
  void set_allocated_trip_count(::xla::cpu::Int64Optional* value);
  void unsafe_arena_set_allocated_trip_count(::xla::cpu::Int64Optional* value);
  ::xla::cpu::Int64Optional* unsafe_arena_release_trip_count();

  private:
  const ::xla::cpu::Int64Optional& _internal_trip_count() const;
  ::xla::cpu::Int64Optional* _internal_mutable_trip_count();

  public:
  // .xla.buffer_assignment.BufferAllocationSliceProto cond_buffer = 4;
  bool has_cond_buffer() const;
  void clear_cond_buffer() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& cond_buffer() const;
  PROTOBUF_NODISCARD ::xla::buffer_assignment::BufferAllocationSliceProto* release_cond_buffer();
  ::xla::buffer_assignment::BufferAllocationSliceProto* mutable_cond_buffer();
  void set_allocated_cond_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  void unsafe_arena_set_allocated_cond_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* unsafe_arena_release_cond_buffer();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_cond_buffer() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _internal_mutable_cond_buffer();

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.WhileThunkProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WhileThunkProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::cpu::ThunkSequenceProto* cond_sequence_;
    ::xla::cpu::ThunkSequenceProto* body_sequence_;
    ::xla::cpu::Int64Optional* trip_count_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* cond_buffer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ResourceProto

// .xla.cpu.ResourceProto.Kind kind = 1;
inline void ResourceProto::clear_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_ = 0;
}
inline ::xla::cpu::ResourceProto_Kind ResourceProto::kind() const {
  // @@protoc_insertion_point(field_get:xla.cpu.ResourceProto.kind)
  return _internal_kind();
}
inline void ResourceProto::set_kind(::xla::cpu::ResourceProto_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:xla.cpu.ResourceProto.kind)
}
inline ::xla::cpu::ResourceProto_Kind ResourceProto::_internal_kind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::xla::cpu::ResourceProto_Kind>(_impl_.kind_);
}
inline void ResourceProto::_internal_set_kind(::xla::cpu::ResourceProto_Kind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_ = value;
}

// -------------------------------------------------------------------

// BoolOptional

// bool value = 1;
inline void BoolOptional::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = false;
}
inline bool BoolOptional::value() const {
  // @@protoc_insertion_point(field_get:xla.cpu.BoolOptional.value)
  return _internal_value();
}
inline void BoolOptional::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xla.cpu.BoolOptional.value)
}
inline bool BoolOptional::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void BoolOptional::_internal_set_value(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// bool contains_value = 2;
inline void BoolOptional::clear_contains_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_value_ = false;
}
inline bool BoolOptional::contains_value() const {
  // @@protoc_insertion_point(field_get:xla.cpu.BoolOptional.contains_value)
  return _internal_contains_value();
}
inline void BoolOptional::set_contains_value(bool value) {
  _internal_set_contains_value(value);
  // @@protoc_insertion_point(field_set:xla.cpu.BoolOptional.contains_value)
}
inline bool BoolOptional::_internal_contains_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contains_value_;
}
inline void BoolOptional::_internal_set_contains_value(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_value_ = value;
}

// -------------------------------------------------------------------

// ResourceOptional

// .xla.cpu.ResourceProto value = 1;
inline bool ResourceOptional::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void ResourceOptional::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ResourceProto& ResourceOptional::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ResourceProto* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ResourceProto&>(::xla::cpu::_ResourceProto_default_instance_);
}
inline const ::xla::cpu::ResourceProto& ResourceOptional::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ResourceOptional.value)
  return _internal_value();
}
inline void ResourceOptional::unsafe_arena_set_allocated_value(::xla::cpu::ResourceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::xla::cpu::ResourceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ResourceOptional.value)
}
inline ::xla::cpu::ResourceProto* ResourceOptional::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceProto* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ResourceProto* ResourceOptional::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ResourceOptional.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceProto* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::xla::cpu::ResourceProto* ResourceOptional::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ResourceProto>(GetArena());
    _impl_.value_ = reinterpret_cast<::xla::cpu::ResourceProto*>(p);
  }
  return _impl_.value_;
}
inline ::xla::cpu::ResourceProto* ResourceOptional::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ResourceProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ResourceOptional.value)
  return _msg;
}
inline void ResourceOptional::set_allocated_value(::xla::cpu::ResourceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::xla::cpu::ResourceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ResourceOptional.value)
}

// bool contains_value = 2;
inline void ResourceOptional::clear_contains_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_value_ = false;
}
inline bool ResourceOptional::contains_value() const {
  // @@protoc_insertion_point(field_get:xla.cpu.ResourceOptional.contains_value)
  return _internal_contains_value();
}
inline void ResourceOptional::set_contains_value(bool value) {
  _internal_set_contains_value(value);
  // @@protoc_insertion_point(field_set:xla.cpu.ResourceOptional.contains_value)
}
inline bool ResourceOptional::_internal_contains_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contains_value_;
}
inline void ResourceOptional::_internal_set_contains_value(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_value_ = value;
}

// -------------------------------------------------------------------

// Int64Optional

// int64 value = 1;
inline void Int64Optional::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = ::int64_t{0};
}
inline ::int64_t Int64Optional::value() const {
  // @@protoc_insertion_point(field_get:xla.cpu.Int64Optional.value)
  return _internal_value();
}
inline void Int64Optional::set_value(::int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xla.cpu.Int64Optional.value)
}
inline ::int64_t Int64Optional::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void Int64Optional::_internal_set_value(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// bool contains_value = 2;
inline void Int64Optional::clear_contains_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_value_ = false;
}
inline bool Int64Optional::contains_value() const {
  // @@protoc_insertion_point(field_get:xla.cpu.Int64Optional.contains_value)
  return _internal_contains_value();
}
inline void Int64Optional::set_contains_value(bool value) {
  _internal_set_contains_value(value);
  // @@protoc_insertion_point(field_set:xla.cpu.Int64Optional.contains_value)
}
inline bool Int64Optional::_internal_contains_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contains_value_;
}
inline void Int64Optional::_internal_set_contains_value(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_value_ = value;
}

// -------------------------------------------------------------------

// SortDirectionOptional

// .xla.cpu.SortDirectionProto value = 1;
inline void SortDirectionOptional::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline ::xla::cpu::SortDirectionProto SortDirectionOptional::value() const {
  // @@protoc_insertion_point(field_get:xla.cpu.SortDirectionOptional.value)
  return _internal_value();
}
inline void SortDirectionOptional::set_value(::xla::cpu::SortDirectionProto value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xla.cpu.SortDirectionOptional.value)
}
inline ::xla::cpu::SortDirectionProto SortDirectionOptional::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::xla::cpu::SortDirectionProto>(_impl_.value_);
}
inline void SortDirectionOptional::_internal_set_value(::xla::cpu::SortDirectionProto value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// bool contains_value = 2;
inline void SortDirectionOptional::clear_contains_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_value_ = false;
}
inline bool SortDirectionOptional::contains_value() const {
  // @@protoc_insertion_point(field_get:xla.cpu.SortDirectionOptional.contains_value)
  return _internal_contains_value();
}
inline void SortDirectionOptional::set_contains_value(bool value) {
  _internal_set_contains_value(value);
  // @@protoc_insertion_point(field_set:xla.cpu.SortDirectionOptional.contains_value)
}
inline bool SortDirectionOptional::_internal_contains_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contains_value_;
}
inline void SortDirectionOptional::_internal_set_contains_value(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_value_ = value;
}

// -------------------------------------------------------------------

// ShapeBufferAllocationSliceProto

// .xla.ShapeProto shape = 1;
inline bool ShapeBufferAllocationSliceProto::has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline const ::xla::ShapeProto& ShapeBufferAllocationSliceProto::_internal_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::ShapeProto* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::ShapeProto&>(::xla::_ShapeProto_default_instance_);
}
inline const ::xla::ShapeProto& ShapeBufferAllocationSliceProto::shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ShapeBufferAllocationSliceProto.shape)
  return _internal_shape();
}
inline void ShapeBufferAllocationSliceProto::unsafe_arena_set_allocated_shape(::xla::ShapeProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = reinterpret_cast<::xla::ShapeProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ShapeBufferAllocationSliceProto.shape)
}
inline ::xla::ShapeProto* ShapeBufferAllocationSliceProto::release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::ShapeProto* released = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::ShapeProto* ShapeBufferAllocationSliceProto::unsafe_arena_release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ShapeBufferAllocationSliceProto.shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::ShapeProto* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::xla::ShapeProto* ShapeBufferAllocationSliceProto::_internal_mutable_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::ShapeProto>(GetArena());
    _impl_.shape_ = reinterpret_cast<::xla::ShapeProto*>(p);
  }
  return _impl_.shape_;
}
inline ::xla::ShapeProto* ShapeBufferAllocationSliceProto::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::ShapeProto* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ShapeBufferAllocationSliceProto.shape)
  return _msg;
}
inline void ShapeBufferAllocationSliceProto::set_allocated_shape(::xla::ShapeProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shape_ = reinterpret_cast<::xla::ShapeProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ShapeBufferAllocationSliceProto.shape)
}

// .xla.buffer_assignment.BufferAllocationSliceProto slice = 2;
inline bool ShapeBufferAllocationSliceProto::has_slice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.slice_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& ShapeBufferAllocationSliceProto::_internal_slice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.slice_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& ShapeBufferAllocationSliceProto::slice() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ShapeBufferAllocationSliceProto.slice)
  return _internal_slice();
}
inline void ShapeBufferAllocationSliceProto::unsafe_arena_set_allocated_slice(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.slice_);
  }
  _impl_.slice_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ShapeBufferAllocationSliceProto.slice)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ShapeBufferAllocationSliceProto::release_slice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.slice_;
  _impl_.slice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ShapeBufferAllocationSliceProto::unsafe_arena_release_slice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ShapeBufferAllocationSliceProto.slice)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.slice_;
  _impl_.slice_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ShapeBufferAllocationSliceProto::_internal_mutable_slice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.slice_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.slice_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.slice_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ShapeBufferAllocationSliceProto::mutable_slice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_slice();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ShapeBufferAllocationSliceProto.slice)
  return _msg;
}
inline void ShapeBufferAllocationSliceProto::set_allocated_slice(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.slice_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.slice_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ShapeBufferAllocationSliceProto.slice)
}

// -------------------------------------------------------------------

// OpParamsProto

// int64 op_id = 1;
inline void OpParamsProto::clear_op_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_id_ = ::int64_t{0};
}
inline ::int64_t OpParamsProto::op_id() const {
  // @@protoc_insertion_point(field_get:xla.cpu.OpParamsProto.op_id)
  return _internal_op_id();
}
inline void OpParamsProto::set_op_id(::int64_t value) {
  _internal_set_op_id(value);
  // @@protoc_insertion_point(field_set:xla.cpu.OpParamsProto.op_id)
}
inline ::int64_t OpParamsProto::_internal_op_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.op_id_;
}
inline void OpParamsProto::_internal_set_op_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_id_ = value;
}

// bool has_channel_id = 2;
inline void OpParamsProto::clear_has_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_channel_id_ = false;
}
inline bool OpParamsProto::has_channel_id() const {
  // @@protoc_insertion_point(field_get:xla.cpu.OpParamsProto.has_channel_id)
  return _internal_has_channel_id();
}
inline void OpParamsProto::set_has_channel_id(bool value) {
  _internal_set_has_channel_id(value);
  // @@protoc_insertion_point(field_set:xla.cpu.OpParamsProto.has_channel_id)
}
inline bool OpParamsProto::_internal_has_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_channel_id_;
}
inline void OpParamsProto::_internal_set_has_channel_id(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_channel_id_ = value;
}

// .xla.cpu.BoolOptional use_global_device_ids = 3;
inline bool OpParamsProto::has_use_global_device_ids() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.use_global_device_ids_ != nullptr);
  return value;
}
inline void OpParamsProto::clear_use_global_device_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.use_global_device_ids_ != nullptr) _impl_.use_global_device_ids_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::BoolOptional& OpParamsProto::_internal_use_global_device_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::BoolOptional* p = _impl_.use_global_device_ids_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::BoolOptional&>(::xla::cpu::_BoolOptional_default_instance_);
}
inline const ::xla::cpu::BoolOptional& OpParamsProto::use_global_device_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OpParamsProto.use_global_device_ids)
  return _internal_use_global_device_ids();
}
inline void OpParamsProto::unsafe_arena_set_allocated_use_global_device_ids(::xla::cpu::BoolOptional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.use_global_device_ids_);
  }
  _impl_.use_global_device_ids_ = reinterpret_cast<::xla::cpu::BoolOptional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.OpParamsProto.use_global_device_ids)
}
inline ::xla::cpu::BoolOptional* OpParamsProto::release_use_global_device_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::BoolOptional* released = _impl_.use_global_device_ids_;
  _impl_.use_global_device_ids_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::BoolOptional* OpParamsProto::unsafe_arena_release_use_global_device_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.OpParamsProto.use_global_device_ids)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::BoolOptional* temp = _impl_.use_global_device_ids_;
  _impl_.use_global_device_ids_ = nullptr;
  return temp;
}
inline ::xla::cpu::BoolOptional* OpParamsProto::_internal_mutable_use_global_device_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.use_global_device_ids_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::BoolOptional>(GetArena());
    _impl_.use_global_device_ids_ = reinterpret_cast<::xla::cpu::BoolOptional*>(p);
  }
  return _impl_.use_global_device_ids_;
}
inline ::xla::cpu::BoolOptional* OpParamsProto::mutable_use_global_device_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::BoolOptional* _msg = _internal_mutable_use_global_device_ids();
  // @@protoc_insertion_point(field_mutable:xla.cpu.OpParamsProto.use_global_device_ids)
  return _msg;
}
inline void OpParamsProto::set_allocated_use_global_device_ids(::xla::cpu::BoolOptional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.use_global_device_ids_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.use_global_device_ids_ = reinterpret_cast<::xla::cpu::BoolOptional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.OpParamsProto.use_global_device_ids)
}

// repeated .xla.ReplicaGroup replica_group = 4;
inline int OpParamsProto::_internal_replica_group_size() const {
  return _internal_replica_group().size();
}
inline int OpParamsProto::replica_group_size() const {
  return _internal_replica_group_size();
}
inline ::xla::ReplicaGroup* OpParamsProto::mutable_replica_group(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.OpParamsProto.replica_group)
  return _internal_mutable_replica_group()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::ReplicaGroup>* OpParamsProto::mutable_replica_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.OpParamsProto.replica_group)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_replica_group();
}
inline const ::xla::ReplicaGroup& OpParamsProto::replica_group(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OpParamsProto.replica_group)
  return _internal_replica_group().Get(index);
}
inline ::xla::ReplicaGroup* OpParamsProto::add_replica_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::ReplicaGroup* _add = _internal_mutable_replica_group()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.OpParamsProto.replica_group)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::ReplicaGroup>& OpParamsProto::replica_group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.OpParamsProto.replica_group)
  return _internal_replica_group();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::ReplicaGroup>&
OpParamsProto::_internal_replica_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replica_group_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::ReplicaGroup>*
OpParamsProto::_internal_mutable_replica_group() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.replica_group_;
}

// -------------------------------------------------------------------

// OpBuffersProto

// repeated .xla.cpu.ShapeBufferAllocationSliceProto source_shapes_buffer_slices = 1;
inline int OpBuffersProto::_internal_source_shapes_buffer_slices_size() const {
  return _internal_source_shapes_buffer_slices().size();
}
inline int OpBuffersProto::source_shapes_buffer_slices_size() const {
  return _internal_source_shapes_buffer_slices_size();
}
inline void OpBuffersProto::clear_source_shapes_buffer_slices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_shapes_buffer_slices_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* OpBuffersProto::mutable_source_shapes_buffer_slices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.OpBuffersProto.source_shapes_buffer_slices)
  return _internal_mutable_source_shapes_buffer_slices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* OpBuffersProto::mutable_source_shapes_buffer_slices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.OpBuffersProto.source_shapes_buffer_slices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_source_shapes_buffer_slices();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& OpBuffersProto::source_shapes_buffer_slices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OpBuffersProto.source_shapes_buffer_slices)
  return _internal_source_shapes_buffer_slices().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* OpBuffersProto::add_source_shapes_buffer_slices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_source_shapes_buffer_slices()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.OpBuffersProto.source_shapes_buffer_slices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& OpBuffersProto::source_shapes_buffer_slices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.OpBuffersProto.source_shapes_buffer_slices)
  return _internal_source_shapes_buffer_slices();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
OpBuffersProto::_internal_source_shapes_buffer_slices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_shapes_buffer_slices_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
OpBuffersProto::_internal_mutable_source_shapes_buffer_slices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.source_shapes_buffer_slices_;
}

// repeated .xla.cpu.ShapeBufferAllocationSliceProto destination_shapes_buffer_slices = 2;
inline int OpBuffersProto::_internal_destination_shapes_buffer_slices_size() const {
  return _internal_destination_shapes_buffer_slices().size();
}
inline int OpBuffersProto::destination_shapes_buffer_slices_size() const {
  return _internal_destination_shapes_buffer_slices_size();
}
inline void OpBuffersProto::clear_destination_shapes_buffer_slices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.destination_shapes_buffer_slices_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* OpBuffersProto::mutable_destination_shapes_buffer_slices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.OpBuffersProto.destination_shapes_buffer_slices)
  return _internal_mutable_destination_shapes_buffer_slices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* OpBuffersProto::mutable_destination_shapes_buffer_slices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.OpBuffersProto.destination_shapes_buffer_slices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_destination_shapes_buffer_slices();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& OpBuffersProto::destination_shapes_buffer_slices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OpBuffersProto.destination_shapes_buffer_slices)
  return _internal_destination_shapes_buffer_slices().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* OpBuffersProto::add_destination_shapes_buffer_slices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_destination_shapes_buffer_slices()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.OpBuffersProto.destination_shapes_buffer_slices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& OpBuffersProto::destination_shapes_buffer_slices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.OpBuffersProto.destination_shapes_buffer_slices)
  return _internal_destination_shapes_buffer_slices();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
OpBuffersProto::_internal_destination_shapes_buffer_slices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.destination_shapes_buffer_slices_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
OpBuffersProto::_internal_mutable_destination_shapes_buffer_slices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.destination_shapes_buffer_slices_;
}

// -------------------------------------------------------------------

// OpResourcesProto

// .xla.cpu.ResourceOptional communicator_resource = 1;
inline bool OpResourcesProto::has_communicator_resource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.communicator_resource_ != nullptr);
  return value;
}
inline void OpResourcesProto::clear_communicator_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.communicator_resource_ != nullptr) _impl_.communicator_resource_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ResourceOptional& OpResourcesProto::_internal_communicator_resource() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ResourceOptional* p = _impl_.communicator_resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ResourceOptional&>(::xla::cpu::_ResourceOptional_default_instance_);
}
inline const ::xla::cpu::ResourceOptional& OpResourcesProto::communicator_resource() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OpResourcesProto.communicator_resource)
  return _internal_communicator_resource();
}
inline void OpResourcesProto::unsafe_arena_set_allocated_communicator_resource(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.communicator_resource_);
  }
  _impl_.communicator_resource_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.OpResourcesProto.communicator_resource)
}
inline ::xla::cpu::ResourceOptional* OpResourcesProto::release_communicator_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceOptional* released = _impl_.communicator_resource_;
  _impl_.communicator_resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ResourceOptional* OpResourcesProto::unsafe_arena_release_communicator_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.OpResourcesProto.communicator_resource)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceOptional* temp = _impl_.communicator_resource_;
  _impl_.communicator_resource_ = nullptr;
  return temp;
}
inline ::xla::cpu::ResourceOptional* OpResourcesProto::_internal_mutable_communicator_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.communicator_resource_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ResourceOptional>(GetArena());
    _impl_.communicator_resource_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(p);
  }
  return _impl_.communicator_resource_;
}
inline ::xla::cpu::ResourceOptional* OpResourcesProto::mutable_communicator_resource() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ResourceOptional* _msg = _internal_mutable_communicator_resource();
  // @@protoc_insertion_point(field_mutable:xla.cpu.OpResourcesProto.communicator_resource)
  return _msg;
}
inline void OpResourcesProto::set_allocated_communicator_resource(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.communicator_resource_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.communicator_resource_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.OpResourcesProto.communicator_resource)
}

// -------------------------------------------------------------------

// AllGatherThunkProto

// -------------------------------------------------------------------

// AllReduceThunkProto

// string reduction_kind = 1;
inline void AllReduceThunkProto::clear_reduction_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_kind_.ClearToEmpty();
}
inline const std::string& AllReduceThunkProto::reduction_kind() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.AllReduceThunkProto.reduction_kind)
  return _internal_reduction_kind();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllReduceThunkProto::set_reduction_kind(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_kind_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.AllReduceThunkProto.reduction_kind)
}
inline std::string* AllReduceThunkProto::mutable_reduction_kind() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reduction_kind();
  // @@protoc_insertion_point(field_mutable:xla.cpu.AllReduceThunkProto.reduction_kind)
  return _s;
}
inline const std::string& AllReduceThunkProto::_internal_reduction_kind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reduction_kind_.Get();
}
inline void AllReduceThunkProto::_internal_set_reduction_kind(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_kind_.Set(value, GetArena());
}
inline std::string* AllReduceThunkProto::_internal_mutable_reduction_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reduction_kind_.Mutable( GetArena());
}
inline std::string* AllReduceThunkProto::release_reduction_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.AllReduceThunkProto.reduction_kind)
  return _impl_.reduction_kind_.Release();
}
inline void AllReduceThunkProto::set_allocated_reduction_kind(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_kind_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reduction_kind_.IsDefault()) {
          _impl_.reduction_kind_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.AllReduceThunkProto.reduction_kind)
}

// bool single_replica = 2;
inline void AllReduceThunkProto::clear_single_replica() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.single_replica_ = false;
}
inline bool AllReduceThunkProto::single_replica() const {
  // @@protoc_insertion_point(field_get:xla.cpu.AllReduceThunkProto.single_replica)
  return _internal_single_replica();
}
inline void AllReduceThunkProto::set_single_replica(bool value) {
  _internal_set_single_replica(value);
  // @@protoc_insertion_point(field_set:xla.cpu.AllReduceThunkProto.single_replica)
}
inline bool AllReduceThunkProto::_internal_single_replica() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.single_replica_;
}
inline void AllReduceThunkProto::_internal_set_single_replica(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.single_replica_ = value;
}

// -------------------------------------------------------------------

// AllToAllThunkProto

// -------------------------------------------------------------------

// ReduceScatterThunkProto

// string reduction_kind = 1;
inline void ReduceScatterThunkProto::clear_reduction_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_kind_.ClearToEmpty();
}
inline const std::string& ReduceScatterThunkProto::reduction_kind() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ReduceScatterThunkProto.reduction_kind)
  return _internal_reduction_kind();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReduceScatterThunkProto::set_reduction_kind(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_kind_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.ReduceScatterThunkProto.reduction_kind)
}
inline std::string* ReduceScatterThunkProto::mutable_reduction_kind() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reduction_kind();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ReduceScatterThunkProto.reduction_kind)
  return _s;
}
inline const std::string& ReduceScatterThunkProto::_internal_reduction_kind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reduction_kind_.Get();
}
inline void ReduceScatterThunkProto::_internal_set_reduction_kind(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_kind_.Set(value, GetArena());
}
inline std::string* ReduceScatterThunkProto::_internal_mutable_reduction_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reduction_kind_.Mutable( GetArena());
}
inline std::string* ReduceScatterThunkProto::release_reduction_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ReduceScatterThunkProto.reduction_kind)
  return _impl_.reduction_kind_.Release();
}
inline void ReduceScatterThunkProto::set_allocated_reduction_kind(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_kind_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reduction_kind_.IsDefault()) {
          _impl_.reduction_kind_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ReduceScatterThunkProto.reduction_kind)
}

// -------------------------------------------------------------------

// CollectivePermuteThunkProto_SourceTargetPairProto

// int64 source = 1;
inline void CollectivePermuteThunkProto_SourceTargetPairProto::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = ::int64_t{0};
}
inline ::int64_t CollectivePermuteThunkProto_SourceTargetPairProto::source() const {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto.source)
  return _internal_source();
}
inline void CollectivePermuteThunkProto_SourceTargetPairProto::set_source(::int64_t value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto.source)
}
inline ::int64_t CollectivePermuteThunkProto_SourceTargetPairProto::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_;
}
inline void CollectivePermuteThunkProto_SourceTargetPairProto::_internal_set_source(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// int64 target = 2;
inline void CollectivePermuteThunkProto_SourceTargetPairProto::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = ::int64_t{0};
}
inline ::int64_t CollectivePermuteThunkProto_SourceTargetPairProto::target() const {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto.target)
  return _internal_target();
}
inline void CollectivePermuteThunkProto_SourceTargetPairProto::set_target(::int64_t value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto.target)
}
inline ::int64_t CollectivePermuteThunkProto_SourceTargetPairProto::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_;
}
inline void CollectivePermuteThunkProto_SourceTargetPairProto::_internal_set_target(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = value;
}

// -------------------------------------------------------------------

// CollectivePermuteThunkProto

// repeated .xla.cpu.CollectivePermuteThunkProto.SourceTargetPairProto source_target_pairs = 1;
inline int CollectivePermuteThunkProto::_internal_source_target_pairs_size() const {
  return _internal_source_target_pairs().size();
}
inline int CollectivePermuteThunkProto::source_target_pairs_size() const {
  return _internal_source_target_pairs_size();
}
inline void CollectivePermuteThunkProto::clear_source_target_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_target_pairs_.Clear();
}
inline ::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto* CollectivePermuteThunkProto::mutable_source_target_pairs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectivePermuteThunkProto.source_target_pairs)
  return _internal_mutable_source_target_pairs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto>* CollectivePermuteThunkProto::mutable_source_target_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.CollectivePermuteThunkProto.source_target_pairs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_source_target_pairs();
}
inline const ::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto& CollectivePermuteThunkProto::source_target_pairs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectivePermuteThunkProto.source_target_pairs)
  return _internal_source_target_pairs().Get(index);
}
inline ::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto* CollectivePermuteThunkProto::add_source_target_pairs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto* _add = _internal_mutable_source_target_pairs()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.CollectivePermuteThunkProto.source_target_pairs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto>& CollectivePermuteThunkProto::source_target_pairs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.CollectivePermuteThunkProto.source_target_pairs)
  return _internal_source_target_pairs();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto>&
CollectivePermuteThunkProto::_internal_source_target_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_target_pairs_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::CollectivePermuteThunkProto_SourceTargetPairProto>*
CollectivePermuteThunkProto::_internal_mutable_source_target_pairs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.source_target_pairs_;
}

// -------------------------------------------------------------------

// CollectiveThunkProto

// .xla.cpu.OpParamsProto op_params = 1;
inline bool CollectiveThunkProto::has_op_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.op_params_ != nullptr);
  return value;
}
inline void CollectiveThunkProto::clear_op_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_params_ != nullptr) _impl_.op_params_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::OpParamsProto& CollectiveThunkProto::_internal_op_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::OpParamsProto* p = _impl_.op_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::OpParamsProto&>(::xla::cpu::_OpParamsProto_default_instance_);
}
inline const ::xla::cpu::OpParamsProto& CollectiveThunkProto::op_params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectiveThunkProto.op_params)
  return _internal_op_params();
}
inline void CollectiveThunkProto::unsafe_arena_set_allocated_op_params(::xla::cpu::OpParamsProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.op_params_);
  }
  _impl_.op_params_ = reinterpret_cast<::xla::cpu::OpParamsProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CollectiveThunkProto.op_params)
}
inline ::xla::cpu::OpParamsProto* CollectiveThunkProto::release_op_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::OpParamsProto* released = _impl_.op_params_;
  _impl_.op_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::OpParamsProto* CollectiveThunkProto::unsafe_arena_release_op_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CollectiveThunkProto.op_params)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::OpParamsProto* temp = _impl_.op_params_;
  _impl_.op_params_ = nullptr;
  return temp;
}
inline ::xla::cpu::OpParamsProto* CollectiveThunkProto::_internal_mutable_op_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_params_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OpParamsProto>(GetArena());
    _impl_.op_params_ = reinterpret_cast<::xla::cpu::OpParamsProto*>(p);
  }
  return _impl_.op_params_;
}
inline ::xla::cpu::OpParamsProto* CollectiveThunkProto::mutable_op_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::OpParamsProto* _msg = _internal_mutable_op_params();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectiveThunkProto.op_params)
  return _msg;
}
inline void CollectiveThunkProto::set_allocated_op_params(::xla::cpu::OpParamsProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.op_params_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.op_params_ = reinterpret_cast<::xla::cpu::OpParamsProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CollectiveThunkProto.op_params)
}

// .xla.cpu.OpBuffersProto op_buffers = 2;
inline bool CollectiveThunkProto::has_op_buffers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.op_buffers_ != nullptr);
  return value;
}
inline void CollectiveThunkProto::clear_op_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_buffers_ != nullptr) _impl_.op_buffers_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::OpBuffersProto& CollectiveThunkProto::_internal_op_buffers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::OpBuffersProto* p = _impl_.op_buffers_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::OpBuffersProto&>(::xla::cpu::_OpBuffersProto_default_instance_);
}
inline const ::xla::cpu::OpBuffersProto& CollectiveThunkProto::op_buffers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectiveThunkProto.op_buffers)
  return _internal_op_buffers();
}
inline void CollectiveThunkProto::unsafe_arena_set_allocated_op_buffers(::xla::cpu::OpBuffersProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.op_buffers_);
  }
  _impl_.op_buffers_ = reinterpret_cast<::xla::cpu::OpBuffersProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CollectiveThunkProto.op_buffers)
}
inline ::xla::cpu::OpBuffersProto* CollectiveThunkProto::release_op_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::OpBuffersProto* released = _impl_.op_buffers_;
  _impl_.op_buffers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::OpBuffersProto* CollectiveThunkProto::unsafe_arena_release_op_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CollectiveThunkProto.op_buffers)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::OpBuffersProto* temp = _impl_.op_buffers_;
  _impl_.op_buffers_ = nullptr;
  return temp;
}
inline ::xla::cpu::OpBuffersProto* CollectiveThunkProto::_internal_mutable_op_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_buffers_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OpBuffersProto>(GetArena());
    _impl_.op_buffers_ = reinterpret_cast<::xla::cpu::OpBuffersProto*>(p);
  }
  return _impl_.op_buffers_;
}
inline ::xla::cpu::OpBuffersProto* CollectiveThunkProto::mutable_op_buffers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::OpBuffersProto* _msg = _internal_mutable_op_buffers();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectiveThunkProto.op_buffers)
  return _msg;
}
inline void CollectiveThunkProto::set_allocated_op_buffers(::xla::cpu::OpBuffersProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.op_buffers_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.op_buffers_ = reinterpret_cast<::xla::cpu::OpBuffersProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CollectiveThunkProto.op_buffers)
}

// .xla.cpu.OpResourcesProto op_resources = 3;
inline bool CollectiveThunkProto::has_op_resources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.op_resources_ != nullptr);
  return value;
}
inline void CollectiveThunkProto::clear_op_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_resources_ != nullptr) _impl_.op_resources_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xla::cpu::OpResourcesProto& CollectiveThunkProto::_internal_op_resources() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::OpResourcesProto* p = _impl_.op_resources_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::OpResourcesProto&>(::xla::cpu::_OpResourcesProto_default_instance_);
}
inline const ::xla::cpu::OpResourcesProto& CollectiveThunkProto::op_resources() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectiveThunkProto.op_resources)
  return _internal_op_resources();
}
inline void CollectiveThunkProto::unsafe_arena_set_allocated_op_resources(::xla::cpu::OpResourcesProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.op_resources_);
  }
  _impl_.op_resources_ = reinterpret_cast<::xla::cpu::OpResourcesProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CollectiveThunkProto.op_resources)
}
inline ::xla::cpu::OpResourcesProto* CollectiveThunkProto::release_op_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::OpResourcesProto* released = _impl_.op_resources_;
  _impl_.op_resources_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::OpResourcesProto* CollectiveThunkProto::unsafe_arena_release_op_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CollectiveThunkProto.op_resources)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::OpResourcesProto* temp = _impl_.op_resources_;
  _impl_.op_resources_ = nullptr;
  return temp;
}
inline ::xla::cpu::OpResourcesProto* CollectiveThunkProto::_internal_mutable_op_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_resources_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OpResourcesProto>(GetArena());
    _impl_.op_resources_ = reinterpret_cast<::xla::cpu::OpResourcesProto*>(p);
  }
  return _impl_.op_resources_;
}
inline ::xla::cpu::OpResourcesProto* CollectiveThunkProto::mutable_op_resources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::cpu::OpResourcesProto* _msg = _internal_mutable_op_resources();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectiveThunkProto.op_resources)
  return _msg;
}
inline void CollectiveThunkProto::set_allocated_op_resources(::xla::cpu::OpResourcesProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.op_resources_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.op_resources_ = reinterpret_cast<::xla::cpu::OpResourcesProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CollectiveThunkProto.op_resources)
}

// .xla.cpu.AllGatherThunkProto all_gather_thunk = 4;
inline bool CollectiveThunkProto::has_all_gather_thunk() const {
  return impl_case() == kAllGatherThunk;
}
inline bool CollectiveThunkProto::_internal_has_all_gather_thunk() const {
  return impl_case() == kAllGatherThunk;
}
inline void CollectiveThunkProto::set_has_all_gather_thunk() {
  _impl_._oneof_case_[0] = kAllGatherThunk;
}
inline void CollectiveThunkProto::clear_all_gather_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kAllGatherThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.all_gather_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.all_gather_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::AllGatherThunkProto* CollectiveThunkProto::release_all_gather_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.CollectiveThunkProto.all_gather_thunk)
  if (impl_case() == kAllGatherThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.all_gather_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.all_gather_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::AllGatherThunkProto& CollectiveThunkProto::_internal_all_gather_thunk() const {
  return impl_case() == kAllGatherThunk ? *_impl_.impl_.all_gather_thunk_ : reinterpret_cast<::xla::cpu::AllGatherThunkProto&>(::xla::cpu::_AllGatherThunkProto_default_instance_);
}
inline const ::xla::cpu::AllGatherThunkProto& CollectiveThunkProto::all_gather_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectiveThunkProto.all_gather_thunk)
  return _internal_all_gather_thunk();
}
inline ::xla::cpu::AllGatherThunkProto* CollectiveThunkProto::unsafe_arena_release_all_gather_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.CollectiveThunkProto.all_gather_thunk)
  if (impl_case() == kAllGatherThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.all_gather_thunk_;
    _impl_.impl_.all_gather_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectiveThunkProto::unsafe_arena_set_allocated_all_gather_thunk(::xla::cpu::AllGatherThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_all_gather_thunk();
    _impl_.impl_.all_gather_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CollectiveThunkProto.all_gather_thunk)
}
inline ::xla::cpu::AllGatherThunkProto* CollectiveThunkProto::_internal_mutable_all_gather_thunk() {
  if (impl_case() != kAllGatherThunk) {
    clear_impl();
    set_has_all_gather_thunk();
    _impl_.impl_.all_gather_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::AllGatherThunkProto>(GetArena());
  }
  return _impl_.impl_.all_gather_thunk_;
}
inline ::xla::cpu::AllGatherThunkProto* CollectiveThunkProto::mutable_all_gather_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::AllGatherThunkProto* _msg = _internal_mutable_all_gather_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectiveThunkProto.all_gather_thunk)
  return _msg;
}

// .xla.cpu.AllReduceThunkProto all_reduce_thunk = 5;
inline bool CollectiveThunkProto::has_all_reduce_thunk() const {
  return impl_case() == kAllReduceThunk;
}
inline bool CollectiveThunkProto::_internal_has_all_reduce_thunk() const {
  return impl_case() == kAllReduceThunk;
}
inline void CollectiveThunkProto::set_has_all_reduce_thunk() {
  _impl_._oneof_case_[0] = kAllReduceThunk;
}
inline void CollectiveThunkProto::clear_all_reduce_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kAllReduceThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.all_reduce_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.all_reduce_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::AllReduceThunkProto* CollectiveThunkProto::release_all_reduce_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.CollectiveThunkProto.all_reduce_thunk)
  if (impl_case() == kAllReduceThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.all_reduce_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.all_reduce_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::AllReduceThunkProto& CollectiveThunkProto::_internal_all_reduce_thunk() const {
  return impl_case() == kAllReduceThunk ? *_impl_.impl_.all_reduce_thunk_ : reinterpret_cast<::xla::cpu::AllReduceThunkProto&>(::xla::cpu::_AllReduceThunkProto_default_instance_);
}
inline const ::xla::cpu::AllReduceThunkProto& CollectiveThunkProto::all_reduce_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectiveThunkProto.all_reduce_thunk)
  return _internal_all_reduce_thunk();
}
inline ::xla::cpu::AllReduceThunkProto* CollectiveThunkProto::unsafe_arena_release_all_reduce_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.CollectiveThunkProto.all_reduce_thunk)
  if (impl_case() == kAllReduceThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.all_reduce_thunk_;
    _impl_.impl_.all_reduce_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectiveThunkProto::unsafe_arena_set_allocated_all_reduce_thunk(::xla::cpu::AllReduceThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_all_reduce_thunk();
    _impl_.impl_.all_reduce_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CollectiveThunkProto.all_reduce_thunk)
}
inline ::xla::cpu::AllReduceThunkProto* CollectiveThunkProto::_internal_mutable_all_reduce_thunk() {
  if (impl_case() != kAllReduceThunk) {
    clear_impl();
    set_has_all_reduce_thunk();
    _impl_.impl_.all_reduce_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::AllReduceThunkProto>(GetArena());
  }
  return _impl_.impl_.all_reduce_thunk_;
}
inline ::xla::cpu::AllReduceThunkProto* CollectiveThunkProto::mutable_all_reduce_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::AllReduceThunkProto* _msg = _internal_mutable_all_reduce_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectiveThunkProto.all_reduce_thunk)
  return _msg;
}

// .xla.cpu.AllToAllThunkProto all_to_all_thunk = 6;
inline bool CollectiveThunkProto::has_all_to_all_thunk() const {
  return impl_case() == kAllToAllThunk;
}
inline bool CollectiveThunkProto::_internal_has_all_to_all_thunk() const {
  return impl_case() == kAllToAllThunk;
}
inline void CollectiveThunkProto::set_has_all_to_all_thunk() {
  _impl_._oneof_case_[0] = kAllToAllThunk;
}
inline void CollectiveThunkProto::clear_all_to_all_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kAllToAllThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.all_to_all_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.all_to_all_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::AllToAllThunkProto* CollectiveThunkProto::release_all_to_all_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.CollectiveThunkProto.all_to_all_thunk)
  if (impl_case() == kAllToAllThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.all_to_all_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.all_to_all_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::AllToAllThunkProto& CollectiveThunkProto::_internal_all_to_all_thunk() const {
  return impl_case() == kAllToAllThunk ? *_impl_.impl_.all_to_all_thunk_ : reinterpret_cast<::xla::cpu::AllToAllThunkProto&>(::xla::cpu::_AllToAllThunkProto_default_instance_);
}
inline const ::xla::cpu::AllToAllThunkProto& CollectiveThunkProto::all_to_all_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectiveThunkProto.all_to_all_thunk)
  return _internal_all_to_all_thunk();
}
inline ::xla::cpu::AllToAllThunkProto* CollectiveThunkProto::unsafe_arena_release_all_to_all_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.CollectiveThunkProto.all_to_all_thunk)
  if (impl_case() == kAllToAllThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.all_to_all_thunk_;
    _impl_.impl_.all_to_all_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectiveThunkProto::unsafe_arena_set_allocated_all_to_all_thunk(::xla::cpu::AllToAllThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_all_to_all_thunk();
    _impl_.impl_.all_to_all_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CollectiveThunkProto.all_to_all_thunk)
}
inline ::xla::cpu::AllToAllThunkProto* CollectiveThunkProto::_internal_mutable_all_to_all_thunk() {
  if (impl_case() != kAllToAllThunk) {
    clear_impl();
    set_has_all_to_all_thunk();
    _impl_.impl_.all_to_all_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::AllToAllThunkProto>(GetArena());
  }
  return _impl_.impl_.all_to_all_thunk_;
}
inline ::xla::cpu::AllToAllThunkProto* CollectiveThunkProto::mutable_all_to_all_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::AllToAllThunkProto* _msg = _internal_mutable_all_to_all_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectiveThunkProto.all_to_all_thunk)
  return _msg;
}

// .xla.cpu.ReduceScatterThunkProto reduce_scatter_thunk = 7;
inline bool CollectiveThunkProto::has_reduce_scatter_thunk() const {
  return impl_case() == kReduceScatterThunk;
}
inline bool CollectiveThunkProto::_internal_has_reduce_scatter_thunk() const {
  return impl_case() == kReduceScatterThunk;
}
inline void CollectiveThunkProto::set_has_reduce_scatter_thunk() {
  _impl_._oneof_case_[0] = kReduceScatterThunk;
}
inline void CollectiveThunkProto::clear_reduce_scatter_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kReduceScatterThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.reduce_scatter_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.reduce_scatter_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::ReduceScatterThunkProto* CollectiveThunkProto::release_reduce_scatter_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.CollectiveThunkProto.reduce_scatter_thunk)
  if (impl_case() == kReduceScatterThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.reduce_scatter_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.reduce_scatter_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::ReduceScatterThunkProto& CollectiveThunkProto::_internal_reduce_scatter_thunk() const {
  return impl_case() == kReduceScatterThunk ? *_impl_.impl_.reduce_scatter_thunk_ : reinterpret_cast<::xla::cpu::ReduceScatterThunkProto&>(::xla::cpu::_ReduceScatterThunkProto_default_instance_);
}
inline const ::xla::cpu::ReduceScatterThunkProto& CollectiveThunkProto::reduce_scatter_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectiveThunkProto.reduce_scatter_thunk)
  return _internal_reduce_scatter_thunk();
}
inline ::xla::cpu::ReduceScatterThunkProto* CollectiveThunkProto::unsafe_arena_release_reduce_scatter_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.CollectiveThunkProto.reduce_scatter_thunk)
  if (impl_case() == kReduceScatterThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.reduce_scatter_thunk_;
    _impl_.impl_.reduce_scatter_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectiveThunkProto::unsafe_arena_set_allocated_reduce_scatter_thunk(::xla::cpu::ReduceScatterThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_reduce_scatter_thunk();
    _impl_.impl_.reduce_scatter_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CollectiveThunkProto.reduce_scatter_thunk)
}
inline ::xla::cpu::ReduceScatterThunkProto* CollectiveThunkProto::_internal_mutable_reduce_scatter_thunk() {
  if (impl_case() != kReduceScatterThunk) {
    clear_impl();
    set_has_reduce_scatter_thunk();
    _impl_.impl_.reduce_scatter_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ReduceScatterThunkProto>(GetArena());
  }
  return _impl_.impl_.reduce_scatter_thunk_;
}
inline ::xla::cpu::ReduceScatterThunkProto* CollectiveThunkProto::mutable_reduce_scatter_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::ReduceScatterThunkProto* _msg = _internal_mutable_reduce_scatter_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectiveThunkProto.reduce_scatter_thunk)
  return _msg;
}

// .xla.cpu.CollectivePermuteThunkProto collective_permute_thunk = 8;
inline bool CollectiveThunkProto::has_collective_permute_thunk() const {
  return impl_case() == kCollectivePermuteThunk;
}
inline bool CollectiveThunkProto::_internal_has_collective_permute_thunk() const {
  return impl_case() == kCollectivePermuteThunk;
}
inline void CollectiveThunkProto::set_has_collective_permute_thunk() {
  _impl_._oneof_case_[0] = kCollectivePermuteThunk;
}
inline void CollectiveThunkProto::clear_collective_permute_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kCollectivePermuteThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.collective_permute_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.collective_permute_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::CollectivePermuteThunkProto* CollectiveThunkProto::release_collective_permute_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.CollectiveThunkProto.collective_permute_thunk)
  if (impl_case() == kCollectivePermuteThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.collective_permute_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.collective_permute_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::CollectivePermuteThunkProto& CollectiveThunkProto::_internal_collective_permute_thunk() const {
  return impl_case() == kCollectivePermuteThunk ? *_impl_.impl_.collective_permute_thunk_ : reinterpret_cast<::xla::cpu::CollectivePermuteThunkProto&>(::xla::cpu::_CollectivePermuteThunkProto_default_instance_);
}
inline const ::xla::cpu::CollectivePermuteThunkProto& CollectiveThunkProto::collective_permute_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CollectiveThunkProto.collective_permute_thunk)
  return _internal_collective_permute_thunk();
}
inline ::xla::cpu::CollectivePermuteThunkProto* CollectiveThunkProto::unsafe_arena_release_collective_permute_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.CollectiveThunkProto.collective_permute_thunk)
  if (impl_case() == kCollectivePermuteThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.collective_permute_thunk_;
    _impl_.impl_.collective_permute_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectiveThunkProto::unsafe_arena_set_allocated_collective_permute_thunk(::xla::cpu::CollectivePermuteThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_collective_permute_thunk();
    _impl_.impl_.collective_permute_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CollectiveThunkProto.collective_permute_thunk)
}
inline ::xla::cpu::CollectivePermuteThunkProto* CollectiveThunkProto::_internal_mutable_collective_permute_thunk() {
  if (impl_case() != kCollectivePermuteThunk) {
    clear_impl();
    set_has_collective_permute_thunk();
    _impl_.impl_.collective_permute_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::CollectivePermuteThunkProto>(GetArena());
  }
  return _impl_.impl_.collective_permute_thunk_;
}
inline ::xla::cpu::CollectivePermuteThunkProto* CollectiveThunkProto::mutable_collective_permute_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::CollectivePermuteThunkProto* _msg = _internal_mutable_collective_permute_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CollectiveThunkProto.collective_permute_thunk)
  return _msg;
}

inline bool CollectiveThunkProto::has_impl() const {
  return impl_case() != IMPL_NOT_SET;
}
inline void CollectiveThunkProto::clear_has_impl() {
  _impl_._oneof_case_[0] = IMPL_NOT_SET;
}
inline CollectiveThunkProto::ImplCase CollectiveThunkProto::impl_case() const {
  return CollectiveThunkProto::ImplCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CallThunkProto

// .xla.cpu.ThunkSequenceProto called_sequence = 1;
inline bool CallThunkProto::has_called_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.called_sequence_ != nullptr);
  return value;
}
inline void CallThunkProto::clear_called_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.called_sequence_ != nullptr) _impl_.called_sequence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ThunkSequenceProto& CallThunkProto::_internal_called_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ThunkSequenceProto* p = _impl_.called_sequence_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ThunkSequenceProto&>(::xla::cpu::_ThunkSequenceProto_default_instance_);
}
inline const ::xla::cpu::ThunkSequenceProto& CallThunkProto::called_sequence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CallThunkProto.called_sequence)
  return _internal_called_sequence();
}
inline void CallThunkProto::unsafe_arena_set_allocated_called_sequence(::xla::cpu::ThunkSequenceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.called_sequence_);
  }
  _impl_.called_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CallThunkProto.called_sequence)
}
inline ::xla::cpu::ThunkSequenceProto* CallThunkProto::release_called_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ThunkSequenceProto* released = _impl_.called_sequence_;
  _impl_.called_sequence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ThunkSequenceProto* CallThunkProto::unsafe_arena_release_called_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CallThunkProto.called_sequence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ThunkSequenceProto* temp = _impl_.called_sequence_;
  _impl_.called_sequence_ = nullptr;
  return temp;
}
inline ::xla::cpu::ThunkSequenceProto* CallThunkProto::_internal_mutable_called_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.called_sequence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ThunkSequenceProto>(GetArena());
    _impl_.called_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(p);
  }
  return _impl_.called_sequence_;
}
inline ::xla::cpu::ThunkSequenceProto* CallThunkProto::mutable_called_sequence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ThunkSequenceProto* _msg = _internal_mutable_called_sequence();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CallThunkProto.called_sequence)
  return _msg;
}
inline void CallThunkProto::set_allocated_called_sequence(::xla::cpu::ThunkSequenceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.called_sequence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.called_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CallThunkProto.called_sequence)
}

// -------------------------------------------------------------------

// ConditionalThunkProto

// repeated .xla.cpu.ThunkSequenceProto branch_sequences = 1;
inline int ConditionalThunkProto::_internal_branch_sequences_size() const {
  return _internal_branch_sequences().size();
}
inline int ConditionalThunkProto::branch_sequences_size() const {
  return _internal_branch_sequences_size();
}
inline void ConditionalThunkProto::clear_branch_sequences() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.branch_sequences_.Clear();
}
inline ::xla::cpu::ThunkSequenceProto* ConditionalThunkProto::mutable_branch_sequences(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.ConditionalThunkProto.branch_sequences)
  return _internal_mutable_branch_sequences()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto>* ConditionalThunkProto::mutable_branch_sequences()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.ConditionalThunkProto.branch_sequences)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_branch_sequences();
}
inline const ::xla::cpu::ThunkSequenceProto& ConditionalThunkProto::branch_sequences(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ConditionalThunkProto.branch_sequences)
  return _internal_branch_sequences().Get(index);
}
inline ::xla::cpu::ThunkSequenceProto* ConditionalThunkProto::add_branch_sequences() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ThunkSequenceProto* _add = _internal_mutable_branch_sequences()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.ConditionalThunkProto.branch_sequences)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto>& ConditionalThunkProto::branch_sequences() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.ConditionalThunkProto.branch_sequences)
  return _internal_branch_sequences();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto>&
ConditionalThunkProto::_internal_branch_sequences() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.branch_sequences_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto>*
ConditionalThunkProto::_internal_mutable_branch_sequences() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.branch_sequences_;
}

// .xla.buffer_assignment.BufferAllocationSliceProto branch_index_buffer = 2;
inline bool ConditionalThunkProto::has_branch_index_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_index_buffer_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& ConditionalThunkProto::_internal_branch_index_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.branch_index_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& ConditionalThunkProto::branch_index_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ConditionalThunkProto.branch_index_buffer)
  return _internal_branch_index_buffer();
}
inline void ConditionalThunkProto::unsafe_arena_set_allocated_branch_index_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.branch_index_buffer_);
  }
  _impl_.branch_index_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ConditionalThunkProto.branch_index_buffer)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ConditionalThunkProto::release_branch_index_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.branch_index_buffer_;
  _impl_.branch_index_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ConditionalThunkProto::unsafe_arena_release_branch_index_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ConditionalThunkProto.branch_index_buffer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.branch_index_buffer_;
  _impl_.branch_index_buffer_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ConditionalThunkProto::_internal_mutable_branch_index_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.branch_index_buffer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.branch_index_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.branch_index_buffer_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ConditionalThunkProto::mutable_branch_index_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_branch_index_buffer();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ConditionalThunkProto.branch_index_buffer)
  return _msg;
}
inline void ConditionalThunkProto::set_allocated_branch_index_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.branch_index_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.branch_index_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ConditionalThunkProto.branch_index_buffer)
}

// -------------------------------------------------------------------

// ConvolutionThunkProto_Options

// bool multi_threaded = 1;
inline void ConvolutionThunkProto_Options::clear_multi_threaded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.multi_threaded_ = false;
}
inline bool ConvolutionThunkProto_Options::multi_threaded() const {
  // @@protoc_insertion_point(field_get:xla.cpu.ConvolutionThunkProto.Options.multi_threaded)
  return _internal_multi_threaded();
}
inline void ConvolutionThunkProto_Options::set_multi_threaded(bool value) {
  _internal_set_multi_threaded(value);
  // @@protoc_insertion_point(field_set:xla.cpu.ConvolutionThunkProto.Options.multi_threaded)
}
inline bool ConvolutionThunkProto_Options::_internal_multi_threaded() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.multi_threaded_;
}
inline void ConvolutionThunkProto_Options::_internal_set_multi_threaded(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.multi_threaded_ = value;
}

// -------------------------------------------------------------------

// ConvolutionThunkProto

// .xla.ConvolutionDimensionNumbers dimension_numbers = 1;
inline bool ConvolutionThunkProto::has_dimension_numbers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimension_numbers_ != nullptr);
  return value;
}
inline const ::xla::ConvolutionDimensionNumbers& ConvolutionThunkProto::_internal_dimension_numbers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::ConvolutionDimensionNumbers* p = _impl_.dimension_numbers_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::ConvolutionDimensionNumbers&>(::xla::_ConvolutionDimensionNumbers_default_instance_);
}
inline const ::xla::ConvolutionDimensionNumbers& ConvolutionThunkProto::dimension_numbers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ConvolutionThunkProto.dimension_numbers)
  return _internal_dimension_numbers();
}
inline void ConvolutionThunkProto::unsafe_arena_set_allocated_dimension_numbers(::xla::ConvolutionDimensionNumbers* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimension_numbers_);
  }
  _impl_.dimension_numbers_ = reinterpret_cast<::xla::ConvolutionDimensionNumbers*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ConvolutionThunkProto.dimension_numbers)
}
inline ::xla::ConvolutionDimensionNumbers* ConvolutionThunkProto::release_dimension_numbers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::ConvolutionDimensionNumbers* released = _impl_.dimension_numbers_;
  _impl_.dimension_numbers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::ConvolutionDimensionNumbers* ConvolutionThunkProto::unsafe_arena_release_dimension_numbers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ConvolutionThunkProto.dimension_numbers)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::ConvolutionDimensionNumbers* temp = _impl_.dimension_numbers_;
  _impl_.dimension_numbers_ = nullptr;
  return temp;
}
inline ::xla::ConvolutionDimensionNumbers* ConvolutionThunkProto::_internal_mutable_dimension_numbers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dimension_numbers_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::ConvolutionDimensionNumbers>(GetArena());
    _impl_.dimension_numbers_ = reinterpret_cast<::xla::ConvolutionDimensionNumbers*>(p);
  }
  return _impl_.dimension_numbers_;
}
inline ::xla::ConvolutionDimensionNumbers* ConvolutionThunkProto::mutable_dimension_numbers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::ConvolutionDimensionNumbers* _msg = _internal_mutable_dimension_numbers();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ConvolutionThunkProto.dimension_numbers)
  return _msg;
}
inline void ConvolutionThunkProto::set_allocated_dimension_numbers(::xla::ConvolutionDimensionNumbers* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimension_numbers_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dimension_numbers_ = reinterpret_cast<::xla::ConvolutionDimensionNumbers*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ConvolutionThunkProto.dimension_numbers)
}

// .xla.Window window = 2;
inline bool ConvolutionThunkProto::has_window() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.window_ != nullptr);
  return value;
}
inline const ::xla::Window& ConvolutionThunkProto::_internal_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::Window* p = _impl_.window_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::Window&>(::xla::_Window_default_instance_);
}
inline const ::xla::Window& ConvolutionThunkProto::window() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ConvolutionThunkProto.window)
  return _internal_window();
}
inline void ConvolutionThunkProto::unsafe_arena_set_allocated_window(::xla::Window* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_);
  }
  _impl_.window_ = reinterpret_cast<::xla::Window*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ConvolutionThunkProto.window)
}
inline ::xla::Window* ConvolutionThunkProto::release_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::Window* released = _impl_.window_;
  _impl_.window_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::Window* ConvolutionThunkProto::unsafe_arena_release_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ConvolutionThunkProto.window)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::Window* temp = _impl_.window_;
  _impl_.window_ = nullptr;
  return temp;
}
inline ::xla::Window* ConvolutionThunkProto::_internal_mutable_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.window_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::Window>(GetArena());
    _impl_.window_ = reinterpret_cast<::xla::Window*>(p);
  }
  return _impl_.window_;
}
inline ::xla::Window* ConvolutionThunkProto::mutable_window() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::Window* _msg = _internal_mutable_window();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ConvolutionThunkProto.window)
  return _msg;
}
inline void ConvolutionThunkProto::set_allocated_window(::xla::Window* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.window_ = reinterpret_cast<::xla::Window*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ConvolutionThunkProto.window)
}

// int64 feature_group_count = 3;
inline void ConvolutionThunkProto::clear_feature_group_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_group_count_ = ::int64_t{0};
}
inline ::int64_t ConvolutionThunkProto::feature_group_count() const {
  // @@protoc_insertion_point(field_get:xla.cpu.ConvolutionThunkProto.feature_group_count)
  return _internal_feature_group_count();
}
inline void ConvolutionThunkProto::set_feature_group_count(::int64_t value) {
  _internal_set_feature_group_count(value);
  // @@protoc_insertion_point(field_set:xla.cpu.ConvolutionThunkProto.feature_group_count)
}
inline ::int64_t ConvolutionThunkProto::_internal_feature_group_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feature_group_count_;
}
inline void ConvolutionThunkProto::_internal_set_feature_group_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_group_count_ = value;
}

// .xla.cpu.ShapeBufferAllocationSliceProto input_buffer_shape = 4;
inline bool ConvolutionThunkProto::has_input_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_buffer_shape_ != nullptr);
  return value;
}
inline void ConvolutionThunkProto::clear_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_buffer_shape_ != nullptr) _impl_.input_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& ConvolutionThunkProto::_internal_input_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.input_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& ConvolutionThunkProto::input_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ConvolutionThunkProto.input_buffer_shape)
  return _internal_input_buffer_shape();
}
inline void ConvolutionThunkProto::unsafe_arena_set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_buffer_shape_);
  }
  _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ConvolutionThunkProto.input_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::release_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.input_buffer_shape_;
  _impl_.input_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::unsafe_arena_release_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ConvolutionThunkProto.input_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.input_buffer_shape_;
  _impl_.input_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::_internal_mutable_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.input_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::mutable_input_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_input_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ConvolutionThunkProto.input_buffer_shape)
  return _msg;
}
inline void ConvolutionThunkProto::set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ConvolutionThunkProto.input_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto kernel_buffer_shape = 5;
inline bool ConvolutionThunkProto::has_kernel_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kernel_buffer_shape_ != nullptr);
  return value;
}
inline void ConvolutionThunkProto::clear_kernel_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kernel_buffer_shape_ != nullptr) _impl_.kernel_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& ConvolutionThunkProto::_internal_kernel_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.kernel_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& ConvolutionThunkProto::kernel_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ConvolutionThunkProto.kernel_buffer_shape)
  return _internal_kernel_buffer_shape();
}
inline void ConvolutionThunkProto::unsafe_arena_set_allocated_kernel_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kernel_buffer_shape_);
  }
  _impl_.kernel_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ConvolutionThunkProto.kernel_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::release_kernel_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.kernel_buffer_shape_;
  _impl_.kernel_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::unsafe_arena_release_kernel_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ConvolutionThunkProto.kernel_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.kernel_buffer_shape_;
  _impl_.kernel_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::_internal_mutable_kernel_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kernel_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.kernel_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.kernel_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::mutable_kernel_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_kernel_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ConvolutionThunkProto.kernel_buffer_shape)
  return _msg;
}
inline void ConvolutionThunkProto::set_allocated_kernel_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.kernel_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.kernel_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ConvolutionThunkProto.kernel_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto output_buffer_shape = 6;
inline bool ConvolutionThunkProto::has_output_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_buffer_shape_ != nullptr);
  return value;
}
inline void ConvolutionThunkProto::clear_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_buffer_shape_ != nullptr) _impl_.output_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& ConvolutionThunkProto::_internal_output_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.output_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& ConvolutionThunkProto::output_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ConvolutionThunkProto.output_buffer_shape)
  return _internal_output_buffer_shape();
}
inline void ConvolutionThunkProto::unsafe_arena_set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_buffer_shape_);
  }
  _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ConvolutionThunkProto.output_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::release_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.output_buffer_shape_;
  _impl_.output_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::unsafe_arena_release_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ConvolutionThunkProto.output_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.output_buffer_shape_;
  _impl_.output_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::_internal_mutable_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.output_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* ConvolutionThunkProto::mutable_output_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_output_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ConvolutionThunkProto.output_buffer_shape)
  return _msg;
}
inline void ConvolutionThunkProto::set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.output_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ConvolutionThunkProto.output_buffer_shape)
}

// .xla.cpu.ConvolutionThunkProto.Options options = 7;
inline bool ConvolutionThunkProto::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void ConvolutionThunkProto::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::xla::cpu::ConvolutionThunkProto_Options& ConvolutionThunkProto::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ConvolutionThunkProto_Options* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ConvolutionThunkProto_Options&>(::xla::cpu::_ConvolutionThunkProto_Options_default_instance_);
}
inline const ::xla::cpu::ConvolutionThunkProto_Options& ConvolutionThunkProto::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ConvolutionThunkProto.options)
  return _internal_options();
}
inline void ConvolutionThunkProto::unsafe_arena_set_allocated_options(::xla::cpu::ConvolutionThunkProto_Options* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::xla::cpu::ConvolutionThunkProto_Options*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ConvolutionThunkProto.options)
}
inline ::xla::cpu::ConvolutionThunkProto_Options* ConvolutionThunkProto::release_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::xla::cpu::ConvolutionThunkProto_Options* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ConvolutionThunkProto_Options* ConvolutionThunkProto::unsafe_arena_release_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ConvolutionThunkProto.options)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::xla::cpu::ConvolutionThunkProto_Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::xla::cpu::ConvolutionThunkProto_Options* ConvolutionThunkProto::_internal_mutable_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ConvolutionThunkProto_Options>(GetArena());
    _impl_.options_ = reinterpret_cast<::xla::cpu::ConvolutionThunkProto_Options*>(p);
  }
  return _impl_.options_;
}
inline ::xla::cpu::ConvolutionThunkProto_Options* ConvolutionThunkProto::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::xla::cpu::ConvolutionThunkProto_Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ConvolutionThunkProto.options)
  return _msg;
}
inline void ConvolutionThunkProto::set_allocated_options(::xla::cpu::ConvolutionThunkProto_Options* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.options_ = reinterpret_cast<::xla::cpu::ConvolutionThunkProto_Options*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ConvolutionThunkProto.options)
}

// -------------------------------------------------------------------

// SortThunkProto

// int64 dimension = 1;
inline void SortThunkProto::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = ::int64_t{0};
}
inline ::int64_t SortThunkProto::dimension() const {
  // @@protoc_insertion_point(field_get:xla.cpu.SortThunkProto.dimension)
  return _internal_dimension();
}
inline void SortThunkProto::set_dimension(::int64_t value) {
  _internal_set_dimension(value);
  // @@protoc_insertion_point(field_set:xla.cpu.SortThunkProto.dimension)
}
inline ::int64_t SortThunkProto::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dimension_;
}
inline void SortThunkProto::_internal_set_dimension(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = value;
}

// bool is_stable = 2;
inline void SortThunkProto::clear_is_stable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_stable_ = false;
}
inline bool SortThunkProto::is_stable() const {
  // @@protoc_insertion_point(field_get:xla.cpu.SortThunkProto.is_stable)
  return _internal_is_stable();
}
inline void SortThunkProto::set_is_stable(bool value) {
  _internal_set_is_stable(value);
  // @@protoc_insertion_point(field_set:xla.cpu.SortThunkProto.is_stable)
}
inline bool SortThunkProto::_internal_is_stable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_stable_;
}
inline void SortThunkProto::_internal_set_is_stable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_stable_ = value;
}

// .xla.cpu.SortDirectionOptional direction = 3;
inline bool SortThunkProto::has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.direction_ != nullptr);
  return value;
}
inline void SortThunkProto::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::SortDirectionOptional& SortThunkProto::_internal_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::SortDirectionOptional* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::SortDirectionOptional&>(::xla::cpu::_SortDirectionOptional_default_instance_);
}
inline const ::xla::cpu::SortDirectionOptional& SortThunkProto::direction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.SortThunkProto.direction)
  return _internal_direction();
}
inline void SortThunkProto::unsafe_arena_set_allocated_direction(::xla::cpu::SortDirectionOptional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = reinterpret_cast<::xla::cpu::SortDirectionOptional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.SortThunkProto.direction)
}
inline ::xla::cpu::SortDirectionOptional* SortThunkProto::release_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::SortDirectionOptional* released = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::SortDirectionOptional* SortThunkProto::unsafe_arena_release_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.SortThunkProto.direction)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::SortDirectionOptional* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::xla::cpu::SortDirectionOptional* SortThunkProto::_internal_mutable_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.direction_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::SortDirectionOptional>(GetArena());
    _impl_.direction_ = reinterpret_cast<::xla::cpu::SortDirectionOptional*>(p);
  }
  return _impl_.direction_;
}
inline ::xla::cpu::SortDirectionOptional* SortThunkProto::mutable_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::SortDirectionOptional* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:xla.cpu.SortThunkProto.direction)
  return _msg;
}
inline void SortThunkProto::set_allocated_direction(::xla::cpu::SortDirectionOptional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.direction_ = reinterpret_cast<::xla::cpu::SortDirectionOptional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.SortThunkProto.direction)
}

// string comparator_name = 4;
inline void SortThunkProto::clear_comparator_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparator_name_.ClearToEmpty();
}
inline const std::string& SortThunkProto::comparator_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.SortThunkProto.comparator_name)
  return _internal_comparator_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SortThunkProto::set_comparator_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparator_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.SortThunkProto.comparator_name)
}
inline std::string* SortThunkProto::mutable_comparator_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_comparator_name();
  // @@protoc_insertion_point(field_mutable:xla.cpu.SortThunkProto.comparator_name)
  return _s;
}
inline const std::string& SortThunkProto::_internal_comparator_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.comparator_name_.Get();
}
inline void SortThunkProto::_internal_set_comparator_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparator_name_.Set(value, GetArena());
}
inline std::string* SortThunkProto::_internal_mutable_comparator_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.comparator_name_.Mutable( GetArena());
}
inline std::string* SortThunkProto::release_comparator_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.SortThunkProto.comparator_name)
  return _impl_.comparator_name_.Release();
}
inline void SortThunkProto::set_allocated_comparator_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparator_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comparator_name_.IsDefault()) {
          _impl_.comparator_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.SortThunkProto.comparator_name)
}

// repeated .xla.cpu.ShapeBufferAllocationSliceProto inputs_shapes = 5;
inline int SortThunkProto::_internal_inputs_shapes_size() const {
  return _internal_inputs_shapes().size();
}
inline int SortThunkProto::inputs_shapes_size() const {
  return _internal_inputs_shapes_size();
}
inline void SortThunkProto::clear_inputs_shapes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_shapes_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* SortThunkProto::mutable_inputs_shapes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.SortThunkProto.inputs_shapes)
  return _internal_mutable_inputs_shapes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* SortThunkProto::mutable_inputs_shapes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.SortThunkProto.inputs_shapes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs_shapes();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& SortThunkProto::inputs_shapes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.SortThunkProto.inputs_shapes)
  return _internal_inputs_shapes().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* SortThunkProto::add_inputs_shapes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_inputs_shapes()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.SortThunkProto.inputs_shapes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& SortThunkProto::inputs_shapes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.SortThunkProto.inputs_shapes)
  return _internal_inputs_shapes();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
SortThunkProto::_internal_inputs_shapes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_shapes_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
SortThunkProto::_internal_mutable_inputs_shapes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_shapes_;
}

// -------------------------------------------------------------------

// XnnDotThunkProto

// .xla.DotDimensionNumbers dot_dimensions = 1;
inline bool XnnDotThunkProto::has_dot_dimensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dot_dimensions_ != nullptr);
  return value;
}
inline const ::xla::DotDimensionNumbers& XnnDotThunkProto::_internal_dot_dimensions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::DotDimensionNumbers* p = _impl_.dot_dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::DotDimensionNumbers&>(::xla::_DotDimensionNumbers_default_instance_);
}
inline const ::xla::DotDimensionNumbers& XnnDotThunkProto::dot_dimensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnDotThunkProto.dot_dimensions)
  return _internal_dot_dimensions();
}
inline void XnnDotThunkProto::unsafe_arena_set_allocated_dot_dimensions(::xla::DotDimensionNumbers* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dot_dimensions_);
  }
  _impl_.dot_dimensions_ = reinterpret_cast<::xla::DotDimensionNumbers*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnDotThunkProto.dot_dimensions)
}
inline ::xla::DotDimensionNumbers* XnnDotThunkProto::release_dot_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::DotDimensionNumbers* released = _impl_.dot_dimensions_;
  _impl_.dot_dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::DotDimensionNumbers* XnnDotThunkProto::unsafe_arena_release_dot_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnDotThunkProto.dot_dimensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::DotDimensionNumbers* temp = _impl_.dot_dimensions_;
  _impl_.dot_dimensions_ = nullptr;
  return temp;
}
inline ::xla::DotDimensionNumbers* XnnDotThunkProto::_internal_mutable_dot_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dot_dimensions_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::DotDimensionNumbers>(GetArena());
    _impl_.dot_dimensions_ = reinterpret_cast<::xla::DotDimensionNumbers*>(p);
  }
  return _impl_.dot_dimensions_;
}
inline ::xla::DotDimensionNumbers* XnnDotThunkProto::mutable_dot_dimensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::DotDimensionNumbers* _msg = _internal_mutable_dot_dimensions();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnDotThunkProto.dot_dimensions)
  return _msg;
}
inline void XnnDotThunkProto::set_allocated_dot_dimensions(::xla::DotDimensionNumbers* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dot_dimensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dot_dimensions_ = reinterpret_cast<::xla::DotDimensionNumbers*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnDotThunkProto.dot_dimensions)
}

// .xla.cpu.ShapeBufferAllocationSliceProto lhs_buffer_shape = 2;
inline bool XnnDotThunkProto::has_lhs_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lhs_buffer_shape_ != nullptr);
  return value;
}
inline void XnnDotThunkProto::clear_lhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_buffer_shape_ != nullptr) _impl_.lhs_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnDotThunkProto::_internal_lhs_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.lhs_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnDotThunkProto::lhs_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnDotThunkProto.lhs_buffer_shape)
  return _internal_lhs_buffer_shape();
}
inline void XnnDotThunkProto::unsafe_arena_set_allocated_lhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lhs_buffer_shape_);
  }
  _impl_.lhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnDotThunkProto.lhs_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::release_lhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.lhs_buffer_shape_;
  _impl_.lhs_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::unsafe_arena_release_lhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnDotThunkProto.lhs_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.lhs_buffer_shape_;
  _impl_.lhs_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::_internal_mutable_lhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.lhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.lhs_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::mutable_lhs_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_lhs_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnDotThunkProto.lhs_buffer_shape)
  return _msg;
}
inline void XnnDotThunkProto::set_allocated_lhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lhs_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnDotThunkProto.lhs_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto rhs_buffer_shape = 3;
inline bool XnnDotThunkProto::has_rhs_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_buffer_shape_ != nullptr);
  return value;
}
inline void XnnDotThunkProto::clear_rhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_buffer_shape_ != nullptr) _impl_.rhs_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnDotThunkProto::_internal_rhs_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.rhs_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnDotThunkProto::rhs_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnDotThunkProto.rhs_buffer_shape)
  return _internal_rhs_buffer_shape();
}
inline void XnnDotThunkProto::unsafe_arena_set_allocated_rhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rhs_buffer_shape_);
  }
  _impl_.rhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnDotThunkProto.rhs_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::release_rhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.rhs_buffer_shape_;
  _impl_.rhs_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::unsafe_arena_release_rhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnDotThunkProto.rhs_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.rhs_buffer_shape_;
  _impl_.rhs_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::_internal_mutable_rhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.rhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.rhs_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::mutable_rhs_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_rhs_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnDotThunkProto.rhs_buffer_shape)
  return _msg;
}
inline void XnnDotThunkProto::set_allocated_rhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rhs_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnDotThunkProto.rhs_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto out_buffer_shape = 4;
inline bool XnnDotThunkProto::has_out_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.out_buffer_shape_ != nullptr);
  return value;
}
inline void XnnDotThunkProto::clear_out_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.out_buffer_shape_ != nullptr) _impl_.out_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnDotThunkProto::_internal_out_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.out_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnDotThunkProto::out_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnDotThunkProto.out_buffer_shape)
  return _internal_out_buffer_shape();
}
inline void XnnDotThunkProto::unsafe_arena_set_allocated_out_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.out_buffer_shape_);
  }
  _impl_.out_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnDotThunkProto.out_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::release_out_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.out_buffer_shape_;
  _impl_.out_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::unsafe_arena_release_out_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnDotThunkProto.out_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.out_buffer_shape_;
  _impl_.out_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::_internal_mutable_out_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.out_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.out_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.out_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnDotThunkProto::mutable_out_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_out_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnDotThunkProto.out_buffer_shape)
  return _msg;
}
inline void XnnDotThunkProto::set_allocated_out_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.out_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.out_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnDotThunkProto.out_buffer_shape)
}

// bool capture_rhs = 5;
inline void XnnDotThunkProto::clear_capture_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capture_rhs_ = false;
}
inline bool XnnDotThunkProto::capture_rhs() const {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnDotThunkProto.capture_rhs)
  return _internal_capture_rhs();
}
inline void XnnDotThunkProto::set_capture_rhs(bool value) {
  _internal_set_capture_rhs(value);
  // @@protoc_insertion_point(field_set:xla.cpu.XnnDotThunkProto.capture_rhs)
}
inline bool XnnDotThunkProto::_internal_capture_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capture_rhs_;
}
inline void XnnDotThunkProto::_internal_set_capture_rhs(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capture_rhs_ = value;
}

// -------------------------------------------------------------------

// XnnConvolutionThunkProto

// .xla.ConvolutionDimensionNumbers dimension_numbers = 1;
inline bool XnnConvolutionThunkProto::has_dimension_numbers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimension_numbers_ != nullptr);
  return value;
}
inline const ::xla::ConvolutionDimensionNumbers& XnnConvolutionThunkProto::_internal_dimension_numbers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::ConvolutionDimensionNumbers* p = _impl_.dimension_numbers_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::ConvolutionDimensionNumbers&>(::xla::_ConvolutionDimensionNumbers_default_instance_);
}
inline const ::xla::ConvolutionDimensionNumbers& XnnConvolutionThunkProto::dimension_numbers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnConvolutionThunkProto.dimension_numbers)
  return _internal_dimension_numbers();
}
inline void XnnConvolutionThunkProto::unsafe_arena_set_allocated_dimension_numbers(::xla::ConvolutionDimensionNumbers* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimension_numbers_);
  }
  _impl_.dimension_numbers_ = reinterpret_cast<::xla::ConvolutionDimensionNumbers*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnConvolutionThunkProto.dimension_numbers)
}
inline ::xla::ConvolutionDimensionNumbers* XnnConvolutionThunkProto::release_dimension_numbers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::ConvolutionDimensionNumbers* released = _impl_.dimension_numbers_;
  _impl_.dimension_numbers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::ConvolutionDimensionNumbers* XnnConvolutionThunkProto::unsafe_arena_release_dimension_numbers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnConvolutionThunkProto.dimension_numbers)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::ConvolutionDimensionNumbers* temp = _impl_.dimension_numbers_;
  _impl_.dimension_numbers_ = nullptr;
  return temp;
}
inline ::xla::ConvolutionDimensionNumbers* XnnConvolutionThunkProto::_internal_mutable_dimension_numbers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dimension_numbers_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::ConvolutionDimensionNumbers>(GetArena());
    _impl_.dimension_numbers_ = reinterpret_cast<::xla::ConvolutionDimensionNumbers*>(p);
  }
  return _impl_.dimension_numbers_;
}
inline ::xla::ConvolutionDimensionNumbers* XnnConvolutionThunkProto::mutable_dimension_numbers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::ConvolutionDimensionNumbers* _msg = _internal_mutable_dimension_numbers();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnConvolutionThunkProto.dimension_numbers)
  return _msg;
}
inline void XnnConvolutionThunkProto::set_allocated_dimension_numbers(::xla::ConvolutionDimensionNumbers* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimension_numbers_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dimension_numbers_ = reinterpret_cast<::xla::ConvolutionDimensionNumbers*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnConvolutionThunkProto.dimension_numbers)
}

// .xla.Window window = 2;
inline bool XnnConvolutionThunkProto::has_window() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.window_ != nullptr);
  return value;
}
inline const ::xla::Window& XnnConvolutionThunkProto::_internal_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::Window* p = _impl_.window_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::Window&>(::xla::_Window_default_instance_);
}
inline const ::xla::Window& XnnConvolutionThunkProto::window() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnConvolutionThunkProto.window)
  return _internal_window();
}
inline void XnnConvolutionThunkProto::unsafe_arena_set_allocated_window(::xla::Window* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_);
  }
  _impl_.window_ = reinterpret_cast<::xla::Window*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnConvolutionThunkProto.window)
}
inline ::xla::Window* XnnConvolutionThunkProto::release_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::Window* released = _impl_.window_;
  _impl_.window_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::Window* XnnConvolutionThunkProto::unsafe_arena_release_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnConvolutionThunkProto.window)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::Window* temp = _impl_.window_;
  _impl_.window_ = nullptr;
  return temp;
}
inline ::xla::Window* XnnConvolutionThunkProto::_internal_mutable_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.window_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::Window>(GetArena());
    _impl_.window_ = reinterpret_cast<::xla::Window*>(p);
  }
  return _impl_.window_;
}
inline ::xla::Window* XnnConvolutionThunkProto::mutable_window() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::Window* _msg = _internal_mutable_window();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnConvolutionThunkProto.window)
  return _msg;
}
inline void XnnConvolutionThunkProto::set_allocated_window(::xla::Window* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.window_ = reinterpret_cast<::xla::Window*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnConvolutionThunkProto.window)
}

// int64 feature_group_count = 3;
inline void XnnConvolutionThunkProto::clear_feature_group_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_group_count_ = ::int64_t{0};
}
inline ::int64_t XnnConvolutionThunkProto::feature_group_count() const {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnConvolutionThunkProto.feature_group_count)
  return _internal_feature_group_count();
}
inline void XnnConvolutionThunkProto::set_feature_group_count(::int64_t value) {
  _internal_set_feature_group_count(value);
  // @@protoc_insertion_point(field_set:xla.cpu.XnnConvolutionThunkProto.feature_group_count)
}
inline ::int64_t XnnConvolutionThunkProto::_internal_feature_group_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feature_group_count_;
}
inline void XnnConvolutionThunkProto::_internal_set_feature_group_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_group_count_ = value;
}

// .xla.cpu.ShapeBufferAllocationSliceProto input_buffer_shape = 4;
inline bool XnnConvolutionThunkProto::has_input_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_buffer_shape_ != nullptr);
  return value;
}
inline void XnnConvolutionThunkProto::clear_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_buffer_shape_ != nullptr) _impl_.input_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnConvolutionThunkProto::_internal_input_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.input_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnConvolutionThunkProto::input_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnConvolutionThunkProto.input_buffer_shape)
  return _internal_input_buffer_shape();
}
inline void XnnConvolutionThunkProto::unsafe_arena_set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_buffer_shape_);
  }
  _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnConvolutionThunkProto.input_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::release_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.input_buffer_shape_;
  _impl_.input_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::unsafe_arena_release_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnConvolutionThunkProto.input_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.input_buffer_shape_;
  _impl_.input_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::_internal_mutable_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.input_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::mutable_input_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_input_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnConvolutionThunkProto.input_buffer_shape)
  return _msg;
}
inline void XnnConvolutionThunkProto::set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnConvolutionThunkProto.input_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto kernel_buffer_shape = 5;
inline bool XnnConvolutionThunkProto::has_kernel_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kernel_buffer_shape_ != nullptr);
  return value;
}
inline void XnnConvolutionThunkProto::clear_kernel_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kernel_buffer_shape_ != nullptr) _impl_.kernel_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnConvolutionThunkProto::_internal_kernel_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.kernel_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnConvolutionThunkProto::kernel_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnConvolutionThunkProto.kernel_buffer_shape)
  return _internal_kernel_buffer_shape();
}
inline void XnnConvolutionThunkProto::unsafe_arena_set_allocated_kernel_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kernel_buffer_shape_);
  }
  _impl_.kernel_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnConvolutionThunkProto.kernel_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::release_kernel_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.kernel_buffer_shape_;
  _impl_.kernel_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::unsafe_arena_release_kernel_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnConvolutionThunkProto.kernel_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.kernel_buffer_shape_;
  _impl_.kernel_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::_internal_mutable_kernel_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kernel_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.kernel_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.kernel_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::mutable_kernel_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_kernel_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnConvolutionThunkProto.kernel_buffer_shape)
  return _msg;
}
inline void XnnConvolutionThunkProto::set_allocated_kernel_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.kernel_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.kernel_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnConvolutionThunkProto.kernel_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto output_buffer_shape = 6;
inline bool XnnConvolutionThunkProto::has_output_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_buffer_shape_ != nullptr);
  return value;
}
inline void XnnConvolutionThunkProto::clear_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_buffer_shape_ != nullptr) _impl_.output_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnConvolutionThunkProto::_internal_output_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.output_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnConvolutionThunkProto::output_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnConvolutionThunkProto.output_buffer_shape)
  return _internal_output_buffer_shape();
}
inline void XnnConvolutionThunkProto::unsafe_arena_set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_buffer_shape_);
  }
  _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnConvolutionThunkProto.output_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::release_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.output_buffer_shape_;
  _impl_.output_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::unsafe_arena_release_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnConvolutionThunkProto.output_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.output_buffer_shape_;
  _impl_.output_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::_internal_mutable_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.output_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnConvolutionThunkProto::mutable_output_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_output_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnConvolutionThunkProto.output_buffer_shape)
  return _msg;
}
inline void XnnConvolutionThunkProto::set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.output_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnConvolutionThunkProto.output_buffer_shape)
}

// -------------------------------------------------------------------

// XnnFusionThunkProtoImpl

// repeated .xla.cpu.ShapeBufferAllocationSliceProto arguments_shapes = 1;
inline int XnnFusionThunkProtoImpl::_internal_arguments_shapes_size() const {
  return _internal_arguments_shapes().size();
}
inline int XnnFusionThunkProtoImpl::arguments_shapes_size() const {
  return _internal_arguments_shapes_size();
}
inline void XnnFusionThunkProtoImpl::clear_arguments_shapes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arguments_shapes_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnFusionThunkProtoImpl::mutable_arguments_shapes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnFusionThunkProtoImpl.arguments_shapes)
  return _internal_mutable_arguments_shapes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* XnnFusionThunkProtoImpl::mutable_arguments_shapes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.XnnFusionThunkProtoImpl.arguments_shapes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arguments_shapes();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnFusionThunkProtoImpl::arguments_shapes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnFusionThunkProtoImpl.arguments_shapes)
  return _internal_arguments_shapes().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnFusionThunkProtoImpl::add_arguments_shapes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_arguments_shapes()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.XnnFusionThunkProtoImpl.arguments_shapes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& XnnFusionThunkProtoImpl::arguments_shapes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.XnnFusionThunkProtoImpl.arguments_shapes)
  return _internal_arguments_shapes();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
XnnFusionThunkProtoImpl::_internal_arguments_shapes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arguments_shapes_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
XnnFusionThunkProtoImpl::_internal_mutable_arguments_shapes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arguments_shapes_;
}

// repeated .xla.cpu.ShapeBufferAllocationSliceProto results_shapes = 2;
inline int XnnFusionThunkProtoImpl::_internal_results_shapes_size() const {
  return _internal_results_shapes().size();
}
inline int XnnFusionThunkProtoImpl::results_shapes_size() const {
  return _internal_results_shapes_size();
}
inline void XnnFusionThunkProtoImpl::clear_results_shapes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.results_shapes_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnFusionThunkProtoImpl::mutable_results_shapes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnFusionThunkProtoImpl.results_shapes)
  return _internal_mutable_results_shapes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* XnnFusionThunkProtoImpl::mutable_results_shapes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.XnnFusionThunkProtoImpl.results_shapes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_results_shapes();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& XnnFusionThunkProtoImpl::results_shapes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnFusionThunkProtoImpl.results_shapes)
  return _internal_results_shapes().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* XnnFusionThunkProtoImpl::add_results_shapes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_results_shapes()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.XnnFusionThunkProtoImpl.results_shapes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& XnnFusionThunkProtoImpl::results_shapes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.XnnFusionThunkProtoImpl.results_shapes)
  return _internal_results_shapes();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
XnnFusionThunkProtoImpl::_internal_results_shapes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.results_shapes_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
XnnFusionThunkProtoImpl::_internal_mutable_results_shapes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.results_shapes_;
}

// -------------------------------------------------------------------

// XnnFusionThunkProto

// .xla.cpu.XnnFusionBackendConfig options = 1;
inline bool XnnFusionThunkProto::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline const ::xla::cpu::XnnFusionBackendConfig& XnnFusionThunkProto::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::XnnFusionBackendConfig* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::XnnFusionBackendConfig&>(::xla::cpu::_XnnFusionBackendConfig_default_instance_);
}
inline const ::xla::cpu::XnnFusionBackendConfig& XnnFusionThunkProto::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnFusionThunkProto.options)
  return _internal_options();
}
inline void XnnFusionThunkProto::unsafe_arena_set_allocated_options(::xla::cpu::XnnFusionBackendConfig* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::xla::cpu::XnnFusionBackendConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnFusionThunkProto.options)
}
inline ::xla::cpu::XnnFusionBackendConfig* XnnFusionThunkProto::release_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::XnnFusionBackendConfig* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::XnnFusionBackendConfig* XnnFusionThunkProto::unsafe_arena_release_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.XnnFusionThunkProto.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::XnnFusionBackendConfig* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::xla::cpu::XnnFusionBackendConfig* XnnFusionThunkProto::_internal_mutable_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::XnnFusionBackendConfig>(GetArena());
    _impl_.options_ = reinterpret_cast<::xla::cpu::XnnFusionBackendConfig*>(p);
  }
  return _impl_.options_;
}
inline ::xla::cpu::XnnFusionBackendConfig* XnnFusionThunkProto::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::XnnFusionBackendConfig* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnFusionThunkProto.options)
  return _msg;
}
inline void XnnFusionThunkProto::set_allocated_options(::xla::cpu::XnnFusionBackendConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::xla::cpu::XnnFusionBackendConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.XnnFusionThunkProto.options)
}

// .xla.cpu.XnnDotThunkProto xnn_dot_thunk = 2;
inline bool XnnFusionThunkProto::has_xnn_dot_thunk() const {
  return impl_case() == kXnnDotThunk;
}
inline bool XnnFusionThunkProto::_internal_has_xnn_dot_thunk() const {
  return impl_case() == kXnnDotThunk;
}
inline void XnnFusionThunkProto::set_has_xnn_dot_thunk() {
  _impl_._oneof_case_[0] = kXnnDotThunk;
}
inline void XnnFusionThunkProto::clear_xnn_dot_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kXnnDotThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.xnn_dot_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.xnn_dot_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::XnnDotThunkProto* XnnFusionThunkProto::release_xnn_dot_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.XnnFusionThunkProto.xnn_dot_thunk)
  if (impl_case() == kXnnDotThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.xnn_dot_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.xnn_dot_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::XnnDotThunkProto& XnnFusionThunkProto::_internal_xnn_dot_thunk() const {
  return impl_case() == kXnnDotThunk ? *_impl_.impl_.xnn_dot_thunk_ : reinterpret_cast<::xla::cpu::XnnDotThunkProto&>(::xla::cpu::_XnnDotThunkProto_default_instance_);
}
inline const ::xla::cpu::XnnDotThunkProto& XnnFusionThunkProto::xnn_dot_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnFusionThunkProto.xnn_dot_thunk)
  return _internal_xnn_dot_thunk();
}
inline ::xla::cpu::XnnDotThunkProto* XnnFusionThunkProto::unsafe_arena_release_xnn_dot_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.XnnFusionThunkProto.xnn_dot_thunk)
  if (impl_case() == kXnnDotThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.xnn_dot_thunk_;
    _impl_.impl_.xnn_dot_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XnnFusionThunkProto::unsafe_arena_set_allocated_xnn_dot_thunk(::xla::cpu::XnnDotThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_xnn_dot_thunk();
    _impl_.impl_.xnn_dot_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnFusionThunkProto.xnn_dot_thunk)
}
inline ::xla::cpu::XnnDotThunkProto* XnnFusionThunkProto::_internal_mutable_xnn_dot_thunk() {
  if (impl_case() != kXnnDotThunk) {
    clear_impl();
    set_has_xnn_dot_thunk();
    _impl_.impl_.xnn_dot_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::XnnDotThunkProto>(GetArena());
  }
  return _impl_.impl_.xnn_dot_thunk_;
}
inline ::xla::cpu::XnnDotThunkProto* XnnFusionThunkProto::mutable_xnn_dot_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::XnnDotThunkProto* _msg = _internal_mutable_xnn_dot_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnFusionThunkProto.xnn_dot_thunk)
  return _msg;
}

// .xla.cpu.XnnConvolutionThunkProto xnn_convolution_thunk = 3;
inline bool XnnFusionThunkProto::has_xnn_convolution_thunk() const {
  return impl_case() == kXnnConvolutionThunk;
}
inline bool XnnFusionThunkProto::_internal_has_xnn_convolution_thunk() const {
  return impl_case() == kXnnConvolutionThunk;
}
inline void XnnFusionThunkProto::set_has_xnn_convolution_thunk() {
  _impl_._oneof_case_[0] = kXnnConvolutionThunk;
}
inline void XnnFusionThunkProto::clear_xnn_convolution_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kXnnConvolutionThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.xnn_convolution_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.xnn_convolution_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::XnnConvolutionThunkProto* XnnFusionThunkProto::release_xnn_convolution_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.XnnFusionThunkProto.xnn_convolution_thunk)
  if (impl_case() == kXnnConvolutionThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.xnn_convolution_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.xnn_convolution_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::XnnConvolutionThunkProto& XnnFusionThunkProto::_internal_xnn_convolution_thunk() const {
  return impl_case() == kXnnConvolutionThunk ? *_impl_.impl_.xnn_convolution_thunk_ : reinterpret_cast<::xla::cpu::XnnConvolutionThunkProto&>(::xla::cpu::_XnnConvolutionThunkProto_default_instance_);
}
inline const ::xla::cpu::XnnConvolutionThunkProto& XnnFusionThunkProto::xnn_convolution_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnFusionThunkProto.xnn_convolution_thunk)
  return _internal_xnn_convolution_thunk();
}
inline ::xla::cpu::XnnConvolutionThunkProto* XnnFusionThunkProto::unsafe_arena_release_xnn_convolution_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.XnnFusionThunkProto.xnn_convolution_thunk)
  if (impl_case() == kXnnConvolutionThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.xnn_convolution_thunk_;
    _impl_.impl_.xnn_convolution_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XnnFusionThunkProto::unsafe_arena_set_allocated_xnn_convolution_thunk(::xla::cpu::XnnConvolutionThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_xnn_convolution_thunk();
    _impl_.impl_.xnn_convolution_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnFusionThunkProto.xnn_convolution_thunk)
}
inline ::xla::cpu::XnnConvolutionThunkProto* XnnFusionThunkProto::_internal_mutable_xnn_convolution_thunk() {
  if (impl_case() != kXnnConvolutionThunk) {
    clear_impl();
    set_has_xnn_convolution_thunk();
    _impl_.impl_.xnn_convolution_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::XnnConvolutionThunkProto>(GetArena());
  }
  return _impl_.impl_.xnn_convolution_thunk_;
}
inline ::xla::cpu::XnnConvolutionThunkProto* XnnFusionThunkProto::mutable_xnn_convolution_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::XnnConvolutionThunkProto* _msg = _internal_mutable_xnn_convolution_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnFusionThunkProto.xnn_convolution_thunk)
  return _msg;
}

// .xla.cpu.XnnFusionThunkProtoImpl xnn_fusion_thunk = 4;
inline bool XnnFusionThunkProto::has_xnn_fusion_thunk() const {
  return impl_case() == kXnnFusionThunk;
}
inline bool XnnFusionThunkProto::_internal_has_xnn_fusion_thunk() const {
  return impl_case() == kXnnFusionThunk;
}
inline void XnnFusionThunkProto::set_has_xnn_fusion_thunk() {
  _impl_._oneof_case_[0] = kXnnFusionThunk;
}
inline void XnnFusionThunkProto::clear_xnn_fusion_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kXnnFusionThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.xnn_fusion_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.xnn_fusion_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::XnnFusionThunkProtoImpl* XnnFusionThunkProto::release_xnn_fusion_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.XnnFusionThunkProto.xnn_fusion_thunk)
  if (impl_case() == kXnnFusionThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.xnn_fusion_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.xnn_fusion_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::XnnFusionThunkProtoImpl& XnnFusionThunkProto::_internal_xnn_fusion_thunk() const {
  return impl_case() == kXnnFusionThunk ? *_impl_.impl_.xnn_fusion_thunk_ : reinterpret_cast<::xla::cpu::XnnFusionThunkProtoImpl&>(::xla::cpu::_XnnFusionThunkProtoImpl_default_instance_);
}
inline const ::xla::cpu::XnnFusionThunkProtoImpl& XnnFusionThunkProto::xnn_fusion_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.XnnFusionThunkProto.xnn_fusion_thunk)
  return _internal_xnn_fusion_thunk();
}
inline ::xla::cpu::XnnFusionThunkProtoImpl* XnnFusionThunkProto::unsafe_arena_release_xnn_fusion_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.XnnFusionThunkProto.xnn_fusion_thunk)
  if (impl_case() == kXnnFusionThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.xnn_fusion_thunk_;
    _impl_.impl_.xnn_fusion_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XnnFusionThunkProto::unsafe_arena_set_allocated_xnn_fusion_thunk(::xla::cpu::XnnFusionThunkProtoImpl* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_xnn_fusion_thunk();
    _impl_.impl_.xnn_fusion_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.XnnFusionThunkProto.xnn_fusion_thunk)
}
inline ::xla::cpu::XnnFusionThunkProtoImpl* XnnFusionThunkProto::_internal_mutable_xnn_fusion_thunk() {
  if (impl_case() != kXnnFusionThunk) {
    clear_impl();
    set_has_xnn_fusion_thunk();
    _impl_.impl_.xnn_fusion_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::XnnFusionThunkProtoImpl>(GetArena());
  }
  return _impl_.impl_.xnn_fusion_thunk_;
}
inline ::xla::cpu::XnnFusionThunkProtoImpl* XnnFusionThunkProto::mutable_xnn_fusion_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::XnnFusionThunkProtoImpl* _msg = _internal_mutable_xnn_fusion_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.XnnFusionThunkProto.xnn_fusion_thunk)
  return _msg;
}

inline bool XnnFusionThunkProto::has_impl() const {
  return impl_case() != IMPL_NOT_SET;
}
inline void XnnFusionThunkProto::clear_has_impl() {
  _impl_._oneof_case_[0] = IMPL_NOT_SET;
}
inline XnnFusionThunkProto::ImplCase XnnFusionThunkProto::impl_case() const {
  return XnnFusionThunkProto::ImplCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DotThunkProto

// .xla.DotDimensionNumbers dot_dimensions = 1;
inline bool DotThunkProto::has_dot_dimensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dot_dimensions_ != nullptr);
  return value;
}
inline const ::xla::DotDimensionNumbers& DotThunkProto::_internal_dot_dimensions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::DotDimensionNumbers* p = _impl_.dot_dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::DotDimensionNumbers&>(::xla::_DotDimensionNumbers_default_instance_);
}
inline const ::xla::DotDimensionNumbers& DotThunkProto::dot_dimensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.DotThunkProto.dot_dimensions)
  return _internal_dot_dimensions();
}
inline void DotThunkProto::unsafe_arena_set_allocated_dot_dimensions(::xla::DotDimensionNumbers* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dot_dimensions_);
  }
  _impl_.dot_dimensions_ = reinterpret_cast<::xla::DotDimensionNumbers*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.DotThunkProto.dot_dimensions)
}
inline ::xla::DotDimensionNumbers* DotThunkProto::release_dot_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::DotDimensionNumbers* released = _impl_.dot_dimensions_;
  _impl_.dot_dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::DotDimensionNumbers* DotThunkProto::unsafe_arena_release_dot_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.DotThunkProto.dot_dimensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::DotDimensionNumbers* temp = _impl_.dot_dimensions_;
  _impl_.dot_dimensions_ = nullptr;
  return temp;
}
inline ::xla::DotDimensionNumbers* DotThunkProto::_internal_mutable_dot_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dot_dimensions_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::DotDimensionNumbers>(GetArena());
    _impl_.dot_dimensions_ = reinterpret_cast<::xla::DotDimensionNumbers*>(p);
  }
  return _impl_.dot_dimensions_;
}
inline ::xla::DotDimensionNumbers* DotThunkProto::mutable_dot_dimensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::DotDimensionNumbers* _msg = _internal_mutable_dot_dimensions();
  // @@protoc_insertion_point(field_mutable:xla.cpu.DotThunkProto.dot_dimensions)
  return _msg;
}
inline void DotThunkProto::set_allocated_dot_dimensions(::xla::DotDimensionNumbers* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dot_dimensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dot_dimensions_ = reinterpret_cast<::xla::DotDimensionNumbers*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.DotThunkProto.dot_dimensions)
}

// .xla.cpu.ShapeBufferAllocationSliceProto lhs_buffer_shape = 2;
inline bool DotThunkProto::has_lhs_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lhs_buffer_shape_ != nullptr);
  return value;
}
inline void DotThunkProto::clear_lhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_buffer_shape_ != nullptr) _impl_.lhs_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& DotThunkProto::_internal_lhs_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.lhs_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& DotThunkProto::lhs_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.DotThunkProto.lhs_buffer_shape)
  return _internal_lhs_buffer_shape();
}
inline void DotThunkProto::unsafe_arena_set_allocated_lhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lhs_buffer_shape_);
  }
  _impl_.lhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.DotThunkProto.lhs_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::release_lhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.lhs_buffer_shape_;
  _impl_.lhs_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::unsafe_arena_release_lhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.DotThunkProto.lhs_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.lhs_buffer_shape_;
  _impl_.lhs_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::_internal_mutable_lhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.lhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.lhs_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::mutable_lhs_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_lhs_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.DotThunkProto.lhs_buffer_shape)
  return _msg;
}
inline void DotThunkProto::set_allocated_lhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lhs_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.DotThunkProto.lhs_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto rhs_buffer_shape = 3;
inline bool DotThunkProto::has_rhs_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_buffer_shape_ != nullptr);
  return value;
}
inline void DotThunkProto::clear_rhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_buffer_shape_ != nullptr) _impl_.rhs_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& DotThunkProto::_internal_rhs_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.rhs_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& DotThunkProto::rhs_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.DotThunkProto.rhs_buffer_shape)
  return _internal_rhs_buffer_shape();
}
inline void DotThunkProto::unsafe_arena_set_allocated_rhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rhs_buffer_shape_);
  }
  _impl_.rhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.DotThunkProto.rhs_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::release_rhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.rhs_buffer_shape_;
  _impl_.rhs_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::unsafe_arena_release_rhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.DotThunkProto.rhs_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.rhs_buffer_shape_;
  _impl_.rhs_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::_internal_mutable_rhs_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.rhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.rhs_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::mutable_rhs_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_rhs_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.DotThunkProto.rhs_buffer_shape)
  return _msg;
}
inline void DotThunkProto::set_allocated_rhs_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rhs_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rhs_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.DotThunkProto.rhs_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto out_buffer_shape = 4;
inline bool DotThunkProto::has_out_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.out_buffer_shape_ != nullptr);
  return value;
}
inline void DotThunkProto::clear_out_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.out_buffer_shape_ != nullptr) _impl_.out_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& DotThunkProto::_internal_out_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.out_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& DotThunkProto::out_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.DotThunkProto.out_buffer_shape)
  return _internal_out_buffer_shape();
}
inline void DotThunkProto::unsafe_arena_set_allocated_out_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.out_buffer_shape_);
  }
  _impl_.out_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.DotThunkProto.out_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::release_out_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.out_buffer_shape_;
  _impl_.out_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::unsafe_arena_release_out_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.DotThunkProto.out_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.out_buffer_shape_;
  _impl_.out_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::_internal_mutable_out_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.out_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.out_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.out_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* DotThunkProto::mutable_out_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_out_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.DotThunkProto.out_buffer_shape)
  return _msg;
}
inline void DotThunkProto::set_allocated_out_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.out_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.out_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.DotThunkProto.out_buffer_shape)
}

// -------------------------------------------------------------------

// RngGetAndUpdateStateThunkProto

// int64 delta = 1;
inline void RngGetAndUpdateStateThunkProto::clear_delta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delta_ = ::int64_t{0};
}
inline ::int64_t RngGetAndUpdateStateThunkProto::delta() const {
  // @@protoc_insertion_point(field_get:xla.cpu.RngGetAndUpdateStateThunkProto.delta)
  return _internal_delta();
}
inline void RngGetAndUpdateStateThunkProto::set_delta(::int64_t value) {
  _internal_set_delta(value);
  // @@protoc_insertion_point(field_set:xla.cpu.RngGetAndUpdateStateThunkProto.delta)
}
inline ::int64_t RngGetAndUpdateStateThunkProto::_internal_delta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delta_;
}
inline void RngGetAndUpdateStateThunkProto::_internal_set_delta(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delta_ = value;
}

// .xla.buffer_assignment.BufferAllocationSliceProto state_buffer = 2;
inline bool RngGetAndUpdateStateThunkProto::has_state_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_buffer_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& RngGetAndUpdateStateThunkProto::_internal_state_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.state_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& RngGetAndUpdateStateThunkProto::state_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.RngGetAndUpdateStateThunkProto.state_buffer)
  return _internal_state_buffer();
}
inline void RngGetAndUpdateStateThunkProto::unsafe_arena_set_allocated_state_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_buffer_);
  }
  _impl_.state_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.RngGetAndUpdateStateThunkProto.state_buffer)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* RngGetAndUpdateStateThunkProto::release_state_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.state_buffer_;
  _impl_.state_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* RngGetAndUpdateStateThunkProto::unsafe_arena_release_state_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.RngGetAndUpdateStateThunkProto.state_buffer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.state_buffer_;
  _impl_.state_buffer_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* RngGetAndUpdateStateThunkProto::_internal_mutable_state_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_buffer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.state_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.state_buffer_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* RngGetAndUpdateStateThunkProto::mutable_state_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_state_buffer();
  // @@protoc_insertion_point(field_mutable:xla.cpu.RngGetAndUpdateStateThunkProto.state_buffer)
  return _msg;
}
inline void RngGetAndUpdateStateThunkProto::set_allocated_state_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.state_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.RngGetAndUpdateStateThunkProto.state_buffer)
}

// -------------------------------------------------------------------

// TopKThunkProto

// int64 batch_size = 1;
inline void TopKThunkProto::clear_batch_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_size_ = ::int64_t{0};
}
inline ::int64_t TopKThunkProto::batch_size() const {
  // @@protoc_insertion_point(field_get:xla.cpu.TopKThunkProto.batch_size)
  return _internal_batch_size();
}
inline void TopKThunkProto::set_batch_size(::int64_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:xla.cpu.TopKThunkProto.batch_size)
}
inline ::int64_t TopKThunkProto::_internal_batch_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.batch_size_;
}
inline void TopKThunkProto::_internal_set_batch_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_size_ = value;
}

// int64 input_size = 2;
inline void TopKThunkProto::clear_input_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_size_ = ::int64_t{0};
}
inline ::int64_t TopKThunkProto::input_size() const {
  // @@protoc_insertion_point(field_get:xla.cpu.TopKThunkProto.input_size)
  return _internal_input_size();
}
inline void TopKThunkProto::set_input_size(::int64_t value) {
  _internal_set_input_size(value);
  // @@protoc_insertion_point(field_set:xla.cpu.TopKThunkProto.input_size)
}
inline ::int64_t TopKThunkProto::_internal_input_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_size_;
}
inline void TopKThunkProto::_internal_set_input_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_size_ = value;
}

// int64 k = 3;
inline void TopKThunkProto::clear_k() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.k_ = ::int64_t{0};
}
inline ::int64_t TopKThunkProto::k() const {
  // @@protoc_insertion_point(field_get:xla.cpu.TopKThunkProto.k)
  return _internal_k();
}
inline void TopKThunkProto::set_k(::int64_t value) {
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:xla.cpu.TopKThunkProto.k)
}
inline ::int64_t TopKThunkProto::_internal_k() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.k_;
}
inline void TopKThunkProto::_internal_set_k(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.k_ = value;
}

// .xla.buffer_assignment.BufferAllocationSliceProto values_buffer = 4;
inline bool TopKThunkProto::has_values_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.values_buffer_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& TopKThunkProto::_internal_values_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.values_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& TopKThunkProto::values_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.TopKThunkProto.values_buffer)
  return _internal_values_buffer();
}
inline void TopKThunkProto::unsafe_arena_set_allocated_values_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_buffer_);
  }
  _impl_.values_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.TopKThunkProto.values_buffer)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::release_values_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.values_buffer_;
  _impl_.values_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::unsafe_arena_release_values_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.TopKThunkProto.values_buffer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.values_buffer_;
  _impl_.values_buffer_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::_internal_mutable_values_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_buffer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.values_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.values_buffer_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::mutable_values_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_values_buffer();
  // @@protoc_insertion_point(field_mutable:xla.cpu.TopKThunkProto.values_buffer)
  return _msg;
}
inline void TopKThunkProto::set_allocated_values_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.values_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.TopKThunkProto.values_buffer)
}

// .xla.buffer_assignment.BufferAllocationSliceProto output_buffer = 5;
inline bool TopKThunkProto::has_output_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_buffer_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& TopKThunkProto::_internal_output_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.output_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& TopKThunkProto::output_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.TopKThunkProto.output_buffer)
  return _internal_output_buffer();
}
inline void TopKThunkProto::unsafe_arena_set_allocated_output_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_buffer_);
  }
  _impl_.output_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.TopKThunkProto.output_buffer)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::release_output_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.output_buffer_;
  _impl_.output_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::unsafe_arena_release_output_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.TopKThunkProto.output_buffer)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.output_buffer_;
  _impl_.output_buffer_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::_internal_mutable_output_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_buffer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.output_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.output_buffer_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::mutable_output_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_output_buffer();
  // @@protoc_insertion_point(field_mutable:xla.cpu.TopKThunkProto.output_buffer)
  return _msg;
}
inline void TopKThunkProto::set_allocated_output_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.output_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.TopKThunkProto.output_buffer)
}

// .xla.buffer_assignment.BufferAllocationSliceProto indices_buffer = 6;
inline bool TopKThunkProto::has_indices_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.indices_buffer_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& TopKThunkProto::_internal_indices_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.indices_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& TopKThunkProto::indices_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.TopKThunkProto.indices_buffer)
  return _internal_indices_buffer();
}
inline void TopKThunkProto::unsafe_arena_set_allocated_indices_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indices_buffer_);
  }
  _impl_.indices_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.TopKThunkProto.indices_buffer)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::release_indices_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.indices_buffer_;
  _impl_.indices_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::unsafe_arena_release_indices_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.TopKThunkProto.indices_buffer)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.indices_buffer_;
  _impl_.indices_buffer_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::_internal_mutable_indices_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indices_buffer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.indices_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.indices_buffer_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* TopKThunkProto::mutable_indices_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_indices_buffer();
  // @@protoc_insertion_point(field_mutable:xla.cpu.TopKThunkProto.indices_buffer)
  return _msg;
}
inline void TopKThunkProto::set_allocated_indices_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indices_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.indices_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.TopKThunkProto.indices_buffer)
}

// -------------------------------------------------------------------

// WhileThunkProto

// .xla.cpu.ThunkSequenceProto cond_sequence = 1;
inline bool WhileThunkProto::has_cond_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cond_sequence_ != nullptr);
  return value;
}
inline void WhileThunkProto::clear_cond_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cond_sequence_ != nullptr) _impl_.cond_sequence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ThunkSequenceProto& WhileThunkProto::_internal_cond_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ThunkSequenceProto* p = _impl_.cond_sequence_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ThunkSequenceProto&>(::xla::cpu::_ThunkSequenceProto_default_instance_);
}
inline const ::xla::cpu::ThunkSequenceProto& WhileThunkProto::cond_sequence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.WhileThunkProto.cond_sequence)
  return _internal_cond_sequence();
}
inline void WhileThunkProto::unsafe_arena_set_allocated_cond_sequence(::xla::cpu::ThunkSequenceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cond_sequence_);
  }
  _impl_.cond_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.WhileThunkProto.cond_sequence)
}
inline ::xla::cpu::ThunkSequenceProto* WhileThunkProto::release_cond_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ThunkSequenceProto* released = _impl_.cond_sequence_;
  _impl_.cond_sequence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ThunkSequenceProto* WhileThunkProto::unsafe_arena_release_cond_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.WhileThunkProto.cond_sequence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ThunkSequenceProto* temp = _impl_.cond_sequence_;
  _impl_.cond_sequence_ = nullptr;
  return temp;
}
inline ::xla::cpu::ThunkSequenceProto* WhileThunkProto::_internal_mutable_cond_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cond_sequence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ThunkSequenceProto>(GetArena());
    _impl_.cond_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(p);
  }
  return _impl_.cond_sequence_;
}
inline ::xla::cpu::ThunkSequenceProto* WhileThunkProto::mutable_cond_sequence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ThunkSequenceProto* _msg = _internal_mutable_cond_sequence();
  // @@protoc_insertion_point(field_mutable:xla.cpu.WhileThunkProto.cond_sequence)
  return _msg;
}
inline void WhileThunkProto::set_allocated_cond_sequence(::xla::cpu::ThunkSequenceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.cond_sequence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.cond_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.WhileThunkProto.cond_sequence)
}

// .xla.cpu.ThunkSequenceProto body_sequence = 2;
inline bool WhileThunkProto::has_body_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_sequence_ != nullptr);
  return value;
}
inline void WhileThunkProto::clear_body_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_sequence_ != nullptr) _impl_.body_sequence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::ThunkSequenceProto& WhileThunkProto::_internal_body_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ThunkSequenceProto* p = _impl_.body_sequence_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ThunkSequenceProto&>(::xla::cpu::_ThunkSequenceProto_default_instance_);
}
inline const ::xla::cpu::ThunkSequenceProto& WhileThunkProto::body_sequence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.WhileThunkProto.body_sequence)
  return _internal_body_sequence();
}
inline void WhileThunkProto::unsafe_arena_set_allocated_body_sequence(::xla::cpu::ThunkSequenceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_sequence_);
  }
  _impl_.body_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.WhileThunkProto.body_sequence)
}
inline ::xla::cpu::ThunkSequenceProto* WhileThunkProto::release_body_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ThunkSequenceProto* released = _impl_.body_sequence_;
  _impl_.body_sequence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ThunkSequenceProto* WhileThunkProto::unsafe_arena_release_body_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.WhileThunkProto.body_sequence)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ThunkSequenceProto* temp = _impl_.body_sequence_;
  _impl_.body_sequence_ = nullptr;
  return temp;
}
inline ::xla::cpu::ThunkSequenceProto* WhileThunkProto::_internal_mutable_body_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_sequence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ThunkSequenceProto>(GetArena());
    _impl_.body_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(p);
  }
  return _impl_.body_sequence_;
}
inline ::xla::cpu::ThunkSequenceProto* WhileThunkProto::mutable_body_sequence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::ThunkSequenceProto* _msg = _internal_mutable_body_sequence();
  // @@protoc_insertion_point(field_mutable:xla.cpu.WhileThunkProto.body_sequence)
  return _msg;
}
inline void WhileThunkProto::set_allocated_body_sequence(::xla::cpu::ThunkSequenceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.body_sequence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.body_sequence_ = reinterpret_cast<::xla::cpu::ThunkSequenceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.WhileThunkProto.body_sequence)
}

// .xla.cpu.Int64Optional trip_count = 3;
inline bool WhileThunkProto::has_trip_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_count_ != nullptr);
  return value;
}
inline void WhileThunkProto::clear_trip_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_count_ != nullptr) _impl_.trip_count_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xla::cpu::Int64Optional& WhileThunkProto::_internal_trip_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::Int64Optional* p = _impl_.trip_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::Int64Optional&>(::xla::cpu::_Int64Optional_default_instance_);
}
inline const ::xla::cpu::Int64Optional& WhileThunkProto::trip_count() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.WhileThunkProto.trip_count)
  return _internal_trip_count();
}
inline void WhileThunkProto::unsafe_arena_set_allocated_trip_count(::xla::cpu::Int64Optional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trip_count_);
  }
  _impl_.trip_count_ = reinterpret_cast<::xla::cpu::Int64Optional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.WhileThunkProto.trip_count)
}
inline ::xla::cpu::Int64Optional* WhileThunkProto::release_trip_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::Int64Optional* released = _impl_.trip_count_;
  _impl_.trip_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::Int64Optional* WhileThunkProto::unsafe_arena_release_trip_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.WhileThunkProto.trip_count)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::cpu::Int64Optional* temp = _impl_.trip_count_;
  _impl_.trip_count_ = nullptr;
  return temp;
}
inline ::xla::cpu::Int64Optional* WhileThunkProto::_internal_mutable_trip_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_count_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::Int64Optional>(GetArena());
    _impl_.trip_count_ = reinterpret_cast<::xla::cpu::Int64Optional*>(p);
  }
  return _impl_.trip_count_;
}
inline ::xla::cpu::Int64Optional* WhileThunkProto::mutable_trip_count() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::cpu::Int64Optional* _msg = _internal_mutable_trip_count();
  // @@protoc_insertion_point(field_mutable:xla.cpu.WhileThunkProto.trip_count)
  return _msg;
}
inline void WhileThunkProto::set_allocated_trip_count(::xla::cpu::Int64Optional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trip_count_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.trip_count_ = reinterpret_cast<::xla::cpu::Int64Optional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.WhileThunkProto.trip_count)
}

// .xla.buffer_assignment.BufferAllocationSliceProto cond_buffer = 4;
inline bool WhileThunkProto::has_cond_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cond_buffer_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& WhileThunkProto::_internal_cond_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.cond_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& WhileThunkProto::cond_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.WhileThunkProto.cond_buffer)
  return _internal_cond_buffer();
}
inline void WhileThunkProto::unsafe_arena_set_allocated_cond_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cond_buffer_);
  }
  _impl_.cond_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.WhileThunkProto.cond_buffer)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* WhileThunkProto::release_cond_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.cond_buffer_;
  _impl_.cond_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* WhileThunkProto::unsafe_arena_release_cond_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.WhileThunkProto.cond_buffer)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.cond_buffer_;
  _impl_.cond_buffer_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* WhileThunkProto::_internal_mutable_cond_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cond_buffer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.cond_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.cond_buffer_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* WhileThunkProto::mutable_cond_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_cond_buffer();
  // @@protoc_insertion_point(field_mutable:xla.cpu.WhileThunkProto.cond_buffer)
  return _msg;
}
inline void WhileThunkProto::set_allocated_cond_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cond_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.cond_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.WhileThunkProto.cond_buffer)
}

// -------------------------------------------------------------------

// KernelThunkProto_NumWorkGroups

// int64 x = 1;
inline void KernelThunkProto_NumWorkGroups::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = ::int64_t{0};
}
inline ::int64_t KernelThunkProto_NumWorkGroups::x() const {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.NumWorkGroups.x)
  return _internal_x();
}
inline void KernelThunkProto_NumWorkGroups::set_x(::int64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:xla.cpu.KernelThunkProto.NumWorkGroups.x)
}
inline ::int64_t KernelThunkProto_NumWorkGroups::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void KernelThunkProto_NumWorkGroups::_internal_set_x(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int64 y = 2;
inline void KernelThunkProto_NumWorkGroups::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = ::int64_t{0};
}
inline ::int64_t KernelThunkProto_NumWorkGroups::y() const {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.NumWorkGroups.y)
  return _internal_y();
}
inline void KernelThunkProto_NumWorkGroups::set_y(::int64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:xla.cpu.KernelThunkProto.NumWorkGroups.y)
}
inline ::int64_t KernelThunkProto_NumWorkGroups::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void KernelThunkProto_NumWorkGroups::_internal_set_y(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// int64 z = 3;
inline void KernelThunkProto_NumWorkGroups::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = ::int64_t{0};
}
inline ::int64_t KernelThunkProto_NumWorkGroups::z() const {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.NumWorkGroups.z)
  return _internal_z();
}
inline void KernelThunkProto_NumWorkGroups::set_z(::int64_t value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:xla.cpu.KernelThunkProto.NumWorkGroups.z)
}
inline ::int64_t KernelThunkProto_NumWorkGroups::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void KernelThunkProto_NumWorkGroups::_internal_set_z(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// KernelThunkProto

// string kernel_name = 1;
inline void KernelThunkProto::clear_kernel_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kernel_name_.ClearToEmpty();
}
inline const std::string& KernelThunkProto::kernel_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.kernel_name)
  return _internal_kernel_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KernelThunkProto::set_kernel_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kernel_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.KernelThunkProto.kernel_name)
}
inline std::string* KernelThunkProto::mutable_kernel_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_kernel_name();
  // @@protoc_insertion_point(field_mutable:xla.cpu.KernelThunkProto.kernel_name)
  return _s;
}
inline const std::string& KernelThunkProto::_internal_kernel_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.kernel_name_.Get();
}
inline void KernelThunkProto::_internal_set_kernel_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kernel_name_.Set(value, GetArena());
}
inline std::string* KernelThunkProto::_internal_mutable_kernel_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.kernel_name_.Mutable( GetArena());
}
inline std::string* KernelThunkProto::release_kernel_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.KernelThunkProto.kernel_name)
  return _impl_.kernel_name_.Release();
}
inline void KernelThunkProto::set_allocated_kernel_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kernel_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.kernel_name_.IsDefault()) {
          _impl_.kernel_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.KernelThunkProto.kernel_name)
}

// .xla.cpu.KernelThunkProto.NumWorkGroups num_workgroups = 2;
inline bool KernelThunkProto::has_num_workgroups() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.num_workgroups_ != nullptr);
  return value;
}
inline void KernelThunkProto::clear_num_workgroups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.num_workgroups_ != nullptr) _impl_.num_workgroups_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::KernelThunkProto_NumWorkGroups& KernelThunkProto::_internal_num_workgroups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::KernelThunkProto_NumWorkGroups* p = _impl_.num_workgroups_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::KernelThunkProto_NumWorkGroups&>(::xla::cpu::_KernelThunkProto_NumWorkGroups_default_instance_);
}
inline const ::xla::cpu::KernelThunkProto_NumWorkGroups& KernelThunkProto::num_workgroups() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.num_workgroups)
  return _internal_num_workgroups();
}
inline void KernelThunkProto::unsafe_arena_set_allocated_num_workgroups(::xla::cpu::KernelThunkProto_NumWorkGroups* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.num_workgroups_);
  }
  _impl_.num_workgroups_ = reinterpret_cast<::xla::cpu::KernelThunkProto_NumWorkGroups*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.KernelThunkProto.num_workgroups)
}
inline ::xla::cpu::KernelThunkProto_NumWorkGroups* KernelThunkProto::release_num_workgroups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::KernelThunkProto_NumWorkGroups* released = _impl_.num_workgroups_;
  _impl_.num_workgroups_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::KernelThunkProto_NumWorkGroups* KernelThunkProto::unsafe_arena_release_num_workgroups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.KernelThunkProto.num_workgroups)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::KernelThunkProto_NumWorkGroups* temp = _impl_.num_workgroups_;
  _impl_.num_workgroups_ = nullptr;
  return temp;
}
inline ::xla::cpu::KernelThunkProto_NumWorkGroups* KernelThunkProto::_internal_mutable_num_workgroups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.num_workgroups_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::KernelThunkProto_NumWorkGroups>(GetArena());
    _impl_.num_workgroups_ = reinterpret_cast<::xla::cpu::KernelThunkProto_NumWorkGroups*>(p);
  }
  return _impl_.num_workgroups_;
}
inline ::xla::cpu::KernelThunkProto_NumWorkGroups* KernelThunkProto::mutable_num_workgroups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::KernelThunkProto_NumWorkGroups* _msg = _internal_mutable_num_workgroups();
  // @@protoc_insertion_point(field_mutable:xla.cpu.KernelThunkProto.num_workgroups)
  return _msg;
}
inline void KernelThunkProto::set_allocated_num_workgroups(::xla::cpu::KernelThunkProto_NumWorkGroups* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.num_workgroups_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.num_workgroups_ = reinterpret_cast<::xla::cpu::KernelThunkProto_NumWorkGroups*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.KernelThunkProto.num_workgroups)
}

// repeated int64 invariant_arguments = 3;
inline int KernelThunkProto::_internal_invariant_arguments_size() const {
  return _internal_invariant_arguments().size();
}
inline int KernelThunkProto::invariant_arguments_size() const {
  return _internal_invariant_arguments_size();
}
inline void KernelThunkProto::clear_invariant_arguments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invariant_arguments_.Clear();
}
inline ::int64_t KernelThunkProto::invariant_arguments(int index) const {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.invariant_arguments)
  return _internal_invariant_arguments().Get(index);
}
inline void KernelThunkProto::set_invariant_arguments(int index, ::int64_t value) {
  _internal_mutable_invariant_arguments()->Set(index, value);
  // @@protoc_insertion_point(field_set:xla.cpu.KernelThunkProto.invariant_arguments)
}
inline void KernelThunkProto::add_invariant_arguments(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_invariant_arguments()->Add(value);
  // @@protoc_insertion_point(field_add:xla.cpu.KernelThunkProto.invariant_arguments)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& KernelThunkProto::invariant_arguments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.KernelThunkProto.invariant_arguments)
  return _internal_invariant_arguments();
}
inline ::google::protobuf::RepeatedField<::int64_t>* KernelThunkProto::mutable_invariant_arguments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.KernelThunkProto.invariant_arguments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_invariant_arguments();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
KernelThunkProto::_internal_invariant_arguments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.invariant_arguments_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* KernelThunkProto::_internal_mutable_invariant_arguments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.invariant_arguments_;
}

// .xla.cpu.Int64Optional min_alignment = 4;
inline bool KernelThunkProto::has_min_alignment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_alignment_ != nullptr);
  return value;
}
inline void KernelThunkProto::clear_min_alignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_alignment_ != nullptr) _impl_.min_alignment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::Int64Optional& KernelThunkProto::_internal_min_alignment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::Int64Optional* p = _impl_.min_alignment_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::Int64Optional&>(::xla::cpu::_Int64Optional_default_instance_);
}
inline const ::xla::cpu::Int64Optional& KernelThunkProto::min_alignment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.min_alignment)
  return _internal_min_alignment();
}
inline void KernelThunkProto::unsafe_arena_set_allocated_min_alignment(::xla::cpu::Int64Optional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_alignment_);
  }
  _impl_.min_alignment_ = reinterpret_cast<::xla::cpu::Int64Optional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.KernelThunkProto.min_alignment)
}
inline ::xla::cpu::Int64Optional* KernelThunkProto::release_min_alignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::Int64Optional* released = _impl_.min_alignment_;
  _impl_.min_alignment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::Int64Optional* KernelThunkProto::unsafe_arena_release_min_alignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.KernelThunkProto.min_alignment)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::Int64Optional* temp = _impl_.min_alignment_;
  _impl_.min_alignment_ = nullptr;
  return temp;
}
inline ::xla::cpu::Int64Optional* KernelThunkProto::_internal_mutable_min_alignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_alignment_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::Int64Optional>(GetArena());
    _impl_.min_alignment_ = reinterpret_cast<::xla::cpu::Int64Optional*>(p);
  }
  return _impl_.min_alignment_;
}
inline ::xla::cpu::Int64Optional* KernelThunkProto::mutable_min_alignment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::Int64Optional* _msg = _internal_mutable_min_alignment();
  // @@protoc_insertion_point(field_mutable:xla.cpu.KernelThunkProto.min_alignment)
  return _msg;
}
inline void KernelThunkProto::set_allocated_min_alignment(::xla::cpu::Int64Optional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.min_alignment_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.min_alignment_ = reinterpret_cast<::xla::cpu::Int64Optional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.KernelThunkProto.min_alignment)
}

// repeated .xla.buffer_assignment.BufferAllocationSliceProto arguments_buffers = 5;
inline int KernelThunkProto::_internal_arguments_buffers_size() const {
  return _internal_arguments_buffers().size();
}
inline int KernelThunkProto::arguments_buffers_size() const {
  return _internal_arguments_buffers_size();
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* KernelThunkProto::mutable_arguments_buffers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.KernelThunkProto.arguments_buffers)
  return _internal_mutable_arguments_buffers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>* KernelThunkProto::mutable_arguments_buffers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.KernelThunkProto.arguments_buffers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arguments_buffers();
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& KernelThunkProto::arguments_buffers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.arguments_buffers)
  return _internal_arguments_buffers().Get(index);
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* KernelThunkProto::add_arguments_buffers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::buffer_assignment::BufferAllocationSliceProto* _add = _internal_mutable_arguments_buffers()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.KernelThunkProto.arguments_buffers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>& KernelThunkProto::arguments_buffers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.KernelThunkProto.arguments_buffers)
  return _internal_arguments_buffers();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>&
KernelThunkProto::_internal_arguments_buffers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arguments_buffers_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>*
KernelThunkProto::_internal_mutable_arguments_buffers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arguments_buffers_;
}

// repeated .xla.buffer_assignment.BufferAllocationSliceProto results_buffers = 6;
inline int KernelThunkProto::_internal_results_buffers_size() const {
  return _internal_results_buffers().size();
}
inline int KernelThunkProto::results_buffers_size() const {
  return _internal_results_buffers_size();
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* KernelThunkProto::mutable_results_buffers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.KernelThunkProto.results_buffers)
  return _internal_mutable_results_buffers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>* KernelThunkProto::mutable_results_buffers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.KernelThunkProto.results_buffers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_results_buffers();
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& KernelThunkProto::results_buffers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.KernelThunkProto.results_buffers)
  return _internal_results_buffers().Get(index);
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* KernelThunkProto::add_results_buffers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::buffer_assignment::BufferAllocationSliceProto* _add = _internal_mutable_results_buffers()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.KernelThunkProto.results_buffers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>& KernelThunkProto::results_buffers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.KernelThunkProto.results_buffers)
  return _internal_results_buffers();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>&
KernelThunkProto::_internal_results_buffers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.results_buffers_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::buffer_assignment::BufferAllocationSliceProto>*
KernelThunkProto::_internal_mutable_results_buffers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.results_buffers_;
}

// -------------------------------------------------------------------

// CopyThunkProto

// .xla.cpu.ShapeBufferAllocationSliceProto src_buffer_shape = 1;
inline bool CopyThunkProto::has_src_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_buffer_shape_ != nullptr);
  return value;
}
inline void CopyThunkProto::clear_src_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.src_buffer_shape_ != nullptr) _impl_.src_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& CopyThunkProto::_internal_src_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.src_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& CopyThunkProto::src_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CopyThunkProto.src_buffer_shape)
  return _internal_src_buffer_shape();
}
inline void CopyThunkProto::unsafe_arena_set_allocated_src_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.src_buffer_shape_);
  }
  _impl_.src_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CopyThunkProto.src_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CopyThunkProto::release_src_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.src_buffer_shape_;
  _impl_.src_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CopyThunkProto::unsafe_arena_release_src_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CopyThunkProto.src_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.src_buffer_shape_;
  _impl_.src_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CopyThunkProto::_internal_mutable_src_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.src_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.src_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.src_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CopyThunkProto::mutable_src_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_src_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CopyThunkProto.src_buffer_shape)
  return _msg;
}
inline void CopyThunkProto::set_allocated_src_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.src_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.src_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CopyThunkProto.src_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto dst_buffer_shape = 2;
inline bool CopyThunkProto::has_dst_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dst_buffer_shape_ != nullptr);
  return value;
}
inline void CopyThunkProto::clear_dst_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dst_buffer_shape_ != nullptr) _impl_.dst_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& CopyThunkProto::_internal_dst_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.dst_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& CopyThunkProto::dst_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CopyThunkProto.dst_buffer_shape)
  return _internal_dst_buffer_shape();
}
inline void CopyThunkProto::unsafe_arena_set_allocated_dst_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dst_buffer_shape_);
  }
  _impl_.dst_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CopyThunkProto.dst_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CopyThunkProto::release_dst_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.dst_buffer_shape_;
  _impl_.dst_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CopyThunkProto::unsafe_arena_release_dst_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CopyThunkProto.dst_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.dst_buffer_shape_;
  _impl_.dst_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CopyThunkProto::_internal_mutable_dst_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dst_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.dst_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.dst_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CopyThunkProto::mutable_dst_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_dst_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CopyThunkProto.dst_buffer_shape)
  return _msg;
}
inline void CopyThunkProto::set_allocated_dst_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dst_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dst_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CopyThunkProto.dst_buffer_shape)
}

// -------------------------------------------------------------------

// FftThunkProto

// bool is_multi_thread_eigen = 1;
inline void FftThunkProto::clear_is_multi_thread_eigen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_multi_thread_eigen_ = false;
}
inline bool FftThunkProto::is_multi_thread_eigen() const {
  // @@protoc_insertion_point(field_get:xla.cpu.FftThunkProto.is_multi_thread_eigen)
  return _internal_is_multi_thread_eigen();
}
inline void FftThunkProto::set_is_multi_thread_eigen(bool value) {
  _internal_set_is_multi_thread_eigen(value);
  // @@protoc_insertion_point(field_set:xla.cpu.FftThunkProto.is_multi_thread_eigen)
}
inline bool FftThunkProto::_internal_is_multi_thread_eigen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_multi_thread_eigen_;
}
inline void FftThunkProto::_internal_set_is_multi_thread_eigen(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_multi_thread_eigen_ = value;
}

// int32 fft_type = 2;
inline void FftThunkProto::clear_fft_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fft_type_ = 0;
}
inline ::int32_t FftThunkProto::fft_type() const {
  // @@protoc_insertion_point(field_get:xla.cpu.FftThunkProto.fft_type)
  return _internal_fft_type();
}
inline void FftThunkProto::set_fft_type(::int32_t value) {
  _internal_set_fft_type(value);
  // @@protoc_insertion_point(field_set:xla.cpu.FftThunkProto.fft_type)
}
inline ::int32_t FftThunkProto::_internal_fft_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fft_type_;
}
inline void FftThunkProto::_internal_set_fft_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fft_type_ = value;
}

// repeated int64 fft_length = 3;
inline int FftThunkProto::_internal_fft_length_size() const {
  return _internal_fft_length().size();
}
inline int FftThunkProto::fft_length_size() const {
  return _internal_fft_length_size();
}
inline void FftThunkProto::clear_fft_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fft_length_.Clear();
}
inline ::int64_t FftThunkProto::fft_length(int index) const {
  // @@protoc_insertion_point(field_get:xla.cpu.FftThunkProto.fft_length)
  return _internal_fft_length().Get(index);
}
inline void FftThunkProto::set_fft_length(int index, ::int64_t value) {
  _internal_mutable_fft_length()->Set(index, value);
  // @@protoc_insertion_point(field_set:xla.cpu.FftThunkProto.fft_length)
}
inline void FftThunkProto::add_fft_length(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_fft_length()->Add(value);
  // @@protoc_insertion_point(field_add:xla.cpu.FftThunkProto.fft_length)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& FftThunkProto::fft_length() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.FftThunkProto.fft_length)
  return _internal_fft_length();
}
inline ::google::protobuf::RepeatedField<::int64_t>* FftThunkProto::mutable_fft_length()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.FftThunkProto.fft_length)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fft_length();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
FftThunkProto::_internal_fft_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fft_length_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* FftThunkProto::_internal_mutable_fft_length() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fft_length_;
}

// .xla.cpu.ShapeBufferAllocationSliceProto input_buffer_shape = 4;
inline bool FftThunkProto::has_input_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_buffer_shape_ != nullptr);
  return value;
}
inline void FftThunkProto::clear_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_buffer_shape_ != nullptr) _impl_.input_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& FftThunkProto::_internal_input_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.input_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& FftThunkProto::input_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.FftThunkProto.input_buffer_shape)
  return _internal_input_buffer_shape();
}
inline void FftThunkProto::unsafe_arena_set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_buffer_shape_);
  }
  _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.FftThunkProto.input_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* FftThunkProto::release_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.input_buffer_shape_;
  _impl_.input_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* FftThunkProto::unsafe_arena_release_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.FftThunkProto.input_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.input_buffer_shape_;
  _impl_.input_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* FftThunkProto::_internal_mutable_input_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.input_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* FftThunkProto::mutable_input_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_input_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.FftThunkProto.input_buffer_shape)
  return _msg;
}
inline void FftThunkProto::set_allocated_input_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.input_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.FftThunkProto.input_buffer_shape)
}

// .xla.cpu.ShapeBufferAllocationSliceProto output_buffer_shape = 5;
inline bool FftThunkProto::has_output_buffer_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_buffer_shape_ != nullptr);
  return value;
}
inline void FftThunkProto::clear_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_buffer_shape_ != nullptr) _impl_.output_buffer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& FftThunkProto::_internal_output_buffer_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ShapeBufferAllocationSliceProto* p = _impl_.output_buffer_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ShapeBufferAllocationSliceProto&>(::xla::cpu::_ShapeBufferAllocationSliceProto_default_instance_);
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& FftThunkProto::output_buffer_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.FftThunkProto.output_buffer_shape)
  return _internal_output_buffer_shape();
}
inline void FftThunkProto::unsafe_arena_set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_buffer_shape_);
  }
  _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.FftThunkProto.output_buffer_shape)
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* FftThunkProto::release_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* released = _impl_.output_buffer_shape_;
  _impl_.output_buffer_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* FftThunkProto::unsafe_arena_release_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.FftThunkProto.output_buffer_shape)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* temp = _impl_.output_buffer_shape_;
  _impl_.output_buffer_shape_ = nullptr;
  return temp;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* FftThunkProto::_internal_mutable_output_buffer_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_buffer_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ShapeBufferAllocationSliceProto>(GetArena());
    _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(p);
  }
  return _impl_.output_buffer_shape_;
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* FftThunkProto::mutable_output_buffer_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::ShapeBufferAllocationSliceProto* _msg = _internal_mutable_output_buffer_shape();
  // @@protoc_insertion_point(field_mutable:xla.cpu.FftThunkProto.output_buffer_shape)
  return _msg;
}
inline void FftThunkProto::set_allocated_output_buffer_shape(::xla::cpu::ShapeBufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.output_buffer_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.output_buffer_shape_ = reinterpret_cast<::xla::cpu::ShapeBufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.FftThunkProto.output_buffer_shape)
}

// -------------------------------------------------------------------

// InfeedThunkProto_InfeedResource

// .xla.cpu.ResourceOptional consume_token = 1;
inline bool InfeedThunkProto_InfeedResource::has_consume_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consume_token_ != nullptr);
  return value;
}
inline void InfeedThunkProto_InfeedResource::clear_consume_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.consume_token_ != nullptr) _impl_.consume_token_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ResourceOptional& InfeedThunkProto_InfeedResource::_internal_consume_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ResourceOptional* p = _impl_.consume_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ResourceOptional&>(::xla::cpu::_ResourceOptional_default_instance_);
}
inline const ::xla::cpu::ResourceOptional& InfeedThunkProto_InfeedResource::consume_token() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.InfeedThunkProto.InfeedResource.consume_token)
  return _internal_consume_token();
}
inline void InfeedThunkProto_InfeedResource::unsafe_arena_set_allocated_consume_token(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.consume_token_);
  }
  _impl_.consume_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.InfeedThunkProto.InfeedResource.consume_token)
}
inline ::xla::cpu::ResourceOptional* InfeedThunkProto_InfeedResource::release_consume_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceOptional* released = _impl_.consume_token_;
  _impl_.consume_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ResourceOptional* InfeedThunkProto_InfeedResource::unsafe_arena_release_consume_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.InfeedThunkProto.InfeedResource.consume_token)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceOptional* temp = _impl_.consume_token_;
  _impl_.consume_token_ = nullptr;
  return temp;
}
inline ::xla::cpu::ResourceOptional* InfeedThunkProto_InfeedResource::_internal_mutable_consume_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.consume_token_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ResourceOptional>(GetArena());
    _impl_.consume_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(p);
  }
  return _impl_.consume_token_;
}
inline ::xla::cpu::ResourceOptional* InfeedThunkProto_InfeedResource::mutable_consume_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ResourceOptional* _msg = _internal_mutable_consume_token();
  // @@protoc_insertion_point(field_mutable:xla.cpu.InfeedThunkProto.InfeedResource.consume_token)
  return _msg;
}
inline void InfeedThunkProto_InfeedResource::set_allocated_consume_token(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.consume_token_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.consume_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.InfeedThunkProto.InfeedResource.consume_token)
}

// .xla.cpu.ResourceOptional produce_token = 2;
inline bool InfeedThunkProto_InfeedResource::has_produce_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.produce_token_ != nullptr);
  return value;
}
inline void InfeedThunkProto_InfeedResource::clear_produce_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.produce_token_ != nullptr) _impl_.produce_token_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::ResourceOptional& InfeedThunkProto_InfeedResource::_internal_produce_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ResourceOptional* p = _impl_.produce_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ResourceOptional&>(::xla::cpu::_ResourceOptional_default_instance_);
}
inline const ::xla::cpu::ResourceOptional& InfeedThunkProto_InfeedResource::produce_token() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.InfeedThunkProto.InfeedResource.produce_token)
  return _internal_produce_token();
}
inline void InfeedThunkProto_InfeedResource::unsafe_arena_set_allocated_produce_token(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.produce_token_);
  }
  _impl_.produce_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.InfeedThunkProto.InfeedResource.produce_token)
}
inline ::xla::cpu::ResourceOptional* InfeedThunkProto_InfeedResource::release_produce_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ResourceOptional* released = _impl_.produce_token_;
  _impl_.produce_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ResourceOptional* InfeedThunkProto_InfeedResource::unsafe_arena_release_produce_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.InfeedThunkProto.InfeedResource.produce_token)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ResourceOptional* temp = _impl_.produce_token_;
  _impl_.produce_token_ = nullptr;
  return temp;
}
inline ::xla::cpu::ResourceOptional* InfeedThunkProto_InfeedResource::_internal_mutable_produce_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.produce_token_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ResourceOptional>(GetArena());
    _impl_.produce_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(p);
  }
  return _impl_.produce_token_;
}
inline ::xla::cpu::ResourceOptional* InfeedThunkProto_InfeedResource::mutable_produce_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::ResourceOptional* _msg = _internal_mutable_produce_token();
  // @@protoc_insertion_point(field_mutable:xla.cpu.InfeedThunkProto.InfeedResource.produce_token)
  return _msg;
}
inline void InfeedThunkProto_InfeedResource::set_allocated_produce_token(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.produce_token_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.produce_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.InfeedThunkProto.InfeedResource.produce_token)
}

// -------------------------------------------------------------------

// InfeedThunkProto

// .xla.cpu.InfeedThunkProto.InfeedResource infeed_resources = 1;
inline bool InfeedThunkProto::has_infeed_resources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.infeed_resources_ != nullptr);
  return value;
}
inline void InfeedThunkProto::clear_infeed_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.infeed_resources_ != nullptr) _impl_.infeed_resources_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::InfeedThunkProto_InfeedResource& InfeedThunkProto::_internal_infeed_resources() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::InfeedThunkProto_InfeedResource* p = _impl_.infeed_resources_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::InfeedThunkProto_InfeedResource&>(::xla::cpu::_InfeedThunkProto_InfeedResource_default_instance_);
}
inline const ::xla::cpu::InfeedThunkProto_InfeedResource& InfeedThunkProto::infeed_resources() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.InfeedThunkProto.infeed_resources)
  return _internal_infeed_resources();
}
inline void InfeedThunkProto::unsafe_arena_set_allocated_infeed_resources(::xla::cpu::InfeedThunkProto_InfeedResource* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.infeed_resources_);
  }
  _impl_.infeed_resources_ = reinterpret_cast<::xla::cpu::InfeedThunkProto_InfeedResource*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.InfeedThunkProto.infeed_resources)
}
inline ::xla::cpu::InfeedThunkProto_InfeedResource* InfeedThunkProto::release_infeed_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::InfeedThunkProto_InfeedResource* released = _impl_.infeed_resources_;
  _impl_.infeed_resources_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::InfeedThunkProto_InfeedResource* InfeedThunkProto::unsafe_arena_release_infeed_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.InfeedThunkProto.infeed_resources)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::InfeedThunkProto_InfeedResource* temp = _impl_.infeed_resources_;
  _impl_.infeed_resources_ = nullptr;
  return temp;
}
inline ::xla::cpu::InfeedThunkProto_InfeedResource* InfeedThunkProto::_internal_mutable_infeed_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.infeed_resources_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::InfeedThunkProto_InfeedResource>(GetArena());
    _impl_.infeed_resources_ = reinterpret_cast<::xla::cpu::InfeedThunkProto_InfeedResource*>(p);
  }
  return _impl_.infeed_resources_;
}
inline ::xla::cpu::InfeedThunkProto_InfeedResource* InfeedThunkProto::mutable_infeed_resources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::InfeedThunkProto_InfeedResource* _msg = _internal_mutable_infeed_resources();
  // @@protoc_insertion_point(field_mutable:xla.cpu.InfeedThunkProto.infeed_resources)
  return _msg;
}
inline void InfeedThunkProto::set_allocated_infeed_resources(::xla::cpu::InfeedThunkProto_InfeedResource* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.infeed_resources_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.infeed_resources_ = reinterpret_cast<::xla::cpu::InfeedThunkProto_InfeedResource*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.InfeedThunkProto.infeed_resources)
}

// repeated .xla.cpu.ShapeBufferAllocationSliceProto infeed_buffers_shapes = 2;
inline int InfeedThunkProto::_internal_infeed_buffers_shapes_size() const {
  return _internal_infeed_buffers_shapes().size();
}
inline int InfeedThunkProto::infeed_buffers_shapes_size() const {
  return _internal_infeed_buffers_shapes_size();
}
inline void InfeedThunkProto::clear_infeed_buffers_shapes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.infeed_buffers_shapes_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* InfeedThunkProto::mutable_infeed_buffers_shapes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.InfeedThunkProto.infeed_buffers_shapes)
  return _internal_mutable_infeed_buffers_shapes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* InfeedThunkProto::mutable_infeed_buffers_shapes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.InfeedThunkProto.infeed_buffers_shapes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_infeed_buffers_shapes();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& InfeedThunkProto::infeed_buffers_shapes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.InfeedThunkProto.infeed_buffers_shapes)
  return _internal_infeed_buffers_shapes().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* InfeedThunkProto::add_infeed_buffers_shapes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_infeed_buffers_shapes()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.InfeedThunkProto.infeed_buffers_shapes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& InfeedThunkProto::infeed_buffers_shapes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.InfeedThunkProto.infeed_buffers_shapes)
  return _internal_infeed_buffers_shapes();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
InfeedThunkProto::_internal_infeed_buffers_shapes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.infeed_buffers_shapes_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
InfeedThunkProto::_internal_mutable_infeed_buffers_shapes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.infeed_buffers_shapes_;
}

// -------------------------------------------------------------------

// OutfeedThunkProto_OutfeedResource

// .xla.cpu.ResourceOptional consume_token = 1;
inline bool OutfeedThunkProto_OutfeedResource::has_consume_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consume_token_ != nullptr);
  return value;
}
inline void OutfeedThunkProto_OutfeedResource::clear_consume_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.consume_token_ != nullptr) _impl_.consume_token_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ResourceOptional& OutfeedThunkProto_OutfeedResource::_internal_consume_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ResourceOptional* p = _impl_.consume_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ResourceOptional&>(::xla::cpu::_ResourceOptional_default_instance_);
}
inline const ::xla::cpu::ResourceOptional& OutfeedThunkProto_OutfeedResource::consume_token() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OutfeedThunkProto.OutfeedResource.consume_token)
  return _internal_consume_token();
}
inline void OutfeedThunkProto_OutfeedResource::unsafe_arena_set_allocated_consume_token(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.consume_token_);
  }
  _impl_.consume_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.OutfeedThunkProto.OutfeedResource.consume_token)
}
inline ::xla::cpu::ResourceOptional* OutfeedThunkProto_OutfeedResource::release_consume_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceOptional* released = _impl_.consume_token_;
  _impl_.consume_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ResourceOptional* OutfeedThunkProto_OutfeedResource::unsafe_arena_release_consume_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.OutfeedThunkProto.OutfeedResource.consume_token)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceOptional* temp = _impl_.consume_token_;
  _impl_.consume_token_ = nullptr;
  return temp;
}
inline ::xla::cpu::ResourceOptional* OutfeedThunkProto_OutfeedResource::_internal_mutable_consume_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.consume_token_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ResourceOptional>(GetArena());
    _impl_.consume_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(p);
  }
  return _impl_.consume_token_;
}
inline ::xla::cpu::ResourceOptional* OutfeedThunkProto_OutfeedResource::mutable_consume_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ResourceOptional* _msg = _internal_mutable_consume_token();
  // @@protoc_insertion_point(field_mutable:xla.cpu.OutfeedThunkProto.OutfeedResource.consume_token)
  return _msg;
}
inline void OutfeedThunkProto_OutfeedResource::set_allocated_consume_token(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.consume_token_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.consume_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.OutfeedThunkProto.OutfeedResource.consume_token)
}

// .xla.cpu.ResourceOptional produce_token = 2;
inline bool OutfeedThunkProto_OutfeedResource::has_produce_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.produce_token_ != nullptr);
  return value;
}
inline void OutfeedThunkProto_OutfeedResource::clear_produce_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.produce_token_ != nullptr) _impl_.produce_token_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::cpu::ResourceOptional& OutfeedThunkProto_OutfeedResource::_internal_produce_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ResourceOptional* p = _impl_.produce_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ResourceOptional&>(::xla::cpu::_ResourceOptional_default_instance_);
}
inline const ::xla::cpu::ResourceOptional& OutfeedThunkProto_OutfeedResource::produce_token() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OutfeedThunkProto.OutfeedResource.produce_token)
  return _internal_produce_token();
}
inline void OutfeedThunkProto_OutfeedResource::unsafe_arena_set_allocated_produce_token(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.produce_token_);
  }
  _impl_.produce_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.OutfeedThunkProto.OutfeedResource.produce_token)
}
inline ::xla::cpu::ResourceOptional* OutfeedThunkProto_OutfeedResource::release_produce_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ResourceOptional* released = _impl_.produce_token_;
  _impl_.produce_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ResourceOptional* OutfeedThunkProto_OutfeedResource::unsafe_arena_release_produce_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.OutfeedThunkProto.OutfeedResource.produce_token)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::cpu::ResourceOptional* temp = _impl_.produce_token_;
  _impl_.produce_token_ = nullptr;
  return temp;
}
inline ::xla::cpu::ResourceOptional* OutfeedThunkProto_OutfeedResource::_internal_mutable_produce_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.produce_token_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ResourceOptional>(GetArena());
    _impl_.produce_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(p);
  }
  return _impl_.produce_token_;
}
inline ::xla::cpu::ResourceOptional* OutfeedThunkProto_OutfeedResource::mutable_produce_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::cpu::ResourceOptional* _msg = _internal_mutable_produce_token();
  // @@protoc_insertion_point(field_mutable:xla.cpu.OutfeedThunkProto.OutfeedResource.produce_token)
  return _msg;
}
inline void OutfeedThunkProto_OutfeedResource::set_allocated_produce_token(::xla::cpu::ResourceOptional* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.produce_token_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.produce_token_ = reinterpret_cast<::xla::cpu::ResourceOptional*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.OutfeedThunkProto.OutfeedResource.produce_token)
}

// -------------------------------------------------------------------

// OutfeedThunkProto

// .xla.cpu.OutfeedThunkProto.OutfeedResource outfeed_resources = 1;
inline bool OutfeedThunkProto::has_outfeed_resources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.outfeed_resources_ != nullptr);
  return value;
}
inline void OutfeedThunkProto::clear_outfeed_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.outfeed_resources_ != nullptr) _impl_.outfeed_resources_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::OutfeedThunkProto_OutfeedResource& OutfeedThunkProto::_internal_outfeed_resources() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::OutfeedThunkProto_OutfeedResource* p = _impl_.outfeed_resources_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::OutfeedThunkProto_OutfeedResource&>(::xla::cpu::_OutfeedThunkProto_OutfeedResource_default_instance_);
}
inline const ::xla::cpu::OutfeedThunkProto_OutfeedResource& OutfeedThunkProto::outfeed_resources() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OutfeedThunkProto.outfeed_resources)
  return _internal_outfeed_resources();
}
inline void OutfeedThunkProto::unsafe_arena_set_allocated_outfeed_resources(::xla::cpu::OutfeedThunkProto_OutfeedResource* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.outfeed_resources_);
  }
  _impl_.outfeed_resources_ = reinterpret_cast<::xla::cpu::OutfeedThunkProto_OutfeedResource*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.OutfeedThunkProto.outfeed_resources)
}
inline ::xla::cpu::OutfeedThunkProto_OutfeedResource* OutfeedThunkProto::release_outfeed_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::OutfeedThunkProto_OutfeedResource* released = _impl_.outfeed_resources_;
  _impl_.outfeed_resources_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::OutfeedThunkProto_OutfeedResource* OutfeedThunkProto::unsafe_arena_release_outfeed_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.OutfeedThunkProto.outfeed_resources)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::OutfeedThunkProto_OutfeedResource* temp = _impl_.outfeed_resources_;
  _impl_.outfeed_resources_ = nullptr;
  return temp;
}
inline ::xla::cpu::OutfeedThunkProto_OutfeedResource* OutfeedThunkProto::_internal_mutable_outfeed_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.outfeed_resources_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OutfeedThunkProto_OutfeedResource>(GetArena());
    _impl_.outfeed_resources_ = reinterpret_cast<::xla::cpu::OutfeedThunkProto_OutfeedResource*>(p);
  }
  return _impl_.outfeed_resources_;
}
inline ::xla::cpu::OutfeedThunkProto_OutfeedResource* OutfeedThunkProto::mutable_outfeed_resources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::OutfeedThunkProto_OutfeedResource* _msg = _internal_mutable_outfeed_resources();
  // @@protoc_insertion_point(field_mutable:xla.cpu.OutfeedThunkProto.outfeed_resources)
  return _msg;
}
inline void OutfeedThunkProto::set_allocated_outfeed_resources(::xla::cpu::OutfeedThunkProto_OutfeedResource* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.outfeed_resources_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.outfeed_resources_ = reinterpret_cast<::xla::cpu::OutfeedThunkProto_OutfeedResource*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.OutfeedThunkProto.outfeed_resources)
}

// repeated .xla.cpu.ShapeBufferAllocationSliceProto outfeed_buffers_shapes = 2;
inline int OutfeedThunkProto::_internal_outfeed_buffers_shapes_size() const {
  return _internal_outfeed_buffers_shapes().size();
}
inline int OutfeedThunkProto::outfeed_buffers_shapes_size() const {
  return _internal_outfeed_buffers_shapes_size();
}
inline void OutfeedThunkProto::clear_outfeed_buffers_shapes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outfeed_buffers_shapes_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* OutfeedThunkProto::mutable_outfeed_buffers_shapes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.OutfeedThunkProto.outfeed_buffers_shapes)
  return _internal_mutable_outfeed_buffers_shapes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* OutfeedThunkProto::mutable_outfeed_buffers_shapes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.OutfeedThunkProto.outfeed_buffers_shapes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outfeed_buffers_shapes();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& OutfeedThunkProto::outfeed_buffers_shapes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.OutfeedThunkProto.outfeed_buffers_shapes)
  return _internal_outfeed_buffers_shapes().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* OutfeedThunkProto::add_outfeed_buffers_shapes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_outfeed_buffers_shapes()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.OutfeedThunkProto.outfeed_buffers_shapes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& OutfeedThunkProto::outfeed_buffers_shapes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.OutfeedThunkProto.outfeed_buffers_shapes)
  return _internal_outfeed_buffers_shapes();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
OutfeedThunkProto::_internal_outfeed_buffers_shapes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outfeed_buffers_shapes_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
OutfeedThunkProto::_internal_mutable_outfeed_buffers_shapes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outfeed_buffers_shapes_;
}

// -------------------------------------------------------------------

// CustomCallThunkProto_OpBuffers

// repeated .xla.cpu.ShapeBufferAllocationSliceProto arguments_shapes = 1;
inline int CustomCallThunkProto_OpBuffers::_internal_arguments_shapes_size() const {
  return _internal_arguments_shapes().size();
}
inline int CustomCallThunkProto_OpBuffers::arguments_shapes_size() const {
  return _internal_arguments_shapes_size();
}
inline void CustomCallThunkProto_OpBuffers::clear_arguments_shapes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arguments_shapes_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CustomCallThunkProto_OpBuffers::mutable_arguments_shapes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.CustomCallThunkProto.OpBuffers.arguments_shapes)
  return _internal_mutable_arguments_shapes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* CustomCallThunkProto_OpBuffers::mutable_arguments_shapes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.CustomCallThunkProto.OpBuffers.arguments_shapes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arguments_shapes();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& CustomCallThunkProto_OpBuffers::arguments_shapes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CustomCallThunkProto.OpBuffers.arguments_shapes)
  return _internal_arguments_shapes().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CustomCallThunkProto_OpBuffers::add_arguments_shapes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_arguments_shapes()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.CustomCallThunkProto.OpBuffers.arguments_shapes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& CustomCallThunkProto_OpBuffers::arguments_shapes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.CustomCallThunkProto.OpBuffers.arguments_shapes)
  return _internal_arguments_shapes();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
CustomCallThunkProto_OpBuffers::_internal_arguments_shapes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arguments_shapes_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
CustomCallThunkProto_OpBuffers::_internal_mutable_arguments_shapes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arguments_shapes_;
}

// repeated .xla.cpu.ShapeBufferAllocationSliceProto results_shapes = 2;
inline int CustomCallThunkProto_OpBuffers::_internal_results_shapes_size() const {
  return _internal_results_shapes().size();
}
inline int CustomCallThunkProto_OpBuffers::results_shapes_size() const {
  return _internal_results_shapes_size();
}
inline void CustomCallThunkProto_OpBuffers::clear_results_shapes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.results_shapes_.Clear();
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CustomCallThunkProto_OpBuffers::mutable_results_shapes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.CustomCallThunkProto.OpBuffers.results_shapes)
  return _internal_mutable_results_shapes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>* CustomCallThunkProto_OpBuffers::mutable_results_shapes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.CustomCallThunkProto.OpBuffers.results_shapes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_results_shapes();
}
inline const ::xla::cpu::ShapeBufferAllocationSliceProto& CustomCallThunkProto_OpBuffers::results_shapes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CustomCallThunkProto.OpBuffers.results_shapes)
  return _internal_results_shapes().Get(index);
}
inline ::xla::cpu::ShapeBufferAllocationSliceProto* CustomCallThunkProto_OpBuffers::add_results_shapes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ShapeBufferAllocationSliceProto* _add = _internal_mutable_results_shapes()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.CustomCallThunkProto.OpBuffers.results_shapes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>& CustomCallThunkProto_OpBuffers::results_shapes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.CustomCallThunkProto.OpBuffers.results_shapes)
  return _internal_results_shapes();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>&
CustomCallThunkProto_OpBuffers::_internal_results_shapes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.results_shapes_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ShapeBufferAllocationSliceProto>*
CustomCallThunkProto_OpBuffers::_internal_mutable_results_shapes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.results_shapes_;
}

// -------------------------------------------------------------------

// CustomCallThunkProto

// .xla.CustomCallApiVersion api_version = 1;
inline void CustomCallThunkProto::clear_api_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.api_version_ = 0;
}
inline ::xla::CustomCallApiVersion CustomCallThunkProto::api_version() const {
  // @@protoc_insertion_point(field_get:xla.cpu.CustomCallThunkProto.api_version)
  return _internal_api_version();
}
inline void CustomCallThunkProto::set_api_version(::xla::CustomCallApiVersion value) {
  _internal_set_api_version(value);
  // @@protoc_insertion_point(field_set:xla.cpu.CustomCallThunkProto.api_version)
}
inline ::xla::CustomCallApiVersion CustomCallThunkProto::_internal_api_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::xla::CustomCallApiVersion>(_impl_.api_version_);
}
inline void CustomCallThunkProto::_internal_set_api_version(::xla::CustomCallApiVersion value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.api_version_ = value;
}

// string target_name = 2;
inline void CustomCallThunkProto::clear_target_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_name_.ClearToEmpty();
}
inline const std::string& CustomCallThunkProto::target_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CustomCallThunkProto.target_name)
  return _internal_target_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomCallThunkProto::set_target_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.CustomCallThunkProto.target_name)
}
inline std::string* CustomCallThunkProto::mutable_target_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_name();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CustomCallThunkProto.target_name)
  return _s;
}
inline const std::string& CustomCallThunkProto::_internal_target_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_name_.Get();
}
inline void CustomCallThunkProto::_internal_set_target_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_name_.Set(value, GetArena());
}
inline std::string* CustomCallThunkProto::_internal_mutable_target_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_name_.Mutable( GetArena());
}
inline std::string* CustomCallThunkProto::release_target_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CustomCallThunkProto.target_name)
  return _impl_.target_name_.Release();
}
inline void CustomCallThunkProto::set_allocated_target_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_name_.IsDefault()) {
          _impl_.target_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CustomCallThunkProto.target_name)
}

// string backend_config = 3;
inline void CustomCallThunkProto::clear_backend_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backend_config_.ClearToEmpty();
}
inline const std::string& CustomCallThunkProto::backend_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CustomCallThunkProto.backend_config)
  return _internal_backend_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomCallThunkProto::set_backend_config(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backend_config_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.CustomCallThunkProto.backend_config)
}
inline std::string* CustomCallThunkProto::mutable_backend_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_backend_config();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CustomCallThunkProto.backend_config)
  return _s;
}
inline const std::string& CustomCallThunkProto::_internal_backend_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.backend_config_.Get();
}
inline void CustomCallThunkProto::_internal_set_backend_config(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backend_config_.Set(value, GetArena());
}
inline std::string* CustomCallThunkProto::_internal_mutable_backend_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.backend_config_.Mutable( GetArena());
}
inline std::string* CustomCallThunkProto::release_backend_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CustomCallThunkProto.backend_config)
  return _impl_.backend_config_.Release();
}
inline void CustomCallThunkProto::set_allocated_backend_config(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backend_config_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.backend_config_.IsDefault()) {
          _impl_.backend_config_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CustomCallThunkProto.backend_config)
}

// .xla.cpu.CustomCallThunkProto.OpBuffers op_buffers = 4;
inline bool CustomCallThunkProto::has_op_buffers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.op_buffers_ != nullptr);
  return value;
}
inline void CustomCallThunkProto::clear_op_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_buffers_ != nullptr) _impl_.op_buffers_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::CustomCallThunkProto_OpBuffers& CustomCallThunkProto::_internal_op_buffers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::CustomCallThunkProto_OpBuffers* p = _impl_.op_buffers_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::CustomCallThunkProto_OpBuffers&>(::xla::cpu::_CustomCallThunkProto_OpBuffers_default_instance_);
}
inline const ::xla::cpu::CustomCallThunkProto_OpBuffers& CustomCallThunkProto::op_buffers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CustomCallThunkProto.op_buffers)
  return _internal_op_buffers();
}
inline void CustomCallThunkProto::unsafe_arena_set_allocated_op_buffers(::xla::cpu::CustomCallThunkProto_OpBuffers* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.op_buffers_);
  }
  _impl_.op_buffers_ = reinterpret_cast<::xla::cpu::CustomCallThunkProto_OpBuffers*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.CustomCallThunkProto.op_buffers)
}
inline ::xla::cpu::CustomCallThunkProto_OpBuffers* CustomCallThunkProto::release_op_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::CustomCallThunkProto_OpBuffers* released = _impl_.op_buffers_;
  _impl_.op_buffers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::CustomCallThunkProto_OpBuffers* CustomCallThunkProto::unsafe_arena_release_op_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CustomCallThunkProto.op_buffers)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::CustomCallThunkProto_OpBuffers* temp = _impl_.op_buffers_;
  _impl_.op_buffers_ = nullptr;
  return temp;
}
inline ::xla::cpu::CustomCallThunkProto_OpBuffers* CustomCallThunkProto::_internal_mutable_op_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_buffers_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::CustomCallThunkProto_OpBuffers>(GetArena());
    _impl_.op_buffers_ = reinterpret_cast<::xla::cpu::CustomCallThunkProto_OpBuffers*>(p);
  }
  return _impl_.op_buffers_;
}
inline ::xla::cpu::CustomCallThunkProto_OpBuffers* CustomCallThunkProto::mutable_op_buffers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::CustomCallThunkProto_OpBuffers* _msg = _internal_mutable_op_buffers();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CustomCallThunkProto.op_buffers)
  return _msg;
}
inline void CustomCallThunkProto::set_allocated_op_buffers(::xla::cpu::CustomCallThunkProto_OpBuffers* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.op_buffers_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.op_buffers_ = reinterpret_cast<::xla::cpu::CustomCallThunkProto_OpBuffers*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CustomCallThunkProto.op_buffers)
}

// -------------------------------------------------------------------

// PartitionIdThunkProto

// .xla.buffer_assignment.BufferAllocationSliceProto logical_id_buffer = 1;
inline bool PartitionIdThunkProto::has_logical_id_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logical_id_buffer_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& PartitionIdThunkProto::_internal_logical_id_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.logical_id_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& PartitionIdThunkProto::logical_id_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.PartitionIdThunkProto.logical_id_buffer)
  return _internal_logical_id_buffer();
}
inline void PartitionIdThunkProto::unsafe_arena_set_allocated_logical_id_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logical_id_buffer_);
  }
  _impl_.logical_id_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.PartitionIdThunkProto.logical_id_buffer)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PartitionIdThunkProto::release_logical_id_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.logical_id_buffer_;
  _impl_.logical_id_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PartitionIdThunkProto::unsafe_arena_release_logical_id_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.PartitionIdThunkProto.logical_id_buffer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.logical_id_buffer_;
  _impl_.logical_id_buffer_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PartitionIdThunkProto::_internal_mutable_logical_id_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logical_id_buffer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.logical_id_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.logical_id_buffer_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PartitionIdThunkProto::mutable_logical_id_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_logical_id_buffer();
  // @@protoc_insertion_point(field_mutable:xla.cpu.PartitionIdThunkProto.logical_id_buffer)
  return _msg;
}
inline void PartitionIdThunkProto::set_allocated_logical_id_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logical_id_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logical_id_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.PartitionIdThunkProto.logical_id_buffer)
}

// -------------------------------------------------------------------

// ReplicaIdThunkProto

// .xla.buffer_assignment.BufferAllocationSliceProto logical_id_buffer = 1;
inline bool ReplicaIdThunkProto::has_logical_id_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logical_id_buffer_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& ReplicaIdThunkProto::_internal_logical_id_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.logical_id_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& ReplicaIdThunkProto::logical_id_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ReplicaIdThunkProto.logical_id_buffer)
  return _internal_logical_id_buffer();
}
inline void ReplicaIdThunkProto::unsafe_arena_set_allocated_logical_id_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logical_id_buffer_);
  }
  _impl_.logical_id_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ReplicaIdThunkProto.logical_id_buffer)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ReplicaIdThunkProto::release_logical_id_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.logical_id_buffer_;
  _impl_.logical_id_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ReplicaIdThunkProto::unsafe_arena_release_logical_id_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ReplicaIdThunkProto.logical_id_buffer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.logical_id_buffer_;
  _impl_.logical_id_buffer_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ReplicaIdThunkProto::_internal_mutable_logical_id_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logical_id_buffer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.logical_id_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.logical_id_buffer_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* ReplicaIdThunkProto::mutable_logical_id_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_logical_id_buffer();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ReplicaIdThunkProto.logical_id_buffer)
  return _msg;
}
inline void ReplicaIdThunkProto::set_allocated_logical_id_buffer(::xla::buffer_assignment::BufferAllocationSliceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logical_id_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logical_id_buffer_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ReplicaIdThunkProto.logical_id_buffer)
}

// -------------------------------------------------------------------

// InfoProto

// string op_name = 1;
inline void InfoProto::clear_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.ClearToEmpty();
}
inline const std::string& InfoProto::op_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.InfoProto.op_name)
  return _internal_op_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InfoProto::set_op_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.InfoProto.op_name)
}
inline std::string* InfoProto::mutable_op_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_op_name();
  // @@protoc_insertion_point(field_mutable:xla.cpu.InfoProto.op_name)
  return _s;
}
inline const std::string& InfoProto::_internal_op_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.op_name_.Get();
}
inline void InfoProto::_internal_set_op_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.Set(value, GetArena());
}
inline std::string* InfoProto::_internal_mutable_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.op_name_.Mutable( GetArena());
}
inline std::string* InfoProto::release_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.InfoProto.op_name)
  return _impl_.op_name_.Release();
}
inline void InfoProto::set_allocated_op_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.op_name_.IsDefault()) {
          _impl_.op_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.InfoProto.op_name)
}

// string module_name = 2;
inline void InfoProto::clear_module_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.module_name_.ClearToEmpty();
}
inline const std::string& InfoProto::module_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.InfoProto.module_name)
  return _internal_module_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InfoProto::set_module_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.module_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.InfoProto.module_name)
}
inline std::string* InfoProto::mutable_module_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_module_name();
  // @@protoc_insertion_point(field_mutable:xla.cpu.InfoProto.module_name)
  return _s;
}
inline const std::string& InfoProto::_internal_module_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.module_name_.Get();
}
inline void InfoProto::_internal_set_module_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.module_name_.Set(value, GetArena());
}
inline std::string* InfoProto::_internal_mutable_module_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.module_name_.Mutable( GetArena());
}
inline std::string* InfoProto::release_module_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.InfoProto.module_name)
  return _impl_.module_name_.Release();
}
inline void InfoProto::set_allocated_module_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.module_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.module_name_.IsDefault()) {
          _impl_.module_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.InfoProto.module_name)
}

// int64 module_id = 3;
inline void InfoProto::clear_module_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.module_id_ = ::int64_t{0};
}
inline ::int64_t InfoProto::module_id() const {
  // @@protoc_insertion_point(field_get:xla.cpu.InfoProto.module_id)
  return _internal_module_id();
}
inline void InfoProto::set_module_id(::int64_t value) {
  _internal_set_module_id(value);
  // @@protoc_insertion_point(field_set:xla.cpu.InfoProto.module_id)
}
inline ::int64_t InfoProto::_internal_module_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.module_id_;
}
inline void InfoProto::_internal_set_module_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.module_id_ = value;
}

// -------------------------------------------------------------------

// ThunkProto

// string kind = 1;
inline void ThunkProto::clear_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_.ClearToEmpty();
}
inline const std::string& ThunkProto::kind() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.kind)
  return _internal_kind();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ThunkProto::set_kind(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.ThunkProto.kind)
}
inline std::string* ThunkProto::mutable_kind() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.kind)
  return _s;
}
inline const std::string& ThunkProto::_internal_kind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.kind_.Get();
}
inline void ThunkProto::_internal_set_kind(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_.Set(value, GetArena());
}
inline std::string* ThunkProto::_internal_mutable_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.kind_.Mutable( GetArena());
}
inline std::string* ThunkProto::release_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.kind)
  return _impl_.kind_.Release();
}
inline void ThunkProto::set_allocated_kind(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.kind_.IsDefault()) {
          _impl_.kind_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ThunkProto.kind)
}

// .xla.cpu.InfoProto info = 2;
inline bool ThunkProto::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline void ThunkProto::clear_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::InfoProto& ThunkProto::_internal_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::InfoProto* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::InfoProto&>(::xla::cpu::_InfoProto_default_instance_);
}
inline const ::xla::cpu::InfoProto& ThunkProto::info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.info)
  return _internal_info();
}
inline void ThunkProto::unsafe_arena_set_allocated_info(::xla::cpu::InfoProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = reinterpret_cast<::xla::cpu::InfoProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.info)
}
inline ::xla::cpu::InfoProto* ThunkProto::release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::InfoProto* released = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::InfoProto* ThunkProto::unsafe_arena_release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::InfoProto* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::xla::cpu::InfoProto* ThunkProto::_internal_mutable_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::InfoProto>(GetArena());
    _impl_.info_ = reinterpret_cast<::xla::cpu::InfoProto*>(p);
  }
  return _impl_.info_;
}
inline ::xla::cpu::InfoProto* ThunkProto::mutable_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::InfoProto* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.info)
  return _msg;
}
inline void ThunkProto::set_allocated_info(::xla::cpu::InfoProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_ = reinterpret_cast<::xla::cpu::InfoProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ThunkProto.info)
}

// .xla.cpu.CallThunkProto call_thunk = 3;
inline bool ThunkProto::has_call_thunk() const {
  return impl_case() == kCallThunk;
}
inline bool ThunkProto::_internal_has_call_thunk() const {
  return impl_case() == kCallThunk;
}
inline void ThunkProto::set_has_call_thunk() {
  _impl_._oneof_case_[0] = kCallThunk;
}
inline void ThunkProto::clear_call_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kCallThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.call_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.call_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::CallThunkProto* ThunkProto::release_call_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.call_thunk)
  if (impl_case() == kCallThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.call_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.call_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::CallThunkProto& ThunkProto::_internal_call_thunk() const {
  return impl_case() == kCallThunk ? *_impl_.impl_.call_thunk_ : reinterpret_cast<::xla::cpu::CallThunkProto&>(::xla::cpu::_CallThunkProto_default_instance_);
}
inline const ::xla::cpu::CallThunkProto& ThunkProto::call_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.call_thunk)
  return _internal_call_thunk();
}
inline ::xla::cpu::CallThunkProto* ThunkProto::unsafe_arena_release_call_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.call_thunk)
  if (impl_case() == kCallThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.call_thunk_;
    _impl_.impl_.call_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_call_thunk(::xla::cpu::CallThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_call_thunk();
    _impl_.impl_.call_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.call_thunk)
}
inline ::xla::cpu::CallThunkProto* ThunkProto::_internal_mutable_call_thunk() {
  if (impl_case() != kCallThunk) {
    clear_impl();
    set_has_call_thunk();
    _impl_.impl_.call_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::CallThunkProto>(GetArena());
  }
  return _impl_.impl_.call_thunk_;
}
inline ::xla::cpu::CallThunkProto* ThunkProto::mutable_call_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::CallThunkProto* _msg = _internal_mutable_call_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.call_thunk)
  return _msg;
}

// .xla.cpu.ConditionalThunkProto conditional_thunk = 4;
inline bool ThunkProto::has_conditional_thunk() const {
  return impl_case() == kConditionalThunk;
}
inline bool ThunkProto::_internal_has_conditional_thunk() const {
  return impl_case() == kConditionalThunk;
}
inline void ThunkProto::set_has_conditional_thunk() {
  _impl_._oneof_case_[0] = kConditionalThunk;
}
inline void ThunkProto::clear_conditional_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kConditionalThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.conditional_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.conditional_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::ConditionalThunkProto* ThunkProto::release_conditional_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.conditional_thunk)
  if (impl_case() == kConditionalThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.conditional_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.conditional_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::ConditionalThunkProto& ThunkProto::_internal_conditional_thunk() const {
  return impl_case() == kConditionalThunk ? *_impl_.impl_.conditional_thunk_ : reinterpret_cast<::xla::cpu::ConditionalThunkProto&>(::xla::cpu::_ConditionalThunkProto_default_instance_);
}
inline const ::xla::cpu::ConditionalThunkProto& ThunkProto::conditional_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.conditional_thunk)
  return _internal_conditional_thunk();
}
inline ::xla::cpu::ConditionalThunkProto* ThunkProto::unsafe_arena_release_conditional_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.conditional_thunk)
  if (impl_case() == kConditionalThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.conditional_thunk_;
    _impl_.impl_.conditional_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_conditional_thunk(::xla::cpu::ConditionalThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_conditional_thunk();
    _impl_.impl_.conditional_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.conditional_thunk)
}
inline ::xla::cpu::ConditionalThunkProto* ThunkProto::_internal_mutable_conditional_thunk() {
  if (impl_case() != kConditionalThunk) {
    clear_impl();
    set_has_conditional_thunk();
    _impl_.impl_.conditional_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ConditionalThunkProto>(GetArena());
  }
  return _impl_.impl_.conditional_thunk_;
}
inline ::xla::cpu::ConditionalThunkProto* ThunkProto::mutable_conditional_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::ConditionalThunkProto* _msg = _internal_mutable_conditional_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.conditional_thunk)
  return _msg;
}

// .xla.cpu.SortThunkProto sort_thunk = 5;
inline bool ThunkProto::has_sort_thunk() const {
  return impl_case() == kSortThunk;
}
inline bool ThunkProto::_internal_has_sort_thunk() const {
  return impl_case() == kSortThunk;
}
inline void ThunkProto::set_has_sort_thunk() {
  _impl_._oneof_case_[0] = kSortThunk;
}
inline void ThunkProto::clear_sort_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kSortThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.sort_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.sort_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::SortThunkProto* ThunkProto::release_sort_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.sort_thunk)
  if (impl_case() == kSortThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.sort_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.sort_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::SortThunkProto& ThunkProto::_internal_sort_thunk() const {
  return impl_case() == kSortThunk ? *_impl_.impl_.sort_thunk_ : reinterpret_cast<::xla::cpu::SortThunkProto&>(::xla::cpu::_SortThunkProto_default_instance_);
}
inline const ::xla::cpu::SortThunkProto& ThunkProto::sort_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.sort_thunk)
  return _internal_sort_thunk();
}
inline ::xla::cpu::SortThunkProto* ThunkProto::unsafe_arena_release_sort_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.sort_thunk)
  if (impl_case() == kSortThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.sort_thunk_;
    _impl_.impl_.sort_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_sort_thunk(::xla::cpu::SortThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_sort_thunk();
    _impl_.impl_.sort_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.sort_thunk)
}
inline ::xla::cpu::SortThunkProto* ThunkProto::_internal_mutable_sort_thunk() {
  if (impl_case() != kSortThunk) {
    clear_impl();
    set_has_sort_thunk();
    _impl_.impl_.sort_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::SortThunkProto>(GetArena());
  }
  return _impl_.impl_.sort_thunk_;
}
inline ::xla::cpu::SortThunkProto* ThunkProto::mutable_sort_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::SortThunkProto* _msg = _internal_mutable_sort_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.sort_thunk)
  return _msg;
}

// .xla.cpu.XnnFusionThunkProto xnn_fusion_thunk = 6;
inline bool ThunkProto::has_xnn_fusion_thunk() const {
  return impl_case() == kXnnFusionThunk;
}
inline bool ThunkProto::_internal_has_xnn_fusion_thunk() const {
  return impl_case() == kXnnFusionThunk;
}
inline void ThunkProto::set_has_xnn_fusion_thunk() {
  _impl_._oneof_case_[0] = kXnnFusionThunk;
}
inline void ThunkProto::clear_xnn_fusion_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kXnnFusionThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.xnn_fusion_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.xnn_fusion_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::XnnFusionThunkProto* ThunkProto::release_xnn_fusion_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.xnn_fusion_thunk)
  if (impl_case() == kXnnFusionThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.xnn_fusion_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.xnn_fusion_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::XnnFusionThunkProto& ThunkProto::_internal_xnn_fusion_thunk() const {
  return impl_case() == kXnnFusionThunk ? *_impl_.impl_.xnn_fusion_thunk_ : reinterpret_cast<::xla::cpu::XnnFusionThunkProto&>(::xla::cpu::_XnnFusionThunkProto_default_instance_);
}
inline const ::xla::cpu::XnnFusionThunkProto& ThunkProto::xnn_fusion_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.xnn_fusion_thunk)
  return _internal_xnn_fusion_thunk();
}
inline ::xla::cpu::XnnFusionThunkProto* ThunkProto::unsafe_arena_release_xnn_fusion_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.xnn_fusion_thunk)
  if (impl_case() == kXnnFusionThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.xnn_fusion_thunk_;
    _impl_.impl_.xnn_fusion_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_xnn_fusion_thunk(::xla::cpu::XnnFusionThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_xnn_fusion_thunk();
    _impl_.impl_.xnn_fusion_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.xnn_fusion_thunk)
}
inline ::xla::cpu::XnnFusionThunkProto* ThunkProto::_internal_mutable_xnn_fusion_thunk() {
  if (impl_case() != kXnnFusionThunk) {
    clear_impl();
    set_has_xnn_fusion_thunk();
    _impl_.impl_.xnn_fusion_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::XnnFusionThunkProto>(GetArena());
  }
  return _impl_.impl_.xnn_fusion_thunk_;
}
inline ::xla::cpu::XnnFusionThunkProto* ThunkProto::mutable_xnn_fusion_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::XnnFusionThunkProto* _msg = _internal_mutable_xnn_fusion_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.xnn_fusion_thunk)
  return _msg;
}

// .xla.cpu.DotThunkProto dot_thunk = 7;
inline bool ThunkProto::has_dot_thunk() const {
  return impl_case() == kDotThunk;
}
inline bool ThunkProto::_internal_has_dot_thunk() const {
  return impl_case() == kDotThunk;
}
inline void ThunkProto::set_has_dot_thunk() {
  _impl_._oneof_case_[0] = kDotThunk;
}
inline void ThunkProto::clear_dot_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kDotThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.dot_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.dot_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::DotThunkProto* ThunkProto::release_dot_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.dot_thunk)
  if (impl_case() == kDotThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.dot_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.dot_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::DotThunkProto& ThunkProto::_internal_dot_thunk() const {
  return impl_case() == kDotThunk ? *_impl_.impl_.dot_thunk_ : reinterpret_cast<::xla::cpu::DotThunkProto&>(::xla::cpu::_DotThunkProto_default_instance_);
}
inline const ::xla::cpu::DotThunkProto& ThunkProto::dot_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.dot_thunk)
  return _internal_dot_thunk();
}
inline ::xla::cpu::DotThunkProto* ThunkProto::unsafe_arena_release_dot_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.dot_thunk)
  if (impl_case() == kDotThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.dot_thunk_;
    _impl_.impl_.dot_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_dot_thunk(::xla::cpu::DotThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_dot_thunk();
    _impl_.impl_.dot_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.dot_thunk)
}
inline ::xla::cpu::DotThunkProto* ThunkProto::_internal_mutable_dot_thunk() {
  if (impl_case() != kDotThunk) {
    clear_impl();
    set_has_dot_thunk();
    _impl_.impl_.dot_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::DotThunkProto>(GetArena());
  }
  return _impl_.impl_.dot_thunk_;
}
inline ::xla::cpu::DotThunkProto* ThunkProto::mutable_dot_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::DotThunkProto* _msg = _internal_mutable_dot_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.dot_thunk)
  return _msg;
}

// .xla.cpu.RngGetAndUpdateStateThunkProto rng_get_and_update_state_thunk = 8;
inline bool ThunkProto::has_rng_get_and_update_state_thunk() const {
  return impl_case() == kRngGetAndUpdateStateThunk;
}
inline bool ThunkProto::_internal_has_rng_get_and_update_state_thunk() const {
  return impl_case() == kRngGetAndUpdateStateThunk;
}
inline void ThunkProto::set_has_rng_get_and_update_state_thunk() {
  _impl_._oneof_case_[0] = kRngGetAndUpdateStateThunk;
}
inline void ThunkProto::clear_rng_get_and_update_state_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kRngGetAndUpdateStateThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.rng_get_and_update_state_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.rng_get_and_update_state_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::RngGetAndUpdateStateThunkProto* ThunkProto::release_rng_get_and_update_state_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.rng_get_and_update_state_thunk)
  if (impl_case() == kRngGetAndUpdateStateThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.rng_get_and_update_state_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.rng_get_and_update_state_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::RngGetAndUpdateStateThunkProto& ThunkProto::_internal_rng_get_and_update_state_thunk() const {
  return impl_case() == kRngGetAndUpdateStateThunk ? *_impl_.impl_.rng_get_and_update_state_thunk_ : reinterpret_cast<::xla::cpu::RngGetAndUpdateStateThunkProto&>(::xla::cpu::_RngGetAndUpdateStateThunkProto_default_instance_);
}
inline const ::xla::cpu::RngGetAndUpdateStateThunkProto& ThunkProto::rng_get_and_update_state_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.rng_get_and_update_state_thunk)
  return _internal_rng_get_and_update_state_thunk();
}
inline ::xla::cpu::RngGetAndUpdateStateThunkProto* ThunkProto::unsafe_arena_release_rng_get_and_update_state_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.rng_get_and_update_state_thunk)
  if (impl_case() == kRngGetAndUpdateStateThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.rng_get_and_update_state_thunk_;
    _impl_.impl_.rng_get_and_update_state_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_rng_get_and_update_state_thunk(::xla::cpu::RngGetAndUpdateStateThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_rng_get_and_update_state_thunk();
    _impl_.impl_.rng_get_and_update_state_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.rng_get_and_update_state_thunk)
}
inline ::xla::cpu::RngGetAndUpdateStateThunkProto* ThunkProto::_internal_mutable_rng_get_and_update_state_thunk() {
  if (impl_case() != kRngGetAndUpdateStateThunk) {
    clear_impl();
    set_has_rng_get_and_update_state_thunk();
    _impl_.impl_.rng_get_and_update_state_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::RngGetAndUpdateStateThunkProto>(GetArena());
  }
  return _impl_.impl_.rng_get_and_update_state_thunk_;
}
inline ::xla::cpu::RngGetAndUpdateStateThunkProto* ThunkProto::mutable_rng_get_and_update_state_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::RngGetAndUpdateStateThunkProto* _msg = _internal_mutable_rng_get_and_update_state_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.rng_get_and_update_state_thunk)
  return _msg;
}

// .xla.cpu.TopKThunkProto top_k_thunk = 9;
inline bool ThunkProto::has_top_k_thunk() const {
  return impl_case() == kTopKThunk;
}
inline bool ThunkProto::_internal_has_top_k_thunk() const {
  return impl_case() == kTopKThunk;
}
inline void ThunkProto::set_has_top_k_thunk() {
  _impl_._oneof_case_[0] = kTopKThunk;
}
inline void ThunkProto::clear_top_k_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kTopKThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.top_k_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.top_k_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::TopKThunkProto* ThunkProto::release_top_k_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.top_k_thunk)
  if (impl_case() == kTopKThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.top_k_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.top_k_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::TopKThunkProto& ThunkProto::_internal_top_k_thunk() const {
  return impl_case() == kTopKThunk ? *_impl_.impl_.top_k_thunk_ : reinterpret_cast<::xla::cpu::TopKThunkProto&>(::xla::cpu::_TopKThunkProto_default_instance_);
}
inline const ::xla::cpu::TopKThunkProto& ThunkProto::top_k_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.top_k_thunk)
  return _internal_top_k_thunk();
}
inline ::xla::cpu::TopKThunkProto* ThunkProto::unsafe_arena_release_top_k_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.top_k_thunk)
  if (impl_case() == kTopKThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.top_k_thunk_;
    _impl_.impl_.top_k_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_top_k_thunk(::xla::cpu::TopKThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_top_k_thunk();
    _impl_.impl_.top_k_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.top_k_thunk)
}
inline ::xla::cpu::TopKThunkProto* ThunkProto::_internal_mutable_top_k_thunk() {
  if (impl_case() != kTopKThunk) {
    clear_impl();
    set_has_top_k_thunk();
    _impl_.impl_.top_k_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::TopKThunkProto>(GetArena());
  }
  return _impl_.impl_.top_k_thunk_;
}
inline ::xla::cpu::TopKThunkProto* ThunkProto::mutable_top_k_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::TopKThunkProto* _msg = _internal_mutable_top_k_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.top_k_thunk)
  return _msg;
}

// .xla.cpu.WhileThunkProto while_thunk = 10;
inline bool ThunkProto::has_while_thunk() const {
  return impl_case() == kWhileThunk;
}
inline bool ThunkProto::_internal_has_while_thunk() const {
  return impl_case() == kWhileThunk;
}
inline void ThunkProto::set_has_while_thunk() {
  _impl_._oneof_case_[0] = kWhileThunk;
}
inline void ThunkProto::clear_while_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kWhileThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.while_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.while_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::WhileThunkProto* ThunkProto::release_while_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.while_thunk)
  if (impl_case() == kWhileThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.while_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.while_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::WhileThunkProto& ThunkProto::_internal_while_thunk() const {
  return impl_case() == kWhileThunk ? *_impl_.impl_.while_thunk_ : reinterpret_cast<::xla::cpu::WhileThunkProto&>(::xla::cpu::_WhileThunkProto_default_instance_);
}
inline const ::xla::cpu::WhileThunkProto& ThunkProto::while_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.while_thunk)
  return _internal_while_thunk();
}
inline ::xla::cpu::WhileThunkProto* ThunkProto::unsafe_arena_release_while_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.while_thunk)
  if (impl_case() == kWhileThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.while_thunk_;
    _impl_.impl_.while_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_while_thunk(::xla::cpu::WhileThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_while_thunk();
    _impl_.impl_.while_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.while_thunk)
}
inline ::xla::cpu::WhileThunkProto* ThunkProto::_internal_mutable_while_thunk() {
  if (impl_case() != kWhileThunk) {
    clear_impl();
    set_has_while_thunk();
    _impl_.impl_.while_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::WhileThunkProto>(GetArena());
  }
  return _impl_.impl_.while_thunk_;
}
inline ::xla::cpu::WhileThunkProto* ThunkProto::mutable_while_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::WhileThunkProto* _msg = _internal_mutable_while_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.while_thunk)
  return _msg;
}

// .xla.cpu.KernelThunkProto kernel_thunk = 11;
inline bool ThunkProto::has_kernel_thunk() const {
  return impl_case() == kKernelThunk;
}
inline bool ThunkProto::_internal_has_kernel_thunk() const {
  return impl_case() == kKernelThunk;
}
inline void ThunkProto::set_has_kernel_thunk() {
  _impl_._oneof_case_[0] = kKernelThunk;
}
inline void ThunkProto::clear_kernel_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kKernelThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.kernel_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.kernel_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::KernelThunkProto* ThunkProto::release_kernel_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.kernel_thunk)
  if (impl_case() == kKernelThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.kernel_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.kernel_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::KernelThunkProto& ThunkProto::_internal_kernel_thunk() const {
  return impl_case() == kKernelThunk ? *_impl_.impl_.kernel_thunk_ : reinterpret_cast<::xla::cpu::KernelThunkProto&>(::xla::cpu::_KernelThunkProto_default_instance_);
}
inline const ::xla::cpu::KernelThunkProto& ThunkProto::kernel_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.kernel_thunk)
  return _internal_kernel_thunk();
}
inline ::xla::cpu::KernelThunkProto* ThunkProto::unsafe_arena_release_kernel_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.kernel_thunk)
  if (impl_case() == kKernelThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.kernel_thunk_;
    _impl_.impl_.kernel_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_kernel_thunk(::xla::cpu::KernelThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_kernel_thunk();
    _impl_.impl_.kernel_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.kernel_thunk)
}
inline ::xla::cpu::KernelThunkProto* ThunkProto::_internal_mutable_kernel_thunk() {
  if (impl_case() != kKernelThunk) {
    clear_impl();
    set_has_kernel_thunk();
    _impl_.impl_.kernel_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::KernelThunkProto>(GetArena());
  }
  return _impl_.impl_.kernel_thunk_;
}
inline ::xla::cpu::KernelThunkProto* ThunkProto::mutable_kernel_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::KernelThunkProto* _msg = _internal_mutable_kernel_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.kernel_thunk)
  return _msg;
}

// .xla.cpu.CopyThunkProto copy_thunk = 12;
inline bool ThunkProto::has_copy_thunk() const {
  return impl_case() == kCopyThunk;
}
inline bool ThunkProto::_internal_has_copy_thunk() const {
  return impl_case() == kCopyThunk;
}
inline void ThunkProto::set_has_copy_thunk() {
  _impl_._oneof_case_[0] = kCopyThunk;
}
inline void ThunkProto::clear_copy_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kCopyThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.copy_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.copy_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::CopyThunkProto* ThunkProto::release_copy_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.copy_thunk)
  if (impl_case() == kCopyThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.copy_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.copy_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::CopyThunkProto& ThunkProto::_internal_copy_thunk() const {
  return impl_case() == kCopyThunk ? *_impl_.impl_.copy_thunk_ : reinterpret_cast<::xla::cpu::CopyThunkProto&>(::xla::cpu::_CopyThunkProto_default_instance_);
}
inline const ::xla::cpu::CopyThunkProto& ThunkProto::copy_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.copy_thunk)
  return _internal_copy_thunk();
}
inline ::xla::cpu::CopyThunkProto* ThunkProto::unsafe_arena_release_copy_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.copy_thunk)
  if (impl_case() == kCopyThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.copy_thunk_;
    _impl_.impl_.copy_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_copy_thunk(::xla::cpu::CopyThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_copy_thunk();
    _impl_.impl_.copy_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.copy_thunk)
}
inline ::xla::cpu::CopyThunkProto* ThunkProto::_internal_mutable_copy_thunk() {
  if (impl_case() != kCopyThunk) {
    clear_impl();
    set_has_copy_thunk();
    _impl_.impl_.copy_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::CopyThunkProto>(GetArena());
  }
  return _impl_.impl_.copy_thunk_;
}
inline ::xla::cpu::CopyThunkProto* ThunkProto::mutable_copy_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::CopyThunkProto* _msg = _internal_mutable_copy_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.copy_thunk)
  return _msg;
}

// .xla.cpu.FftThunkProto fft_thunk = 13;
inline bool ThunkProto::has_fft_thunk() const {
  return impl_case() == kFftThunk;
}
inline bool ThunkProto::_internal_has_fft_thunk() const {
  return impl_case() == kFftThunk;
}
inline void ThunkProto::set_has_fft_thunk() {
  _impl_._oneof_case_[0] = kFftThunk;
}
inline void ThunkProto::clear_fft_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kFftThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.fft_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.fft_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::FftThunkProto* ThunkProto::release_fft_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.fft_thunk)
  if (impl_case() == kFftThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.fft_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.fft_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::FftThunkProto& ThunkProto::_internal_fft_thunk() const {
  return impl_case() == kFftThunk ? *_impl_.impl_.fft_thunk_ : reinterpret_cast<::xla::cpu::FftThunkProto&>(::xla::cpu::_FftThunkProto_default_instance_);
}
inline const ::xla::cpu::FftThunkProto& ThunkProto::fft_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.fft_thunk)
  return _internal_fft_thunk();
}
inline ::xla::cpu::FftThunkProto* ThunkProto::unsafe_arena_release_fft_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.fft_thunk)
  if (impl_case() == kFftThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.fft_thunk_;
    _impl_.impl_.fft_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_fft_thunk(::xla::cpu::FftThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_fft_thunk();
    _impl_.impl_.fft_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.fft_thunk)
}
inline ::xla::cpu::FftThunkProto* ThunkProto::_internal_mutable_fft_thunk() {
  if (impl_case() != kFftThunk) {
    clear_impl();
    set_has_fft_thunk();
    _impl_.impl_.fft_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::FftThunkProto>(GetArena());
  }
  return _impl_.impl_.fft_thunk_;
}
inline ::xla::cpu::FftThunkProto* ThunkProto::mutable_fft_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::FftThunkProto* _msg = _internal_mutable_fft_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.fft_thunk)
  return _msg;
}

// .xla.cpu.InfeedThunkProto infeed_thunk = 14;
inline bool ThunkProto::has_infeed_thunk() const {
  return impl_case() == kInfeedThunk;
}
inline bool ThunkProto::_internal_has_infeed_thunk() const {
  return impl_case() == kInfeedThunk;
}
inline void ThunkProto::set_has_infeed_thunk() {
  _impl_._oneof_case_[0] = kInfeedThunk;
}
inline void ThunkProto::clear_infeed_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kInfeedThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.infeed_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.infeed_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::InfeedThunkProto* ThunkProto::release_infeed_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.infeed_thunk)
  if (impl_case() == kInfeedThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.infeed_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.infeed_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::InfeedThunkProto& ThunkProto::_internal_infeed_thunk() const {
  return impl_case() == kInfeedThunk ? *_impl_.impl_.infeed_thunk_ : reinterpret_cast<::xla::cpu::InfeedThunkProto&>(::xla::cpu::_InfeedThunkProto_default_instance_);
}
inline const ::xla::cpu::InfeedThunkProto& ThunkProto::infeed_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.infeed_thunk)
  return _internal_infeed_thunk();
}
inline ::xla::cpu::InfeedThunkProto* ThunkProto::unsafe_arena_release_infeed_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.infeed_thunk)
  if (impl_case() == kInfeedThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.infeed_thunk_;
    _impl_.impl_.infeed_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_infeed_thunk(::xla::cpu::InfeedThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_infeed_thunk();
    _impl_.impl_.infeed_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.infeed_thunk)
}
inline ::xla::cpu::InfeedThunkProto* ThunkProto::_internal_mutable_infeed_thunk() {
  if (impl_case() != kInfeedThunk) {
    clear_impl();
    set_has_infeed_thunk();
    _impl_.impl_.infeed_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::InfeedThunkProto>(GetArena());
  }
  return _impl_.impl_.infeed_thunk_;
}
inline ::xla::cpu::InfeedThunkProto* ThunkProto::mutable_infeed_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::InfeedThunkProto* _msg = _internal_mutable_infeed_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.infeed_thunk)
  return _msg;
}

// .xla.cpu.OutfeedThunkProto outfeed_thunk = 15;
inline bool ThunkProto::has_outfeed_thunk() const {
  return impl_case() == kOutfeedThunk;
}
inline bool ThunkProto::_internal_has_outfeed_thunk() const {
  return impl_case() == kOutfeedThunk;
}
inline void ThunkProto::set_has_outfeed_thunk() {
  _impl_._oneof_case_[0] = kOutfeedThunk;
}
inline void ThunkProto::clear_outfeed_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kOutfeedThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.outfeed_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.outfeed_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::OutfeedThunkProto* ThunkProto::release_outfeed_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.outfeed_thunk)
  if (impl_case() == kOutfeedThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.outfeed_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.outfeed_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::OutfeedThunkProto& ThunkProto::_internal_outfeed_thunk() const {
  return impl_case() == kOutfeedThunk ? *_impl_.impl_.outfeed_thunk_ : reinterpret_cast<::xla::cpu::OutfeedThunkProto&>(::xla::cpu::_OutfeedThunkProto_default_instance_);
}
inline const ::xla::cpu::OutfeedThunkProto& ThunkProto::outfeed_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.outfeed_thunk)
  return _internal_outfeed_thunk();
}
inline ::xla::cpu::OutfeedThunkProto* ThunkProto::unsafe_arena_release_outfeed_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.outfeed_thunk)
  if (impl_case() == kOutfeedThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.outfeed_thunk_;
    _impl_.impl_.outfeed_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_outfeed_thunk(::xla::cpu::OutfeedThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_outfeed_thunk();
    _impl_.impl_.outfeed_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.outfeed_thunk)
}
inline ::xla::cpu::OutfeedThunkProto* ThunkProto::_internal_mutable_outfeed_thunk() {
  if (impl_case() != kOutfeedThunk) {
    clear_impl();
    set_has_outfeed_thunk();
    _impl_.impl_.outfeed_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OutfeedThunkProto>(GetArena());
  }
  return _impl_.impl_.outfeed_thunk_;
}
inline ::xla::cpu::OutfeedThunkProto* ThunkProto::mutable_outfeed_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::OutfeedThunkProto* _msg = _internal_mutable_outfeed_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.outfeed_thunk)
  return _msg;
}

// .xla.cpu.CustomCallThunkProto custom_call_thunk = 16;
inline bool ThunkProto::has_custom_call_thunk() const {
  return impl_case() == kCustomCallThunk;
}
inline bool ThunkProto::_internal_has_custom_call_thunk() const {
  return impl_case() == kCustomCallThunk;
}
inline void ThunkProto::set_has_custom_call_thunk() {
  _impl_._oneof_case_[0] = kCustomCallThunk;
}
inline void ThunkProto::clear_custom_call_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kCustomCallThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.custom_call_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.custom_call_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::CustomCallThunkProto* ThunkProto::release_custom_call_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.custom_call_thunk)
  if (impl_case() == kCustomCallThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.custom_call_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.custom_call_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::CustomCallThunkProto& ThunkProto::_internal_custom_call_thunk() const {
  return impl_case() == kCustomCallThunk ? *_impl_.impl_.custom_call_thunk_ : reinterpret_cast<::xla::cpu::CustomCallThunkProto&>(::xla::cpu::_CustomCallThunkProto_default_instance_);
}
inline const ::xla::cpu::CustomCallThunkProto& ThunkProto::custom_call_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.custom_call_thunk)
  return _internal_custom_call_thunk();
}
inline ::xla::cpu::CustomCallThunkProto* ThunkProto::unsafe_arena_release_custom_call_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.custom_call_thunk)
  if (impl_case() == kCustomCallThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.custom_call_thunk_;
    _impl_.impl_.custom_call_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_custom_call_thunk(::xla::cpu::CustomCallThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_custom_call_thunk();
    _impl_.impl_.custom_call_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.custom_call_thunk)
}
inline ::xla::cpu::CustomCallThunkProto* ThunkProto::_internal_mutable_custom_call_thunk() {
  if (impl_case() != kCustomCallThunk) {
    clear_impl();
    set_has_custom_call_thunk();
    _impl_.impl_.custom_call_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::CustomCallThunkProto>(GetArena());
  }
  return _impl_.impl_.custom_call_thunk_;
}
inline ::xla::cpu::CustomCallThunkProto* ThunkProto::mutable_custom_call_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::CustomCallThunkProto* _msg = _internal_mutable_custom_call_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.custom_call_thunk)
  return _msg;
}

// .xla.cpu.ConvolutionThunkProto convolution_thunk = 17;
inline bool ThunkProto::has_convolution_thunk() const {
  return impl_case() == kConvolutionThunk;
}
inline bool ThunkProto::_internal_has_convolution_thunk() const {
  return impl_case() == kConvolutionThunk;
}
inline void ThunkProto::set_has_convolution_thunk() {
  _impl_._oneof_case_[0] = kConvolutionThunk;
}
inline void ThunkProto::clear_convolution_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kConvolutionThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.convolution_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.convolution_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::ConvolutionThunkProto* ThunkProto::release_convolution_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.convolution_thunk)
  if (impl_case() == kConvolutionThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.convolution_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.convolution_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::ConvolutionThunkProto& ThunkProto::_internal_convolution_thunk() const {
  return impl_case() == kConvolutionThunk ? *_impl_.impl_.convolution_thunk_ : reinterpret_cast<::xla::cpu::ConvolutionThunkProto&>(::xla::cpu::_ConvolutionThunkProto_default_instance_);
}
inline const ::xla::cpu::ConvolutionThunkProto& ThunkProto::convolution_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.convolution_thunk)
  return _internal_convolution_thunk();
}
inline ::xla::cpu::ConvolutionThunkProto* ThunkProto::unsafe_arena_release_convolution_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.convolution_thunk)
  if (impl_case() == kConvolutionThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.convolution_thunk_;
    _impl_.impl_.convolution_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_convolution_thunk(::xla::cpu::ConvolutionThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_convolution_thunk();
    _impl_.impl_.convolution_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.convolution_thunk)
}
inline ::xla::cpu::ConvolutionThunkProto* ThunkProto::_internal_mutable_convolution_thunk() {
  if (impl_case() != kConvolutionThunk) {
    clear_impl();
    set_has_convolution_thunk();
    _impl_.impl_.convolution_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ConvolutionThunkProto>(GetArena());
  }
  return _impl_.impl_.convolution_thunk_;
}
inline ::xla::cpu::ConvolutionThunkProto* ThunkProto::mutable_convolution_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::ConvolutionThunkProto* _msg = _internal_mutable_convolution_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.convolution_thunk)
  return _msg;
}

// .xla.cpu.CollectiveThunkProto collective_thunk = 18;
inline bool ThunkProto::has_collective_thunk() const {
  return impl_case() == kCollectiveThunk;
}
inline bool ThunkProto::_internal_has_collective_thunk() const {
  return impl_case() == kCollectiveThunk;
}
inline void ThunkProto::set_has_collective_thunk() {
  _impl_._oneof_case_[0] = kCollectiveThunk;
}
inline void ThunkProto::clear_collective_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kCollectiveThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.collective_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.collective_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::CollectiveThunkProto* ThunkProto::release_collective_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.collective_thunk)
  if (impl_case() == kCollectiveThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.collective_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.collective_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::CollectiveThunkProto& ThunkProto::_internal_collective_thunk() const {
  return impl_case() == kCollectiveThunk ? *_impl_.impl_.collective_thunk_ : reinterpret_cast<::xla::cpu::CollectiveThunkProto&>(::xla::cpu::_CollectiveThunkProto_default_instance_);
}
inline const ::xla::cpu::CollectiveThunkProto& ThunkProto::collective_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.collective_thunk)
  return _internal_collective_thunk();
}
inline ::xla::cpu::CollectiveThunkProto* ThunkProto::unsafe_arena_release_collective_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.collective_thunk)
  if (impl_case() == kCollectiveThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.collective_thunk_;
    _impl_.impl_.collective_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_collective_thunk(::xla::cpu::CollectiveThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_collective_thunk();
    _impl_.impl_.collective_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.collective_thunk)
}
inline ::xla::cpu::CollectiveThunkProto* ThunkProto::_internal_mutable_collective_thunk() {
  if (impl_case() != kCollectiveThunk) {
    clear_impl();
    set_has_collective_thunk();
    _impl_.impl_.collective_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::CollectiveThunkProto>(GetArena());
  }
  return _impl_.impl_.collective_thunk_;
}
inline ::xla::cpu::CollectiveThunkProto* ThunkProto::mutable_collective_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::CollectiveThunkProto* _msg = _internal_mutable_collective_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.collective_thunk)
  return _msg;
}

// .xla.cpu.PartitionIdThunkProto partition_id_thunk = 19;
inline bool ThunkProto::has_partition_id_thunk() const {
  return impl_case() == kPartitionIdThunk;
}
inline bool ThunkProto::_internal_has_partition_id_thunk() const {
  return impl_case() == kPartitionIdThunk;
}
inline void ThunkProto::set_has_partition_id_thunk() {
  _impl_._oneof_case_[0] = kPartitionIdThunk;
}
inline void ThunkProto::clear_partition_id_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kPartitionIdThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.partition_id_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.partition_id_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::PartitionIdThunkProto* ThunkProto::release_partition_id_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.partition_id_thunk)
  if (impl_case() == kPartitionIdThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.partition_id_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.partition_id_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::PartitionIdThunkProto& ThunkProto::_internal_partition_id_thunk() const {
  return impl_case() == kPartitionIdThunk ? *_impl_.impl_.partition_id_thunk_ : reinterpret_cast<::xla::cpu::PartitionIdThunkProto&>(::xla::cpu::_PartitionIdThunkProto_default_instance_);
}
inline const ::xla::cpu::PartitionIdThunkProto& ThunkProto::partition_id_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.partition_id_thunk)
  return _internal_partition_id_thunk();
}
inline ::xla::cpu::PartitionIdThunkProto* ThunkProto::unsafe_arena_release_partition_id_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.partition_id_thunk)
  if (impl_case() == kPartitionIdThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.partition_id_thunk_;
    _impl_.impl_.partition_id_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_partition_id_thunk(::xla::cpu::PartitionIdThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_partition_id_thunk();
    _impl_.impl_.partition_id_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.partition_id_thunk)
}
inline ::xla::cpu::PartitionIdThunkProto* ThunkProto::_internal_mutable_partition_id_thunk() {
  if (impl_case() != kPartitionIdThunk) {
    clear_impl();
    set_has_partition_id_thunk();
    _impl_.impl_.partition_id_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::PartitionIdThunkProto>(GetArena());
  }
  return _impl_.impl_.partition_id_thunk_;
}
inline ::xla::cpu::PartitionIdThunkProto* ThunkProto::mutable_partition_id_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::PartitionIdThunkProto* _msg = _internal_mutable_partition_id_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.partition_id_thunk)
  return _msg;
}

// .xla.cpu.ReplicaIdThunkProto replica_id_thunk = 20;
inline bool ThunkProto::has_replica_id_thunk() const {
  return impl_case() == kReplicaIdThunk;
}
inline bool ThunkProto::_internal_has_replica_id_thunk() const {
  return impl_case() == kReplicaIdThunk;
}
inline void ThunkProto::set_has_replica_id_thunk() {
  _impl_._oneof_case_[0] = kReplicaIdThunk;
}
inline void ThunkProto::clear_replica_id_thunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (impl_case() == kReplicaIdThunk) {
    if (GetArena() == nullptr) {
      delete _impl_.impl_.replica_id_thunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.impl_.replica_id_thunk_);
    }
    clear_has_impl();
  }
}
inline ::xla::cpu::ReplicaIdThunkProto* ThunkProto::release_replica_id_thunk() {
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkProto.replica_id_thunk)
  if (impl_case() == kReplicaIdThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.replica_id_thunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.impl_.replica_id_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::ReplicaIdThunkProto& ThunkProto::_internal_replica_id_thunk() const {
  return impl_case() == kReplicaIdThunk ? *_impl_.impl_.replica_id_thunk_ : reinterpret_cast<::xla::cpu::ReplicaIdThunkProto&>(::xla::cpu::_ReplicaIdThunkProto_default_instance_);
}
inline const ::xla::cpu::ReplicaIdThunkProto& ThunkProto::replica_id_thunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkProto.replica_id_thunk)
  return _internal_replica_id_thunk();
}
inline ::xla::cpu::ReplicaIdThunkProto* ThunkProto::unsafe_arena_release_replica_id_thunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.ThunkProto.replica_id_thunk)
  if (impl_case() == kReplicaIdThunk) {
    clear_has_impl();
    auto* temp = _impl_.impl_.replica_id_thunk_;
    _impl_.impl_.replica_id_thunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ThunkProto::unsafe_arena_set_allocated_replica_id_thunk(::xla::cpu::ReplicaIdThunkProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_impl();
  if (value) {
    set_has_replica_id_thunk();
    _impl_.impl_.replica_id_thunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkProto.replica_id_thunk)
}
inline ::xla::cpu::ReplicaIdThunkProto* ThunkProto::_internal_mutable_replica_id_thunk() {
  if (impl_case() != kReplicaIdThunk) {
    clear_impl();
    set_has_replica_id_thunk();
    _impl_.impl_.replica_id_thunk_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ReplicaIdThunkProto>(GetArena());
  }
  return _impl_.impl_.replica_id_thunk_;
}
inline ::xla::cpu::ReplicaIdThunkProto* ThunkProto::mutable_replica_id_thunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::ReplicaIdThunkProto* _msg = _internal_mutable_replica_id_thunk();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkProto.replica_id_thunk)
  return _msg;
}

inline bool ThunkProto::has_impl() const {
  return impl_case() != IMPL_NOT_SET;
}
inline void ThunkProto::clear_has_impl() {
  _impl_._oneof_case_[0] = IMPL_NOT_SET;
}
inline ThunkProto::ImplCase ThunkProto::impl_case() const {
  return ThunkProto::ImplCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ThunkSequenceProto_ResourceUsersProto

// repeated int64 thunk_indices = 1;
inline int ThunkSequenceProto_ResourceUsersProto::_internal_thunk_indices_size() const {
  return _internal_thunk_indices().size();
}
inline int ThunkSequenceProto_ResourceUsersProto::thunk_indices_size() const {
  return _internal_thunk_indices_size();
}
inline void ThunkSequenceProto_ResourceUsersProto::clear_thunk_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.thunk_indices_.Clear();
}
inline ::int64_t ThunkSequenceProto_ResourceUsersProto::thunk_indices(int index) const {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkSequenceProto.ResourceUsersProto.thunk_indices)
  return _internal_thunk_indices().Get(index);
}
inline void ThunkSequenceProto_ResourceUsersProto::set_thunk_indices(int index, ::int64_t value) {
  _internal_mutable_thunk_indices()->Set(index, value);
  // @@protoc_insertion_point(field_set:xla.cpu.ThunkSequenceProto.ResourceUsersProto.thunk_indices)
}
inline void ThunkSequenceProto_ResourceUsersProto::add_thunk_indices(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_thunk_indices()->Add(value);
  // @@protoc_insertion_point(field_add:xla.cpu.ThunkSequenceProto.ResourceUsersProto.thunk_indices)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& ThunkSequenceProto_ResourceUsersProto::thunk_indices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.ThunkSequenceProto.ResourceUsersProto.thunk_indices)
  return _internal_thunk_indices();
}
inline ::google::protobuf::RepeatedField<::int64_t>* ThunkSequenceProto_ResourceUsersProto::mutable_thunk_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.ThunkSequenceProto.ResourceUsersProto.thunk_indices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_thunk_indices();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
ThunkSequenceProto_ResourceUsersProto::_internal_thunk_indices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.thunk_indices_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* ThunkSequenceProto_ResourceUsersProto::_internal_mutable_thunk_indices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.thunk_indices_;
}

// .xla.cpu.ResourceProto resource = 2;
inline bool ThunkSequenceProto_ResourceUsersProto::has_resource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resource_ != nullptr);
  return value;
}
inline void ThunkSequenceProto_ResourceUsersProto::clear_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.resource_ != nullptr) _impl_.resource_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::cpu::ResourceProto& ThunkSequenceProto_ResourceUsersProto::_internal_resource() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::cpu::ResourceProto* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::cpu::ResourceProto&>(::xla::cpu::_ResourceProto_default_instance_);
}
inline const ::xla::cpu::ResourceProto& ThunkSequenceProto_ResourceUsersProto::resource() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkSequenceProto.ResourceUsersProto.resource)
  return _internal_resource();
}
inline void ThunkSequenceProto_ResourceUsersProto::unsafe_arena_set_allocated_resource(::xla::cpu::ResourceProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = reinterpret_cast<::xla::cpu::ResourceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.ThunkSequenceProto.ResourceUsersProto.resource)
}
inline ::xla::cpu::ResourceProto* ThunkSequenceProto_ResourceUsersProto::release_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceProto* released = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::cpu::ResourceProto* ThunkSequenceProto_ResourceUsersProto::unsafe_arena_release_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.ThunkSequenceProto.ResourceUsersProto.resource)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::cpu::ResourceProto* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::xla::cpu::ResourceProto* ThunkSequenceProto_ResourceUsersProto::_internal_mutable_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.resource_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::cpu::ResourceProto>(GetArena());
    _impl_.resource_ = reinterpret_cast<::xla::cpu::ResourceProto*>(p);
  }
  return _impl_.resource_;
}
inline ::xla::cpu::ResourceProto* ThunkSequenceProto_ResourceUsersProto::mutable_resource() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::cpu::ResourceProto* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkSequenceProto.ResourceUsersProto.resource)
  return _msg;
}
inline void ThunkSequenceProto_ResourceUsersProto::set_allocated_resource(::xla::cpu::ResourceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.resource_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.resource_ = reinterpret_cast<::xla::cpu::ResourceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.ThunkSequenceProto.ResourceUsersProto.resource)
}

// -------------------------------------------------------------------

// ThunkSequenceProto

// repeated .xla.cpu.ThunkProto thunks = 1;
inline int ThunkSequenceProto::_internal_thunks_size() const {
  return _internal_thunks().size();
}
inline int ThunkSequenceProto::thunks_size() const {
  return _internal_thunks_size();
}
inline void ThunkSequenceProto::clear_thunks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.thunks_.Clear();
}
inline ::xla::cpu::ThunkProto* ThunkSequenceProto::mutable_thunks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkSequenceProto.thunks)
  return _internal_mutable_thunks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkProto>* ThunkSequenceProto::mutable_thunks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.ThunkSequenceProto.thunks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_thunks();
}
inline const ::xla::cpu::ThunkProto& ThunkSequenceProto::thunks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkSequenceProto.thunks)
  return _internal_thunks().Get(index);
}
inline ::xla::cpu::ThunkProto* ThunkSequenceProto::add_thunks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ThunkProto* _add = _internal_mutable_thunks()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.ThunkSequenceProto.thunks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkProto>& ThunkSequenceProto::thunks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.ThunkSequenceProto.thunks)
  return _internal_thunks();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkProto>&
ThunkSequenceProto::_internal_thunks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.thunks_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkProto>*
ThunkSequenceProto::_internal_mutable_thunks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.thunks_;
}

// repeated .xla.cpu.ThunkSequenceProto.ResourceUsersProto thunk_resources = 2;
inline int ThunkSequenceProto::_internal_thunk_resources_size() const {
  return _internal_thunk_resources().size();
}
inline int ThunkSequenceProto::thunk_resources_size() const {
  return _internal_thunk_resources_size();
}
inline void ThunkSequenceProto::clear_thunk_resources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.thunk_resources_.Clear();
}
inline ::xla::cpu::ThunkSequenceProto_ResourceUsersProto* ThunkSequenceProto::mutable_thunk_resources(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.cpu.ThunkSequenceProto.thunk_resources)
  return _internal_mutable_thunk_resources()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto_ResourceUsersProto>* ThunkSequenceProto::mutable_thunk_resources()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.ThunkSequenceProto.thunk_resources)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_thunk_resources();
}
inline const ::xla::cpu::ThunkSequenceProto_ResourceUsersProto& ThunkSequenceProto::thunk_resources(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.ThunkSequenceProto.thunk_resources)
  return _internal_thunk_resources().Get(index);
}
inline ::xla::cpu::ThunkSequenceProto_ResourceUsersProto* ThunkSequenceProto::add_thunk_resources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::cpu::ThunkSequenceProto_ResourceUsersProto* _add = _internal_mutable_thunk_resources()->Add();
  // @@protoc_insertion_point(field_add:xla.cpu.ThunkSequenceProto.thunk_resources)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto_ResourceUsersProto>& ThunkSequenceProto::thunk_resources() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.ThunkSequenceProto.thunk_resources)
  return _internal_thunk_resources();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto_ResourceUsersProto>&
ThunkSequenceProto::_internal_thunk_resources() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.thunk_resources_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::cpu::ThunkSequenceProto_ResourceUsersProto>*
ThunkSequenceProto::_internal_mutable_thunk_resources() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.thunk_resources_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace cpu
}  // namespace xla


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::xla::cpu::ResourceProto_Kind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xla::cpu::ResourceProto_Kind>() {
  return ::xla::cpu::ResourceProto_Kind_descriptor();
}
template <>
struct is_proto_enum<::xla::cpu::SortDirectionProto> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xla::cpu::SortDirectionProto>() {
  return ::xla::cpu::SortDirectionProto_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_xla_2fbackends_2fcpu_2fruntime_2fthunk_2eproto_2epb_2eh
