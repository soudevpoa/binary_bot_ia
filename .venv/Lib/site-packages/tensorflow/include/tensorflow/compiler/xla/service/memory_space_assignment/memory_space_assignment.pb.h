// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: xla/service/memory_space_assignment/memory_space_assignment.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
namespace xla {
namespace memory_space_assignment {
class ExpandedScopedAlternateMemoryMode;
struct ExpandedScopedAlternateMemoryModeDefaultTypeInternal;
PROTOBUF_EXPORT extern ExpandedScopedAlternateMemoryModeDefaultTypeInternal _ExpandedScopedAlternateMemoryMode_default_instance_;
class HloOperandFilter;
struct HloOperandFilterDefaultTypeInternal;
PROTOBUF_EXPORT extern HloOperandFilterDefaultTypeInternal _HloOperandFilter_default_instance_;
class HloPositionMatcher;
struct HloPositionMatcherDefaultTypeInternal;
PROTOBUF_EXPORT extern HloPositionMatcherDefaultTypeInternal _HloPositionMatcher_default_instance_;
class MemoryBoundLoopOptimizerOptions;
struct MemoryBoundLoopOptimizerOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern MemoryBoundLoopOptimizerOptionsDefaultTypeInternal _MemoryBoundLoopOptimizerOptions_default_instance_;
class MsaSortOrderOverride;
struct MsaSortOrderOverrideDefaultTypeInternal;
PROTOBUF_EXPORT extern MsaSortOrderOverrideDefaultTypeInternal _MsaSortOrderOverride_default_instance_;
class MsaSortOrderOverrideOptions;
struct MsaSortOrderOverrideOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern MsaSortOrderOverrideOptionsDefaultTypeInternal _MsaSortOrderOverrideOptions_default_instance_;
class MsaSortOrderOverrides;
struct MsaSortOrderOverridesDefaultTypeInternal;
PROTOBUF_EXPORT extern MsaSortOrderOverridesDefaultTypeInternal _MsaSortOrderOverrides_default_instance_;
class PreferredPrefetchOverride;
struct PreferredPrefetchOverrideDefaultTypeInternal;
PROTOBUF_EXPORT extern PreferredPrefetchOverrideDefaultTypeInternal _PreferredPrefetchOverride_default_instance_;
class PreferredPrefetchOverrideOptions;
struct PreferredPrefetchOverrideOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern PreferredPrefetchOverrideOptionsDefaultTypeInternal _PreferredPrefetchOverrideOptions_default_instance_;
class PreferredPrefetchOverrides;
struct PreferredPrefetchOverridesDefaultTypeInternal;
PROTOBUF_EXPORT extern PreferredPrefetchOverridesDefaultTypeInternal _PreferredPrefetchOverrides_default_instance_;
class SlicedPrefetchOptions;
struct SlicedPrefetchOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern SlicedPrefetchOptionsDefaultTypeInternal _SlicedPrefetchOptions_default_instance_;
class TupleShapeIndex;
struct TupleShapeIndexDefaultTypeInternal;
PROTOBUF_EXPORT extern TupleShapeIndexDefaultTypeInternal _TupleShapeIndex_default_instance_;
class WindowPrefetchDetail;
struct WindowPrefetchDetailDefaultTypeInternal;
PROTOBUF_EXPORT extern WindowPrefetchDetailDefaultTypeInternal _WindowPrefetchDetail_default_instance_;
class WindowPrefetchDetail_WindowDetail;
struct WindowPrefetchDetail_WindowDetailDefaultTypeInternal;
PROTOBUF_EXPORT extern WindowPrefetchDetail_WindowDetailDefaultTypeInternal _WindowPrefetchDetail_WindowDetail_default_instance_;
}  // namespace memory_space_assignment
}  // namespace xla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xla {
namespace memory_space_assignment {
enum ExpandedScopedAlternateMemoryMode_Value : int {
  ExpandedScopedAlternateMemoryMode_Value_UNDEFINED = 0,
  ExpandedScopedAlternateMemoryMode_Value_DISABLED = 1,
  ExpandedScopedAlternateMemoryMode_Value_ENABLED = 2,
  ExpandedScopedAlternateMemoryMode_Value_ExpandedScopedAlternateMemoryMode_Value_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExpandedScopedAlternateMemoryMode_Value_ExpandedScopedAlternateMemoryMode_Value_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool ExpandedScopedAlternateMemoryMode_Value_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t ExpandedScopedAlternateMemoryMode_Value_internal_data_[];
constexpr ExpandedScopedAlternateMemoryMode_Value ExpandedScopedAlternateMemoryMode_Value_Value_MIN = static_cast<ExpandedScopedAlternateMemoryMode_Value>(0);
constexpr ExpandedScopedAlternateMemoryMode_Value ExpandedScopedAlternateMemoryMode_Value_Value_MAX = static_cast<ExpandedScopedAlternateMemoryMode_Value>(2);
constexpr int ExpandedScopedAlternateMemoryMode_Value_Value_ARRAYSIZE = 2 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
ExpandedScopedAlternateMemoryMode_Value_descriptor();
template <typename T>
const std::string& ExpandedScopedAlternateMemoryMode_Value_Name(T value) {
  static_assert(std::is_same<T, ExpandedScopedAlternateMemoryMode_Value>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Value_Name().");
  return ExpandedScopedAlternateMemoryMode_Value_Name(static_cast<ExpandedScopedAlternateMemoryMode_Value>(value));
}
template <>
inline const std::string& ExpandedScopedAlternateMemoryMode_Value_Name(ExpandedScopedAlternateMemoryMode_Value value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExpandedScopedAlternateMemoryMode_Value_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ExpandedScopedAlternateMemoryMode_Value_Parse(absl::string_view name, ExpandedScopedAlternateMemoryMode_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExpandedScopedAlternateMemoryMode_Value>(
      ExpandedScopedAlternateMemoryMode_Value_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT WindowPrefetchDetail_WindowDetail final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail) */ {
 public:
  inline WindowPrefetchDetail_WindowDetail() : WindowPrefetchDetail_WindowDetail(nullptr) {}
  ~WindowPrefetchDetail_WindowDetail() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WindowPrefetchDetail_WindowDetail(
      ::google::protobuf::internal::ConstantInitialized);

  inline WindowPrefetchDetail_WindowDetail(const WindowPrefetchDetail_WindowDetail& from) : WindowPrefetchDetail_WindowDetail(nullptr, from) {}
  inline WindowPrefetchDetail_WindowDetail(WindowPrefetchDetail_WindowDetail&& from) noexcept
      : WindowPrefetchDetail_WindowDetail(nullptr, std::move(from)) {}
  inline WindowPrefetchDetail_WindowDetail& operator=(const WindowPrefetchDetail_WindowDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowPrefetchDetail_WindowDetail& operator=(WindowPrefetchDetail_WindowDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowPrefetchDetail_WindowDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowPrefetchDetail_WindowDetail* internal_default_instance() {
    return reinterpret_cast<const WindowPrefetchDetail_WindowDetail*>(
        &_WindowPrefetchDetail_WindowDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(WindowPrefetchDetail_WindowDetail& a, WindowPrefetchDetail_WindowDetail& b) { a.Swap(&b); }
  inline void Swap(WindowPrefetchDetail_WindowDetail* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowPrefetchDetail_WindowDetail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowPrefetchDetail_WindowDetail* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WindowPrefetchDetail_WindowDetail>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WindowPrefetchDetail_WindowDetail& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WindowPrefetchDetail_WindowDetail& from) { WindowPrefetchDetail_WindowDetail::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WindowPrefetchDetail_WindowDetail* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail"; }

 protected:
  explicit WindowPrefetchDetail_WindowDetail(::google::protobuf::Arena* arena);
  WindowPrefetchDetail_WindowDetail(::google::protobuf::Arena* arena, const WindowPrefetchDetail_WindowDetail& from);
  WindowPrefetchDetail_WindowDetail(::google::protobuf::Arena* arena, WindowPrefetchDetail_WindowDetail&& from) noexcept
      : WindowPrefetchDetail_WindowDetail(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOperandFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // int64 operand = 1;
  void clear_operand() ;
  ::int64_t operand() const;
  void set_operand(::int64_t value);

  private:
  ::int64_t _internal_operand() const;
  void _internal_set_operand(::int64_t value);

  public:
  // int64 size = 2;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WindowPrefetchDetail_WindowDetail& from_msg);
    ::int64_t operand_;
    ::int64_t size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TupleShapeIndex final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.TupleShapeIndex) */ {
 public:
  inline TupleShapeIndex() : TupleShapeIndex(nullptr) {}
  ~TupleShapeIndex() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TupleShapeIndex(
      ::google::protobuf::internal::ConstantInitialized);

  inline TupleShapeIndex(const TupleShapeIndex& from) : TupleShapeIndex(nullptr, from) {}
  inline TupleShapeIndex(TupleShapeIndex&& from) noexcept
      : TupleShapeIndex(nullptr, std::move(from)) {}
  inline TupleShapeIndex& operator=(const TupleShapeIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleShapeIndex& operator=(TupleShapeIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleShapeIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleShapeIndex* internal_default_instance() {
    return reinterpret_cast<const TupleShapeIndex*>(
        &_TupleShapeIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TupleShapeIndex& a, TupleShapeIndex& b) { a.Swap(&b); }
  inline void Swap(TupleShapeIndex* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleShapeIndex* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleShapeIndex* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TupleShapeIndex>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TupleShapeIndex& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TupleShapeIndex& from) { TupleShapeIndex::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TupleShapeIndex* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.TupleShapeIndex"; }

 protected:
  explicit TupleShapeIndex(::google::protobuf::Arena* arena);
  TupleShapeIndex(::google::protobuf::Arena* arena, const TupleShapeIndex& from);
  TupleShapeIndex(::google::protobuf::Arena* arena, TupleShapeIndex&& from) noexcept
      : TupleShapeIndex(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
  };
  // repeated int64 index = 1;
  int index_size() const;
  private:
  int _internal_index_size() const;

  public:
  void clear_index() ;
  ::int64_t index(int index) const;
  void set_index(int index, ::int64_t value);
  void add_index(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& index() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_index();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_index() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_index();

  public:
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.TupleShapeIndex)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TupleShapeIndex& from_msg);
    ::google::protobuf::RepeatedField<::int64_t> index_;
    mutable ::google::protobuf::internal::CachedSize _index_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SlicedPrefetchOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.SlicedPrefetchOptions) */ {
 public:
  inline SlicedPrefetchOptions() : SlicedPrefetchOptions(nullptr) {}
  ~SlicedPrefetchOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SlicedPrefetchOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline SlicedPrefetchOptions(const SlicedPrefetchOptions& from) : SlicedPrefetchOptions(nullptr, from) {}
  inline SlicedPrefetchOptions(SlicedPrefetchOptions&& from) noexcept
      : SlicedPrefetchOptions(nullptr, std::move(from)) {}
  inline SlicedPrefetchOptions& operator=(const SlicedPrefetchOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlicedPrefetchOptions& operator=(SlicedPrefetchOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SlicedPrefetchOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SlicedPrefetchOptions* internal_default_instance() {
    return reinterpret_cast<const SlicedPrefetchOptions*>(
        &_SlicedPrefetchOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SlicedPrefetchOptions& a, SlicedPrefetchOptions& b) { a.Swap(&b); }
  inline void Swap(SlicedPrefetchOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlicedPrefetchOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SlicedPrefetchOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SlicedPrefetchOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SlicedPrefetchOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SlicedPrefetchOptions& from) { SlicedPrefetchOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SlicedPrefetchOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.SlicedPrefetchOptions"; }

 protected:
  explicit SlicedPrefetchOptions(::google::protobuf::Arena* arena);
  SlicedPrefetchOptions(::google::protobuf::Arena* arena, const SlicedPrefetchOptions& from);
  SlicedPrefetchOptions(::google::protobuf::Arena* arena, SlicedPrefetchOptions&& from) noexcept
      : SlicedPrefetchOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMinBytesFieldNumber = 2,
    kMaxSlicesFieldNumber = 1,
    kFailOnNonAlignmentBoundarySliceProposalFieldNumber = 3,
    kPreferredSliceSizeFieldNumber = 5,
    kAllSliceTimePermutationsThresholdFieldNumber = 4,
  };
  // uint64 min_bytes = 2;
  void clear_min_bytes() ;
  ::uint64_t min_bytes() const;
  void set_min_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_min_bytes() const;
  void _internal_set_min_bytes(::uint64_t value);

  public:
  // uint32 max_slices = 1;
  void clear_max_slices() ;
  ::uint32_t max_slices() const;
  void set_max_slices(::uint32_t value);

  private:
  ::uint32_t _internal_max_slices() const;
  void _internal_set_max_slices(::uint32_t value);

  public:
  // bool fail_on_non_alignment_boundary_slice_proposal = 3;
  void clear_fail_on_non_alignment_boundary_slice_proposal() ;
  bool fail_on_non_alignment_boundary_slice_proposal() const;
  void set_fail_on_non_alignment_boundary_slice_proposal(bool value);

  private:
  bool _internal_fail_on_non_alignment_boundary_slice_proposal() const;
  void _internal_set_fail_on_non_alignment_boundary_slice_proposal(bool value);

  public:
  // uint64 preferred_slice_size = 5;
  void clear_preferred_slice_size() ;
  ::uint64_t preferred_slice_size() const;
  void set_preferred_slice_size(::uint64_t value);

  private:
  ::uint64_t _internal_preferred_slice_size() const;
  void _internal_set_preferred_slice_size(::uint64_t value);

  public:
  // uint32 all_slice_time_permutations_threshold = 4;
  void clear_all_slice_time_permutations_threshold() ;
  ::uint32_t all_slice_time_permutations_threshold() const;
  void set_all_slice_time_permutations_threshold(::uint32_t value);

  private:
  ::uint32_t _internal_all_slice_time_permutations_threshold() const;
  void _internal_set_all_slice_time_permutations_threshold(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.SlicedPrefetchOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SlicedPrefetchOptions& from_msg);
    ::uint64_t min_bytes_;
    ::uint32_t max_slices_;
    bool fail_on_non_alignment_boundary_slice_proposal_;
    ::uint64_t preferred_slice_size_;
    ::uint32_t all_slice_time_permutations_threshold_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MsaSortOrderOverrideOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.MsaSortOrderOverrideOptions) */ {
 public:
  inline MsaSortOrderOverrideOptions() : MsaSortOrderOverrideOptions(nullptr) {}
  ~MsaSortOrderOverrideOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MsaSortOrderOverrideOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline MsaSortOrderOverrideOptions(const MsaSortOrderOverrideOptions& from) : MsaSortOrderOverrideOptions(nullptr, from) {}
  inline MsaSortOrderOverrideOptions(MsaSortOrderOverrideOptions&& from) noexcept
      : MsaSortOrderOverrideOptions(nullptr, std::move(from)) {}
  inline MsaSortOrderOverrideOptions& operator=(const MsaSortOrderOverrideOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsaSortOrderOverrideOptions& operator=(MsaSortOrderOverrideOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsaSortOrderOverrideOptions& default_instance() {
    return *internal_default_instance();
  }
  enum OptionsCase {
    kAssignFirst = 1,
    kAssignLast = 2,
    OPTIONS_NOT_SET = 0,
  };
  static inline const MsaSortOrderOverrideOptions* internal_default_instance() {
    return reinterpret_cast<const MsaSortOrderOverrideOptions*>(
        &_MsaSortOrderOverrideOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(MsaSortOrderOverrideOptions& a, MsaSortOrderOverrideOptions& b) { a.Swap(&b); }
  inline void Swap(MsaSortOrderOverrideOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsaSortOrderOverrideOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsaSortOrderOverrideOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MsaSortOrderOverrideOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MsaSortOrderOverrideOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MsaSortOrderOverrideOptions& from) { MsaSortOrderOverrideOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MsaSortOrderOverrideOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.MsaSortOrderOverrideOptions"; }

 protected:
  explicit MsaSortOrderOverrideOptions(::google::protobuf::Arena* arena);
  MsaSortOrderOverrideOptions(::google::protobuf::Arena* arena, const MsaSortOrderOverrideOptions& from);
  MsaSortOrderOverrideOptions(::google::protobuf::Arena* arena, MsaSortOrderOverrideOptions&& from) noexcept
      : MsaSortOrderOverrideOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAssignFirstFieldNumber = 1,
    kAssignLastFieldNumber = 2,
  };
  // bool assign_first = 1;
  bool has_assign_first() const;
  void clear_assign_first() ;
  bool assign_first() const;
  void set_assign_first(bool value);

  private:
  bool _internal_assign_first() const;
  void _internal_set_assign_first(bool value);

  public:
  // bool assign_last = 2;
  bool has_assign_last() const;
  void clear_assign_last() ;
  bool assign_last() const;
  void set_assign_last(bool value);

  private:
  bool _internal_assign_last() const;
  void _internal_set_assign_last(bool value);

  public:
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.MsaSortOrderOverrideOptions)
 private:
  class _Internal;
  void set_has_assign_first();
  void set_has_assign_last();
  inline bool has_options() const;
  inline void clear_has_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MsaSortOrderOverrideOptions& from_msg);
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool assign_first_;
      bool assign_last_;
    } options_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MemoryBoundLoopOptimizerOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions) */ {
 public:
  inline MemoryBoundLoopOptimizerOptions() : MemoryBoundLoopOptimizerOptions(nullptr) {}
  ~MemoryBoundLoopOptimizerOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MemoryBoundLoopOptimizerOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline MemoryBoundLoopOptimizerOptions(const MemoryBoundLoopOptimizerOptions& from) : MemoryBoundLoopOptimizerOptions(nullptr, from) {}
  inline MemoryBoundLoopOptimizerOptions(MemoryBoundLoopOptimizerOptions&& from) noexcept
      : MemoryBoundLoopOptimizerOptions(nullptr, std::move(from)) {}
  inline MemoryBoundLoopOptimizerOptions& operator=(const MemoryBoundLoopOptimizerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryBoundLoopOptimizerOptions& operator=(MemoryBoundLoopOptimizerOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoryBoundLoopOptimizerOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoryBoundLoopOptimizerOptions* internal_default_instance() {
    return reinterpret_cast<const MemoryBoundLoopOptimizerOptions*>(
        &_MemoryBoundLoopOptimizerOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(MemoryBoundLoopOptimizerOptions& a, MemoryBoundLoopOptimizerOptions& b) { a.Swap(&b); }
  inline void Swap(MemoryBoundLoopOptimizerOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoryBoundLoopOptimizerOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoryBoundLoopOptimizerOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MemoryBoundLoopOptimizerOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MemoryBoundLoopOptimizerOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MemoryBoundLoopOptimizerOptions& from) { MemoryBoundLoopOptimizerOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MemoryBoundLoopOptimizerOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions"; }

 protected:
  explicit MemoryBoundLoopOptimizerOptions(::google::protobuf::Arena* arena);
  MemoryBoundLoopOptimizerOptions(::google::protobuf::Arena* arena, const MemoryBoundLoopOptimizerOptions& from);
  MemoryBoundLoopOptimizerOptions(::google::protobuf::Arena* arena, MemoryBoundLoopOptimizerOptions&& from) noexcept
      : MemoryBoundLoopOptimizerOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDesiredCopyRatioFieldNumber = 2,
    kEnabledFieldNumber = 1,
    kAllowUnsatisfiedFullyPipelinedPrefetchFieldNumber = 3,
    kMinNumIterationsFieldNumber = 4,
  };
  // optional float desired_copy_ratio = 2;
  bool has_desired_copy_ratio() const;
  void clear_desired_copy_ratio() ;
  float desired_copy_ratio() const;
  void set_desired_copy_ratio(float value);

  private:
  float _internal_desired_copy_ratio() const;
  void _internal_set_desired_copy_ratio(float value);

  public:
  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // optional bool allow_unsatisfied_fully_pipelined_prefetch = 3;
  bool has_allow_unsatisfied_fully_pipelined_prefetch() const;
  void clear_allow_unsatisfied_fully_pipelined_prefetch() ;
  bool allow_unsatisfied_fully_pipelined_prefetch() const;
  void set_allow_unsatisfied_fully_pipelined_prefetch(bool value);

  private:
  bool _internal_allow_unsatisfied_fully_pipelined_prefetch() const;
  void _internal_set_allow_unsatisfied_fully_pipelined_prefetch(bool value);

  public:
  // optional float min_num_iterations = 4;
  bool has_min_num_iterations() const;
  void clear_min_num_iterations() ;
  float min_num_iterations() const;
  void set_min_num_iterations(float value);

  private:
  float _internal_min_num_iterations() const;
  void _internal_set_min_num_iterations(float value);

  public:
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MemoryBoundLoopOptimizerOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float desired_copy_ratio_;
    bool enabled_;
    bool allow_unsatisfied_fully_pipelined_prefetch_;
    float min_num_iterations_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ExpandedScopedAlternateMemoryMode final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.ExpandedScopedAlternateMemoryMode) */ {
 public:
  inline ExpandedScopedAlternateMemoryMode() : ExpandedScopedAlternateMemoryMode(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpandedScopedAlternateMemoryMode(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpandedScopedAlternateMemoryMode(const ExpandedScopedAlternateMemoryMode& from) : ExpandedScopedAlternateMemoryMode(nullptr, from) {}
  inline ExpandedScopedAlternateMemoryMode(ExpandedScopedAlternateMemoryMode&& from) noexcept
      : ExpandedScopedAlternateMemoryMode(nullptr, std::move(from)) {}
  inline ExpandedScopedAlternateMemoryMode& operator=(const ExpandedScopedAlternateMemoryMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandedScopedAlternateMemoryMode& operator=(ExpandedScopedAlternateMemoryMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandedScopedAlternateMemoryMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpandedScopedAlternateMemoryMode* internal_default_instance() {
    return reinterpret_cast<const ExpandedScopedAlternateMemoryMode*>(
        &_ExpandedScopedAlternateMemoryMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ExpandedScopedAlternateMemoryMode& a, ExpandedScopedAlternateMemoryMode& b) { a.Swap(&b); }
  inline void Swap(ExpandedScopedAlternateMemoryMode* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandedScopedAlternateMemoryMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandedScopedAlternateMemoryMode* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ExpandedScopedAlternateMemoryMode>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExpandedScopedAlternateMemoryMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExpandedScopedAlternateMemoryMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.ExpandedScopedAlternateMemoryMode"; }

 protected:
  explicit ExpandedScopedAlternateMemoryMode(::google::protobuf::Arena* arena);
  ExpandedScopedAlternateMemoryMode(::google::protobuf::Arena* arena, const ExpandedScopedAlternateMemoryMode& from);
  ExpandedScopedAlternateMemoryMode(::google::protobuf::Arena* arena, ExpandedScopedAlternateMemoryMode&& from) noexcept
      : ExpandedScopedAlternateMemoryMode(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Value = ExpandedScopedAlternateMemoryMode_Value;
  static constexpr Value UNDEFINED = ExpandedScopedAlternateMemoryMode_Value_UNDEFINED;
  static constexpr Value DISABLED = ExpandedScopedAlternateMemoryMode_Value_DISABLED;
  static constexpr Value ENABLED = ExpandedScopedAlternateMemoryMode_Value_ENABLED;
  static inline bool Value_IsValid(int value) {
    return ExpandedScopedAlternateMemoryMode_Value_IsValid(value);
  }
  static constexpr Value Value_MIN = ExpandedScopedAlternateMemoryMode_Value_Value_MIN;
  static constexpr Value Value_MAX = ExpandedScopedAlternateMemoryMode_Value_Value_MAX;
  static constexpr int Value_ARRAYSIZE = ExpandedScopedAlternateMemoryMode_Value_Value_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Value_descriptor() {
    return ExpandedScopedAlternateMemoryMode_Value_descriptor();
  }
  template <typename T>
  static inline const std::string& Value_Name(T value) {
    return ExpandedScopedAlternateMemoryMode_Value_Name(value);
  }
  static inline bool Value_Parse(absl::string_view name, Value* value) {
    return ExpandedScopedAlternateMemoryMode_Value_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.ExpandedScopedAlternateMemoryMode)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpandedScopedAlternateMemoryMode& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT WindowPrefetchDetail final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.WindowPrefetchDetail) */ {
 public:
  inline WindowPrefetchDetail() : WindowPrefetchDetail(nullptr) {}
  ~WindowPrefetchDetail() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WindowPrefetchDetail(
      ::google::protobuf::internal::ConstantInitialized);

  inline WindowPrefetchDetail(const WindowPrefetchDetail& from) : WindowPrefetchDetail(nullptr, from) {}
  inline WindowPrefetchDetail(WindowPrefetchDetail&& from) noexcept
      : WindowPrefetchDetail(nullptr, std::move(from)) {}
  inline WindowPrefetchDetail& operator=(const WindowPrefetchDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowPrefetchDetail& operator=(WindowPrefetchDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowPrefetchDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowPrefetchDetail* internal_default_instance() {
    return reinterpret_cast<const WindowPrefetchDetail*>(
        &_WindowPrefetchDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(WindowPrefetchDetail& a, WindowPrefetchDetail& b) { a.Swap(&b); }
  inline void Swap(WindowPrefetchDetail* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowPrefetchDetail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowPrefetchDetail* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WindowPrefetchDetail>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WindowPrefetchDetail& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WindowPrefetchDetail& from) { WindowPrefetchDetail::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WindowPrefetchDetail* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.WindowPrefetchDetail"; }

 protected:
  explicit WindowPrefetchDetail(::google::protobuf::Arena* arena);
  WindowPrefetchDetail(::google::protobuf::Arena* arena, const WindowPrefetchDetail& from);
  WindowPrefetchDetail(::google::protobuf::Arena* arena, WindowPrefetchDetail&& from) noexcept
      : WindowPrefetchDetail(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using WindowDetail = WindowPrefetchDetail_WindowDetail;

  // accessors -------------------------------------------------------
  enum : int {
    kWindowsFieldNumber = 1,
  };
  // repeated .xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail windows = 1;
  int windows_size() const;
  private:
  int _internal_windows_size() const;

  public:
  void clear_windows() ;
  ::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail* mutable_windows(int index);
  ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail>* mutable_windows();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail>& _internal_windows() const;
  ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail>* _internal_mutable_windows();
  public:
  const ::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail& windows(int index) const;
  ::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail* add_windows();
  const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail>& windows() const;
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.WindowPrefetchDetail)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WindowPrefetchDetail& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail > windows_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT HloOperandFilter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.HloOperandFilter) */ {
 public:
  inline HloOperandFilter() : HloOperandFilter(nullptr) {}
  ~HloOperandFilter() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HloOperandFilter(
      ::google::protobuf::internal::ConstantInitialized);

  inline HloOperandFilter(const HloOperandFilter& from) : HloOperandFilter(nullptr, from) {}
  inline HloOperandFilter(HloOperandFilter&& from) noexcept
      : HloOperandFilter(nullptr, std::move(from)) {}
  inline HloOperandFilter& operator=(const HloOperandFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline HloOperandFilter& operator=(HloOperandFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HloOperandFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const HloOperandFilter* internal_default_instance() {
    return reinterpret_cast<const HloOperandFilter*>(
        &_HloOperandFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(HloOperandFilter& a, HloOperandFilter& b) { a.Swap(&b); }
  inline void Swap(HloOperandFilter* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HloOperandFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HloOperandFilter* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<HloOperandFilter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HloOperandFilter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HloOperandFilter& from) { HloOperandFilter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HloOperandFilter* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.HloOperandFilter"; }

 protected:
  explicit HloOperandFilter(::google::protobuf::Arena* arena);
  HloOperandFilter(::google::protobuf::Arena* arena, const HloOperandFilter& from);
  HloOperandFilter(::google::protobuf::Arena* arena, HloOperandFilter&& from) noexcept
      : HloOperandFilter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInstructionNameRegexFieldNumber = 1,
    kInstructionRegexFieldNumber = 6,
    kTupleIndexFieldNumber = 5,
    kOperandNumberFieldNumber = 2,
    kSizeGteFieldNumber = 3,
    kSizeLteFieldNumber = 4,
  };
  // optional string instruction_name_regex = 1;
  bool has_instruction_name_regex() const;
  void clear_instruction_name_regex() ;
  const std::string& instruction_name_regex() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_instruction_name_regex(Arg_&& arg, Args_... args);
  std::string* mutable_instruction_name_regex();
  PROTOBUF_NODISCARD std::string* release_instruction_name_regex();
  void set_allocated_instruction_name_regex(std::string* value);

  private:
  const std::string& _internal_instruction_name_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instruction_name_regex(
      const std::string& value);
  std::string* _internal_mutable_instruction_name_regex();

  public:
  // optional string instruction_regex = 6;
  bool has_instruction_regex() const;
  void clear_instruction_regex() ;
  const std::string& instruction_regex() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_instruction_regex(Arg_&& arg, Args_... args);
  std::string* mutable_instruction_regex();
  PROTOBUF_NODISCARD std::string* release_instruction_regex();
  void set_allocated_instruction_regex(std::string* value);

  private:
  const std::string& _internal_instruction_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instruction_regex(
      const std::string& value);
  std::string* _internal_mutable_instruction_regex();

  public:
  // optional .xla.memory_space_assignment.TupleShapeIndex tuple_index = 5;
  bool has_tuple_index() const;
  void clear_tuple_index() ;
  const ::xla::memory_space_assignment::TupleShapeIndex& tuple_index() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::TupleShapeIndex* release_tuple_index();
  ::xla::memory_space_assignment::TupleShapeIndex* mutable_tuple_index();
  void set_allocated_tuple_index(::xla::memory_space_assignment::TupleShapeIndex* value);
  void unsafe_arena_set_allocated_tuple_index(::xla::memory_space_assignment::TupleShapeIndex* value);
  ::xla::memory_space_assignment::TupleShapeIndex* unsafe_arena_release_tuple_index();

  private:
  const ::xla::memory_space_assignment::TupleShapeIndex& _internal_tuple_index() const;
  ::xla::memory_space_assignment::TupleShapeIndex* _internal_mutable_tuple_index();

  public:
  // optional int64 operand_number = 2;
  bool has_operand_number() const;
  void clear_operand_number() ;
  ::int64_t operand_number() const;
  void set_operand_number(::int64_t value);

  private:
  ::int64_t _internal_operand_number() const;
  void _internal_set_operand_number(::int64_t value);

  public:
  // optional int64 size_gte = 3;
  bool has_size_gte() const;
  void clear_size_gte() ;
  ::int64_t size_gte() const;
  void set_size_gte(::int64_t value);

  private:
  ::int64_t _internal_size_gte() const;
  void _internal_set_size_gte(::int64_t value);

  public:
  // optional int64 size_lte = 4;
  bool has_size_lte() const;
  void clear_size_lte() ;
  ::int64_t size_lte() const;
  void set_size_lte(::int64_t value);

  private:
  ::int64_t _internal_size_lte() const;
  void _internal_set_size_lte(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.HloOperandFilter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      92, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HloOperandFilter& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr instruction_name_regex_;
    ::google::protobuf::internal::ArenaStringPtr instruction_regex_;
    ::xla::memory_space_assignment::TupleShapeIndex* tuple_index_;
    ::int64_t operand_number_;
    ::int64_t size_gte_;
    ::int64_t size_lte_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT HloPositionMatcher final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.HloPositionMatcher) */ {
 public:
  inline HloPositionMatcher() : HloPositionMatcher(nullptr) {}
  ~HloPositionMatcher() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HloPositionMatcher(
      ::google::protobuf::internal::ConstantInitialized);

  inline HloPositionMatcher(const HloPositionMatcher& from) : HloPositionMatcher(nullptr, from) {}
  inline HloPositionMatcher(HloPositionMatcher&& from) noexcept
      : HloPositionMatcher(nullptr, std::move(from)) {}
  inline HloPositionMatcher& operator=(const HloPositionMatcher& from) {
    CopyFrom(from);
    return *this;
  }
  inline HloPositionMatcher& operator=(HloPositionMatcher&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HloPositionMatcher& default_instance() {
    return *internal_default_instance();
  }
  static inline const HloPositionMatcher* internal_default_instance() {
    return reinterpret_cast<const HloPositionMatcher*>(
        &_HloPositionMatcher_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(HloPositionMatcher& a, HloPositionMatcher& b) { a.Swap(&b); }
  inline void Swap(HloPositionMatcher* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HloPositionMatcher* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HloPositionMatcher* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<HloPositionMatcher>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HloPositionMatcher& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HloPositionMatcher& from) { HloPositionMatcher::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HloPositionMatcher* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.HloPositionMatcher"; }

 protected:
  explicit HloPositionMatcher(::google::protobuf::Arena* arena);
  HloPositionMatcher(::google::protobuf::Arena* arena, const HloPositionMatcher& from);
  HloPositionMatcher(::google::protobuf::Arena* arena, HloPositionMatcher&& from) noexcept
      : HloPositionMatcher(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInstructionRegexFieldNumber = 1,
    kInstructionNameRegexFieldNumber = 2,
    kTupleIndexFieldNumber = 3,
    kHloUseFilterFieldNumber = 6,
    kSizeGteFieldNumber = 4,
    kSizeLteFieldNumber = 5,
  };
  // optional string instruction_regex = 1;
  bool has_instruction_regex() const;
  void clear_instruction_regex() ;
  const std::string& instruction_regex() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_instruction_regex(Arg_&& arg, Args_... args);
  std::string* mutable_instruction_regex();
  PROTOBUF_NODISCARD std::string* release_instruction_regex();
  void set_allocated_instruction_regex(std::string* value);

  private:
  const std::string& _internal_instruction_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instruction_regex(
      const std::string& value);
  std::string* _internal_mutable_instruction_regex();

  public:
  // optional string instruction_name_regex = 2;
  bool has_instruction_name_regex() const;
  void clear_instruction_name_regex() ;
  const std::string& instruction_name_regex() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_instruction_name_regex(Arg_&& arg, Args_... args);
  std::string* mutable_instruction_name_regex();
  PROTOBUF_NODISCARD std::string* release_instruction_name_regex();
  void set_allocated_instruction_name_regex(std::string* value);

  private:
  const std::string& _internal_instruction_name_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instruction_name_regex(
      const std::string& value);
  std::string* _internal_mutable_instruction_name_regex();

  public:
  // optional .xla.memory_space_assignment.TupleShapeIndex tuple_index = 3;
  bool has_tuple_index() const;
  void clear_tuple_index() ;
  const ::xla::memory_space_assignment::TupleShapeIndex& tuple_index() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::TupleShapeIndex* release_tuple_index();
  ::xla::memory_space_assignment::TupleShapeIndex* mutable_tuple_index();
  void set_allocated_tuple_index(::xla::memory_space_assignment::TupleShapeIndex* value);
  void unsafe_arena_set_allocated_tuple_index(::xla::memory_space_assignment::TupleShapeIndex* value);
  ::xla::memory_space_assignment::TupleShapeIndex* unsafe_arena_release_tuple_index();

  private:
  const ::xla::memory_space_assignment::TupleShapeIndex& _internal_tuple_index() const;
  ::xla::memory_space_assignment::TupleShapeIndex* _internal_mutable_tuple_index();

  public:
  // optional .xla.memory_space_assignment.HloOperandFilter hlo_use_filter = 6;
  bool has_hlo_use_filter() const;
  void clear_hlo_use_filter() ;
  const ::xla::memory_space_assignment::HloOperandFilter& hlo_use_filter() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::HloOperandFilter* release_hlo_use_filter();
  ::xla::memory_space_assignment::HloOperandFilter* mutable_hlo_use_filter();
  void set_allocated_hlo_use_filter(::xla::memory_space_assignment::HloOperandFilter* value);
  void unsafe_arena_set_allocated_hlo_use_filter(::xla::memory_space_assignment::HloOperandFilter* value);
  ::xla::memory_space_assignment::HloOperandFilter* unsafe_arena_release_hlo_use_filter();

  private:
  const ::xla::memory_space_assignment::HloOperandFilter& _internal_hlo_use_filter() const;
  ::xla::memory_space_assignment::HloOperandFilter* _internal_mutable_hlo_use_filter();

  public:
  // optional int64 size_gte = 4;
  bool has_size_gte() const;
  void clear_size_gte() ;
  ::int64_t size_gte() const;
  void set_size_gte(::int64_t value);

  private:
  ::int64_t _internal_size_gte() const;
  void _internal_set_size_gte(::int64_t value);

  public:
  // optional int64 size_lte = 5;
  bool has_size_lte() const;
  void clear_size_lte() ;
  ::int64_t size_lte() const;
  void set_size_lte(::int64_t value);

  private:
  ::int64_t _internal_size_lte() const;
  void _internal_set_size_lte(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.HloPositionMatcher)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      94, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HloPositionMatcher& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr instruction_regex_;
    ::google::protobuf::internal::ArenaStringPtr instruction_name_regex_;
    ::xla::memory_space_assignment::TupleShapeIndex* tuple_index_;
    ::xla::memory_space_assignment::HloOperandFilter* hlo_use_filter_;
    ::int64_t size_gte_;
    ::int64_t size_lte_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PreferredPrefetchOverrideOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.PreferredPrefetchOverrideOptions) */ {
 public:
  inline PreferredPrefetchOverrideOptions() : PreferredPrefetchOverrideOptions(nullptr) {}
  ~PreferredPrefetchOverrideOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PreferredPrefetchOverrideOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline PreferredPrefetchOverrideOptions(const PreferredPrefetchOverrideOptions& from) : PreferredPrefetchOverrideOptions(nullptr, from) {}
  inline PreferredPrefetchOverrideOptions(PreferredPrefetchOverrideOptions&& from) noexcept
      : PreferredPrefetchOverrideOptions(nullptr, std::move(from)) {}
  inline PreferredPrefetchOverrideOptions& operator=(const PreferredPrefetchOverrideOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreferredPrefetchOverrideOptions& operator=(PreferredPrefetchOverrideOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreferredPrefetchOverrideOptions& default_instance() {
    return *internal_default_instance();
  }
  enum OptionsCase {
    kPrefetchEagerness = 1,
    kAfterInstruction = 4,
    kBeforeInstruction = 5,
    OPTIONS_NOT_SET = 0,
  };
  static inline const PreferredPrefetchOverrideOptions* internal_default_instance() {
    return reinterpret_cast<const PreferredPrefetchOverrideOptions*>(
        &_PreferredPrefetchOverrideOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PreferredPrefetchOverrideOptions& a, PreferredPrefetchOverrideOptions& b) { a.Swap(&b); }
  inline void Swap(PreferredPrefetchOverrideOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreferredPrefetchOverrideOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreferredPrefetchOverrideOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PreferredPrefetchOverrideOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PreferredPrefetchOverrideOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PreferredPrefetchOverrideOptions& from) { PreferredPrefetchOverrideOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PreferredPrefetchOverrideOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.PreferredPrefetchOverrideOptions"; }

 protected:
  explicit PreferredPrefetchOverrideOptions(::google::protobuf::Arena* arena);
  PreferredPrefetchOverrideOptions(::google::protobuf::Arena* arena, const PreferredPrefetchOverrideOptions& from);
  PreferredPrefetchOverrideOptions(::google::protobuf::Arena* arena, PreferredPrefetchOverrideOptions&& from) noexcept
      : PreferredPrefetchOverrideOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrefetchEagernessFieldNumber = 1,
    kAfterInstructionFieldNumber = 4,
    kBeforeInstructionFieldNumber = 5,
  };
  // float prefetch_eagerness = 1;
  bool has_prefetch_eagerness() const;
  void clear_prefetch_eagerness() ;
  float prefetch_eagerness() const;
  void set_prefetch_eagerness(float value);

  private:
  float _internal_prefetch_eagerness() const;
  void _internal_set_prefetch_eagerness(float value);

  public:
  // .xla.memory_space_assignment.HloPositionMatcher after_instruction = 4;
  bool has_after_instruction() const;
  private:
  bool _internal_has_after_instruction() const;

  public:
  void clear_after_instruction() ;
  const ::xla::memory_space_assignment::HloPositionMatcher& after_instruction() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::HloPositionMatcher* release_after_instruction();
  ::xla::memory_space_assignment::HloPositionMatcher* mutable_after_instruction();
  void set_allocated_after_instruction(::xla::memory_space_assignment::HloPositionMatcher* value);
  void unsafe_arena_set_allocated_after_instruction(::xla::memory_space_assignment::HloPositionMatcher* value);
  ::xla::memory_space_assignment::HloPositionMatcher* unsafe_arena_release_after_instruction();

  private:
  const ::xla::memory_space_assignment::HloPositionMatcher& _internal_after_instruction() const;
  ::xla::memory_space_assignment::HloPositionMatcher* _internal_mutable_after_instruction();

  public:
  // .xla.memory_space_assignment.HloPositionMatcher before_instruction = 5;
  bool has_before_instruction() const;
  private:
  bool _internal_has_before_instruction() const;

  public:
  void clear_before_instruction() ;
  const ::xla::memory_space_assignment::HloPositionMatcher& before_instruction() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::HloPositionMatcher* release_before_instruction();
  ::xla::memory_space_assignment::HloPositionMatcher* mutable_before_instruction();
  void set_allocated_before_instruction(::xla::memory_space_assignment::HloPositionMatcher* value);
  void unsafe_arena_set_allocated_before_instruction(::xla::memory_space_assignment::HloPositionMatcher* value);
  ::xla::memory_space_assignment::HloPositionMatcher* unsafe_arena_release_before_instruction();

  private:
  const ::xla::memory_space_assignment::HloPositionMatcher& _internal_before_instruction() const;
  ::xla::memory_space_assignment::HloPositionMatcher* _internal_mutable_before_instruction();

  public:
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.PreferredPrefetchOverrideOptions)
 private:
  class _Internal;
  void set_has_prefetch_eagerness();
  void set_has_after_instruction();
  void set_has_before_instruction();
  inline bool has_options() const;
  inline void clear_has_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PreferredPrefetchOverrideOptions& from_msg);
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      float prefetch_eagerness_;
      ::xla::memory_space_assignment::HloPositionMatcher* after_instruction_;
      ::xla::memory_space_assignment::HloPositionMatcher* before_instruction_;
    } options_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MsaSortOrderOverride final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.MsaSortOrderOverride) */ {
 public:
  inline MsaSortOrderOverride() : MsaSortOrderOverride(nullptr) {}
  ~MsaSortOrderOverride() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MsaSortOrderOverride(
      ::google::protobuf::internal::ConstantInitialized);

  inline MsaSortOrderOverride(const MsaSortOrderOverride& from) : MsaSortOrderOverride(nullptr, from) {}
  inline MsaSortOrderOverride(MsaSortOrderOverride&& from) noexcept
      : MsaSortOrderOverride(nullptr, std::move(from)) {}
  inline MsaSortOrderOverride& operator=(const MsaSortOrderOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsaSortOrderOverride& operator=(MsaSortOrderOverride&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsaSortOrderOverride& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsaSortOrderOverride* internal_default_instance() {
    return reinterpret_cast<const MsaSortOrderOverride*>(
        &_MsaSortOrderOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(MsaSortOrderOverride& a, MsaSortOrderOverride& b) { a.Swap(&b); }
  inline void Swap(MsaSortOrderOverride* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsaSortOrderOverride* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsaSortOrderOverride* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MsaSortOrderOverride>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MsaSortOrderOverride& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MsaSortOrderOverride& from) { MsaSortOrderOverride::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MsaSortOrderOverride* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.MsaSortOrderOverride"; }

 protected:
  explicit MsaSortOrderOverride(::google::protobuf::Arena* arena);
  MsaSortOrderOverride(::google::protobuf::Arena* arena, const MsaSortOrderOverride& from);
  MsaSortOrderOverride(::google::protobuf::Arena* arena, MsaSortOrderOverride&& from) noexcept
      : MsaSortOrderOverride(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHloPositionMatcherFieldNumber = 1,
    kOverrideOptionsFieldNumber = 2,
    kApplyToCrossProgramPrefetchesFieldNumber = 3,
  };
  // optional .xla.memory_space_assignment.HloPositionMatcher hlo_position_matcher = 1;
  bool has_hlo_position_matcher() const;
  void clear_hlo_position_matcher() ;
  const ::xla::memory_space_assignment::HloPositionMatcher& hlo_position_matcher() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::HloPositionMatcher* release_hlo_position_matcher();
  ::xla::memory_space_assignment::HloPositionMatcher* mutable_hlo_position_matcher();
  void set_allocated_hlo_position_matcher(::xla::memory_space_assignment::HloPositionMatcher* value);
  void unsafe_arena_set_allocated_hlo_position_matcher(::xla::memory_space_assignment::HloPositionMatcher* value);
  ::xla::memory_space_assignment::HloPositionMatcher* unsafe_arena_release_hlo_position_matcher();

  private:
  const ::xla::memory_space_assignment::HloPositionMatcher& _internal_hlo_position_matcher() const;
  ::xla::memory_space_assignment::HloPositionMatcher* _internal_mutable_hlo_position_matcher();

  public:
  // optional .xla.memory_space_assignment.MsaSortOrderOverrideOptions override_options = 2;
  bool has_override_options() const;
  void clear_override_options() ;
  const ::xla::memory_space_assignment::MsaSortOrderOverrideOptions& override_options() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* release_override_options();
  ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* mutable_override_options();
  void set_allocated_override_options(::xla::memory_space_assignment::MsaSortOrderOverrideOptions* value);
  void unsafe_arena_set_allocated_override_options(::xla::memory_space_assignment::MsaSortOrderOverrideOptions* value);
  ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* unsafe_arena_release_override_options();

  private:
  const ::xla::memory_space_assignment::MsaSortOrderOverrideOptions& _internal_override_options() const;
  ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* _internal_mutable_override_options();

  public:
  // optional bool apply_to_cross_program_prefetches = 3;
  bool has_apply_to_cross_program_prefetches() const;
  void clear_apply_to_cross_program_prefetches() ;
  bool apply_to_cross_program_prefetches() const;
  void set_apply_to_cross_program_prefetches(bool value);

  private:
  bool _internal_apply_to_cross_program_prefetches() const;
  void _internal_set_apply_to_cross_program_prefetches(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.MsaSortOrderOverride)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MsaSortOrderOverride& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::memory_space_assignment::HloPositionMatcher* hlo_position_matcher_;
    ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* override_options_;
    bool apply_to_cross_program_prefetches_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PreferredPrefetchOverride final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.PreferredPrefetchOverride) */ {
 public:
  inline PreferredPrefetchOverride() : PreferredPrefetchOverride(nullptr) {}
  ~PreferredPrefetchOverride() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PreferredPrefetchOverride(
      ::google::protobuf::internal::ConstantInitialized);

  inline PreferredPrefetchOverride(const PreferredPrefetchOverride& from) : PreferredPrefetchOverride(nullptr, from) {}
  inline PreferredPrefetchOverride(PreferredPrefetchOverride&& from) noexcept
      : PreferredPrefetchOverride(nullptr, std::move(from)) {}
  inline PreferredPrefetchOverride& operator=(const PreferredPrefetchOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreferredPrefetchOverride& operator=(PreferredPrefetchOverride&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreferredPrefetchOverride& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreferredPrefetchOverride* internal_default_instance() {
    return reinterpret_cast<const PreferredPrefetchOverride*>(
        &_PreferredPrefetchOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PreferredPrefetchOverride& a, PreferredPrefetchOverride& b) { a.Swap(&b); }
  inline void Swap(PreferredPrefetchOverride* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreferredPrefetchOverride* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreferredPrefetchOverride* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PreferredPrefetchOverride>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PreferredPrefetchOverride& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PreferredPrefetchOverride& from) { PreferredPrefetchOverride::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PreferredPrefetchOverride* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.PreferredPrefetchOverride"; }

 protected:
  explicit PreferredPrefetchOverride(::google::protobuf::Arena* arena);
  PreferredPrefetchOverride(::google::protobuf::Arena* arena, const PreferredPrefetchOverride& from);
  PreferredPrefetchOverride(::google::protobuf::Arena* arena, PreferredPrefetchOverride&& from) noexcept
      : PreferredPrefetchOverride(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHloOperandFilterFieldNumber = 1,
    kOverrideOptionsFieldNumber = 2,
  };
  // optional .xla.memory_space_assignment.HloOperandFilter hlo_operand_filter = 1;
  bool has_hlo_operand_filter() const;
  void clear_hlo_operand_filter() ;
  const ::xla::memory_space_assignment::HloOperandFilter& hlo_operand_filter() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::HloOperandFilter* release_hlo_operand_filter();
  ::xla::memory_space_assignment::HloOperandFilter* mutable_hlo_operand_filter();
  void set_allocated_hlo_operand_filter(::xla::memory_space_assignment::HloOperandFilter* value);
  void unsafe_arena_set_allocated_hlo_operand_filter(::xla::memory_space_assignment::HloOperandFilter* value);
  ::xla::memory_space_assignment::HloOperandFilter* unsafe_arena_release_hlo_operand_filter();

  private:
  const ::xla::memory_space_assignment::HloOperandFilter& _internal_hlo_operand_filter() const;
  ::xla::memory_space_assignment::HloOperandFilter* _internal_mutable_hlo_operand_filter();

  public:
  // optional .xla.memory_space_assignment.PreferredPrefetchOverrideOptions override_options = 2;
  bool has_override_options() const;
  void clear_override_options() ;
  const ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions& override_options() const;
  PROTOBUF_NODISCARD ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* release_override_options();
  ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* mutable_override_options();
  void set_allocated_override_options(::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* value);
  void unsafe_arena_set_allocated_override_options(::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* value);
  ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* unsafe_arena_release_override_options();

  private:
  const ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions& _internal_override_options() const;
  ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* _internal_mutable_override_options();

  public:
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.PreferredPrefetchOverride)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PreferredPrefetchOverride& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::memory_space_assignment::HloOperandFilter* hlo_operand_filter_;
    ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* override_options_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MsaSortOrderOverrides final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.MsaSortOrderOverrides) */ {
 public:
  inline MsaSortOrderOverrides() : MsaSortOrderOverrides(nullptr) {}
  ~MsaSortOrderOverrides() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MsaSortOrderOverrides(
      ::google::protobuf::internal::ConstantInitialized);

  inline MsaSortOrderOverrides(const MsaSortOrderOverrides& from) : MsaSortOrderOverrides(nullptr, from) {}
  inline MsaSortOrderOverrides(MsaSortOrderOverrides&& from) noexcept
      : MsaSortOrderOverrides(nullptr, std::move(from)) {}
  inline MsaSortOrderOverrides& operator=(const MsaSortOrderOverrides& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsaSortOrderOverrides& operator=(MsaSortOrderOverrides&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsaSortOrderOverrides& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsaSortOrderOverrides* internal_default_instance() {
    return reinterpret_cast<const MsaSortOrderOverrides*>(
        &_MsaSortOrderOverrides_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(MsaSortOrderOverrides& a, MsaSortOrderOverrides& b) { a.Swap(&b); }
  inline void Swap(MsaSortOrderOverrides* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsaSortOrderOverrides* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsaSortOrderOverrides* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MsaSortOrderOverrides>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MsaSortOrderOverrides& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MsaSortOrderOverrides& from) { MsaSortOrderOverrides::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MsaSortOrderOverrides* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.MsaSortOrderOverrides"; }

 protected:
  explicit MsaSortOrderOverrides(::google::protobuf::Arena* arena);
  MsaSortOrderOverrides(::google::protobuf::Arena* arena, const MsaSortOrderOverrides& from);
  MsaSortOrderOverrides(::google::protobuf::Arena* arena, MsaSortOrderOverrides&& from) noexcept
      : MsaSortOrderOverrides(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOverridesFieldNumber = 1,
  };
  // repeated .xla.memory_space_assignment.MsaSortOrderOverride overrides = 1;
  int overrides_size() const;
  private:
  int _internal_overrides_size() const;

  public:
  void clear_overrides() ;
  ::xla::memory_space_assignment::MsaSortOrderOverride* mutable_overrides(int index);
  ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::MsaSortOrderOverride>* mutable_overrides();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::MsaSortOrderOverride>& _internal_overrides() const;
  ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::MsaSortOrderOverride>* _internal_mutable_overrides();
  public:
  const ::xla::memory_space_assignment::MsaSortOrderOverride& overrides(int index) const;
  ::xla::memory_space_assignment::MsaSortOrderOverride* add_overrides();
  const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::MsaSortOrderOverride>& overrides() const;
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.MsaSortOrderOverrides)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MsaSortOrderOverrides& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::memory_space_assignment::MsaSortOrderOverride > overrides_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PreferredPrefetchOverrides final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.memory_space_assignment.PreferredPrefetchOverrides) */ {
 public:
  inline PreferredPrefetchOverrides() : PreferredPrefetchOverrides(nullptr) {}
  ~PreferredPrefetchOverrides() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PreferredPrefetchOverrides(
      ::google::protobuf::internal::ConstantInitialized);

  inline PreferredPrefetchOverrides(const PreferredPrefetchOverrides& from) : PreferredPrefetchOverrides(nullptr, from) {}
  inline PreferredPrefetchOverrides(PreferredPrefetchOverrides&& from) noexcept
      : PreferredPrefetchOverrides(nullptr, std::move(from)) {}
  inline PreferredPrefetchOverrides& operator=(const PreferredPrefetchOverrides& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreferredPrefetchOverrides& operator=(PreferredPrefetchOverrides&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreferredPrefetchOverrides& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreferredPrefetchOverrides* internal_default_instance() {
    return reinterpret_cast<const PreferredPrefetchOverrides*>(
        &_PreferredPrefetchOverrides_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PreferredPrefetchOverrides& a, PreferredPrefetchOverrides& b) { a.Swap(&b); }
  inline void Swap(PreferredPrefetchOverrides* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreferredPrefetchOverrides* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreferredPrefetchOverrides* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PreferredPrefetchOverrides>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PreferredPrefetchOverrides& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PreferredPrefetchOverrides& from) { PreferredPrefetchOverrides::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PreferredPrefetchOverrides* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "xla.memory_space_assignment.PreferredPrefetchOverrides"; }

 protected:
  explicit PreferredPrefetchOverrides(::google::protobuf::Arena* arena);
  PreferredPrefetchOverrides(::google::protobuf::Arena* arena, const PreferredPrefetchOverrides& from);
  PreferredPrefetchOverrides(::google::protobuf::Arena* arena, PreferredPrefetchOverrides&& from) noexcept
      : PreferredPrefetchOverrides(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOverridesFieldNumber = 1,
  };
  // repeated .xla.memory_space_assignment.PreferredPrefetchOverride overrides = 1;
  int overrides_size() const;
  private:
  int _internal_overrides_size() const;

  public:
  void clear_overrides() ;
  ::xla::memory_space_assignment::PreferredPrefetchOverride* mutable_overrides(int index);
  ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::PreferredPrefetchOverride>* mutable_overrides();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::PreferredPrefetchOverride>& _internal_overrides() const;
  ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::PreferredPrefetchOverride>* _internal_mutable_overrides();
  public:
  const ::xla::memory_space_assignment::PreferredPrefetchOverride& overrides(int index) const;
  ::xla::memory_space_assignment::PreferredPrefetchOverride* add_overrides();
  const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::PreferredPrefetchOverride>& overrides() const;
  // @@protoc_insertion_point(class_scope:xla.memory_space_assignment.PreferredPrefetchOverrides)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PreferredPrefetchOverrides& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::memory_space_assignment::PreferredPrefetchOverride > overrides_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SlicedPrefetchOptions

// uint32 max_slices = 1;
inline void SlicedPrefetchOptions::clear_max_slices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_slices_ = 0u;
}
inline ::uint32_t SlicedPrefetchOptions::max_slices() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.SlicedPrefetchOptions.max_slices)
  return _internal_max_slices();
}
inline void SlicedPrefetchOptions::set_max_slices(::uint32_t value) {
  _internal_set_max_slices(value);
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.SlicedPrefetchOptions.max_slices)
}
inline ::uint32_t SlicedPrefetchOptions::_internal_max_slices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_slices_;
}
inline void SlicedPrefetchOptions::_internal_set_max_slices(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_slices_ = value;
}

// uint64 min_bytes = 2;
inline void SlicedPrefetchOptions::clear_min_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t SlicedPrefetchOptions::min_bytes() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.SlicedPrefetchOptions.min_bytes)
  return _internal_min_bytes();
}
inline void SlicedPrefetchOptions::set_min_bytes(::uint64_t value) {
  _internal_set_min_bytes(value);
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.SlicedPrefetchOptions.min_bytes)
}
inline ::uint64_t SlicedPrefetchOptions::_internal_min_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_bytes_;
}
inline void SlicedPrefetchOptions::_internal_set_min_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_bytes_ = value;
}

// bool fail_on_non_alignment_boundary_slice_proposal = 3;
inline void SlicedPrefetchOptions::clear_fail_on_non_alignment_boundary_slice_proposal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fail_on_non_alignment_boundary_slice_proposal_ = false;
}
inline bool SlicedPrefetchOptions::fail_on_non_alignment_boundary_slice_proposal() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.SlicedPrefetchOptions.fail_on_non_alignment_boundary_slice_proposal)
  return _internal_fail_on_non_alignment_boundary_slice_proposal();
}
inline void SlicedPrefetchOptions::set_fail_on_non_alignment_boundary_slice_proposal(bool value) {
  _internal_set_fail_on_non_alignment_boundary_slice_proposal(value);
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.SlicedPrefetchOptions.fail_on_non_alignment_boundary_slice_proposal)
}
inline bool SlicedPrefetchOptions::_internal_fail_on_non_alignment_boundary_slice_proposal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fail_on_non_alignment_boundary_slice_proposal_;
}
inline void SlicedPrefetchOptions::_internal_set_fail_on_non_alignment_boundary_slice_proposal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fail_on_non_alignment_boundary_slice_proposal_ = value;
}

// uint32 all_slice_time_permutations_threshold = 4;
inline void SlicedPrefetchOptions::clear_all_slice_time_permutations_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_slice_time_permutations_threshold_ = 0u;
}
inline ::uint32_t SlicedPrefetchOptions::all_slice_time_permutations_threshold() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.SlicedPrefetchOptions.all_slice_time_permutations_threshold)
  return _internal_all_slice_time_permutations_threshold();
}
inline void SlicedPrefetchOptions::set_all_slice_time_permutations_threshold(::uint32_t value) {
  _internal_set_all_slice_time_permutations_threshold(value);
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.SlicedPrefetchOptions.all_slice_time_permutations_threshold)
}
inline ::uint32_t SlicedPrefetchOptions::_internal_all_slice_time_permutations_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.all_slice_time_permutations_threshold_;
}
inline void SlicedPrefetchOptions::_internal_set_all_slice_time_permutations_threshold(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_slice_time_permutations_threshold_ = value;
}

// uint64 preferred_slice_size = 5;
inline void SlicedPrefetchOptions::clear_preferred_slice_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preferred_slice_size_ = ::uint64_t{0u};
}
inline ::uint64_t SlicedPrefetchOptions::preferred_slice_size() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.SlicedPrefetchOptions.preferred_slice_size)
  return _internal_preferred_slice_size();
}
inline void SlicedPrefetchOptions::set_preferred_slice_size(::uint64_t value) {
  _internal_set_preferred_slice_size(value);
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.SlicedPrefetchOptions.preferred_slice_size)
}
inline ::uint64_t SlicedPrefetchOptions::_internal_preferred_slice_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.preferred_slice_size_;
}
inline void SlicedPrefetchOptions::_internal_set_preferred_slice_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preferred_slice_size_ = value;
}

// -------------------------------------------------------------------

// WindowPrefetchDetail_WindowDetail

// int64 operand = 1;
inline void WindowPrefetchDetail_WindowDetail::clear_operand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operand_ = ::int64_t{0};
}
inline ::int64_t WindowPrefetchDetail_WindowDetail::operand() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail.operand)
  return _internal_operand();
}
inline void WindowPrefetchDetail_WindowDetail::set_operand(::int64_t value) {
  _internal_set_operand(value);
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail.operand)
}
inline ::int64_t WindowPrefetchDetail_WindowDetail::_internal_operand() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operand_;
}
inline void WindowPrefetchDetail_WindowDetail::_internal_set_operand(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operand_ = value;
}

// int64 size = 2;
inline void WindowPrefetchDetail_WindowDetail::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = ::int64_t{0};
}
inline ::int64_t WindowPrefetchDetail_WindowDetail::size() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail.size)
  return _internal_size();
}
inline void WindowPrefetchDetail_WindowDetail::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail.size)
}
inline ::int64_t WindowPrefetchDetail_WindowDetail::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void WindowPrefetchDetail_WindowDetail::_internal_set_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// WindowPrefetchDetail

// repeated .xla.memory_space_assignment.WindowPrefetchDetail.WindowDetail windows = 1;
inline int WindowPrefetchDetail::_internal_windows_size() const {
  return _internal_windows().size();
}
inline int WindowPrefetchDetail::windows_size() const {
  return _internal_windows_size();
}
inline void WindowPrefetchDetail::clear_windows() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.windows_.Clear();
}
inline ::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail* WindowPrefetchDetail::mutable_windows(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.WindowPrefetchDetail.windows)
  return _internal_mutable_windows()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail>* WindowPrefetchDetail::mutable_windows()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.memory_space_assignment.WindowPrefetchDetail.windows)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_windows();
}
inline const ::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail& WindowPrefetchDetail::windows(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.WindowPrefetchDetail.windows)
  return _internal_windows().Get(index);
}
inline ::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail* WindowPrefetchDetail::add_windows() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail* _add = _internal_mutable_windows()->Add();
  // @@protoc_insertion_point(field_add:xla.memory_space_assignment.WindowPrefetchDetail.windows)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail>& WindowPrefetchDetail::windows() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.memory_space_assignment.WindowPrefetchDetail.windows)
  return _internal_windows();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail>&
WindowPrefetchDetail::_internal_windows() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.windows_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::WindowPrefetchDetail_WindowDetail>*
WindowPrefetchDetail::_internal_mutable_windows() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.windows_;
}

// -------------------------------------------------------------------

// MemoryBoundLoopOptimizerOptions

// optional bool enabled = 1;
inline bool MemoryBoundLoopOptimizerOptions::has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MemoryBoundLoopOptimizerOptions::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MemoryBoundLoopOptimizerOptions::enabled() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions.enabled)
  return _internal_enabled();
}
inline void MemoryBoundLoopOptimizerOptions::set_enabled(bool value) {
  _internal_set_enabled(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions.enabled)
}
inline bool MemoryBoundLoopOptimizerOptions::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void MemoryBoundLoopOptimizerOptions::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// optional float desired_copy_ratio = 2;
inline bool MemoryBoundLoopOptimizerOptions::has_desired_copy_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MemoryBoundLoopOptimizerOptions::clear_desired_copy_ratio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.desired_copy_ratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float MemoryBoundLoopOptimizerOptions::desired_copy_ratio() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions.desired_copy_ratio)
  return _internal_desired_copy_ratio();
}
inline void MemoryBoundLoopOptimizerOptions::set_desired_copy_ratio(float value) {
  _internal_set_desired_copy_ratio(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions.desired_copy_ratio)
}
inline float MemoryBoundLoopOptimizerOptions::_internal_desired_copy_ratio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.desired_copy_ratio_;
}
inline void MemoryBoundLoopOptimizerOptions::_internal_set_desired_copy_ratio(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.desired_copy_ratio_ = value;
}

// optional bool allow_unsatisfied_fully_pipelined_prefetch = 3;
inline bool MemoryBoundLoopOptimizerOptions::has_allow_unsatisfied_fully_pipelined_prefetch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MemoryBoundLoopOptimizerOptions::clear_allow_unsatisfied_fully_pipelined_prefetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_unsatisfied_fully_pipelined_prefetch_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MemoryBoundLoopOptimizerOptions::allow_unsatisfied_fully_pipelined_prefetch() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions.allow_unsatisfied_fully_pipelined_prefetch)
  return _internal_allow_unsatisfied_fully_pipelined_prefetch();
}
inline void MemoryBoundLoopOptimizerOptions::set_allow_unsatisfied_fully_pipelined_prefetch(bool value) {
  _internal_set_allow_unsatisfied_fully_pipelined_prefetch(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions.allow_unsatisfied_fully_pipelined_prefetch)
}
inline bool MemoryBoundLoopOptimizerOptions::_internal_allow_unsatisfied_fully_pipelined_prefetch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.allow_unsatisfied_fully_pipelined_prefetch_;
}
inline void MemoryBoundLoopOptimizerOptions::_internal_set_allow_unsatisfied_fully_pipelined_prefetch(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_unsatisfied_fully_pipelined_prefetch_ = value;
}

// optional float min_num_iterations = 4;
inline bool MemoryBoundLoopOptimizerOptions::has_min_num_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MemoryBoundLoopOptimizerOptions::clear_min_num_iterations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_num_iterations_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MemoryBoundLoopOptimizerOptions::min_num_iterations() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions.min_num_iterations)
  return _internal_min_num_iterations();
}
inline void MemoryBoundLoopOptimizerOptions::set_min_num_iterations(float value) {
  _internal_set_min_num_iterations(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.MemoryBoundLoopOptimizerOptions.min_num_iterations)
}
inline float MemoryBoundLoopOptimizerOptions::_internal_min_num_iterations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_num_iterations_;
}
inline void MemoryBoundLoopOptimizerOptions::_internal_set_min_num_iterations(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_num_iterations_ = value;
}

// -------------------------------------------------------------------

// TupleShapeIndex

// repeated int64 index = 1;
inline int TupleShapeIndex::_internal_index_size() const {
  return _internal_index().size();
}
inline int TupleShapeIndex::index_size() const {
  return _internal_index_size();
}
inline void TupleShapeIndex::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_.Clear();
}
inline ::int64_t TupleShapeIndex::index(int index) const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.TupleShapeIndex.index)
  return _internal_index().Get(index);
}
inline void TupleShapeIndex::set_index(int index, ::int64_t value) {
  _internal_mutable_index()->Set(index, value);
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.TupleShapeIndex.index)
}
inline void TupleShapeIndex::add_index(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_index()->Add(value);
  // @@protoc_insertion_point(field_add:xla.memory_space_assignment.TupleShapeIndex.index)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TupleShapeIndex::index() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.memory_space_assignment.TupleShapeIndex.index)
  return _internal_index();
}
inline ::google::protobuf::RepeatedField<::int64_t>* TupleShapeIndex::mutable_index()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.memory_space_assignment.TupleShapeIndex.index)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_index();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
TupleShapeIndex::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* TupleShapeIndex::_internal_mutable_index() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.index_;
}

// -------------------------------------------------------------------

// HloOperandFilter

// optional string instruction_name_regex = 1;
inline bool HloOperandFilter::has_instruction_name_regex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HloOperandFilter::clear_instruction_name_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instruction_name_regex_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HloOperandFilter::instruction_name_regex() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloOperandFilter.instruction_name_regex)
  return _internal_instruction_name_regex();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HloOperandFilter::set_instruction_name_regex(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instruction_name_regex_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloOperandFilter.instruction_name_regex)
}
inline std::string* HloOperandFilter::mutable_instruction_name_regex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_instruction_name_regex();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.HloOperandFilter.instruction_name_regex)
  return _s;
}
inline const std::string& HloOperandFilter::_internal_instruction_name_regex() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.instruction_name_regex_.Get();
}
inline void HloOperandFilter::_internal_set_instruction_name_regex(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instruction_name_regex_.Set(value, GetArena());
}
inline std::string* HloOperandFilter::_internal_mutable_instruction_name_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instruction_name_regex_.Mutable( GetArena());
}
inline std::string* HloOperandFilter::release_instruction_name_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.HloOperandFilter.instruction_name_regex)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.instruction_name_regex_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.instruction_name_regex_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void HloOperandFilter::set_allocated_instruction_name_regex(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instruction_name_regex_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.instruction_name_regex_.IsDefault()) {
          _impl_.instruction_name_regex_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.HloOperandFilter.instruction_name_regex)
}

// optional int64 operand_number = 2;
inline bool HloOperandFilter::has_operand_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void HloOperandFilter::clear_operand_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operand_number_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t HloOperandFilter::operand_number() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloOperandFilter.operand_number)
  return _internal_operand_number();
}
inline void HloOperandFilter::set_operand_number(::int64_t value) {
  _internal_set_operand_number(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloOperandFilter.operand_number)
}
inline ::int64_t HloOperandFilter::_internal_operand_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operand_number_;
}
inline void HloOperandFilter::_internal_set_operand_number(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operand_number_ = value;
}

// optional int64 size_gte = 3;
inline bool HloOperandFilter::has_size_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void HloOperandFilter::clear_size_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_gte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t HloOperandFilter::size_gte() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloOperandFilter.size_gte)
  return _internal_size_gte();
}
inline void HloOperandFilter::set_size_gte(::int64_t value) {
  _internal_set_size_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloOperandFilter.size_gte)
}
inline ::int64_t HloOperandFilter::_internal_size_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_gte_;
}
inline void HloOperandFilter::_internal_set_size_gte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_gte_ = value;
}

// optional int64 size_lte = 4;
inline bool HloOperandFilter::has_size_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void HloOperandFilter::clear_size_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_lte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t HloOperandFilter::size_lte() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloOperandFilter.size_lte)
  return _internal_size_lte();
}
inline void HloOperandFilter::set_size_lte(::int64_t value) {
  _internal_set_size_lte(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloOperandFilter.size_lte)
}
inline ::int64_t HloOperandFilter::_internal_size_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_lte_;
}
inline void HloOperandFilter::_internal_set_size_lte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_lte_ = value;
}

// optional .xla.memory_space_assignment.TupleShapeIndex tuple_index = 5;
inline bool HloOperandFilter::has_tuple_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tuple_index_ != nullptr);
  return value;
}
inline void HloOperandFilter::clear_tuple_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tuple_index_ != nullptr) _impl_.tuple_index_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xla::memory_space_assignment::TupleShapeIndex& HloOperandFilter::_internal_tuple_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::memory_space_assignment::TupleShapeIndex* p = _impl_.tuple_index_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::memory_space_assignment::TupleShapeIndex&>(::xla::memory_space_assignment::_TupleShapeIndex_default_instance_);
}
inline const ::xla::memory_space_assignment::TupleShapeIndex& HloOperandFilter::tuple_index() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloOperandFilter.tuple_index)
  return _internal_tuple_index();
}
inline void HloOperandFilter::unsafe_arena_set_allocated_tuple_index(::xla::memory_space_assignment::TupleShapeIndex* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tuple_index_);
  }
  _impl_.tuple_index_ = reinterpret_cast<::xla::memory_space_assignment::TupleShapeIndex*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.HloOperandFilter.tuple_index)
}
inline ::xla::memory_space_assignment::TupleShapeIndex* HloOperandFilter::release_tuple_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::memory_space_assignment::TupleShapeIndex* released = _impl_.tuple_index_;
  _impl_.tuple_index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::memory_space_assignment::TupleShapeIndex* HloOperandFilter::unsafe_arena_release_tuple_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.HloOperandFilter.tuple_index)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::memory_space_assignment::TupleShapeIndex* temp = _impl_.tuple_index_;
  _impl_.tuple_index_ = nullptr;
  return temp;
}
inline ::xla::memory_space_assignment::TupleShapeIndex* HloOperandFilter::_internal_mutable_tuple_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tuple_index_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::TupleShapeIndex>(GetArena());
    _impl_.tuple_index_ = reinterpret_cast<::xla::memory_space_assignment::TupleShapeIndex*>(p);
  }
  return _impl_.tuple_index_;
}
inline ::xla::memory_space_assignment::TupleShapeIndex* HloOperandFilter::mutable_tuple_index() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::memory_space_assignment::TupleShapeIndex* _msg = _internal_mutable_tuple_index();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.HloOperandFilter.tuple_index)
  return _msg;
}
inline void HloOperandFilter::set_allocated_tuple_index(::xla::memory_space_assignment::TupleShapeIndex* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tuple_index_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.tuple_index_ = reinterpret_cast<::xla::memory_space_assignment::TupleShapeIndex*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.HloOperandFilter.tuple_index)
}

// optional string instruction_regex = 6;
inline bool HloOperandFilter::has_instruction_regex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HloOperandFilter::clear_instruction_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instruction_regex_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HloOperandFilter::instruction_regex() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloOperandFilter.instruction_regex)
  return _internal_instruction_regex();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HloOperandFilter::set_instruction_regex(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.instruction_regex_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloOperandFilter.instruction_regex)
}
inline std::string* HloOperandFilter::mutable_instruction_regex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_instruction_regex();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.HloOperandFilter.instruction_regex)
  return _s;
}
inline const std::string& HloOperandFilter::_internal_instruction_regex() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.instruction_regex_.Get();
}
inline void HloOperandFilter::_internal_set_instruction_regex(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.instruction_regex_.Set(value, GetArena());
}
inline std::string* HloOperandFilter::_internal_mutable_instruction_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.instruction_regex_.Mutable( GetArena());
}
inline std::string* HloOperandFilter::release_instruction_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.HloOperandFilter.instruction_regex)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.instruction_regex_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.instruction_regex_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void HloOperandFilter::set_allocated_instruction_regex(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instruction_regex_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.instruction_regex_.IsDefault()) {
          _impl_.instruction_regex_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.HloOperandFilter.instruction_regex)
}

// -------------------------------------------------------------------

// PreferredPrefetchOverrideOptions

// float prefetch_eagerness = 1;
inline bool PreferredPrefetchOverrideOptions::has_prefetch_eagerness() const {
  return options_case() == kPrefetchEagerness;
}
inline void PreferredPrefetchOverrideOptions::set_has_prefetch_eagerness() {
  _impl_._oneof_case_[0] = kPrefetchEagerness;
}
inline void PreferredPrefetchOverrideOptions::clear_prefetch_eagerness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kPrefetchEagerness) {
    _impl_.options_.prefetch_eagerness_ = 0;
    clear_has_options();
  }
}
inline float PreferredPrefetchOverrideOptions::prefetch_eagerness() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.prefetch_eagerness)
  return _internal_prefetch_eagerness();
}
inline void PreferredPrefetchOverrideOptions::set_prefetch_eagerness(float value) {
  if (options_case() != kPrefetchEagerness) {
    clear_options();
    set_has_prefetch_eagerness();
  }
  _impl_.options_.prefetch_eagerness_ = value;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.prefetch_eagerness)
}
inline float PreferredPrefetchOverrideOptions::_internal_prefetch_eagerness() const {
  if (options_case() == kPrefetchEagerness) {
    return _impl_.options_.prefetch_eagerness_;
  }
  return 0;
}

// .xla.memory_space_assignment.HloPositionMatcher after_instruction = 4;
inline bool PreferredPrefetchOverrideOptions::has_after_instruction() const {
  return options_case() == kAfterInstruction;
}
inline bool PreferredPrefetchOverrideOptions::_internal_has_after_instruction() const {
  return options_case() == kAfterInstruction;
}
inline void PreferredPrefetchOverrideOptions::set_has_after_instruction() {
  _impl_._oneof_case_[0] = kAfterInstruction;
}
inline void PreferredPrefetchOverrideOptions::clear_after_instruction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kAfterInstruction) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.after_instruction_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.after_instruction_);
    }
    clear_has_options();
  }
}
inline ::xla::memory_space_assignment::HloPositionMatcher* PreferredPrefetchOverrideOptions::release_after_instruction() {
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.after_instruction)
  if (options_case() == kAfterInstruction) {
    clear_has_options();
    auto* temp = _impl_.options_.after_instruction_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.after_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::memory_space_assignment::HloPositionMatcher& PreferredPrefetchOverrideOptions::_internal_after_instruction() const {
  return options_case() == kAfterInstruction ? *_impl_.options_.after_instruction_ : reinterpret_cast<::xla::memory_space_assignment::HloPositionMatcher&>(::xla::memory_space_assignment::_HloPositionMatcher_default_instance_);
}
inline const ::xla::memory_space_assignment::HloPositionMatcher& PreferredPrefetchOverrideOptions::after_instruction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.after_instruction)
  return _internal_after_instruction();
}
inline ::xla::memory_space_assignment::HloPositionMatcher* PreferredPrefetchOverrideOptions::unsafe_arena_release_after_instruction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.after_instruction)
  if (options_case() == kAfterInstruction) {
    clear_has_options();
    auto* temp = _impl_.options_.after_instruction_;
    _impl_.options_.after_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PreferredPrefetchOverrideOptions::unsafe_arena_set_allocated_after_instruction(::xla::memory_space_assignment::HloPositionMatcher* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_after_instruction();
    _impl_.options_.after_instruction_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.after_instruction)
}
inline ::xla::memory_space_assignment::HloPositionMatcher* PreferredPrefetchOverrideOptions::_internal_mutable_after_instruction() {
  if (options_case() != kAfterInstruction) {
    clear_options();
    set_has_after_instruction();
    _impl_.options_.after_instruction_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::HloPositionMatcher>(GetArena());
  }
  return _impl_.options_.after_instruction_;
}
inline ::xla::memory_space_assignment::HloPositionMatcher* PreferredPrefetchOverrideOptions::mutable_after_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::memory_space_assignment::HloPositionMatcher* _msg = _internal_mutable_after_instruction();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.after_instruction)
  return _msg;
}

// .xla.memory_space_assignment.HloPositionMatcher before_instruction = 5;
inline bool PreferredPrefetchOverrideOptions::has_before_instruction() const {
  return options_case() == kBeforeInstruction;
}
inline bool PreferredPrefetchOverrideOptions::_internal_has_before_instruction() const {
  return options_case() == kBeforeInstruction;
}
inline void PreferredPrefetchOverrideOptions::set_has_before_instruction() {
  _impl_._oneof_case_[0] = kBeforeInstruction;
}
inline void PreferredPrefetchOverrideOptions::clear_before_instruction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kBeforeInstruction) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.before_instruction_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.before_instruction_);
    }
    clear_has_options();
  }
}
inline ::xla::memory_space_assignment::HloPositionMatcher* PreferredPrefetchOverrideOptions::release_before_instruction() {
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.before_instruction)
  if (options_case() == kBeforeInstruction) {
    clear_has_options();
    auto* temp = _impl_.options_.before_instruction_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.before_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::memory_space_assignment::HloPositionMatcher& PreferredPrefetchOverrideOptions::_internal_before_instruction() const {
  return options_case() == kBeforeInstruction ? *_impl_.options_.before_instruction_ : reinterpret_cast<::xla::memory_space_assignment::HloPositionMatcher&>(::xla::memory_space_assignment::_HloPositionMatcher_default_instance_);
}
inline const ::xla::memory_space_assignment::HloPositionMatcher& PreferredPrefetchOverrideOptions::before_instruction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.before_instruction)
  return _internal_before_instruction();
}
inline ::xla::memory_space_assignment::HloPositionMatcher* PreferredPrefetchOverrideOptions::unsafe_arena_release_before_instruction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.before_instruction)
  if (options_case() == kBeforeInstruction) {
    clear_has_options();
    auto* temp = _impl_.options_.before_instruction_;
    _impl_.options_.before_instruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PreferredPrefetchOverrideOptions::unsafe_arena_set_allocated_before_instruction(::xla::memory_space_assignment::HloPositionMatcher* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_before_instruction();
    _impl_.options_.before_instruction_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.before_instruction)
}
inline ::xla::memory_space_assignment::HloPositionMatcher* PreferredPrefetchOverrideOptions::_internal_mutable_before_instruction() {
  if (options_case() != kBeforeInstruction) {
    clear_options();
    set_has_before_instruction();
    _impl_.options_.before_instruction_ =
        ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::HloPositionMatcher>(GetArena());
  }
  return _impl_.options_.before_instruction_;
}
inline ::xla::memory_space_assignment::HloPositionMatcher* PreferredPrefetchOverrideOptions::mutable_before_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::memory_space_assignment::HloPositionMatcher* _msg = _internal_mutable_before_instruction();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.PreferredPrefetchOverrideOptions.before_instruction)
  return _msg;
}

inline bool PreferredPrefetchOverrideOptions::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void PreferredPrefetchOverrideOptions::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline PreferredPrefetchOverrideOptions::OptionsCase PreferredPrefetchOverrideOptions::options_case() const {
  return PreferredPrefetchOverrideOptions::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PreferredPrefetchOverride

// optional .xla.memory_space_assignment.HloOperandFilter hlo_operand_filter = 1;
inline bool PreferredPrefetchOverride::has_hlo_operand_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hlo_operand_filter_ != nullptr);
  return value;
}
inline void PreferredPrefetchOverride::clear_hlo_operand_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hlo_operand_filter_ != nullptr) _impl_.hlo_operand_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::memory_space_assignment::HloOperandFilter& PreferredPrefetchOverride::_internal_hlo_operand_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::memory_space_assignment::HloOperandFilter* p = _impl_.hlo_operand_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::memory_space_assignment::HloOperandFilter&>(::xla::memory_space_assignment::_HloOperandFilter_default_instance_);
}
inline const ::xla::memory_space_assignment::HloOperandFilter& PreferredPrefetchOverride::hlo_operand_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.PreferredPrefetchOverride.hlo_operand_filter)
  return _internal_hlo_operand_filter();
}
inline void PreferredPrefetchOverride::unsafe_arena_set_allocated_hlo_operand_filter(::xla::memory_space_assignment::HloOperandFilter* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hlo_operand_filter_);
  }
  _impl_.hlo_operand_filter_ = reinterpret_cast<::xla::memory_space_assignment::HloOperandFilter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.PreferredPrefetchOverride.hlo_operand_filter)
}
inline ::xla::memory_space_assignment::HloOperandFilter* PreferredPrefetchOverride::release_hlo_operand_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::memory_space_assignment::HloOperandFilter* released = _impl_.hlo_operand_filter_;
  _impl_.hlo_operand_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::memory_space_assignment::HloOperandFilter* PreferredPrefetchOverride::unsafe_arena_release_hlo_operand_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.PreferredPrefetchOverride.hlo_operand_filter)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::memory_space_assignment::HloOperandFilter* temp = _impl_.hlo_operand_filter_;
  _impl_.hlo_operand_filter_ = nullptr;
  return temp;
}
inline ::xla::memory_space_assignment::HloOperandFilter* PreferredPrefetchOverride::_internal_mutable_hlo_operand_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hlo_operand_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::HloOperandFilter>(GetArena());
    _impl_.hlo_operand_filter_ = reinterpret_cast<::xla::memory_space_assignment::HloOperandFilter*>(p);
  }
  return _impl_.hlo_operand_filter_;
}
inline ::xla::memory_space_assignment::HloOperandFilter* PreferredPrefetchOverride::mutable_hlo_operand_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::memory_space_assignment::HloOperandFilter* _msg = _internal_mutable_hlo_operand_filter();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.PreferredPrefetchOverride.hlo_operand_filter)
  return _msg;
}
inline void PreferredPrefetchOverride::set_allocated_hlo_operand_filter(::xla::memory_space_assignment::HloOperandFilter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hlo_operand_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hlo_operand_filter_ = reinterpret_cast<::xla::memory_space_assignment::HloOperandFilter*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.PreferredPrefetchOverride.hlo_operand_filter)
}

// optional .xla.memory_space_assignment.PreferredPrefetchOverrideOptions override_options = 2;
inline bool PreferredPrefetchOverride::has_override_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.override_options_ != nullptr);
  return value;
}
inline void PreferredPrefetchOverride::clear_override_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.override_options_ != nullptr) _impl_.override_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions& PreferredPrefetchOverride::_internal_override_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* p = _impl_.override_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions&>(::xla::memory_space_assignment::_PreferredPrefetchOverrideOptions_default_instance_);
}
inline const ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions& PreferredPrefetchOverride::override_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.PreferredPrefetchOverride.override_options)
  return _internal_override_options();
}
inline void PreferredPrefetchOverride::unsafe_arena_set_allocated_override_options(::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.override_options_);
  }
  _impl_.override_options_ = reinterpret_cast<::xla::memory_space_assignment::PreferredPrefetchOverrideOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.PreferredPrefetchOverride.override_options)
}
inline ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* PreferredPrefetchOverride::release_override_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* released = _impl_.override_options_;
  _impl_.override_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* PreferredPrefetchOverride::unsafe_arena_release_override_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.PreferredPrefetchOverride.override_options)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* temp = _impl_.override_options_;
  _impl_.override_options_ = nullptr;
  return temp;
}
inline ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* PreferredPrefetchOverride::_internal_mutable_override_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.override_options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::PreferredPrefetchOverrideOptions>(GetArena());
    _impl_.override_options_ = reinterpret_cast<::xla::memory_space_assignment::PreferredPrefetchOverrideOptions*>(p);
  }
  return _impl_.override_options_;
}
inline ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* PreferredPrefetchOverride::mutable_override_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* _msg = _internal_mutable_override_options();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.PreferredPrefetchOverride.override_options)
  return _msg;
}
inline void PreferredPrefetchOverride::set_allocated_override_options(::xla::memory_space_assignment::PreferredPrefetchOverrideOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.override_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.override_options_ = reinterpret_cast<::xla::memory_space_assignment::PreferredPrefetchOverrideOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.PreferredPrefetchOverride.override_options)
}

// -------------------------------------------------------------------

// PreferredPrefetchOverrides

// repeated .xla.memory_space_assignment.PreferredPrefetchOverride overrides = 1;
inline int PreferredPrefetchOverrides::_internal_overrides_size() const {
  return _internal_overrides().size();
}
inline int PreferredPrefetchOverrides::overrides_size() const {
  return _internal_overrides_size();
}
inline void PreferredPrefetchOverrides::clear_overrides() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overrides_.Clear();
}
inline ::xla::memory_space_assignment::PreferredPrefetchOverride* PreferredPrefetchOverrides::mutable_overrides(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.PreferredPrefetchOverrides.overrides)
  return _internal_mutable_overrides()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::PreferredPrefetchOverride>* PreferredPrefetchOverrides::mutable_overrides()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.memory_space_assignment.PreferredPrefetchOverrides.overrides)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_overrides();
}
inline const ::xla::memory_space_assignment::PreferredPrefetchOverride& PreferredPrefetchOverrides::overrides(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.PreferredPrefetchOverrides.overrides)
  return _internal_overrides().Get(index);
}
inline ::xla::memory_space_assignment::PreferredPrefetchOverride* PreferredPrefetchOverrides::add_overrides() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::memory_space_assignment::PreferredPrefetchOverride* _add = _internal_mutable_overrides()->Add();
  // @@protoc_insertion_point(field_add:xla.memory_space_assignment.PreferredPrefetchOverrides.overrides)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::PreferredPrefetchOverride>& PreferredPrefetchOverrides::overrides() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.memory_space_assignment.PreferredPrefetchOverrides.overrides)
  return _internal_overrides();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::PreferredPrefetchOverride>&
PreferredPrefetchOverrides::_internal_overrides() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.overrides_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::PreferredPrefetchOverride>*
PreferredPrefetchOverrides::_internal_mutable_overrides() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.overrides_;
}

// -------------------------------------------------------------------

// HloPositionMatcher

// optional string instruction_regex = 1;
inline bool HloPositionMatcher::has_instruction_regex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HloPositionMatcher::clear_instruction_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instruction_regex_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HloPositionMatcher::instruction_regex() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloPositionMatcher.instruction_regex)
  return _internal_instruction_regex();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HloPositionMatcher::set_instruction_regex(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instruction_regex_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloPositionMatcher.instruction_regex)
}
inline std::string* HloPositionMatcher::mutable_instruction_regex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_instruction_regex();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.HloPositionMatcher.instruction_regex)
  return _s;
}
inline const std::string& HloPositionMatcher::_internal_instruction_regex() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.instruction_regex_.Get();
}
inline void HloPositionMatcher::_internal_set_instruction_regex(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instruction_regex_.Set(value, GetArena());
}
inline std::string* HloPositionMatcher::_internal_mutable_instruction_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instruction_regex_.Mutable( GetArena());
}
inline std::string* HloPositionMatcher::release_instruction_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.HloPositionMatcher.instruction_regex)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.instruction_regex_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.instruction_regex_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void HloPositionMatcher::set_allocated_instruction_regex(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instruction_regex_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.instruction_regex_.IsDefault()) {
          _impl_.instruction_regex_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.HloPositionMatcher.instruction_regex)
}

// optional string instruction_name_regex = 2;
inline bool HloPositionMatcher::has_instruction_name_regex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HloPositionMatcher::clear_instruction_name_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instruction_name_regex_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HloPositionMatcher::instruction_name_regex() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloPositionMatcher.instruction_name_regex)
  return _internal_instruction_name_regex();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HloPositionMatcher::set_instruction_name_regex(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.instruction_name_regex_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloPositionMatcher.instruction_name_regex)
}
inline std::string* HloPositionMatcher::mutable_instruction_name_regex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_instruction_name_regex();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.HloPositionMatcher.instruction_name_regex)
  return _s;
}
inline const std::string& HloPositionMatcher::_internal_instruction_name_regex() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.instruction_name_regex_.Get();
}
inline void HloPositionMatcher::_internal_set_instruction_name_regex(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.instruction_name_regex_.Set(value, GetArena());
}
inline std::string* HloPositionMatcher::_internal_mutable_instruction_name_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.instruction_name_regex_.Mutable( GetArena());
}
inline std::string* HloPositionMatcher::release_instruction_name_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.HloPositionMatcher.instruction_name_regex)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.instruction_name_regex_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.instruction_name_regex_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void HloPositionMatcher::set_allocated_instruction_name_regex(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.instruction_name_regex_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.instruction_name_regex_.IsDefault()) {
          _impl_.instruction_name_regex_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.HloPositionMatcher.instruction_name_regex)
}

// optional .xla.memory_space_assignment.TupleShapeIndex tuple_index = 3;
inline bool HloPositionMatcher::has_tuple_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tuple_index_ != nullptr);
  return value;
}
inline void HloPositionMatcher::clear_tuple_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tuple_index_ != nullptr) _impl_.tuple_index_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xla::memory_space_assignment::TupleShapeIndex& HloPositionMatcher::_internal_tuple_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::memory_space_assignment::TupleShapeIndex* p = _impl_.tuple_index_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::memory_space_assignment::TupleShapeIndex&>(::xla::memory_space_assignment::_TupleShapeIndex_default_instance_);
}
inline const ::xla::memory_space_assignment::TupleShapeIndex& HloPositionMatcher::tuple_index() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloPositionMatcher.tuple_index)
  return _internal_tuple_index();
}
inline void HloPositionMatcher::unsafe_arena_set_allocated_tuple_index(::xla::memory_space_assignment::TupleShapeIndex* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tuple_index_);
  }
  _impl_.tuple_index_ = reinterpret_cast<::xla::memory_space_assignment::TupleShapeIndex*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.HloPositionMatcher.tuple_index)
}
inline ::xla::memory_space_assignment::TupleShapeIndex* HloPositionMatcher::release_tuple_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::memory_space_assignment::TupleShapeIndex* released = _impl_.tuple_index_;
  _impl_.tuple_index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::memory_space_assignment::TupleShapeIndex* HloPositionMatcher::unsafe_arena_release_tuple_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.HloPositionMatcher.tuple_index)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xla::memory_space_assignment::TupleShapeIndex* temp = _impl_.tuple_index_;
  _impl_.tuple_index_ = nullptr;
  return temp;
}
inline ::xla::memory_space_assignment::TupleShapeIndex* HloPositionMatcher::_internal_mutable_tuple_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tuple_index_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::TupleShapeIndex>(GetArena());
    _impl_.tuple_index_ = reinterpret_cast<::xla::memory_space_assignment::TupleShapeIndex*>(p);
  }
  return _impl_.tuple_index_;
}
inline ::xla::memory_space_assignment::TupleShapeIndex* HloPositionMatcher::mutable_tuple_index() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::xla::memory_space_assignment::TupleShapeIndex* _msg = _internal_mutable_tuple_index();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.HloPositionMatcher.tuple_index)
  return _msg;
}
inline void HloPositionMatcher::set_allocated_tuple_index(::xla::memory_space_assignment::TupleShapeIndex* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tuple_index_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.tuple_index_ = reinterpret_cast<::xla::memory_space_assignment::TupleShapeIndex*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.HloPositionMatcher.tuple_index)
}

// optional int64 size_gte = 4;
inline bool HloPositionMatcher::has_size_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void HloPositionMatcher::clear_size_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_gte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t HloPositionMatcher::size_gte() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloPositionMatcher.size_gte)
  return _internal_size_gte();
}
inline void HloPositionMatcher::set_size_gte(::int64_t value) {
  _internal_set_size_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloPositionMatcher.size_gte)
}
inline ::int64_t HloPositionMatcher::_internal_size_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_gte_;
}
inline void HloPositionMatcher::_internal_set_size_gte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_gte_ = value;
}

// optional int64 size_lte = 5;
inline bool HloPositionMatcher::has_size_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void HloPositionMatcher::clear_size_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_lte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t HloPositionMatcher::size_lte() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloPositionMatcher.size_lte)
  return _internal_size_lte();
}
inline void HloPositionMatcher::set_size_lte(::int64_t value) {
  _internal_set_size_lte(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.HloPositionMatcher.size_lte)
}
inline ::int64_t HloPositionMatcher::_internal_size_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_lte_;
}
inline void HloPositionMatcher::_internal_set_size_lte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_lte_ = value;
}

// optional .xla.memory_space_assignment.HloOperandFilter hlo_use_filter = 6;
inline bool HloPositionMatcher::has_hlo_use_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hlo_use_filter_ != nullptr);
  return value;
}
inline void HloPositionMatcher::clear_hlo_use_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hlo_use_filter_ != nullptr) _impl_.hlo_use_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::xla::memory_space_assignment::HloOperandFilter& HloPositionMatcher::_internal_hlo_use_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::memory_space_assignment::HloOperandFilter* p = _impl_.hlo_use_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::memory_space_assignment::HloOperandFilter&>(::xla::memory_space_assignment::_HloOperandFilter_default_instance_);
}
inline const ::xla::memory_space_assignment::HloOperandFilter& HloPositionMatcher::hlo_use_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.HloPositionMatcher.hlo_use_filter)
  return _internal_hlo_use_filter();
}
inline void HloPositionMatcher::unsafe_arena_set_allocated_hlo_use_filter(::xla::memory_space_assignment::HloOperandFilter* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hlo_use_filter_);
  }
  _impl_.hlo_use_filter_ = reinterpret_cast<::xla::memory_space_assignment::HloOperandFilter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.HloPositionMatcher.hlo_use_filter)
}
inline ::xla::memory_space_assignment::HloOperandFilter* HloPositionMatcher::release_hlo_use_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::memory_space_assignment::HloOperandFilter* released = _impl_.hlo_use_filter_;
  _impl_.hlo_use_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::memory_space_assignment::HloOperandFilter* HloPositionMatcher::unsafe_arena_release_hlo_use_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.HloPositionMatcher.hlo_use_filter)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xla::memory_space_assignment::HloOperandFilter* temp = _impl_.hlo_use_filter_;
  _impl_.hlo_use_filter_ = nullptr;
  return temp;
}
inline ::xla::memory_space_assignment::HloOperandFilter* HloPositionMatcher::_internal_mutable_hlo_use_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hlo_use_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::HloOperandFilter>(GetArena());
    _impl_.hlo_use_filter_ = reinterpret_cast<::xla::memory_space_assignment::HloOperandFilter*>(p);
  }
  return _impl_.hlo_use_filter_;
}
inline ::xla::memory_space_assignment::HloOperandFilter* HloPositionMatcher::mutable_hlo_use_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::xla::memory_space_assignment::HloOperandFilter* _msg = _internal_mutable_hlo_use_filter();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.HloPositionMatcher.hlo_use_filter)
  return _msg;
}
inline void HloPositionMatcher::set_allocated_hlo_use_filter(::xla::memory_space_assignment::HloOperandFilter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hlo_use_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.hlo_use_filter_ = reinterpret_cast<::xla::memory_space_assignment::HloOperandFilter*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.HloPositionMatcher.hlo_use_filter)
}

// -------------------------------------------------------------------

// MsaSortOrderOverrideOptions

// bool assign_first = 1;
inline bool MsaSortOrderOverrideOptions::has_assign_first() const {
  return options_case() == kAssignFirst;
}
inline void MsaSortOrderOverrideOptions::set_has_assign_first() {
  _impl_._oneof_case_[0] = kAssignFirst;
}
inline void MsaSortOrderOverrideOptions::clear_assign_first() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kAssignFirst) {
    _impl_.options_.assign_first_ = false;
    clear_has_options();
  }
}
inline bool MsaSortOrderOverrideOptions::assign_first() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MsaSortOrderOverrideOptions.assign_first)
  return _internal_assign_first();
}
inline void MsaSortOrderOverrideOptions::set_assign_first(bool value) {
  if (options_case() != kAssignFirst) {
    clear_options();
    set_has_assign_first();
  }
  _impl_.options_.assign_first_ = value;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.MsaSortOrderOverrideOptions.assign_first)
}
inline bool MsaSortOrderOverrideOptions::_internal_assign_first() const {
  if (options_case() == kAssignFirst) {
    return _impl_.options_.assign_first_;
  }
  return false;
}

// bool assign_last = 2;
inline bool MsaSortOrderOverrideOptions::has_assign_last() const {
  return options_case() == kAssignLast;
}
inline void MsaSortOrderOverrideOptions::set_has_assign_last() {
  _impl_._oneof_case_[0] = kAssignLast;
}
inline void MsaSortOrderOverrideOptions::clear_assign_last() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kAssignLast) {
    _impl_.options_.assign_last_ = false;
    clear_has_options();
  }
}
inline bool MsaSortOrderOverrideOptions::assign_last() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MsaSortOrderOverrideOptions.assign_last)
  return _internal_assign_last();
}
inline void MsaSortOrderOverrideOptions::set_assign_last(bool value) {
  if (options_case() != kAssignLast) {
    clear_options();
    set_has_assign_last();
  }
  _impl_.options_.assign_last_ = value;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.MsaSortOrderOverrideOptions.assign_last)
}
inline bool MsaSortOrderOverrideOptions::_internal_assign_last() const {
  if (options_case() == kAssignLast) {
    return _impl_.options_.assign_last_;
  }
  return false;
}

inline bool MsaSortOrderOverrideOptions::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void MsaSortOrderOverrideOptions::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline MsaSortOrderOverrideOptions::OptionsCase MsaSortOrderOverrideOptions::options_case() const {
  return MsaSortOrderOverrideOptions::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MsaSortOrderOverride

// optional .xla.memory_space_assignment.HloPositionMatcher hlo_position_matcher = 1;
inline bool MsaSortOrderOverride::has_hlo_position_matcher() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hlo_position_matcher_ != nullptr);
  return value;
}
inline void MsaSortOrderOverride::clear_hlo_position_matcher() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hlo_position_matcher_ != nullptr) _impl_.hlo_position_matcher_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::memory_space_assignment::HloPositionMatcher& MsaSortOrderOverride::_internal_hlo_position_matcher() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::memory_space_assignment::HloPositionMatcher* p = _impl_.hlo_position_matcher_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::memory_space_assignment::HloPositionMatcher&>(::xla::memory_space_assignment::_HloPositionMatcher_default_instance_);
}
inline const ::xla::memory_space_assignment::HloPositionMatcher& MsaSortOrderOverride::hlo_position_matcher() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MsaSortOrderOverride.hlo_position_matcher)
  return _internal_hlo_position_matcher();
}
inline void MsaSortOrderOverride::unsafe_arena_set_allocated_hlo_position_matcher(::xla::memory_space_assignment::HloPositionMatcher* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hlo_position_matcher_);
  }
  _impl_.hlo_position_matcher_ = reinterpret_cast<::xla::memory_space_assignment::HloPositionMatcher*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.MsaSortOrderOverride.hlo_position_matcher)
}
inline ::xla::memory_space_assignment::HloPositionMatcher* MsaSortOrderOverride::release_hlo_position_matcher() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::memory_space_assignment::HloPositionMatcher* released = _impl_.hlo_position_matcher_;
  _impl_.hlo_position_matcher_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::memory_space_assignment::HloPositionMatcher* MsaSortOrderOverride::unsafe_arena_release_hlo_position_matcher() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.MsaSortOrderOverride.hlo_position_matcher)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::memory_space_assignment::HloPositionMatcher* temp = _impl_.hlo_position_matcher_;
  _impl_.hlo_position_matcher_ = nullptr;
  return temp;
}
inline ::xla::memory_space_assignment::HloPositionMatcher* MsaSortOrderOverride::_internal_mutable_hlo_position_matcher() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hlo_position_matcher_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::HloPositionMatcher>(GetArena());
    _impl_.hlo_position_matcher_ = reinterpret_cast<::xla::memory_space_assignment::HloPositionMatcher*>(p);
  }
  return _impl_.hlo_position_matcher_;
}
inline ::xla::memory_space_assignment::HloPositionMatcher* MsaSortOrderOverride::mutable_hlo_position_matcher() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::memory_space_assignment::HloPositionMatcher* _msg = _internal_mutable_hlo_position_matcher();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.MsaSortOrderOverride.hlo_position_matcher)
  return _msg;
}
inline void MsaSortOrderOverride::set_allocated_hlo_position_matcher(::xla::memory_space_assignment::HloPositionMatcher* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hlo_position_matcher_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hlo_position_matcher_ = reinterpret_cast<::xla::memory_space_assignment::HloPositionMatcher*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.MsaSortOrderOverride.hlo_position_matcher)
}

// optional .xla.memory_space_assignment.MsaSortOrderOverrideOptions override_options = 2;
inline bool MsaSortOrderOverride::has_override_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.override_options_ != nullptr);
  return value;
}
inline void MsaSortOrderOverride::clear_override_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.override_options_ != nullptr) _impl_.override_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xla::memory_space_assignment::MsaSortOrderOverrideOptions& MsaSortOrderOverride::_internal_override_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* p = _impl_.override_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::memory_space_assignment::MsaSortOrderOverrideOptions&>(::xla::memory_space_assignment::_MsaSortOrderOverrideOptions_default_instance_);
}
inline const ::xla::memory_space_assignment::MsaSortOrderOverrideOptions& MsaSortOrderOverride::override_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MsaSortOrderOverride.override_options)
  return _internal_override_options();
}
inline void MsaSortOrderOverride::unsafe_arena_set_allocated_override_options(::xla::memory_space_assignment::MsaSortOrderOverrideOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.override_options_);
  }
  _impl_.override_options_ = reinterpret_cast<::xla::memory_space_assignment::MsaSortOrderOverrideOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.memory_space_assignment.MsaSortOrderOverride.override_options)
}
inline ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* MsaSortOrderOverride::release_override_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* released = _impl_.override_options_;
  _impl_.override_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* MsaSortOrderOverride::unsafe_arena_release_override_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.memory_space_assignment.MsaSortOrderOverride.override_options)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* temp = _impl_.override_options_;
  _impl_.override_options_ = nullptr;
  return temp;
}
inline ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* MsaSortOrderOverride::_internal_mutable_override_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.override_options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::memory_space_assignment::MsaSortOrderOverrideOptions>(GetArena());
    _impl_.override_options_ = reinterpret_cast<::xla::memory_space_assignment::MsaSortOrderOverrideOptions*>(p);
  }
  return _impl_.override_options_;
}
inline ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* MsaSortOrderOverride::mutable_override_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::memory_space_assignment::MsaSortOrderOverrideOptions* _msg = _internal_mutable_override_options();
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.MsaSortOrderOverride.override_options)
  return _msg;
}
inline void MsaSortOrderOverride::set_allocated_override_options(::xla::memory_space_assignment::MsaSortOrderOverrideOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.override_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.override_options_ = reinterpret_cast<::xla::memory_space_assignment::MsaSortOrderOverrideOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.memory_space_assignment.MsaSortOrderOverride.override_options)
}

// optional bool apply_to_cross_program_prefetches = 3;
inline bool MsaSortOrderOverride::has_apply_to_cross_program_prefetches() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MsaSortOrderOverride::clear_apply_to_cross_program_prefetches() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_to_cross_program_prefetches_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MsaSortOrderOverride::apply_to_cross_program_prefetches() const {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MsaSortOrderOverride.apply_to_cross_program_prefetches)
  return _internal_apply_to_cross_program_prefetches();
}
inline void MsaSortOrderOverride::set_apply_to_cross_program_prefetches(bool value) {
  _internal_set_apply_to_cross_program_prefetches(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:xla.memory_space_assignment.MsaSortOrderOverride.apply_to_cross_program_prefetches)
}
inline bool MsaSortOrderOverride::_internal_apply_to_cross_program_prefetches() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apply_to_cross_program_prefetches_;
}
inline void MsaSortOrderOverride::_internal_set_apply_to_cross_program_prefetches(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_to_cross_program_prefetches_ = value;
}

// -------------------------------------------------------------------

// MsaSortOrderOverrides

// repeated .xla.memory_space_assignment.MsaSortOrderOverride overrides = 1;
inline int MsaSortOrderOverrides::_internal_overrides_size() const {
  return _internal_overrides().size();
}
inline int MsaSortOrderOverrides::overrides_size() const {
  return _internal_overrides_size();
}
inline void MsaSortOrderOverrides::clear_overrides() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overrides_.Clear();
}
inline ::xla::memory_space_assignment::MsaSortOrderOverride* MsaSortOrderOverrides::mutable_overrides(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.memory_space_assignment.MsaSortOrderOverrides.overrides)
  return _internal_mutable_overrides()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::MsaSortOrderOverride>* MsaSortOrderOverrides::mutable_overrides()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.memory_space_assignment.MsaSortOrderOverrides.overrides)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_overrides();
}
inline const ::xla::memory_space_assignment::MsaSortOrderOverride& MsaSortOrderOverrides::overrides(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.memory_space_assignment.MsaSortOrderOverrides.overrides)
  return _internal_overrides().Get(index);
}
inline ::xla::memory_space_assignment::MsaSortOrderOverride* MsaSortOrderOverrides::add_overrides() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::memory_space_assignment::MsaSortOrderOverride* _add = _internal_mutable_overrides()->Add();
  // @@protoc_insertion_point(field_add:xla.memory_space_assignment.MsaSortOrderOverrides.overrides)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::MsaSortOrderOverride>& MsaSortOrderOverrides::overrides() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.memory_space_assignment.MsaSortOrderOverrides.overrides)
  return _internal_overrides();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::MsaSortOrderOverride>&
MsaSortOrderOverrides::_internal_overrides() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.overrides_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::memory_space_assignment::MsaSortOrderOverride>*
MsaSortOrderOverrides::_internal_mutable_overrides() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.overrides_;
}

// -------------------------------------------------------------------

// ExpandedScopedAlternateMemoryMode

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace memory_space_assignment
}  // namespace xla


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::xla::memory_space_assignment::ExpandedScopedAlternateMemoryMode_Value> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xla::memory_space_assignment::ExpandedScopedAlternateMemoryMode_Value>() {
  return ::xla::memory_space_assignment::ExpandedScopedAlternateMemoryMode_Value_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_xla_2fservice_2fmemory_5fspace_5fassignment_2fmemory_5fspace_5fassignment_2eproto_2epb_2eh
