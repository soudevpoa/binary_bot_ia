// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: xla/tsl/protobuf/coordination_service.proto

#include "xla/tsl/protobuf/coordination_service.pb.h"
#include "xla/tsl/protobuf/coordination_service.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace tensorflow {

static const char* grpcCoordinationService_method_names[] = {
  "/tensorflow.CoordinationService/RegisterTask",
  "/tensorflow.CoordinationService/Heartbeat",
  "/tensorflow.CoordinationService/WaitForAllTasks",
  "/tensorflow.CoordinationService/ShutdownTask",
  "/tensorflow.CoordinationService/ResetTask",
  "/tensorflow.CoordinationService/ReportErrorToTask",
  "/tensorflow.CoordinationService/ReportErrorToService",
  "/tensorflow.CoordinationService/GetTaskState",
  "/tensorflow.CoordinationService/GetJobState",
  "/tensorflow.CoordinationService/InsertKeyValue",
  "/tensorflow.CoordinationService/GetKeyValue",
  "/tensorflow.CoordinationService/TryGetKeyValue",
  "/tensorflow.CoordinationService/GetKeyValueDir",
  "/tensorflow.CoordinationService/DeleteKeyValue",
  "/tensorflow.CoordinationService/Barrier",
  "/tensorflow.CoordinationService/CancelBarrier",
  "/tensorflow.CoordinationService/GetAliveTasks",
  "/tensorflow.CoordinationService/PollForError",
};

std::unique_ptr< grpc::CoordinationService::Stub> grpc::CoordinationService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< grpc::CoordinationService::Stub> stub(new grpc::CoordinationService::Stub(channel, options));
  return stub;
}

grpc::CoordinationService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_RegisterTask_(grpcCoordinationService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Heartbeat_(grpcCoordinationService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_WaitForAllTasks_(grpcCoordinationService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ShutdownTask_(grpcCoordinationService_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ResetTask_(grpcCoordinationService_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReportErrorToTask_(grpcCoordinationService_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReportErrorToService_(grpcCoordinationService_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetTaskState_(grpcCoordinationService_method_names[7], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetJobState_(grpcCoordinationService_method_names[8], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_InsertKeyValue_(grpcCoordinationService_method_names[9], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetKeyValue_(grpcCoordinationService_method_names[10], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_TryGetKeyValue_(grpcCoordinationService_method_names[11], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetKeyValueDir_(grpcCoordinationService_method_names[12], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DeleteKeyValue_(grpcCoordinationService_method_names[13], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Barrier_(grpcCoordinationService_method_names[14], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CancelBarrier_(grpcCoordinationService_method_names[15], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetAliveTasks_(grpcCoordinationService_method_names[16], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_PollForError_(grpcCoordinationService_method_names[17], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status grpc::CoordinationService::Stub::RegisterTask(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest& request, ::tensorflow::RegisterTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::RegisterTaskRequest, ::tensorflow::RegisterTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_RegisterTask_, context, request, response);
}

void grpc::CoordinationService::Stub::async::RegisterTask(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest* request, ::tensorflow::RegisterTaskResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::RegisterTaskRequest, ::tensorflow::RegisterTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RegisterTask_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::RegisterTask(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest* request, ::tensorflow::RegisterTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RegisterTask_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::RegisterTaskResponse>* grpc::CoordinationService::Stub::PrepareAsyncRegisterTaskRaw(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::RegisterTaskResponse, ::tensorflow::RegisterTaskRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_RegisterTask_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::RegisterTaskResponse>* grpc::CoordinationService::Stub::AsyncRegisterTaskRaw(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRegisterTaskRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::Heartbeat(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest& request, ::tensorflow::HeartbeatResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::HeartbeatRequest, ::tensorflow::HeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Heartbeat_, context, request, response);
}

void grpc::CoordinationService::Stub::async::Heartbeat(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest* request, ::tensorflow::HeartbeatResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::HeartbeatRequest, ::tensorflow::HeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Heartbeat_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::Heartbeat(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest* request, ::tensorflow::HeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Heartbeat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::HeartbeatResponse>* grpc::CoordinationService::Stub::PrepareAsyncHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::HeartbeatResponse, ::tensorflow::HeartbeatRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Heartbeat_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::HeartbeatResponse>* grpc::CoordinationService::Stub::AsyncHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncHeartbeatRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::WaitForAllTasks(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest& request, ::tensorflow::WaitForAllTasksResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::WaitForAllTasksRequest, ::tensorflow::WaitForAllTasksResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_WaitForAllTasks_, context, request, response);
}

void grpc::CoordinationService::Stub::async::WaitForAllTasks(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest* request, ::tensorflow::WaitForAllTasksResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::WaitForAllTasksRequest, ::tensorflow::WaitForAllTasksResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_WaitForAllTasks_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::WaitForAllTasks(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest* request, ::tensorflow::WaitForAllTasksResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_WaitForAllTasks_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::WaitForAllTasksResponse>* grpc::CoordinationService::Stub::PrepareAsyncWaitForAllTasksRaw(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::WaitForAllTasksResponse, ::tensorflow::WaitForAllTasksRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_WaitForAllTasks_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::WaitForAllTasksResponse>* grpc::CoordinationService::Stub::AsyncWaitForAllTasksRaw(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncWaitForAllTasksRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::ShutdownTask(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest& request, ::tensorflow::ShutdownTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::ShutdownTaskRequest, ::tensorflow::ShutdownTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ShutdownTask_, context, request, response);
}

void grpc::CoordinationService::Stub::async::ShutdownTask(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest* request, ::tensorflow::ShutdownTaskResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::ShutdownTaskRequest, ::tensorflow::ShutdownTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ShutdownTask_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::ShutdownTask(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest* request, ::tensorflow::ShutdownTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ShutdownTask_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ShutdownTaskResponse>* grpc::CoordinationService::Stub::PrepareAsyncShutdownTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::ShutdownTaskResponse, ::tensorflow::ShutdownTaskRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ShutdownTask_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ShutdownTaskResponse>* grpc::CoordinationService::Stub::AsyncShutdownTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncShutdownTaskRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::ResetTask(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest& request, ::tensorflow::ResetTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::ResetTaskRequest, ::tensorflow::ResetTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ResetTask_, context, request, response);
}

void grpc::CoordinationService::Stub::async::ResetTask(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest* request, ::tensorflow::ResetTaskResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::ResetTaskRequest, ::tensorflow::ResetTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ResetTask_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::ResetTask(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest* request, ::tensorflow::ResetTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ResetTask_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ResetTaskResponse>* grpc::CoordinationService::Stub::PrepareAsyncResetTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::ResetTaskResponse, ::tensorflow::ResetTaskRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ResetTask_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ResetTaskResponse>* grpc::CoordinationService::Stub::AsyncResetTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncResetTaskRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::ReportErrorToTask(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest& request, ::tensorflow::ReportErrorToTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::ReportErrorToTaskRequest, ::tensorflow::ReportErrorToTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ReportErrorToTask_, context, request, response);
}

void grpc::CoordinationService::Stub::async::ReportErrorToTask(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest* request, ::tensorflow::ReportErrorToTaskResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::ReportErrorToTaskRequest, ::tensorflow::ReportErrorToTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReportErrorToTask_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::ReportErrorToTask(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest* request, ::tensorflow::ReportErrorToTaskResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReportErrorToTask_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ReportErrorToTaskResponse>* grpc::CoordinationService::Stub::PrepareAsyncReportErrorToTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::ReportErrorToTaskResponse, ::tensorflow::ReportErrorToTaskRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ReportErrorToTask_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ReportErrorToTaskResponse>* grpc::CoordinationService::Stub::AsyncReportErrorToTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncReportErrorToTaskRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::ReportErrorToService(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest& request, ::tensorflow::ReportErrorToServiceResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::ReportErrorToServiceRequest, ::tensorflow::ReportErrorToServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ReportErrorToService_, context, request, response);
}

void grpc::CoordinationService::Stub::async::ReportErrorToService(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest* request, ::tensorflow::ReportErrorToServiceResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::ReportErrorToServiceRequest, ::tensorflow::ReportErrorToServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReportErrorToService_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::ReportErrorToService(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest* request, ::tensorflow::ReportErrorToServiceResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReportErrorToService_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ReportErrorToServiceResponse>* grpc::CoordinationService::Stub::PrepareAsyncReportErrorToServiceRaw(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::ReportErrorToServiceResponse, ::tensorflow::ReportErrorToServiceRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ReportErrorToService_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ReportErrorToServiceResponse>* grpc::CoordinationService::Stub::AsyncReportErrorToServiceRaw(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncReportErrorToServiceRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::GetTaskState(::grpc::ClientContext* context, const ::tensorflow::GetTaskStateRequest& request, ::tensorflow::GetTaskStateResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::GetTaskStateRequest, ::tensorflow::GetTaskStateResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetTaskState_, context, request, response);
}

void grpc::CoordinationService::Stub::async::GetTaskState(::grpc::ClientContext* context, const ::tensorflow::GetTaskStateRequest* request, ::tensorflow::GetTaskStateResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::GetTaskStateRequest, ::tensorflow::GetTaskStateResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetTaskState_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::GetTaskState(::grpc::ClientContext* context, const ::tensorflow::GetTaskStateRequest* request, ::tensorflow::GetTaskStateResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetTaskState_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetTaskStateResponse>* grpc::CoordinationService::Stub::PrepareAsyncGetTaskStateRaw(::grpc::ClientContext* context, const ::tensorflow::GetTaskStateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::GetTaskStateResponse, ::tensorflow::GetTaskStateRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetTaskState_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetTaskStateResponse>* grpc::CoordinationService::Stub::AsyncGetTaskStateRaw(::grpc::ClientContext* context, const ::tensorflow::GetTaskStateRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetTaskStateRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::GetJobState(::grpc::ClientContext* context, const ::tensorflow::GetJobStateRequest& request, ::tensorflow::GetJobStateResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::GetJobStateRequest, ::tensorflow::GetJobStateResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetJobState_, context, request, response);
}

void grpc::CoordinationService::Stub::async::GetJobState(::grpc::ClientContext* context, const ::tensorflow::GetJobStateRequest* request, ::tensorflow::GetJobStateResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::GetJobStateRequest, ::tensorflow::GetJobStateResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetJobState_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::GetJobState(::grpc::ClientContext* context, const ::tensorflow::GetJobStateRequest* request, ::tensorflow::GetJobStateResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetJobState_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetJobStateResponse>* grpc::CoordinationService::Stub::PrepareAsyncGetJobStateRaw(::grpc::ClientContext* context, const ::tensorflow::GetJobStateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::GetJobStateResponse, ::tensorflow::GetJobStateRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetJobState_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetJobStateResponse>* grpc::CoordinationService::Stub::AsyncGetJobStateRaw(::grpc::ClientContext* context, const ::tensorflow::GetJobStateRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetJobStateRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::InsertKeyValue(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest& request, ::tensorflow::InsertKeyValueResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::InsertKeyValueRequest, ::tensorflow::InsertKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_InsertKeyValue_, context, request, response);
}

void grpc::CoordinationService::Stub::async::InsertKeyValue(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest* request, ::tensorflow::InsertKeyValueResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::InsertKeyValueRequest, ::tensorflow::InsertKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_InsertKeyValue_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::InsertKeyValue(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest* request, ::tensorflow::InsertKeyValueResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_InsertKeyValue_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::InsertKeyValueResponse>* grpc::CoordinationService::Stub::PrepareAsyncInsertKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::InsertKeyValueResponse, ::tensorflow::InsertKeyValueRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_InsertKeyValue_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::InsertKeyValueResponse>* grpc::CoordinationService::Stub::AsyncInsertKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncInsertKeyValueRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::GetKeyValue(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest& request, ::tensorflow::GetKeyValueResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::GetKeyValueRequest, ::tensorflow::GetKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetKeyValue_, context, request, response);
}

void grpc::CoordinationService::Stub::async::GetKeyValue(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest* request, ::tensorflow::GetKeyValueResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::GetKeyValueRequest, ::tensorflow::GetKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetKeyValue_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::GetKeyValue(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest* request, ::tensorflow::GetKeyValueResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetKeyValue_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetKeyValueResponse>* grpc::CoordinationService::Stub::PrepareAsyncGetKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::GetKeyValueResponse, ::tensorflow::GetKeyValueRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetKeyValue_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetKeyValueResponse>* grpc::CoordinationService::Stub::AsyncGetKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetKeyValueRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::TryGetKeyValue(::grpc::ClientContext* context, const ::tensorflow::TryGetKeyValueRequest& request, ::tensorflow::TryGetKeyValueResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::TryGetKeyValueRequest, ::tensorflow::TryGetKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_TryGetKeyValue_, context, request, response);
}

void grpc::CoordinationService::Stub::async::TryGetKeyValue(::grpc::ClientContext* context, const ::tensorflow::TryGetKeyValueRequest* request, ::tensorflow::TryGetKeyValueResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::TryGetKeyValueRequest, ::tensorflow::TryGetKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_TryGetKeyValue_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::TryGetKeyValue(::grpc::ClientContext* context, const ::tensorflow::TryGetKeyValueRequest* request, ::tensorflow::TryGetKeyValueResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_TryGetKeyValue_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::TryGetKeyValueResponse>* grpc::CoordinationService::Stub::PrepareAsyncTryGetKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::TryGetKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::TryGetKeyValueResponse, ::tensorflow::TryGetKeyValueRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_TryGetKeyValue_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::TryGetKeyValueResponse>* grpc::CoordinationService::Stub::AsyncTryGetKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::TryGetKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncTryGetKeyValueRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::GetKeyValueDir(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueDirRequest& request, ::tensorflow::GetKeyValueDirResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::GetKeyValueDirRequest, ::tensorflow::GetKeyValueDirResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetKeyValueDir_, context, request, response);
}

void grpc::CoordinationService::Stub::async::GetKeyValueDir(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueDirRequest* request, ::tensorflow::GetKeyValueDirResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::GetKeyValueDirRequest, ::tensorflow::GetKeyValueDirResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetKeyValueDir_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::GetKeyValueDir(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueDirRequest* request, ::tensorflow::GetKeyValueDirResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetKeyValueDir_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetKeyValueDirResponse>* grpc::CoordinationService::Stub::PrepareAsyncGetKeyValueDirRaw(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueDirRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::GetKeyValueDirResponse, ::tensorflow::GetKeyValueDirRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetKeyValueDir_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetKeyValueDirResponse>* grpc::CoordinationService::Stub::AsyncGetKeyValueDirRaw(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueDirRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetKeyValueDirRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::DeleteKeyValue(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest& request, ::tensorflow::DeleteKeyValueResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::DeleteKeyValueRequest, ::tensorflow::DeleteKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_DeleteKeyValue_, context, request, response);
}

void grpc::CoordinationService::Stub::async::DeleteKeyValue(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest* request, ::tensorflow::DeleteKeyValueResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::DeleteKeyValueRequest, ::tensorflow::DeleteKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DeleteKeyValue_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::DeleteKeyValue(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest* request, ::tensorflow::DeleteKeyValueResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DeleteKeyValue_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::DeleteKeyValueResponse>* grpc::CoordinationService::Stub::PrepareAsyncDeleteKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::DeleteKeyValueResponse, ::tensorflow::DeleteKeyValueRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_DeleteKeyValue_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::DeleteKeyValueResponse>* grpc::CoordinationService::Stub::AsyncDeleteKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncDeleteKeyValueRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::Barrier(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest& request, ::tensorflow::BarrierResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::BarrierRequest, ::tensorflow::BarrierResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Barrier_, context, request, response);
}

void grpc::CoordinationService::Stub::async::Barrier(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest* request, ::tensorflow::BarrierResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::BarrierRequest, ::tensorflow::BarrierResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Barrier_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::Barrier(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest* request, ::tensorflow::BarrierResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Barrier_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::BarrierResponse>* grpc::CoordinationService::Stub::PrepareAsyncBarrierRaw(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::BarrierResponse, ::tensorflow::BarrierRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Barrier_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::BarrierResponse>* grpc::CoordinationService::Stub::AsyncBarrierRaw(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncBarrierRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::CancelBarrier(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest& request, ::tensorflow::CancelBarrierResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::CancelBarrierRequest, ::tensorflow::CancelBarrierResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_CancelBarrier_, context, request, response);
}

void grpc::CoordinationService::Stub::async::CancelBarrier(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest* request, ::tensorflow::CancelBarrierResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::CancelBarrierRequest, ::tensorflow::CancelBarrierResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CancelBarrier_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::CancelBarrier(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest* request, ::tensorflow::CancelBarrierResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_CancelBarrier_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::CancelBarrierResponse>* grpc::CoordinationService::Stub::PrepareAsyncCancelBarrierRaw(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::CancelBarrierResponse, ::tensorflow::CancelBarrierRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CancelBarrier_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::CancelBarrierResponse>* grpc::CoordinationService::Stub::AsyncCancelBarrierRaw(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncCancelBarrierRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::GetAliveTasks(::grpc::ClientContext* context, const ::tensorflow::GetAliveTasksRequest& request, ::tensorflow::GetAliveTasksResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::GetAliveTasksRequest, ::tensorflow::GetAliveTasksResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetAliveTasks_, context, request, response);
}

void grpc::CoordinationService::Stub::async::GetAliveTasks(::grpc::ClientContext* context, const ::tensorflow::GetAliveTasksRequest* request, ::tensorflow::GetAliveTasksResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::GetAliveTasksRequest, ::tensorflow::GetAliveTasksResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetAliveTasks_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::GetAliveTasks(::grpc::ClientContext* context, const ::tensorflow::GetAliveTasksRequest* request, ::tensorflow::GetAliveTasksResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetAliveTasks_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetAliveTasksResponse>* grpc::CoordinationService::Stub::PrepareAsyncGetAliveTasksRaw(::grpc::ClientContext* context, const ::tensorflow::GetAliveTasksRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::GetAliveTasksResponse, ::tensorflow::GetAliveTasksRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetAliveTasks_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetAliveTasksResponse>* grpc::CoordinationService::Stub::AsyncGetAliveTasksRaw(::grpc::ClientContext* context, const ::tensorflow::GetAliveTasksRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetAliveTasksRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status grpc::CoordinationService::Stub::PollForError(::grpc::ClientContext* context, const ::tensorflow::PollForErrorRequest& request, ::tensorflow::PollForErrorResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::tensorflow::PollForErrorRequest, ::tensorflow::PollForErrorResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_PollForError_, context, request, response);
}

void grpc::CoordinationService::Stub::async::PollForError(::grpc::ClientContext* context, const ::tensorflow::PollForErrorRequest* request, ::tensorflow::PollForErrorResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::tensorflow::PollForErrorRequest, ::tensorflow::PollForErrorResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_PollForError_, context, request, response, std::move(f));
}

void grpc::CoordinationService::Stub::async::PollForError(::grpc::ClientContext* context, const ::tensorflow::PollForErrorRequest* request, ::tensorflow::PollForErrorResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_PollForError_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::PollForErrorResponse>* grpc::CoordinationService::Stub::PrepareAsyncPollForErrorRaw(::grpc::ClientContext* context, const ::tensorflow::PollForErrorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::tensorflow::PollForErrorResponse, ::tensorflow::PollForErrorRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_PollForError_, context, request);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::PollForErrorResponse>* grpc::CoordinationService::Stub::AsyncPollForErrorRaw(::grpc::ClientContext* context, const ::tensorflow::PollForErrorRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPollForErrorRaw(context, request, cq);
  result->StartCall();
  return result;
}

grpc::CoordinationService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::RegisterTaskRequest, ::tensorflow::RegisterTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::RegisterTaskRequest* req,
             ::tensorflow::RegisterTaskResponse* resp) {
               return service->RegisterTask(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::HeartbeatRequest, ::tensorflow::HeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::HeartbeatRequest* req,
             ::tensorflow::HeartbeatResponse* resp) {
               return service->Heartbeat(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::WaitForAllTasksRequest, ::tensorflow::WaitForAllTasksResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::WaitForAllTasksRequest* req,
             ::tensorflow::WaitForAllTasksResponse* resp) {
               return service->WaitForAllTasks(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::ShutdownTaskRequest, ::tensorflow::ShutdownTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::ShutdownTaskRequest* req,
             ::tensorflow::ShutdownTaskResponse* resp) {
               return service->ShutdownTask(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::ResetTaskRequest, ::tensorflow::ResetTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::ResetTaskRequest* req,
             ::tensorflow::ResetTaskResponse* resp) {
               return service->ResetTask(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::ReportErrorToTaskRequest, ::tensorflow::ReportErrorToTaskResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::ReportErrorToTaskRequest* req,
             ::tensorflow::ReportErrorToTaskResponse* resp) {
               return service->ReportErrorToTask(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::ReportErrorToServiceRequest, ::tensorflow::ReportErrorToServiceResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::ReportErrorToServiceRequest* req,
             ::tensorflow::ReportErrorToServiceResponse* resp) {
               return service->ReportErrorToService(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::GetTaskStateRequest, ::tensorflow::GetTaskStateResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::GetTaskStateRequest* req,
             ::tensorflow::GetTaskStateResponse* resp) {
               return service->GetTaskState(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::GetJobStateRequest, ::tensorflow::GetJobStateResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::GetJobStateRequest* req,
             ::tensorflow::GetJobStateResponse* resp) {
               return service->GetJobState(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::InsertKeyValueRequest, ::tensorflow::InsertKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::InsertKeyValueRequest* req,
             ::tensorflow::InsertKeyValueResponse* resp) {
               return service->InsertKeyValue(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::GetKeyValueRequest, ::tensorflow::GetKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::GetKeyValueRequest* req,
             ::tensorflow::GetKeyValueResponse* resp) {
               return service->GetKeyValue(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::TryGetKeyValueRequest, ::tensorflow::TryGetKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::TryGetKeyValueRequest* req,
             ::tensorflow::TryGetKeyValueResponse* resp) {
               return service->TryGetKeyValue(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::GetKeyValueDirRequest, ::tensorflow::GetKeyValueDirResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::GetKeyValueDirRequest* req,
             ::tensorflow::GetKeyValueDirResponse* resp) {
               return service->GetKeyValueDir(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::DeleteKeyValueRequest, ::tensorflow::DeleteKeyValueResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::DeleteKeyValueRequest* req,
             ::tensorflow::DeleteKeyValueResponse* resp) {
               return service->DeleteKeyValue(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::BarrierRequest, ::tensorflow::BarrierResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::BarrierRequest* req,
             ::tensorflow::BarrierResponse* resp) {
               return service->Barrier(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::CancelBarrierRequest, ::tensorflow::CancelBarrierResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::CancelBarrierRequest* req,
             ::tensorflow::CancelBarrierResponse* resp) {
               return service->CancelBarrier(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::GetAliveTasksRequest, ::tensorflow::GetAliveTasksResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::GetAliveTasksRequest* req,
             ::tensorflow::GetAliveTasksResponse* resp) {
               return service->GetAliveTasks(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      grpcCoordinationService_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< grpc::CoordinationService::Service, ::tensorflow::PollForErrorRequest, ::tensorflow::PollForErrorResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](grpc::CoordinationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::tensorflow::PollForErrorRequest* req,
             ::tensorflow::PollForErrorResponse* resp) {
               return service->PollForError(ctx, req, resp);
             }, this)));
}

grpc::CoordinationService::Service::~Service() {
}

::grpc::Status grpc::CoordinationService::Service::RegisterTask(::grpc::ServerContext* context, const ::tensorflow::RegisterTaskRequest* request, ::tensorflow::RegisterTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::Heartbeat(::grpc::ServerContext* context, const ::tensorflow::HeartbeatRequest* request, ::tensorflow::HeartbeatResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::WaitForAllTasks(::grpc::ServerContext* context, const ::tensorflow::WaitForAllTasksRequest* request, ::tensorflow::WaitForAllTasksResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::ShutdownTask(::grpc::ServerContext* context, const ::tensorflow::ShutdownTaskRequest* request, ::tensorflow::ShutdownTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::ResetTask(::grpc::ServerContext* context, const ::tensorflow::ResetTaskRequest* request, ::tensorflow::ResetTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::ReportErrorToTask(::grpc::ServerContext* context, const ::tensorflow::ReportErrorToTaskRequest* request, ::tensorflow::ReportErrorToTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::ReportErrorToService(::grpc::ServerContext* context, const ::tensorflow::ReportErrorToServiceRequest* request, ::tensorflow::ReportErrorToServiceResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::GetTaskState(::grpc::ServerContext* context, const ::tensorflow::GetTaskStateRequest* request, ::tensorflow::GetTaskStateResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::GetJobState(::grpc::ServerContext* context, const ::tensorflow::GetJobStateRequest* request, ::tensorflow::GetJobStateResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::InsertKeyValue(::grpc::ServerContext* context, const ::tensorflow::InsertKeyValueRequest* request, ::tensorflow::InsertKeyValueResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::GetKeyValue(::grpc::ServerContext* context, const ::tensorflow::GetKeyValueRequest* request, ::tensorflow::GetKeyValueResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::TryGetKeyValue(::grpc::ServerContext* context, const ::tensorflow::TryGetKeyValueRequest* request, ::tensorflow::TryGetKeyValueResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::GetKeyValueDir(::grpc::ServerContext* context, const ::tensorflow::GetKeyValueDirRequest* request, ::tensorflow::GetKeyValueDirResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::DeleteKeyValue(::grpc::ServerContext* context, const ::tensorflow::DeleteKeyValueRequest* request, ::tensorflow::DeleteKeyValueResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::Barrier(::grpc::ServerContext* context, const ::tensorflow::BarrierRequest* request, ::tensorflow::BarrierResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::CancelBarrier(::grpc::ServerContext* context, const ::tensorflow::CancelBarrierRequest* request, ::tensorflow::CancelBarrierResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::GetAliveTasks(::grpc::ServerContext* context, const ::tensorflow::GetAliveTasksRequest* request, ::tensorflow::GetAliveTasksResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status grpc::CoordinationService::Service::PollForError(::grpc::ServerContext* context, const ::tensorflow::PollForErrorRequest* request, ::tensorflow::PollForErrorResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace tensorflow

