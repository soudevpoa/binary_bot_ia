// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: xla/tsl/protobuf/coordination_service.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
namespace tensorflow {
class BarrierError;
struct BarrierErrorDefaultTypeInternal;
PROTOBUF_EXPORT extern BarrierErrorDefaultTypeInternal _BarrierError_default_instance_;
class BarrierRequest;
struct BarrierRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern BarrierRequestDefaultTypeInternal _BarrierRequest_default_instance_;
class BarrierResponse;
struct BarrierResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern BarrierResponseDefaultTypeInternal _BarrierResponse_default_instance_;
class CancelBarrierRequest;
struct CancelBarrierRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern CancelBarrierRequestDefaultTypeInternal _CancelBarrierRequest_default_instance_;
class CancelBarrierResponse;
struct CancelBarrierResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern CancelBarrierResponseDefaultTypeInternal _CancelBarrierResponse_default_instance_;
class CoordinatedTask;
struct CoordinatedTaskDefaultTypeInternal;
PROTOBUF_EXPORT extern CoordinatedTaskDefaultTypeInternal _CoordinatedTask_default_instance_;
class CoordinatedTaskStateInfo;
struct CoordinatedTaskStateInfoDefaultTypeInternal;
PROTOBUF_EXPORT extern CoordinatedTaskStateInfoDefaultTypeInternal _CoordinatedTaskStateInfo_default_instance_;
class CoordinationServiceError;
struct CoordinationServiceErrorDefaultTypeInternal;
PROTOBUF_EXPORT extern CoordinationServiceErrorDefaultTypeInternal _CoordinationServiceError_default_instance_;
class DeleteKeyValueRequest;
struct DeleteKeyValueRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern DeleteKeyValueRequestDefaultTypeInternal _DeleteKeyValueRequest_default_instance_;
class DeleteKeyValueResponse;
struct DeleteKeyValueResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern DeleteKeyValueResponseDefaultTypeInternal _DeleteKeyValueResponse_default_instance_;
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
PROTOBUF_EXPORT extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class GetAliveTasksRequest;
struct GetAliveTasksRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern GetAliveTasksRequestDefaultTypeInternal _GetAliveTasksRequest_default_instance_;
class GetAliveTasksResponse;
struct GetAliveTasksResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern GetAliveTasksResponseDefaultTypeInternal _GetAliveTasksResponse_default_instance_;
class GetJobStateRequest;
struct GetJobStateRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern GetJobStateRequestDefaultTypeInternal _GetJobStateRequest_default_instance_;
class GetJobStateResponse;
struct GetJobStateResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern GetJobStateResponseDefaultTypeInternal _GetJobStateResponse_default_instance_;
class GetKeyValueDirRequest;
struct GetKeyValueDirRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern GetKeyValueDirRequestDefaultTypeInternal _GetKeyValueDirRequest_default_instance_;
class GetKeyValueDirResponse;
struct GetKeyValueDirResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern GetKeyValueDirResponseDefaultTypeInternal _GetKeyValueDirResponse_default_instance_;
class GetKeyValueRequest;
struct GetKeyValueRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern GetKeyValueRequestDefaultTypeInternal _GetKeyValueRequest_default_instance_;
class GetKeyValueResponse;
struct GetKeyValueResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern GetKeyValueResponseDefaultTypeInternal _GetKeyValueResponse_default_instance_;
class GetTaskStateRequest;
struct GetTaskStateRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern GetTaskStateRequestDefaultTypeInternal _GetTaskStateRequest_default_instance_;
class GetTaskStateResponse;
struct GetTaskStateResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern GetTaskStateResponseDefaultTypeInternal _GetTaskStateResponse_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class InsertKeyValueRequest;
struct InsertKeyValueRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern InsertKeyValueRequestDefaultTypeInternal _InsertKeyValueRequest_default_instance_;
class InsertKeyValueResponse;
struct InsertKeyValueResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern InsertKeyValueResponseDefaultTypeInternal _InsertKeyValueResponse_default_instance_;
class KeyValueEntry;
struct KeyValueEntryDefaultTypeInternal;
PROTOBUF_EXPORT extern KeyValueEntryDefaultTypeInternal _KeyValueEntry_default_instance_;
class PollForErrorRequest;
struct PollForErrorRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern PollForErrorRequestDefaultTypeInternal _PollForErrorRequest_default_instance_;
class PollForErrorResponse;
struct PollForErrorResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern PollForErrorResponseDefaultTypeInternal _PollForErrorResponse_default_instance_;
class RegisterTaskRequest;
struct RegisterTaskRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern RegisterTaskRequestDefaultTypeInternal _RegisterTaskRequest_default_instance_;
class RegisterTaskResponse;
struct RegisterTaskResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern RegisterTaskResponseDefaultTypeInternal _RegisterTaskResponse_default_instance_;
class ReportErrorToServiceRequest;
struct ReportErrorToServiceRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern ReportErrorToServiceRequestDefaultTypeInternal _ReportErrorToServiceRequest_default_instance_;
class ReportErrorToServiceResponse;
struct ReportErrorToServiceResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern ReportErrorToServiceResponseDefaultTypeInternal _ReportErrorToServiceResponse_default_instance_;
class ReportErrorToTaskRequest;
struct ReportErrorToTaskRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern ReportErrorToTaskRequestDefaultTypeInternal _ReportErrorToTaskRequest_default_instance_;
class ReportErrorToTaskResponse;
struct ReportErrorToTaskResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern ReportErrorToTaskResponseDefaultTypeInternal _ReportErrorToTaskResponse_default_instance_;
class ResetTaskRequest;
struct ResetTaskRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern ResetTaskRequestDefaultTypeInternal _ResetTaskRequest_default_instance_;
class ResetTaskResponse;
struct ResetTaskResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern ResetTaskResponseDefaultTypeInternal _ResetTaskResponse_default_instance_;
class ShutdownTaskRequest;
struct ShutdownTaskRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern ShutdownTaskRequestDefaultTypeInternal _ShutdownTaskRequest_default_instance_;
class ShutdownTaskResponse;
struct ShutdownTaskResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern ShutdownTaskResponseDefaultTypeInternal _ShutdownTaskResponse_default_instance_;
class TryGetKeyValueRequest;
struct TryGetKeyValueRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern TryGetKeyValueRequestDefaultTypeInternal _TryGetKeyValueRequest_default_instance_;
class TryGetKeyValueResponse;
struct TryGetKeyValueResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern TryGetKeyValueResponseDefaultTypeInternal _TryGetKeyValueResponse_default_instance_;
class WaitForAllTasksRequest;
struct WaitForAllTasksRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern WaitForAllTasksRequestDefaultTypeInternal _WaitForAllTasksRequest_default_instance_;
class WaitForAllTasksResponse;
struct WaitForAllTasksResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern WaitForAllTasksResponseDefaultTypeInternal _WaitForAllTasksResponse_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {
enum CoordinatedTaskState : int {
  TASKSTATE_UNSPECIFIED = 0,
  TASKSTATE_UNINITIALIZED = 1,
  TASKSTATE_DISCONNECTED = 2,
  TASKSTATE_CONNECTED = 3,
  TASKSTATE_ERROR = 4,
  CoordinatedTaskState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CoordinatedTaskState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool CoordinatedTaskState_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t CoordinatedTaskState_internal_data_[];
constexpr CoordinatedTaskState CoordinatedTaskState_MIN = static_cast<CoordinatedTaskState>(0);
constexpr CoordinatedTaskState CoordinatedTaskState_MAX = static_cast<CoordinatedTaskState>(4);
constexpr int CoordinatedTaskState_ARRAYSIZE = 4 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
CoordinatedTaskState_descriptor();
template <typename T>
const std::string& CoordinatedTaskState_Name(T value) {
  static_assert(std::is_same<T, CoordinatedTaskState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CoordinatedTaskState_Name().");
  return CoordinatedTaskState_Name(static_cast<CoordinatedTaskState>(value));
}
template <>
inline const std::string& CoordinatedTaskState_Name(CoordinatedTaskState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CoordinatedTaskState_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool CoordinatedTaskState_Parse(absl::string_view name, CoordinatedTaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoordinatedTaskState>(
      CoordinatedTaskState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT TryGetKeyValueRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TryGetKeyValueRequest) */ {
 public:
  inline TryGetKeyValueRequest() : TryGetKeyValueRequest(nullptr) {}
  ~TryGetKeyValueRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TryGetKeyValueRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline TryGetKeyValueRequest(const TryGetKeyValueRequest& from) : TryGetKeyValueRequest(nullptr, from) {}
  inline TryGetKeyValueRequest(TryGetKeyValueRequest&& from) noexcept
      : TryGetKeyValueRequest(nullptr, std::move(from)) {}
  inline TryGetKeyValueRequest& operator=(const TryGetKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryGetKeyValueRequest& operator=(TryGetKeyValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TryGetKeyValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TryGetKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const TryGetKeyValueRequest*>(
        &_TryGetKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(TryGetKeyValueRequest& a, TryGetKeyValueRequest& b) { a.Swap(&b); }
  inline void Swap(TryGetKeyValueRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TryGetKeyValueRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TryGetKeyValueRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TryGetKeyValueRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TryGetKeyValueRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TryGetKeyValueRequest& from) { TryGetKeyValueRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TryGetKeyValueRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TryGetKeyValueRequest"; }

 protected:
  explicit TryGetKeyValueRequest(::google::protobuf::Arena* arena);
  TryGetKeyValueRequest(::google::protobuf::Arena* arena, const TryGetKeyValueRequest& from);
  TryGetKeyValueRequest(::google::protobuf::Arena* arena, TryGetKeyValueRequest&& from) noexcept
      : TryGetKeyValueRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.TryGetKeyValueRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      44, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TryGetKeyValueRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ShutdownTaskResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.ShutdownTaskResponse) */ {
 public:
  inline ShutdownTaskResponse() : ShutdownTaskResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShutdownTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ShutdownTaskResponse(const ShutdownTaskResponse& from) : ShutdownTaskResponse(nullptr, from) {}
  inline ShutdownTaskResponse(ShutdownTaskResponse&& from) noexcept
      : ShutdownTaskResponse(nullptr, std::move(from)) {}
  inline ShutdownTaskResponse& operator=(const ShutdownTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownTaskResponse& operator=(ShutdownTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ShutdownTaskResponse*>(
        &_ShutdownTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ShutdownTaskResponse& a, ShutdownTaskResponse& b) { a.Swap(&b); }
  inline void Swap(ShutdownTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ShutdownTaskResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShutdownTaskResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShutdownTaskResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ShutdownTaskResponse"; }

 protected:
  explicit ShutdownTaskResponse(::google::protobuf::Arena* arena);
  ShutdownTaskResponse(::google::protobuf::Arena* arena, const ShutdownTaskResponse& from);
  ShutdownTaskResponse(::google::protobuf::Arena* arena, ShutdownTaskResponse&& from) noexcept
      : ShutdownTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.ShutdownTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ShutdownTaskResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ResetTaskResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.ResetTaskResponse) */ {
 public:
  inline ResetTaskResponse() : ResetTaskResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResetTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResetTaskResponse(const ResetTaskResponse& from) : ResetTaskResponse(nullptr, from) {}
  inline ResetTaskResponse(ResetTaskResponse&& from) noexcept
      : ResetTaskResponse(nullptr, std::move(from)) {}
  inline ResetTaskResponse& operator=(const ResetTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetTaskResponse& operator=(ResetTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ResetTaskResponse*>(
        &_ResetTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ResetTaskResponse& a, ResetTaskResponse& b) { a.Swap(&b); }
  inline void Swap(ResetTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ResetTaskResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetTaskResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetTaskResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ResetTaskResponse"; }

 protected:
  explicit ResetTaskResponse(::google::protobuf::Arena* arena);
  ResetTaskResponse(::google::protobuf::Arena* arena, const ResetTaskResponse& from);
  ResetTaskResponse(::google::protobuf::Arena* arena, ResetTaskResponse&& from) noexcept
      : ResetTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.ResetTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResetTaskResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ReportErrorToTaskResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToTaskResponse) */ {
 public:
  inline ReportErrorToTaskResponse() : ReportErrorToTaskResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportErrorToTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportErrorToTaskResponse(const ReportErrorToTaskResponse& from) : ReportErrorToTaskResponse(nullptr, from) {}
  inline ReportErrorToTaskResponse(ReportErrorToTaskResponse&& from) noexcept
      : ReportErrorToTaskResponse(nullptr, std::move(from)) {}
  inline ReportErrorToTaskResponse& operator=(const ReportErrorToTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportErrorToTaskResponse& operator=(ReportErrorToTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportErrorToTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportErrorToTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToTaskResponse*>(
        &_ReportErrorToTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ReportErrorToTaskResponse& a, ReportErrorToTaskResponse& b) { a.Swap(&b); }
  inline void Swap(ReportErrorToTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportErrorToTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportErrorToTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ReportErrorToTaskResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportErrorToTaskResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportErrorToTaskResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ReportErrorToTaskResponse"; }

 protected:
  explicit ReportErrorToTaskResponse(::google::protobuf::Arena* arena);
  ReportErrorToTaskResponse(::google::protobuf::Arena* arena, const ReportErrorToTaskResponse& from);
  ReportErrorToTaskResponse(::google::protobuf::Arena* arena, ReportErrorToTaskResponse&& from) noexcept
      : ReportErrorToTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReportErrorToTaskResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ReportErrorToServiceResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToServiceResponse) */ {
 public:
  inline ReportErrorToServiceResponse() : ReportErrorToServiceResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportErrorToServiceResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportErrorToServiceResponse(const ReportErrorToServiceResponse& from) : ReportErrorToServiceResponse(nullptr, from) {}
  inline ReportErrorToServiceResponse(ReportErrorToServiceResponse&& from) noexcept
      : ReportErrorToServiceResponse(nullptr, std::move(from)) {}
  inline ReportErrorToServiceResponse& operator=(const ReportErrorToServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportErrorToServiceResponse& operator=(ReportErrorToServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportErrorToServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportErrorToServiceResponse* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToServiceResponse*>(
        &_ReportErrorToServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ReportErrorToServiceResponse& a, ReportErrorToServiceResponse& b) { a.Swap(&b); }
  inline void Swap(ReportErrorToServiceResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportErrorToServiceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportErrorToServiceResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ReportErrorToServiceResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportErrorToServiceResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportErrorToServiceResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ReportErrorToServiceResponse"; }

 protected:
  explicit ReportErrorToServiceResponse(::google::protobuf::Arena* arena);
  ReportErrorToServiceResponse(::google::protobuf::Arena* arena, const ReportErrorToServiceResponse& from);
  ReportErrorToServiceResponse(::google::protobuf::Arena* arena, ReportErrorToServiceResponse&& from) noexcept
      : ReportErrorToServiceResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToServiceResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReportErrorToServiceResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT RegisterTaskResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.RegisterTaskResponse) */ {
 public:
  inline RegisterTaskResponse() : RegisterTaskResponse(nullptr) {}
  ~RegisterTaskResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterTaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterTaskResponse(const RegisterTaskResponse& from) : RegisterTaskResponse(nullptr, from) {}
  inline RegisterTaskResponse(RegisterTaskResponse&& from) noexcept
      : RegisterTaskResponse(nullptr, std::move(from)) {}
  inline RegisterTaskResponse& operator=(const RegisterTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterTaskResponse& operator=(RegisterTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterTaskResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterTaskResponse*>(
        &_RegisterTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(RegisterTaskResponse& a, RegisterTaskResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterTaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterTaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterTaskResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RegisterTaskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterTaskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterTaskResponse& from) { RegisterTaskResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterTaskResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.RegisterTaskResponse"; }

 protected:
  explicit RegisterTaskResponse(::google::protobuf::Arena* arena);
  RegisterTaskResponse(::google::protobuf::Arena* arena, const RegisterTaskResponse& from);
  RegisterTaskResponse(::google::protobuf::Arena* arena, RegisterTaskResponse&& from) noexcept
      : RegisterTaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLeaderIncarnationFieldNumber = 1,
  };
  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation() ;
  ::uint64_t leader_incarnation() const;
  void set_leader_incarnation(::uint64_t value);

  private:
  ::uint64_t _internal_leader_incarnation() const;
  void _internal_set_leader_incarnation(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.RegisterTaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterTaskResponse& from_msg);
    ::uint64_t leader_incarnation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PollForErrorResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.PollForErrorResponse) */ {
 public:
  inline PollForErrorResponse() : PollForErrorResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PollForErrorResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PollForErrorResponse(const PollForErrorResponse& from) : PollForErrorResponse(nullptr, from) {}
  inline PollForErrorResponse(PollForErrorResponse&& from) noexcept
      : PollForErrorResponse(nullptr, std::move(from)) {}
  inline PollForErrorResponse& operator=(const PollForErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollForErrorResponse& operator=(PollForErrorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollForErrorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PollForErrorResponse* internal_default_instance() {
    return reinterpret_cast<const PollForErrorResponse*>(
        &_PollForErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PollForErrorResponse& a, PollForErrorResponse& b) { a.Swap(&b); }
  inline void Swap(PollForErrorResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollForErrorResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollForErrorResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<PollForErrorResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PollForErrorResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PollForErrorResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.PollForErrorResponse"; }

 protected:
  explicit PollForErrorResponse(::google::protobuf::Arena* arena);
  PollForErrorResponse(::google::protobuf::Arena* arena, const PollForErrorResponse& from);
  PollForErrorResponse(::google::protobuf::Arena* arena, PollForErrorResponse&& from) noexcept
      : PollForErrorResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.PollForErrorResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PollForErrorResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT KeyValueEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.KeyValueEntry) */ {
 public:
  inline KeyValueEntry() : KeyValueEntry(nullptr) {}
  ~KeyValueEntry() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyValueEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyValueEntry(const KeyValueEntry& from) : KeyValueEntry(nullptr, from) {}
  inline KeyValueEntry(KeyValueEntry&& from) noexcept
      : KeyValueEntry(nullptr, std::move(from)) {}
  inline KeyValueEntry& operator=(const KeyValueEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValueEntry& operator=(KeyValueEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValueEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValueEntry* internal_default_instance() {
    return reinterpret_cast<const KeyValueEntry*>(
        &_KeyValueEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(KeyValueEntry& a, KeyValueEntry& b) { a.Swap(&b); }
  inline void Swap(KeyValueEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValueEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValueEntry* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KeyValueEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyValueEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyValueEntry& from) { KeyValueEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyValueEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.KeyValueEntry"; }

 protected:
  explicit KeyValueEntry(::google::protobuf::Arena* arena);
  KeyValueEntry(::google::protobuf::Arena* arena, const KeyValueEntry& from);
  KeyValueEntry(::google::protobuf::Arena* arena, KeyValueEntry&& from) noexcept
      : KeyValueEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.KeyValueEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyValueEntry& from_msg);
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT InsertKeyValueResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.InsertKeyValueResponse) */ {
 public:
  inline InsertKeyValueResponse() : InsertKeyValueResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InsertKeyValueResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline InsertKeyValueResponse(const InsertKeyValueResponse& from) : InsertKeyValueResponse(nullptr, from) {}
  inline InsertKeyValueResponse(InsertKeyValueResponse&& from) noexcept
      : InsertKeyValueResponse(nullptr, std::move(from)) {}
  inline InsertKeyValueResponse& operator=(const InsertKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertKeyValueResponse& operator=(InsertKeyValueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertKeyValueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const InsertKeyValueResponse*>(
        &_InsertKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(InsertKeyValueResponse& a, InsertKeyValueResponse& b) { a.Swap(&b); }
  inline void Swap(InsertKeyValueResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertKeyValueResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertKeyValueResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InsertKeyValueResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InsertKeyValueResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InsertKeyValueResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.InsertKeyValueResponse"; }

 protected:
  explicit InsertKeyValueResponse(::google::protobuf::Arena* arena);
  InsertKeyValueResponse(::google::protobuf::Arena* arena, const InsertKeyValueResponse& from);
  InsertKeyValueResponse(::google::protobuf::Arena* arena, InsertKeyValueResponse&& from) noexcept
      : InsertKeyValueResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.InsertKeyValueResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InsertKeyValueResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT HeartbeatResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeartbeatResponse(const HeartbeatResponse& from) : HeartbeatResponse(nullptr, from) {}
  inline HeartbeatResponse(HeartbeatResponse&& from) noexcept
      : HeartbeatResponse(nullptr, std::move(from)) {}
  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
        &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) { a.Swap(&b); }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<HeartbeatResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeartbeatResponse& from) { HeartbeatResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeartbeatResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.HeartbeatResponse"; }

 protected:
  explicit HeartbeatResponse(::google::protobuf::Arena* arena);
  HeartbeatResponse(::google::protobuf::Arena* arena, const HeartbeatResponse& from);
  HeartbeatResponse(::google::protobuf::Arena* arena, HeartbeatResponse&& from) noexcept
      : HeartbeatResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLeaderIncarnationFieldNumber = 1,
  };
  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation() ;
  ::uint64_t leader_incarnation() const;
  void set_leader_incarnation(::uint64_t value);

  private:
  ::uint64_t _internal_leader_incarnation() const;
  void _internal_set_leader_incarnation(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.HeartbeatResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeartbeatResponse& from_msg);
    ::uint64_t leader_incarnation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetKeyValueRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueRequest) */ {
 public:
  inline GetKeyValueRequest() : GetKeyValueRequest(nullptr) {}
  ~GetKeyValueRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetKeyValueRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetKeyValueRequest(const GetKeyValueRequest& from) : GetKeyValueRequest(nullptr, from) {}
  inline GetKeyValueRequest(GetKeyValueRequest&& from) noexcept
      : GetKeyValueRequest(nullptr, std::move(from)) {}
  inline GetKeyValueRequest& operator=(const GetKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyValueRequest& operator=(GetKeyValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKeyValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueRequest*>(
        &_GetKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(GetKeyValueRequest& a, GetKeyValueRequest& b) { a.Swap(&b); }
  inline void Swap(GetKeyValueRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKeyValueRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKeyValueRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetKeyValueRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetKeyValueRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetKeyValueRequest& from) { GetKeyValueRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetKeyValueRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetKeyValueRequest"; }

 protected:
  explicit GetKeyValueRequest(::google::protobuf::Arena* arena);
  GetKeyValueRequest(::google::protobuf::Arena* arena, const GetKeyValueRequest& from);
  GetKeyValueRequest(::google::protobuf::Arena* arena, GetKeyValueRequest&& from) noexcept
      : GetKeyValueRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetKeyValueRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetKeyValueDirRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueDirRequest) */ {
 public:
  inline GetKeyValueDirRequest() : GetKeyValueDirRequest(nullptr) {}
  ~GetKeyValueDirRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetKeyValueDirRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetKeyValueDirRequest(const GetKeyValueDirRequest& from) : GetKeyValueDirRequest(nullptr, from) {}
  inline GetKeyValueDirRequest(GetKeyValueDirRequest&& from) noexcept
      : GetKeyValueDirRequest(nullptr, std::move(from)) {}
  inline GetKeyValueDirRequest& operator=(const GetKeyValueDirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyValueDirRequest& operator=(GetKeyValueDirRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKeyValueDirRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKeyValueDirRequest* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueDirRequest*>(
        &_GetKeyValueDirRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(GetKeyValueDirRequest& a, GetKeyValueDirRequest& b) { a.Swap(&b); }
  inline void Swap(GetKeyValueDirRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKeyValueDirRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKeyValueDirRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetKeyValueDirRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetKeyValueDirRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetKeyValueDirRequest& from) { GetKeyValueDirRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetKeyValueDirRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetKeyValueDirRequest"; }

 protected:
  explicit GetKeyValueDirRequest(::google::protobuf::Arena* arena);
  GetKeyValueDirRequest(::google::protobuf::Arena* arena, const GetKeyValueDirRequest& from);
  GetKeyValueDirRequest(::google::protobuf::Arena* arena, GetKeyValueDirRequest&& from) noexcept
      : GetKeyValueDirRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDirectoryKeyFieldNumber = 1,
  };
  // string directory_key = 1;
  void clear_directory_key() ;
  const std::string& directory_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_directory_key(Arg_&& arg, Args_... args);
  std::string* mutable_directory_key();
  PROTOBUF_NODISCARD std::string* release_directory_key();
  void set_allocated_directory_key(std::string* value);

  private:
  const std::string& _internal_directory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory_key(
      const std::string& value);
  std::string* _internal_mutable_directory_key();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueDirRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      54, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetKeyValueDirRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr directory_key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetJobStateRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetJobStateRequest) */ {
 public:
  inline GetJobStateRequest() : GetJobStateRequest(nullptr) {}
  ~GetJobStateRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetJobStateRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetJobStateRequest(const GetJobStateRequest& from) : GetJobStateRequest(nullptr, from) {}
  inline GetJobStateRequest(GetJobStateRequest&& from) noexcept
      : GetJobStateRequest(nullptr, std::move(from)) {}
  inline GetJobStateRequest& operator=(const GetJobStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetJobStateRequest& operator=(GetJobStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetJobStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetJobStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetJobStateRequest*>(
        &_GetJobStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(GetJobStateRequest& a, GetJobStateRequest& b) { a.Swap(&b); }
  inline void Swap(GetJobStateRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetJobStateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetJobStateRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetJobStateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetJobStateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetJobStateRequest& from) { GetJobStateRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetJobStateRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetJobStateRequest"; }

 protected:
  explicit GetJobStateRequest(::google::protobuf::Arena* arena);
  GetJobStateRequest(::google::protobuf::Arena* arena, const GetJobStateRequest& from);
  GetJobStateRequest(::google::protobuf::Arena* arena, GetJobStateRequest&& from) noexcept
      : GetJobStateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJobNameFieldNumber = 1,
  };
  // string job_name = 1;
  void clear_job_name() ;
  const std::string& job_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_name(Arg_&& arg, Args_... args);
  std::string* mutable_job_name();
  PROTOBUF_NODISCARD std::string* release_job_name();
  void set_allocated_job_name(std::string* value);

  private:
  const std::string& _internal_job_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_name(
      const std::string& value);
  std::string* _internal_mutable_job_name();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GetJobStateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetJobStateRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr job_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DeleteKeyValueResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.DeleteKeyValueResponse) */ {
 public:
  inline DeleteKeyValueResponse() : DeleteKeyValueResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteKeyValueResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteKeyValueResponse(const DeleteKeyValueResponse& from) : DeleteKeyValueResponse(nullptr, from) {}
  inline DeleteKeyValueResponse(DeleteKeyValueResponse&& from) noexcept
      : DeleteKeyValueResponse(nullptr, std::move(from)) {}
  inline DeleteKeyValueResponse& operator=(const DeleteKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyValueResponse& operator=(DeleteKeyValueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteKeyValueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyValueResponse*>(
        &_DeleteKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(DeleteKeyValueResponse& a, DeleteKeyValueResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteKeyValueResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKeyValueResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteKeyValueResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeleteKeyValueResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteKeyValueResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteKeyValueResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.DeleteKeyValueResponse"; }

 protected:
  explicit DeleteKeyValueResponse(::google::protobuf::Arena* arena);
  DeleteKeyValueResponse(::google::protobuf::Arena* arena, const DeleteKeyValueResponse& from);
  DeleteKeyValueResponse(::google::protobuf::Arena* arena, DeleteKeyValueResponse&& from) noexcept
      : DeleteKeyValueResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.DeleteKeyValueResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteKeyValueResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DeleteKeyValueRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.DeleteKeyValueRequest) */ {
 public:
  inline DeleteKeyValueRequest() : DeleteKeyValueRequest(nullptr) {}
  ~DeleteKeyValueRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteKeyValueRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteKeyValueRequest(const DeleteKeyValueRequest& from) : DeleteKeyValueRequest(nullptr, from) {}
  inline DeleteKeyValueRequest(DeleteKeyValueRequest&& from) noexcept
      : DeleteKeyValueRequest(nullptr, std::move(from)) {}
  inline DeleteKeyValueRequest& operator=(const DeleteKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyValueRequest& operator=(DeleteKeyValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteKeyValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyValueRequest*>(
        &_DeleteKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(DeleteKeyValueRequest& a, DeleteKeyValueRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteKeyValueRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKeyValueRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteKeyValueRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DeleteKeyValueRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteKeyValueRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteKeyValueRequest& from) { DeleteKeyValueRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeleteKeyValueRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.DeleteKeyValueRequest"; }

 protected:
  explicit DeleteKeyValueRequest(::google::protobuf::Arena* arena);
  DeleteKeyValueRequest(::google::protobuf::Arena* arena, const DeleteKeyValueRequest& from);
  DeleteKeyValueRequest(::google::protobuf::Arena* arena, DeleteKeyValueRequest&& from) noexcept
      : DeleteKeyValueRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kIsDirectoryFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bool is_directory = 2;
  void clear_is_directory() ;
  bool is_directory() const;
  void set_is_directory(bool value);

  private:
  bool _internal_is_directory() const;
  void _internal_set_is_directory(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.DeleteKeyValueRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteKeyValueRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr key_;
    bool is_directory_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CoordinatedTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CoordinatedTask) */ {
 public:
  inline CoordinatedTask() : CoordinatedTask(nullptr) {}
  ~CoordinatedTask() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CoordinatedTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline CoordinatedTask(const CoordinatedTask& from) : CoordinatedTask(nullptr, from) {}
  inline CoordinatedTask(CoordinatedTask&& from) noexcept
      : CoordinatedTask(nullptr, std::move(from)) {}
  inline CoordinatedTask& operator=(const CoordinatedTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinatedTask& operator=(CoordinatedTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordinatedTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoordinatedTask* internal_default_instance() {
    return reinterpret_cast<const CoordinatedTask*>(
        &_CoordinatedTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CoordinatedTask& a, CoordinatedTask& b) { a.Swap(&b); }
  inline void Swap(CoordinatedTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordinatedTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoordinatedTask* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CoordinatedTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CoordinatedTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CoordinatedTask& from) { CoordinatedTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CoordinatedTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CoordinatedTask"; }

 protected:
  explicit CoordinatedTask(::google::protobuf::Arena* arena);
  CoordinatedTask(::google::protobuf::Arena* arena, const CoordinatedTask& from);
  CoordinatedTask(::google::protobuf::Arena* arena, CoordinatedTask&& from) noexcept
      : CoordinatedTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJobNameFieldNumber = 1,
    kTaskIdFieldNumber = 2,
    kRecoverableFieldNumber = 3,
  };
  // string job_name = 1;
  void clear_job_name() ;
  const std::string& job_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_name(Arg_&& arg, Args_... args);
  std::string* mutable_job_name();
  PROTOBUF_NODISCARD std::string* release_job_name();
  void set_allocated_job_name(std::string* value);

  private:
  const std::string& _internal_job_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_name(
      const std::string& value);
  std::string* _internal_mutable_job_name();

  public:
  // int32 task_id = 2;
  void clear_task_id() ;
  ::int32_t task_id() const;
  void set_task_id(::int32_t value);

  private:
  ::int32_t _internal_task_id() const;
  void _internal_set_task_id(::int32_t value);

  public:
  // bool recoverable = 3;
  void clear_recoverable() ;
  bool recoverable() const;
  void set_recoverable(bool value);

  private:
  bool _internal_recoverable() const;
  void _internal_set_recoverable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CoordinatedTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      43, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CoordinatedTask& from_msg);
    ::google::protobuf::internal::ArenaStringPtr job_name_;
    ::int32_t task_id_;
    bool recoverable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CancelBarrierResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.CancelBarrierResponse) */ {
 public:
  inline CancelBarrierResponse() : CancelBarrierResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelBarrierResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelBarrierResponse(const CancelBarrierResponse& from) : CancelBarrierResponse(nullptr, from) {}
  inline CancelBarrierResponse(CancelBarrierResponse&& from) noexcept
      : CancelBarrierResponse(nullptr, std::move(from)) {}
  inline CancelBarrierResponse& operator=(const CancelBarrierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelBarrierResponse& operator=(CancelBarrierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelBarrierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelBarrierResponse* internal_default_instance() {
    return reinterpret_cast<const CancelBarrierResponse*>(
        &_CancelBarrierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(CancelBarrierResponse& a, CancelBarrierResponse& b) { a.Swap(&b); }
  inline void Swap(CancelBarrierResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelBarrierResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelBarrierResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CancelBarrierResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CancelBarrierResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CancelBarrierResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CancelBarrierResponse"; }

 protected:
  explicit CancelBarrierResponse(::google::protobuf::Arena* arena);
  CancelBarrierResponse(::google::protobuf::Arena* arena, const CancelBarrierResponse& from);
  CancelBarrierResponse(::google::protobuf::Arena* arena, CancelBarrierResponse&& from) noexcept
      : CancelBarrierResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.CancelBarrierResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelBarrierResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BarrierResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.BarrierResponse) */ {
 public:
  inline BarrierResponse() : BarrierResponse(nullptr) {}
  ~BarrierResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BarrierResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline BarrierResponse(const BarrierResponse& from) : BarrierResponse(nullptr, from) {}
  inline BarrierResponse(BarrierResponse&& from) noexcept
      : BarrierResponse(nullptr, std::move(from)) {}
  inline BarrierResponse& operator=(const BarrierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarrierResponse& operator=(BarrierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BarrierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BarrierResponse* internal_default_instance() {
    return reinterpret_cast<const BarrierResponse*>(
        &_BarrierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(BarrierResponse& a, BarrierResponse& b) { a.Swap(&b); }
  inline void Swap(BarrierResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BarrierResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BarrierResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BarrierResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BarrierResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BarrierResponse& from) { BarrierResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BarrierResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.BarrierResponse"; }

 protected:
  explicit BarrierResponse(::google::protobuf::Arena* arena);
  BarrierResponse(::google::protobuf::Arena* arena, const BarrierResponse& from);
  BarrierResponse(::google::protobuf::Arena* arena, BarrierResponse&& from) noexcept
      : BarrierResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCounterFieldNumber = 1,
  };
  // int64 counter = 1;
  void clear_counter() ;
  ::int64_t counter() const;
  void set_counter(::int64_t value);

  private:
  ::int64_t _internal_counter() const;
  void _internal_set_counter(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.BarrierResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BarrierResponse& from_msg);
    ::int64_t counter_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BarrierError final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.BarrierError) */ {
 public:
  inline BarrierError() : BarrierError(nullptr) {}
  ~BarrierError() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BarrierError(
      ::google::protobuf::internal::ConstantInitialized);

  inline BarrierError(const BarrierError& from) : BarrierError(nullptr, from) {}
  inline BarrierError(BarrierError&& from) noexcept
      : BarrierError(nullptr, std::move(from)) {}
  inline BarrierError& operator=(const BarrierError& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarrierError& operator=(BarrierError&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BarrierError& default_instance() {
    return *internal_default_instance();
  }
  static inline const BarrierError* internal_default_instance() {
    return reinterpret_cast<const BarrierError*>(
        &_BarrierError_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(BarrierError& a, BarrierError& b) { a.Swap(&b); }
  inline void Swap(BarrierError* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BarrierError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BarrierError* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BarrierError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BarrierError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BarrierError& from) { BarrierError::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BarrierError* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.BarrierError"; }

 protected:
  explicit BarrierError(::google::protobuf::Arena* arena);
  BarrierError(::google::protobuf::Arena* arena, const BarrierError& from);
  BarrierError(::google::protobuf::Arena* arena, BarrierError&& from) noexcept
      : BarrierError(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBarrierIdFieldNumber = 1,
    kCounterFieldNumber = 2,
  };
  // string barrier_id = 1;
  void clear_barrier_id() ;
  const std::string& barrier_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_barrier_id(Arg_&& arg, Args_... args);
  std::string* mutable_barrier_id();
  PROTOBUF_NODISCARD std::string* release_barrier_id();
  void set_allocated_barrier_id(std::string* value);

  private:
  const std::string& _internal_barrier_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_barrier_id(
      const std::string& value);
  std::string* _internal_mutable_barrier_id();

  public:
  // int64 counter = 2;
  void clear_counter() ;
  ::int64_t counter() const;
  void set_counter(::int64_t value);

  private:
  ::int64_t _internal_counter() const;
  void _internal_set_counter(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.BarrierError)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BarrierError& from_msg);
    ::google::protobuf::internal::ArenaStringPtr barrier_id_;
    ::int64_t counter_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TryGetKeyValueResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TryGetKeyValueResponse) */ {
 public:
  inline TryGetKeyValueResponse() : TryGetKeyValueResponse(nullptr) {}
  ~TryGetKeyValueResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TryGetKeyValueResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline TryGetKeyValueResponse(const TryGetKeyValueResponse& from) : TryGetKeyValueResponse(nullptr, from) {}
  inline TryGetKeyValueResponse(TryGetKeyValueResponse&& from) noexcept
      : TryGetKeyValueResponse(nullptr, std::move(from)) {}
  inline TryGetKeyValueResponse& operator=(const TryGetKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryGetKeyValueResponse& operator=(TryGetKeyValueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TryGetKeyValueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TryGetKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const TryGetKeyValueResponse*>(
        &_TryGetKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(TryGetKeyValueResponse& a, TryGetKeyValueResponse& b) { a.Swap(&b); }
  inline void Swap(TryGetKeyValueResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TryGetKeyValueResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TryGetKeyValueResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TryGetKeyValueResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TryGetKeyValueResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TryGetKeyValueResponse& from) { TryGetKeyValueResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TryGetKeyValueResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TryGetKeyValueResponse"; }

 protected:
  explicit TryGetKeyValueResponse(::google::protobuf::Arena* arena);
  TryGetKeyValueResponse(::google::protobuf::Arena* arena, const TryGetKeyValueResponse& from);
  TryGetKeyValueResponse(::google::protobuf::Arena* arena, TryGetKeyValueResponse&& from) noexcept
      : TryGetKeyValueResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKvFieldNumber = 1,
  };
  // .tensorflow.KeyValueEntry kv = 1;
  bool has_kv() const;
  void clear_kv() ;
  const ::tensorflow::KeyValueEntry& kv() const;
  PROTOBUF_NODISCARD ::tensorflow::KeyValueEntry* release_kv();
  ::tensorflow::KeyValueEntry* mutable_kv();
  void set_allocated_kv(::tensorflow::KeyValueEntry* value);
  void unsafe_arena_set_allocated_kv(::tensorflow::KeyValueEntry* value);
  ::tensorflow::KeyValueEntry* unsafe_arena_release_kv();

  private:
  const ::tensorflow::KeyValueEntry& _internal_kv() const;
  ::tensorflow::KeyValueEntry* _internal_mutable_kv();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.TryGetKeyValueResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TryGetKeyValueResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::KeyValueEntry* kv_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ShutdownTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ShutdownTaskRequest) */ {
 public:
  inline ShutdownTaskRequest() : ShutdownTaskRequest(nullptr) {}
  ~ShutdownTaskRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShutdownTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ShutdownTaskRequest(const ShutdownTaskRequest& from) : ShutdownTaskRequest(nullptr, from) {}
  inline ShutdownTaskRequest(ShutdownTaskRequest&& from) noexcept
      : ShutdownTaskRequest(nullptr, std::move(from)) {}
  inline ShutdownTaskRequest& operator=(const ShutdownTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownTaskRequest& operator=(ShutdownTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ShutdownTaskRequest*>(
        &_ShutdownTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ShutdownTaskRequest& a, ShutdownTaskRequest& b) { a.Swap(&b); }
  inline void Swap(ShutdownTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ShutdownTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShutdownTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ShutdownTaskRequest& from) { ShutdownTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ShutdownTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ShutdownTaskRequest"; }

 protected:
  explicit ShutdownTaskRequest(::google::protobuf::Arena* arena);
  ShutdownTaskRequest(::google::protobuf::Arena* arena, const ShutdownTaskRequest& from);
  ShutdownTaskRequest(::google::protobuf::Arena* arena, ShutdownTaskRequest&& from) noexcept
      : ShutdownTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTaskFieldNumber = 1,
  };
  // .tensorflow.CoordinatedTask source_task = 1;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ShutdownTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ShutdownTaskRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::CoordinatedTask* source_task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ResetTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ResetTaskRequest) */ {
 public:
  inline ResetTaskRequest() : ResetTaskRequest(nullptr) {}
  ~ResetTaskRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResetTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResetTaskRequest(const ResetTaskRequest& from) : ResetTaskRequest(nullptr, from) {}
  inline ResetTaskRequest(ResetTaskRequest&& from) noexcept
      : ResetTaskRequest(nullptr, std::move(from)) {}
  inline ResetTaskRequest& operator=(const ResetTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetTaskRequest& operator=(ResetTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ResetTaskRequest*>(
        &_ResetTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ResetTaskRequest& a, ResetTaskRequest& b) { a.Swap(&b); }
  inline void Swap(ResetTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ResetTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResetTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResetTaskRequest& from) { ResetTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResetTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ResetTaskRequest"; }

 protected:
  explicit ResetTaskRequest(::google::protobuf::Arena* arena);
  ResetTaskRequest(::google::protobuf::Arena* arena, const ResetTaskRequest& from);
  ResetTaskRequest(::google::protobuf::Arena* arena, ResetTaskRequest&& from) noexcept
      : ResetTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTaskFieldNumber = 1,
  };
  // .tensorflow.CoordinatedTask source_task = 1;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ResetTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResetTaskRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::CoordinatedTask* source_task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ReportErrorToServiceRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToServiceRequest) */ {
 public:
  inline ReportErrorToServiceRequest() : ReportErrorToServiceRequest(nullptr) {}
  ~ReportErrorToServiceRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportErrorToServiceRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportErrorToServiceRequest(const ReportErrorToServiceRequest& from) : ReportErrorToServiceRequest(nullptr, from) {}
  inline ReportErrorToServiceRequest(ReportErrorToServiceRequest&& from) noexcept
      : ReportErrorToServiceRequest(nullptr, std::move(from)) {}
  inline ReportErrorToServiceRequest& operator=(const ReportErrorToServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportErrorToServiceRequest& operator=(ReportErrorToServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportErrorToServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportErrorToServiceRequest* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToServiceRequest*>(
        &_ReportErrorToServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ReportErrorToServiceRequest& a, ReportErrorToServiceRequest& b) { a.Swap(&b); }
  inline void Swap(ReportErrorToServiceRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportErrorToServiceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportErrorToServiceRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ReportErrorToServiceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportErrorToServiceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportErrorToServiceRequest& from) { ReportErrorToServiceRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportErrorToServiceRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ReportErrorToServiceRequest"; }

 protected:
  explicit ReportErrorToServiceRequest(::google::protobuf::Arena* arena);
  ReportErrorToServiceRequest(::google::protobuf::Arena* arena, const ReportErrorToServiceRequest& from);
  ReportErrorToServiceRequest(::google::protobuf::Arena* arena, ReportErrorToServiceRequest&& from) noexcept
      : ReportErrorToServiceRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorOriginFieldNumber = 5,
    kErrorCodeFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .tensorflow.CoordinatedTask error_origin = 5;
  bool has_error_origin() const;
  void clear_error_origin() ;
  const ::tensorflow::CoordinatedTask& error_origin() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_error_origin();
  ::tensorflow::CoordinatedTask* mutable_error_origin();
  void set_allocated_error_origin(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_error_origin(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_error_origin();

  private:
  const ::tensorflow::CoordinatedTask& _internal_error_origin() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_error_origin();

  public:
  // int32 error_code = 1;
  void clear_error_code() ;
  ::int32_t error_code() const;
  void set_error_code(::int32_t value);

  private:
  ::int32_t _internal_error_code() const;
  void _internal_set_error_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToServiceRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      60, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReportErrorToServiceRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::tensorflow::CoordinatedTask* error_origin_;
    ::int32_t error_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT RegisterTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.RegisterTaskRequest) */ {
 public:
  inline RegisterTaskRequest() : RegisterTaskRequest(nullptr) {}
  ~RegisterTaskRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterTaskRequest(const RegisterTaskRequest& from) : RegisterTaskRequest(nullptr, from) {}
  inline RegisterTaskRequest(RegisterTaskRequest&& from) noexcept
      : RegisterTaskRequest(nullptr, std::move(from)) {}
  inline RegisterTaskRequest& operator=(const RegisterTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterTaskRequest& operator=(RegisterTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterTaskRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterTaskRequest*>(
        &_RegisterTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RegisterTaskRequest& a, RegisterTaskRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RegisterTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterTaskRequest& from) { RegisterTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.RegisterTaskRequest"; }

 protected:
  explicit RegisterTaskRequest(::google::protobuf::Arena* arena);
  RegisterTaskRequest(::google::protobuf::Arena* arena, const RegisterTaskRequest& from);
  RegisterTaskRequest(::google::protobuf::Arena* arena, RegisterTaskRequest&& from) noexcept
      : RegisterTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTaskFieldNumber = 5,
    kIncarnationFieldNumber = 3,
  };
  // .tensorflow.CoordinatedTask source_task = 5;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // fixed64 incarnation = 3;
  void clear_incarnation() ;
  ::uint64_t incarnation() const;
  void set_incarnation(::uint64_t value);

  private:
  ::uint64_t _internal_incarnation() const;
  void _internal_set_incarnation(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.RegisterTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterTaskRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::CoordinatedTask* source_task_;
    ::uint64_t incarnation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PollForErrorRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.PollForErrorRequest) */ {
 public:
  inline PollForErrorRequest() : PollForErrorRequest(nullptr) {}
  ~PollForErrorRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PollForErrorRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PollForErrorRequest(const PollForErrorRequest& from) : PollForErrorRequest(nullptr, from) {}
  inline PollForErrorRequest(PollForErrorRequest&& from) noexcept
      : PollForErrorRequest(nullptr, std::move(from)) {}
  inline PollForErrorRequest& operator=(const PollForErrorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollForErrorRequest& operator=(PollForErrorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollForErrorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PollForErrorRequest* internal_default_instance() {
    return reinterpret_cast<const PollForErrorRequest*>(
        &_PollForErrorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(PollForErrorRequest& a, PollForErrorRequest& b) { a.Swap(&b); }
  inline void Swap(PollForErrorRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollForErrorRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollForErrorRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PollForErrorRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PollForErrorRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PollForErrorRequest& from) { PollForErrorRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PollForErrorRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.PollForErrorRequest"; }

 protected:
  explicit PollForErrorRequest(::google::protobuf::Arena* arena);
  PollForErrorRequest(::google::protobuf::Arena* arena, const PollForErrorRequest& from);
  PollForErrorRequest(::google::protobuf::Arena* arena, PollForErrorRequest&& from) noexcept
      : PollForErrorRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTaskFieldNumber = 1,
  };
  // .tensorflow.CoordinatedTask source_task = 1;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.PollForErrorRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PollForErrorRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::CoordinatedTask* source_task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT InsertKeyValueRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.InsertKeyValueRequest) */ {
 public:
  inline InsertKeyValueRequest() : InsertKeyValueRequest(nullptr) {}
  ~InsertKeyValueRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InsertKeyValueRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline InsertKeyValueRequest(const InsertKeyValueRequest& from) : InsertKeyValueRequest(nullptr, from) {}
  inline InsertKeyValueRequest(InsertKeyValueRequest&& from) noexcept
      : InsertKeyValueRequest(nullptr, std::move(from)) {}
  inline InsertKeyValueRequest& operator=(const InsertKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertKeyValueRequest& operator=(InsertKeyValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertKeyValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const InsertKeyValueRequest*>(
        &_InsertKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(InsertKeyValueRequest& a, InsertKeyValueRequest& b) { a.Swap(&b); }
  inline void Swap(InsertKeyValueRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertKeyValueRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertKeyValueRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InsertKeyValueRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InsertKeyValueRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InsertKeyValueRequest& from) { InsertKeyValueRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InsertKeyValueRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.InsertKeyValueRequest"; }

 protected:
  explicit InsertKeyValueRequest(::google::protobuf::Arena* arena);
  InsertKeyValueRequest(::google::protobuf::Arena* arena, const InsertKeyValueRequest& from);
  InsertKeyValueRequest(::google::protobuf::Arena* arena, InsertKeyValueRequest&& from) noexcept
      : InsertKeyValueRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKvFieldNumber = 1,
    kAllowOverwriteFieldNumber = 2,
  };
  // .tensorflow.KeyValueEntry kv = 1;
  bool has_kv() const;
  void clear_kv() ;
  const ::tensorflow::KeyValueEntry& kv() const;
  PROTOBUF_NODISCARD ::tensorflow::KeyValueEntry* release_kv();
  ::tensorflow::KeyValueEntry* mutable_kv();
  void set_allocated_kv(::tensorflow::KeyValueEntry* value);
  void unsafe_arena_set_allocated_kv(::tensorflow::KeyValueEntry* value);
  ::tensorflow::KeyValueEntry* unsafe_arena_release_kv();

  private:
  const ::tensorflow::KeyValueEntry& _internal_kv() const;
  ::tensorflow::KeyValueEntry* _internal_mutable_kv();

  public:
  // bool allow_overwrite = 2;
  void clear_allow_overwrite() ;
  bool allow_overwrite() const;
  void set_allow_overwrite(bool value);

  private:
  bool _internal_allow_overwrite() const;
  void _internal_set_allow_overwrite(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.InsertKeyValueRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InsertKeyValueRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::KeyValueEntry* kv_;
    bool allow_overwrite_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT HeartbeatRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeartbeatRequest(const HeartbeatRequest& from) : HeartbeatRequest(nullptr, from) {}
  inline HeartbeatRequest(HeartbeatRequest&& from) noexcept
      : HeartbeatRequest(nullptr, std::move(from)) {}
  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
        &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) { a.Swap(&b); }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<HeartbeatRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeartbeatRequest& from) { HeartbeatRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeartbeatRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.HeartbeatRequest"; }

 protected:
  explicit HeartbeatRequest(::google::protobuf::Arena* arena);
  HeartbeatRequest(::google::protobuf::Arena* arena, const HeartbeatRequest& from);
  HeartbeatRequest(::google::protobuf::Arena* arena, HeartbeatRequest&& from) noexcept
      : HeartbeatRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTaskFieldNumber = 4,
    kIncarnationFieldNumber = 3,
  };
  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // fixed64 incarnation = 3;
  void clear_incarnation() ;
  ::uint64_t incarnation() const;
  void set_incarnation(::uint64_t value);

  private:
  ::uint64_t _internal_incarnation() const;
  void _internal_set_incarnation(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.HeartbeatRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeartbeatRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::CoordinatedTask* source_task_;
    ::uint64_t incarnation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetTaskStateRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetTaskStateRequest) */ {
 public:
  inline GetTaskStateRequest() : GetTaskStateRequest(nullptr) {}
  ~GetTaskStateRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTaskStateRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTaskStateRequest(const GetTaskStateRequest& from) : GetTaskStateRequest(nullptr, from) {}
  inline GetTaskStateRequest(GetTaskStateRequest&& from) noexcept
      : GetTaskStateRequest(nullptr, std::move(from)) {}
  inline GetTaskStateRequest& operator=(const GetTaskStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTaskStateRequest& operator=(GetTaskStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTaskStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTaskStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetTaskStateRequest*>(
        &_GetTaskStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(GetTaskStateRequest& a, GetTaskStateRequest& b) { a.Swap(&b); }
  inline void Swap(GetTaskStateRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTaskStateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTaskStateRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetTaskStateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTaskStateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTaskStateRequest& from) { GetTaskStateRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTaskStateRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetTaskStateRequest"; }

 protected:
  explicit GetTaskStateRequest(::google::protobuf::Arena* arena);
  GetTaskStateRequest(::google::protobuf::Arena* arena, const GetTaskStateRequest& from);
  GetTaskStateRequest(::google::protobuf::Arena* arena, GetTaskStateRequest&& from) noexcept
      : GetTaskStateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTaskFieldNumber = 1,
  };
  // repeated .tensorflow.CoordinatedTask source_task = 1;
  int source_task_size() const;
  private:
  int _internal_source_task_size() const;

  public:
  void clear_source_task() ;
  ::tensorflow::CoordinatedTask* mutable_source_task(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* mutable_source_task();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& _internal_source_task() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* _internal_mutable_source_task();
  public:
  const ::tensorflow::CoordinatedTask& source_task(int index) const;
  ::tensorflow::CoordinatedTask* add_source_task();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& source_task() const;
  // @@protoc_insertion_point(class_scope:tensorflow.GetTaskStateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTaskStateRequest& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask > source_task_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetKeyValueResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueResponse) */ {
 public:
  inline GetKeyValueResponse() : GetKeyValueResponse(nullptr) {}
  ~GetKeyValueResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetKeyValueResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetKeyValueResponse(const GetKeyValueResponse& from) : GetKeyValueResponse(nullptr, from) {}
  inline GetKeyValueResponse(GetKeyValueResponse&& from) noexcept
      : GetKeyValueResponse(nullptr, std::move(from)) {}
  inline GetKeyValueResponse& operator=(const GetKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyValueResponse& operator=(GetKeyValueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKeyValueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueResponse*>(
        &_GetKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(GetKeyValueResponse& a, GetKeyValueResponse& b) { a.Swap(&b); }
  inline void Swap(GetKeyValueResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKeyValueResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKeyValueResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetKeyValueResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetKeyValueResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetKeyValueResponse& from) { GetKeyValueResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetKeyValueResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetKeyValueResponse"; }

 protected:
  explicit GetKeyValueResponse(::google::protobuf::Arena* arena);
  GetKeyValueResponse(::google::protobuf::Arena* arena, const GetKeyValueResponse& from);
  GetKeyValueResponse(::google::protobuf::Arena* arena, GetKeyValueResponse&& from) noexcept
      : GetKeyValueResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKvFieldNumber = 1,
  };
  // .tensorflow.KeyValueEntry kv = 1;
  bool has_kv() const;
  void clear_kv() ;
  const ::tensorflow::KeyValueEntry& kv() const;
  PROTOBUF_NODISCARD ::tensorflow::KeyValueEntry* release_kv();
  ::tensorflow::KeyValueEntry* mutable_kv();
  void set_allocated_kv(::tensorflow::KeyValueEntry* value);
  void unsafe_arena_set_allocated_kv(::tensorflow::KeyValueEntry* value);
  ::tensorflow::KeyValueEntry* unsafe_arena_release_kv();

  private:
  const ::tensorflow::KeyValueEntry& _internal_kv() const;
  ::tensorflow::KeyValueEntry* _internal_mutable_kv();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetKeyValueResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::KeyValueEntry* kv_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetKeyValueDirResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueDirResponse) */ {
 public:
  inline GetKeyValueDirResponse() : GetKeyValueDirResponse(nullptr) {}
  ~GetKeyValueDirResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetKeyValueDirResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetKeyValueDirResponse(const GetKeyValueDirResponse& from) : GetKeyValueDirResponse(nullptr, from) {}
  inline GetKeyValueDirResponse(GetKeyValueDirResponse&& from) noexcept
      : GetKeyValueDirResponse(nullptr, std::move(from)) {}
  inline GetKeyValueDirResponse& operator=(const GetKeyValueDirResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyValueDirResponse& operator=(GetKeyValueDirResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKeyValueDirResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKeyValueDirResponse* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueDirResponse*>(
        &_GetKeyValueDirResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(GetKeyValueDirResponse& a, GetKeyValueDirResponse& b) { a.Swap(&b); }
  inline void Swap(GetKeyValueDirResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKeyValueDirResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKeyValueDirResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetKeyValueDirResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetKeyValueDirResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetKeyValueDirResponse& from) { GetKeyValueDirResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetKeyValueDirResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetKeyValueDirResponse"; }

 protected:
  explicit GetKeyValueDirResponse(::google::protobuf::Arena* arena);
  GetKeyValueDirResponse(::google::protobuf::Arena* arena, const GetKeyValueDirResponse& from);
  GetKeyValueDirResponse(::google::protobuf::Arena* arena, GetKeyValueDirResponse&& from) noexcept
      : GetKeyValueDirResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKvFieldNumber = 2,
    kDirectoryKeyFieldNumber = 1,
  };
  // repeated .tensorflow.KeyValueEntry kv = 2;
  int kv_size() const;
  private:
  int _internal_kv_size() const;

  public:
  void clear_kv() ;
  ::tensorflow::KeyValueEntry* mutable_kv(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::KeyValueEntry>* mutable_kv();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::KeyValueEntry>& _internal_kv() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::KeyValueEntry>* _internal_mutable_kv();
  public:
  const ::tensorflow::KeyValueEntry& kv(int index) const;
  ::tensorflow::KeyValueEntry* add_kv();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::KeyValueEntry>& kv() const;
  // string directory_key = 1;
  void clear_directory_key() ;
  const std::string& directory_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_directory_key(Arg_&& arg, Args_... args);
  std::string* mutable_directory_key();
  PROTOBUF_NODISCARD std::string* release_directory_key();
  void set_allocated_directory_key(std::string* value);

  private:
  const std::string& _internal_directory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory_key(
      const std::string& value);
  std::string* _internal_mutable_directory_key();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueDirResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      55, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetKeyValueDirResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::KeyValueEntry > kv_;
    ::google::protobuf::internal::ArenaStringPtr directory_key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetAliveTasksResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetAliveTasksResponse) */ {
 public:
  inline GetAliveTasksResponse() : GetAliveTasksResponse(nullptr) {}
  ~GetAliveTasksResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetAliveTasksResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetAliveTasksResponse(const GetAliveTasksResponse& from) : GetAliveTasksResponse(nullptr, from) {}
  inline GetAliveTasksResponse(GetAliveTasksResponse&& from) noexcept
      : GetAliveTasksResponse(nullptr, std::move(from)) {}
  inline GetAliveTasksResponse& operator=(const GetAliveTasksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAliveTasksResponse& operator=(GetAliveTasksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAliveTasksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAliveTasksResponse* internal_default_instance() {
    return reinterpret_cast<const GetAliveTasksResponse*>(
        &_GetAliveTasksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(GetAliveTasksResponse& a, GetAliveTasksResponse& b) { a.Swap(&b); }
  inline void Swap(GetAliveTasksResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAliveTasksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAliveTasksResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetAliveTasksResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAliveTasksResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetAliveTasksResponse& from) { GetAliveTasksResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetAliveTasksResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetAliveTasksResponse"; }

 protected:
  explicit GetAliveTasksResponse(::google::protobuf::Arena* arena);
  GetAliveTasksResponse(::google::protobuf::Arena* arena, const GetAliveTasksResponse& from);
  GetAliveTasksResponse(::google::protobuf::Arena* arena, GetAliveTasksResponse&& from) noexcept
      : GetAliveTasksResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAliveTasksFieldNumber = 1,
    kIncarnationsFieldNumber = 2,
  };
  // repeated .tensorflow.CoordinatedTask alive_tasks = 1;
  int alive_tasks_size() const;
  private:
  int _internal_alive_tasks_size() const;

  public:
  void clear_alive_tasks() ;
  ::tensorflow::CoordinatedTask* mutable_alive_tasks(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* mutable_alive_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& _internal_alive_tasks() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* _internal_mutable_alive_tasks();
  public:
  const ::tensorflow::CoordinatedTask& alive_tasks(int index) const;
  ::tensorflow::CoordinatedTask* add_alive_tasks();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& alive_tasks() const;
  // repeated fixed64 incarnations = 2;
  int incarnations_size() const;
  private:
  int _internal_incarnations_size() const;

  public:
  void clear_incarnations() ;
  ::uint64_t incarnations(int index) const;
  void set_incarnations(int index, ::uint64_t value);
  void add_incarnations(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& incarnations() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_incarnations();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_incarnations() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_incarnations();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GetAliveTasksResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetAliveTasksResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask > alive_tasks_;
    ::google::protobuf::RepeatedField<::uint64_t> incarnations_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetAliveTasksRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetAliveTasksRequest) */ {
 public:
  inline GetAliveTasksRequest() : GetAliveTasksRequest(nullptr) {}
  ~GetAliveTasksRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetAliveTasksRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetAliveTasksRequest(const GetAliveTasksRequest& from) : GetAliveTasksRequest(nullptr, from) {}
  inline GetAliveTasksRequest(GetAliveTasksRequest&& from) noexcept
      : GetAliveTasksRequest(nullptr, std::move(from)) {}
  inline GetAliveTasksRequest& operator=(const GetAliveTasksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAliveTasksRequest& operator=(GetAliveTasksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAliveTasksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAliveTasksRequest* internal_default_instance() {
    return reinterpret_cast<const GetAliveTasksRequest*>(
        &_GetAliveTasksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(GetAliveTasksRequest& a, GetAliveTasksRequest& b) { a.Swap(&b); }
  inline void Swap(GetAliveTasksRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAliveTasksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAliveTasksRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetAliveTasksRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAliveTasksRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetAliveTasksRequest& from) { GetAliveTasksRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetAliveTasksRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetAliveTasksRequest"; }

 protected:
  explicit GetAliveTasksRequest(::google::protobuf::Arena* arena);
  GetAliveTasksRequest(::google::protobuf::Arena* arena, const GetAliveTasksRequest& from);
  GetAliveTasksRequest(::google::protobuf::Arena* arena, GetAliveTasksRequest&& from) noexcept
      : GetAliveTasksRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTasksFieldNumber = 2,
    kRequestingTaskFieldNumber = 1,
  };
  // repeated .tensorflow.CoordinatedTask tasks = 2;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  ::tensorflow::CoordinatedTask* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* mutable_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* _internal_mutable_tasks();
  public:
  const ::tensorflow::CoordinatedTask& tasks(int index) const;
  ::tensorflow::CoordinatedTask* add_tasks();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& tasks() const;
  // .tensorflow.CoordinatedTask requesting_task = 1;
  bool has_requesting_task() const;
  void clear_requesting_task() ;
  const ::tensorflow::CoordinatedTask& requesting_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_requesting_task();
  ::tensorflow::CoordinatedTask* mutable_requesting_task();
  void set_allocated_requesting_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_requesting_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_requesting_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_requesting_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_requesting_task();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GetAliveTasksRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetAliveTasksRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask > tasks_;
    ::tensorflow::CoordinatedTask* requesting_task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DeviceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceInfo(const DeviceInfo& from) : DeviceInfo(nullptr, from) {}
  inline DeviceInfo(DeviceInfo&& from) noexcept
      : DeviceInfo(nullptr, std::move(from)) {}
  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
        &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(DeviceInfo& a, DeviceInfo& b) { a.Swap(&b); }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DeviceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeviceInfo& from) { DeviceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeviceInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.DeviceInfo"; }

 protected:
  explicit DeviceInfo(::google::protobuf::Arena* arena);
  DeviceInfo(::google::protobuf::Arena* arena, const DeviceInfo& from);
  DeviceInfo(::google::protobuf::Arena* arena, DeviceInfo&& from) noexcept
      : DeviceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 1,
  };
  // repeated .google.protobuf.Any device = 1;
  int device_size() const;
  private:
  int _internal_device_size() const;

  public:
  void clear_device() ;
  ::google::protobuf::Any* mutable_device(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* mutable_device();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_device() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_device();
  public:
  const ::google::protobuf::Any& device(int index) const;
  ::google::protobuf::Any* add_device();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& device() const;
  // @@protoc_insertion_point(class_scope:tensorflow.DeviceInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceInfo& from_msg);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > device_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CoordinationServiceError final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CoordinationServiceError) */ {
 public:
  inline CoordinationServiceError() : CoordinationServiceError(nullptr) {}
  ~CoordinationServiceError() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CoordinationServiceError(
      ::google::protobuf::internal::ConstantInitialized);

  inline CoordinationServiceError(const CoordinationServiceError& from) : CoordinationServiceError(nullptr, from) {}
  inline CoordinationServiceError(CoordinationServiceError&& from) noexcept
      : CoordinationServiceError(nullptr, std::move(from)) {}
  inline CoordinationServiceError& operator=(const CoordinationServiceError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinationServiceError& operator=(CoordinationServiceError&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordinationServiceError& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoordinationServiceError* internal_default_instance() {
    return reinterpret_cast<const CoordinationServiceError*>(
        &_CoordinationServiceError_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CoordinationServiceError& a, CoordinationServiceError& b) { a.Swap(&b); }
  inline void Swap(CoordinationServiceError* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordinationServiceError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoordinationServiceError* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CoordinationServiceError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CoordinationServiceError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CoordinationServiceError& from) { CoordinationServiceError::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CoordinationServiceError* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CoordinationServiceError"; }

 protected:
  explicit CoordinationServiceError(::google::protobuf::Arena* arena);
  CoordinationServiceError(::google::protobuf::Arena* arena, const CoordinationServiceError& from);
  CoordinationServiceError(::google::protobuf::Arena* arena, CoordinationServiceError&& from) noexcept
      : CoordinationServiceError(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTaskFieldNumber = 4,
    kIsReportedErrorFieldNumber = 3,
  };
  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // bool is_reported_error = 3;
  void clear_is_reported_error() ;
  bool is_reported_error() const;
  void set_is_reported_error(bool value);

  private:
  bool _internal_is_reported_error() const;
  void _internal_set_is_reported_error(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CoordinationServiceError)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CoordinationServiceError& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::CoordinatedTask* source_task_;
    bool is_reported_error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CancelBarrierRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CancelBarrierRequest) */ {
 public:
  inline CancelBarrierRequest() : CancelBarrierRequest(nullptr) {}
  ~CancelBarrierRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelBarrierRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelBarrierRequest(const CancelBarrierRequest& from) : CancelBarrierRequest(nullptr, from) {}
  inline CancelBarrierRequest(CancelBarrierRequest&& from) noexcept
      : CancelBarrierRequest(nullptr, std::move(from)) {}
  inline CancelBarrierRequest& operator=(const CancelBarrierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelBarrierRequest& operator=(CancelBarrierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelBarrierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelBarrierRequest* internal_default_instance() {
    return reinterpret_cast<const CancelBarrierRequest*>(
        &_CancelBarrierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(CancelBarrierRequest& a, CancelBarrierRequest& b) { a.Swap(&b); }
  inline void Swap(CancelBarrierRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelBarrierRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelBarrierRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CancelBarrierRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelBarrierRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelBarrierRequest& from) { CancelBarrierRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CancelBarrierRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CancelBarrierRequest"; }

 protected:
  explicit CancelBarrierRequest(::google::protobuf::Arena* arena);
  CancelBarrierRequest(::google::protobuf::Arena* arena, const CancelBarrierRequest& from);
  CancelBarrierRequest(::google::protobuf::Arena* arena, CancelBarrierRequest&& from) noexcept
      : CancelBarrierRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBarrierIdFieldNumber = 1,
    kSourceTaskFieldNumber = 2,
    kCounterFieldNumber = 3,
  };
  // string barrier_id = 1;
  void clear_barrier_id() ;
  const std::string& barrier_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_barrier_id(Arg_&& arg, Args_... args);
  std::string* mutable_barrier_id();
  PROTOBUF_NODISCARD std::string* release_barrier_id();
  void set_allocated_barrier_id(std::string* value);

  private:
  const std::string& _internal_barrier_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_barrier_id(
      const std::string& value);
  std::string* _internal_mutable_barrier_id();

  public:
  // .tensorflow.CoordinatedTask source_task = 2;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // int64 counter = 3;
  void clear_counter() ;
  ::int64_t counter() const;
  void set_counter(::int64_t value);

  private:
  ::int64_t _internal_counter() const;
  void _internal_set_counter(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CancelBarrierRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      50, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelBarrierRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr barrier_id_;
    ::tensorflow::CoordinatedTask* source_task_;
    ::int64_t counter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BarrierRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.BarrierRequest) */ {
 public:
  inline BarrierRequest() : BarrierRequest(nullptr) {}
  ~BarrierRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BarrierRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline BarrierRequest(const BarrierRequest& from) : BarrierRequest(nullptr, from) {}
  inline BarrierRequest(BarrierRequest&& from) noexcept
      : BarrierRequest(nullptr, std::move(from)) {}
  inline BarrierRequest& operator=(const BarrierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarrierRequest& operator=(BarrierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BarrierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BarrierRequest* internal_default_instance() {
    return reinterpret_cast<const BarrierRequest*>(
        &_BarrierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(BarrierRequest& a, BarrierRequest& b) { a.Swap(&b); }
  inline void Swap(BarrierRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BarrierRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BarrierRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BarrierRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BarrierRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BarrierRequest& from) { BarrierRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BarrierRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.BarrierRequest"; }

 protected:
  explicit BarrierRequest(::google::protobuf::Arena* arena);
  BarrierRequest(::google::protobuf::Arena* arena, const BarrierRequest& from);
  BarrierRequest(::google::protobuf::Arena* arena, BarrierRequest&& from) noexcept
      : BarrierRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTasksFieldNumber = 3,
    kBarrierIdFieldNumber = 1,
    kSourceTaskFieldNumber = 4,
    kBarrierTimeoutInMsFieldNumber = 2,
    kCounterFieldNumber = 5,
  };
  // repeated .tensorflow.CoordinatedTask tasks = 3;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  ::tensorflow::CoordinatedTask* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* mutable_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* _internal_mutable_tasks();
  public:
  const ::tensorflow::CoordinatedTask& tasks(int index) const;
  ::tensorflow::CoordinatedTask* add_tasks();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& tasks() const;
  // string barrier_id = 1;
  void clear_barrier_id() ;
  const std::string& barrier_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_barrier_id(Arg_&& arg, Args_... args);
  std::string* mutable_barrier_id();
  PROTOBUF_NODISCARD std::string* release_barrier_id();
  void set_allocated_barrier_id(std::string* value);

  private:
  const std::string& _internal_barrier_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_barrier_id(
      const std::string& value);
  std::string* _internal_mutable_barrier_id();

  public:
  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // int64 barrier_timeout_in_ms = 2;
  void clear_barrier_timeout_in_ms() ;
  ::int64_t barrier_timeout_in_ms() const;
  void set_barrier_timeout_in_ms(::int64_t value);

  private:
  ::int64_t _internal_barrier_timeout_in_ms() const;
  void _internal_set_barrier_timeout_in_ms(::int64_t value);

  public:
  // int64 counter = 5;
  void clear_counter() ;
  ::int64_t counter() const;
  void set_counter(::int64_t value);

  private:
  ::int64_t _internal_counter() const;
  void _internal_set_counter(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.BarrierRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      44, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BarrierRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask > tasks_;
    ::google::protobuf::internal::ArenaStringPtr barrier_id_;
    ::tensorflow::CoordinatedTask* source_task_;
    ::int64_t barrier_timeout_in_ms_;
    ::int64_t counter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT WaitForAllTasksResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.WaitForAllTasksResponse) */ {
 public:
  inline WaitForAllTasksResponse() : WaitForAllTasksResponse(nullptr) {}
  ~WaitForAllTasksResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WaitForAllTasksResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline WaitForAllTasksResponse(const WaitForAllTasksResponse& from) : WaitForAllTasksResponse(nullptr, from) {}
  inline WaitForAllTasksResponse(WaitForAllTasksResponse&& from) noexcept
      : WaitForAllTasksResponse(nullptr, std::move(from)) {}
  inline WaitForAllTasksResponse& operator=(const WaitForAllTasksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForAllTasksResponse& operator=(WaitForAllTasksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitForAllTasksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForAllTasksResponse* internal_default_instance() {
    return reinterpret_cast<const WaitForAllTasksResponse*>(
        &_WaitForAllTasksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(WaitForAllTasksResponse& a, WaitForAllTasksResponse& b) { a.Swap(&b); }
  inline void Swap(WaitForAllTasksResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForAllTasksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForAllTasksResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WaitForAllTasksResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WaitForAllTasksResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WaitForAllTasksResponse& from) { WaitForAllTasksResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WaitForAllTasksResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.WaitForAllTasksResponse"; }

 protected:
  explicit WaitForAllTasksResponse(::google::protobuf::Arena* arena);
  WaitForAllTasksResponse(::google::protobuf::Arena* arena, const WaitForAllTasksResponse& from);
  WaitForAllTasksResponse(::google::protobuf::Arena* arena, WaitForAllTasksResponse&& from) noexcept
      : WaitForAllTasksResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceInfoFieldNumber = 4,
    kLeaderIncarnationFieldNumber = 1,
  };
  // .tensorflow.DeviceInfo device_info = 4;
  bool has_device_info() const;
  void clear_device_info() ;
  const ::tensorflow::DeviceInfo& device_info() const;
  PROTOBUF_NODISCARD ::tensorflow::DeviceInfo* release_device_info();
  ::tensorflow::DeviceInfo* mutable_device_info();
  void set_allocated_device_info(::tensorflow::DeviceInfo* value);
  void unsafe_arena_set_allocated_device_info(::tensorflow::DeviceInfo* value);
  ::tensorflow::DeviceInfo* unsafe_arena_release_device_info();

  private:
  const ::tensorflow::DeviceInfo& _internal_device_info() const;
  ::tensorflow::DeviceInfo* _internal_mutable_device_info();

  public:
  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation() ;
  ::uint64_t leader_incarnation() const;
  void set_leader_incarnation(::uint64_t value);

  private:
  ::uint64_t _internal_leader_incarnation() const;
  void _internal_set_leader_incarnation(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.WaitForAllTasksResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WaitForAllTasksResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::DeviceInfo* device_info_;
    ::uint64_t leader_incarnation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT WaitForAllTasksRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.WaitForAllTasksRequest) */ {
 public:
  inline WaitForAllTasksRequest() : WaitForAllTasksRequest(nullptr) {}
  ~WaitForAllTasksRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WaitForAllTasksRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline WaitForAllTasksRequest(const WaitForAllTasksRequest& from) : WaitForAllTasksRequest(nullptr, from) {}
  inline WaitForAllTasksRequest(WaitForAllTasksRequest&& from) noexcept
      : WaitForAllTasksRequest(nullptr, std::move(from)) {}
  inline WaitForAllTasksRequest& operator=(const WaitForAllTasksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForAllTasksRequest& operator=(WaitForAllTasksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitForAllTasksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForAllTasksRequest* internal_default_instance() {
    return reinterpret_cast<const WaitForAllTasksRequest*>(
        &_WaitForAllTasksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(WaitForAllTasksRequest& a, WaitForAllTasksRequest& b) { a.Swap(&b); }
  inline void Swap(WaitForAllTasksRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForAllTasksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForAllTasksRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WaitForAllTasksRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WaitForAllTasksRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WaitForAllTasksRequest& from) { WaitForAllTasksRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WaitForAllTasksRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.WaitForAllTasksRequest"; }

 protected:
  explicit WaitForAllTasksRequest(::google::protobuf::Arena* arena);
  WaitForAllTasksRequest(::google::protobuf::Arena* arena, const WaitForAllTasksRequest& from);
  WaitForAllTasksRequest(::google::protobuf::Arena* arena, WaitForAllTasksRequest&& from) noexcept
      : WaitForAllTasksRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceTaskFieldNumber = 5,
    kDeviceInfoFieldNumber = 6,
  };
  // .tensorflow.CoordinatedTask source_task = 5;
  bool has_source_task() const;
  void clear_source_task() ;
  const ::tensorflow::CoordinatedTask& source_task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_source_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_source_task();

  public:
  // .tensorflow.DeviceInfo device_info = 6;
  bool has_device_info() const;
  void clear_device_info() ;
  const ::tensorflow::DeviceInfo& device_info() const;
  PROTOBUF_NODISCARD ::tensorflow::DeviceInfo* release_device_info();
  ::tensorflow::DeviceInfo* mutable_device_info();
  void set_allocated_device_info(::tensorflow::DeviceInfo* value);
  void unsafe_arena_set_allocated_device_info(::tensorflow::DeviceInfo* value);
  ::tensorflow::DeviceInfo* unsafe_arena_release_device_info();

  private:
  const ::tensorflow::DeviceInfo& _internal_device_info() const;
  ::tensorflow::DeviceInfo* _internal_mutable_device_info();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.WaitForAllTasksRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WaitForAllTasksRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::CoordinatedTask* source_task_;
    ::tensorflow::DeviceInfo* device_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ReportErrorToTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToTaskRequest) */ {
 public:
  inline ReportErrorToTaskRequest() : ReportErrorToTaskRequest(nullptr) {}
  ~ReportErrorToTaskRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportErrorToTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportErrorToTaskRequest(const ReportErrorToTaskRequest& from) : ReportErrorToTaskRequest(nullptr, from) {}
  inline ReportErrorToTaskRequest(ReportErrorToTaskRequest&& from) noexcept
      : ReportErrorToTaskRequest(nullptr, std::move(from)) {}
  inline ReportErrorToTaskRequest& operator=(const ReportErrorToTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportErrorToTaskRequest& operator=(ReportErrorToTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportErrorToTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportErrorToTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToTaskRequest*>(
        &_ReportErrorToTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ReportErrorToTaskRequest& a, ReportErrorToTaskRequest& b) { a.Swap(&b); }
  inline void Swap(ReportErrorToTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportErrorToTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportErrorToTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ReportErrorToTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportErrorToTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportErrorToTaskRequest& from) { ReportErrorToTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportErrorToTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ReportErrorToTaskRequest"; }

 protected:
  explicit ReportErrorToTaskRequest(::google::protobuf::Arena* arena);
  ReportErrorToTaskRequest(::google::protobuf::Arena* arena, const ReportErrorToTaskRequest& from);
  ReportErrorToTaskRequest(::google::protobuf::Arena* arena, ReportErrorToTaskRequest&& from) noexcept
      : ReportErrorToTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorPayloadFieldNumber = 5,
    kErrorCodeFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .tensorflow.CoordinationServiceError error_payload = 5;
  bool has_error_payload() const;
  void clear_error_payload() ;
  const ::tensorflow::CoordinationServiceError& error_payload() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinationServiceError* release_error_payload();
  ::tensorflow::CoordinationServiceError* mutable_error_payload();
  void set_allocated_error_payload(::tensorflow::CoordinationServiceError* value);
  void unsafe_arena_set_allocated_error_payload(::tensorflow::CoordinationServiceError* value);
  ::tensorflow::CoordinationServiceError* unsafe_arena_release_error_payload();

  private:
  const ::tensorflow::CoordinationServiceError& _internal_error_payload() const;
  ::tensorflow::CoordinationServiceError* _internal_mutable_error_payload();

  public:
  // int32 error_code = 1;
  void clear_error_code() ;
  ::int32_t error_code() const;
  void set_error_code(::int32_t value);

  private:
  ::int32_t _internal_error_code() const;
  void _internal_set_error_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      57, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReportErrorToTaskRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::tensorflow::CoordinationServiceError* error_payload_;
    ::int32_t error_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CoordinatedTaskStateInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CoordinatedTaskStateInfo) */ {
 public:
  inline CoordinatedTaskStateInfo() : CoordinatedTaskStateInfo(nullptr) {}
  ~CoordinatedTaskStateInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CoordinatedTaskStateInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CoordinatedTaskStateInfo(const CoordinatedTaskStateInfo& from) : CoordinatedTaskStateInfo(nullptr, from) {}
  inline CoordinatedTaskStateInfo(CoordinatedTaskStateInfo&& from) noexcept
      : CoordinatedTaskStateInfo(nullptr, std::move(from)) {}
  inline CoordinatedTaskStateInfo& operator=(const CoordinatedTaskStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinatedTaskStateInfo& operator=(CoordinatedTaskStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordinatedTaskStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoordinatedTaskStateInfo* internal_default_instance() {
    return reinterpret_cast<const CoordinatedTaskStateInfo*>(
        &_CoordinatedTaskStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(CoordinatedTaskStateInfo& a, CoordinatedTaskStateInfo& b) { a.Swap(&b); }
  inline void Swap(CoordinatedTaskStateInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordinatedTaskStateInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoordinatedTaskStateInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CoordinatedTaskStateInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CoordinatedTaskStateInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CoordinatedTaskStateInfo& from) { CoordinatedTaskStateInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CoordinatedTaskStateInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CoordinatedTaskStateInfo"; }

 protected:
  explicit CoordinatedTaskStateInfo(::google::protobuf::Arena* arena);
  CoordinatedTaskStateInfo(::google::protobuf::Arena* arena, const CoordinatedTaskStateInfo& from);
  CoordinatedTaskStateInfo(::google::protobuf::Arena* arena, CoordinatedTaskStateInfo&& from) noexcept
      : CoordinatedTaskStateInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorMessageFieldNumber = 4,
    kTaskFieldNumber = 1,
    kErrorPayloadFieldNumber = 5,
    kStateFieldNumber = 2,
    kErrorCodeFieldNumber = 3,
    kIncarnationFieldNumber = 6,
  };
  // string error_message = 4;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .tensorflow.CoordinatedTask task = 1;
  bool has_task() const;
  void clear_task() ;
  const ::tensorflow::CoordinatedTask& task() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinatedTask* release_task();
  ::tensorflow::CoordinatedTask* mutable_task();
  void set_allocated_task(::tensorflow::CoordinatedTask* value);
  void unsafe_arena_set_allocated_task(::tensorflow::CoordinatedTask* value);
  ::tensorflow::CoordinatedTask* unsafe_arena_release_task();

  private:
  const ::tensorflow::CoordinatedTask& _internal_task() const;
  ::tensorflow::CoordinatedTask* _internal_mutable_task();

  public:
  // .tensorflow.CoordinationServiceError error_payload = 5;
  bool has_error_payload() const;
  void clear_error_payload() ;
  const ::tensorflow::CoordinationServiceError& error_payload() const;
  PROTOBUF_NODISCARD ::tensorflow::CoordinationServiceError* release_error_payload();
  ::tensorflow::CoordinationServiceError* mutable_error_payload();
  void set_allocated_error_payload(::tensorflow::CoordinationServiceError* value);
  void unsafe_arena_set_allocated_error_payload(::tensorflow::CoordinationServiceError* value);
  ::tensorflow::CoordinationServiceError* unsafe_arena_release_error_payload();

  private:
  const ::tensorflow::CoordinationServiceError& _internal_error_payload() const;
  ::tensorflow::CoordinationServiceError* _internal_mutable_error_payload();

  public:
  // .tensorflow.CoordinatedTaskState state = 2;
  void clear_state() ;
  ::tensorflow::CoordinatedTaskState state() const;
  void set_state(::tensorflow::CoordinatedTaskState value);

  private:
  ::tensorflow::CoordinatedTaskState _internal_state() const;
  void _internal_set_state(::tensorflow::CoordinatedTaskState value);

  public:
  // int32 error_code = 3;
  void clear_error_code() ;
  ::int32_t error_code() const;
  void set_error_code(::int32_t value);

  private:
  ::int32_t _internal_error_code() const;
  void _internal_set_error_code(::int32_t value);

  public:
  // fixed64 incarnation = 6;
  void clear_incarnation() ;
  ::uint64_t incarnation() const;
  void set_incarnation(::uint64_t value);

  private:
  ::uint64_t _internal_incarnation() const;
  void _internal_set_incarnation(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CoordinatedTaskStateInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      57, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CoordinatedTaskStateInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::tensorflow::CoordinatedTask* task_;
    ::tensorflow::CoordinationServiceError* error_payload_;
    int state_;
    ::int32_t error_code_;
    ::uint64_t incarnation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetTaskStateResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetTaskStateResponse) */ {
 public:
  inline GetTaskStateResponse() : GetTaskStateResponse(nullptr) {}
  ~GetTaskStateResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTaskStateResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTaskStateResponse(const GetTaskStateResponse& from) : GetTaskStateResponse(nullptr, from) {}
  inline GetTaskStateResponse(GetTaskStateResponse&& from) noexcept
      : GetTaskStateResponse(nullptr, std::move(from)) {}
  inline GetTaskStateResponse& operator=(const GetTaskStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTaskStateResponse& operator=(GetTaskStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTaskStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTaskStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetTaskStateResponse*>(
        &_GetTaskStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(GetTaskStateResponse& a, GetTaskStateResponse& b) { a.Swap(&b); }
  inline void Swap(GetTaskStateResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTaskStateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTaskStateResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetTaskStateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTaskStateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTaskStateResponse& from) { GetTaskStateResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTaskStateResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetTaskStateResponse"; }

 protected:
  explicit GetTaskStateResponse(::google::protobuf::Arena* arena);
  GetTaskStateResponse(::google::protobuf::Arena* arena, const GetTaskStateResponse& from);
  GetTaskStateResponse(::google::protobuf::Arena* arena, GetTaskStateResponse&& from) noexcept
      : GetTaskStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskStateFieldNumber = 1,
  };
  // repeated .tensorflow.CoordinatedTaskStateInfo task_state = 1;
  int task_state_size() const;
  private:
  int _internal_task_state_size() const;

  public:
  void clear_task_state() ;
  ::tensorflow::CoordinatedTaskStateInfo* mutable_task_state(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>* mutable_task_state();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>& _internal_task_state() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>* _internal_mutable_task_state();
  public:
  const ::tensorflow::CoordinatedTaskStateInfo& task_state(int index) const;
  ::tensorflow::CoordinatedTaskStateInfo* add_task_state();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>& task_state() const;
  // @@protoc_insertion_point(class_scope:tensorflow.GetTaskStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTaskStateResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTaskStateInfo > task_state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GetJobStateResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GetJobStateResponse) */ {
 public:
  inline GetJobStateResponse() : GetJobStateResponse(nullptr) {}
  ~GetJobStateResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetJobStateResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetJobStateResponse(const GetJobStateResponse& from) : GetJobStateResponse(nullptr, from) {}
  inline GetJobStateResponse(GetJobStateResponse&& from) noexcept
      : GetJobStateResponse(nullptr, std::move(from)) {}
  inline GetJobStateResponse& operator=(const GetJobStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetJobStateResponse& operator=(GetJobStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetJobStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetJobStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetJobStateResponse*>(
        &_GetJobStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(GetJobStateResponse& a, GetJobStateResponse& b) { a.Swap(&b); }
  inline void Swap(GetJobStateResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetJobStateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetJobStateResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetJobStateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetJobStateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetJobStateResponse& from) { GetJobStateResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetJobStateResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GetJobStateResponse"; }

 protected:
  explicit GetJobStateResponse(::google::protobuf::Arena* arena);
  GetJobStateResponse(::google::protobuf::Arena* arena, const GetJobStateResponse& from);
  GetJobStateResponse(::google::protobuf::Arena* arena, GetJobStateResponse&& from) noexcept
      : GetJobStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskStateFieldNumber = 1,
  };
  // repeated .tensorflow.CoordinatedTaskStateInfo task_state = 1;
  int task_state_size() const;
  private:
  int _internal_task_state_size() const;

  public:
  void clear_task_state() ;
  ::tensorflow::CoordinatedTaskStateInfo* mutable_task_state(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>* mutable_task_state();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>& _internal_task_state() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>* _internal_mutable_task_state();
  public:
  const ::tensorflow::CoordinatedTaskStateInfo& task_state(int index) const;
  ::tensorflow::CoordinatedTaskStateInfo* add_task_state();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>& task_state() const;
  // @@protoc_insertion_point(class_scope:tensorflow.GetJobStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetJobStateResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTaskStateInfo > task_state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CoordinatedTask

// string job_name = 1;
inline void CoordinatedTask::clear_job_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_name_.ClearToEmpty();
}
inline const std::string& CoordinatedTask::job_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTask.job_name)
  return _internal_job_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CoordinatedTask::set_job_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTask.job_name)
}
inline std::string* CoordinatedTask::mutable_job_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTask.job_name)
  return _s;
}
inline const std::string& CoordinatedTask::_internal_job_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_name_.Get();
}
inline void CoordinatedTask::_internal_set_job_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_name_.Set(value, GetArena());
}
inline std::string* CoordinatedTask::_internal_mutable_job_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.job_name_.Mutable( GetArena());
}
inline std::string* CoordinatedTask::release_job_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTask.job_name)
  return _impl_.job_name_.Release();
}
inline void CoordinatedTask::set_allocated_job_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.job_name_.IsDefault()) {
          _impl_.job_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTask.job_name)
}

// int32 task_id = 2;
inline void CoordinatedTask::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_ = 0;
}
inline ::int32_t CoordinatedTask::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTask.task_id)
  return _internal_task_id();
}
inline void CoordinatedTask::set_task_id(::int32_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTask.task_id)
}
inline ::int32_t CoordinatedTask::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_;
}
inline void CoordinatedTask::_internal_set_task_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_ = value;
}

// bool recoverable = 3;
inline void CoordinatedTask::clear_recoverable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recoverable_ = false;
}
inline bool CoordinatedTask::recoverable() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTask.recoverable)
  return _internal_recoverable();
}
inline void CoordinatedTask::set_recoverable(bool value) {
  _internal_set_recoverable(value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTask.recoverable)
}
inline bool CoordinatedTask::_internal_recoverable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recoverable_;
}
inline void CoordinatedTask::_internal_set_recoverable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recoverable_ = value;
}

// -------------------------------------------------------------------

// CoordinationServiceError

// bool is_reported_error = 3;
inline void CoordinationServiceError::clear_is_reported_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_reported_error_ = false;
}
inline bool CoordinationServiceError::is_reported_error() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceError.is_reported_error)
  return _internal_is_reported_error();
}
inline void CoordinationServiceError::set_is_reported_error(bool value) {
  _internal_set_is_reported_error(value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinationServiceError.is_reported_error)
}
inline bool CoordinationServiceError::_internal_is_reported_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_reported_error_;
}
inline void CoordinationServiceError::_internal_set_is_reported_error(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_reported_error_ = value;
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool CoordinationServiceError::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void CoordinationServiceError::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& CoordinationServiceError::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& CoordinationServiceError::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceError.source_task)
  return _internal_source_task();
}
inline void CoordinationServiceError::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CoordinationServiceError.source_task)
}
inline ::tensorflow::CoordinatedTask* CoordinationServiceError::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* CoordinationServiceError::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CoordinationServiceError.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* CoordinationServiceError::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* CoordinationServiceError::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinationServiceError.source_task)
  return _msg;
}
inline void CoordinationServiceError::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinationServiceError.source_task)
}

// -------------------------------------------------------------------

// BarrierError

// string barrier_id = 1;
inline void BarrierError::clear_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.ClearToEmpty();
}
inline const std::string& BarrierError::barrier_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierError.barrier_id)
  return _internal_barrier_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BarrierError::set_barrier_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.BarrierError.barrier_id)
}
inline std::string* BarrierError::mutable_barrier_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_barrier_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierError.barrier_id)
  return _s;
}
inline const std::string& BarrierError::_internal_barrier_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.barrier_id_.Get();
}
inline void BarrierError::_internal_set_barrier_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.Set(value, GetArena());
}
inline std::string* BarrierError::_internal_mutable_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.barrier_id_.Mutable( GetArena());
}
inline std::string* BarrierError::release_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BarrierError.barrier_id)
  return _impl_.barrier_id_.Release();
}
inline void BarrierError::set_allocated_barrier_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.barrier_id_.IsDefault()) {
          _impl_.barrier_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BarrierError.barrier_id)
}

// int64 counter = 2;
inline void BarrierError::clear_counter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = ::int64_t{0};
}
inline ::int64_t BarrierError::counter() const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierError.counter)
  return _internal_counter();
}
inline void BarrierError::set_counter(::int64_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:tensorflow.BarrierError.counter)
}
inline ::int64_t BarrierError::_internal_counter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.counter_;
}
inline void BarrierError::_internal_set_counter(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = value;
}

// -------------------------------------------------------------------

// CoordinatedTaskStateInfo

// .tensorflow.CoordinatedTask task = 1;
inline bool CoordinatedTaskStateInfo::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline void CoordinatedTaskStateInfo::clear_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ != nullptr) _impl_.task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& CoordinatedTaskStateInfo::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& CoordinatedTaskStateInfo::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.task)
  return _internal_task();
}
inline void CoordinatedTaskStateInfo::unsafe_arena_set_allocated_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CoordinatedTaskStateInfo.task)
}
inline ::tensorflow::CoordinatedTask* CoordinatedTaskStateInfo::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* CoordinatedTaskStateInfo::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTaskStateInfo.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* CoordinatedTaskStateInfo::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.task_;
}
inline ::tensorflow::CoordinatedTask* CoordinatedTaskStateInfo::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTaskStateInfo.task)
  return _msg;
}
inline void CoordinatedTaskStateInfo::set_allocated_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTaskStateInfo.task)
}

// fixed64 incarnation = 6;
inline void CoordinatedTaskStateInfo::clear_incarnation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.incarnation_ = ::uint64_t{0u};
}
inline ::uint64_t CoordinatedTaskStateInfo::incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.incarnation)
  return _internal_incarnation();
}
inline void CoordinatedTaskStateInfo::set_incarnation(::uint64_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTaskStateInfo.incarnation)
}
inline ::uint64_t CoordinatedTaskStateInfo::_internal_incarnation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.incarnation_;
}
inline void CoordinatedTaskStateInfo::_internal_set_incarnation(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.incarnation_ = value;
}

// .tensorflow.CoordinatedTaskState state = 2;
inline void CoordinatedTaskStateInfo::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::tensorflow::CoordinatedTaskState CoordinatedTaskStateInfo::state() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.state)
  return _internal_state();
}
inline void CoordinatedTaskStateInfo::set_state(::tensorflow::CoordinatedTaskState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTaskStateInfo.state)
}
inline ::tensorflow::CoordinatedTaskState CoordinatedTaskStateInfo::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::CoordinatedTaskState>(_impl_.state_);
}
inline void CoordinatedTaskStateInfo::_internal_set_state(::tensorflow::CoordinatedTaskState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// int32 error_code = 3;
inline void CoordinatedTaskStateInfo::clear_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_ = 0;
}
inline ::int32_t CoordinatedTaskStateInfo::error_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.error_code)
  return _internal_error_code();
}
inline void CoordinatedTaskStateInfo::set_error_code(::int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTaskStateInfo.error_code)
}
inline ::int32_t CoordinatedTaskStateInfo::_internal_error_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_code_;
}
inline void CoordinatedTaskStateInfo::_internal_set_error_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_ = value;
}

// string error_message = 4;
inline void CoordinatedTaskStateInfo::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& CoordinatedTaskStateInfo::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CoordinatedTaskStateInfo::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTaskStateInfo.error_message)
}
inline std::string* CoordinatedTaskStateInfo::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTaskStateInfo.error_message)
  return _s;
}
inline const std::string& CoordinatedTaskStateInfo::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void CoordinatedTaskStateInfo::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* CoordinatedTaskStateInfo::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* CoordinatedTaskStateInfo::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTaskStateInfo.error_message)
  return _impl_.error_message_.Release();
}
inline void CoordinatedTaskStateInfo::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTaskStateInfo.error_message)
}

// .tensorflow.CoordinationServiceError error_payload = 5;
inline bool CoordinatedTaskStateInfo::has_error_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_payload_ != nullptr);
  return value;
}
inline void CoordinatedTaskStateInfo::clear_error_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_payload_ != nullptr) _impl_.error_payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tensorflow::CoordinationServiceError& CoordinatedTaskStateInfo::_internal_error_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinationServiceError* p = _impl_.error_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinationServiceError&>(::tensorflow::_CoordinationServiceError_default_instance_);
}
inline const ::tensorflow::CoordinationServiceError& CoordinatedTaskStateInfo::error_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.error_payload)
  return _internal_error_payload();
}
inline void CoordinatedTaskStateInfo::unsafe_arena_set_allocated_error_payload(::tensorflow::CoordinationServiceError* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_payload_);
  }
  _impl_.error_payload_ = reinterpret_cast<::tensorflow::CoordinationServiceError*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CoordinatedTaskStateInfo.error_payload)
}
inline ::tensorflow::CoordinationServiceError* CoordinatedTaskStateInfo::release_error_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::CoordinationServiceError* released = _impl_.error_payload_;
  _impl_.error_payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinationServiceError* CoordinatedTaskStateInfo::unsafe_arena_release_error_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTaskStateInfo.error_payload)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::CoordinationServiceError* temp = _impl_.error_payload_;
  _impl_.error_payload_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinationServiceError* CoordinatedTaskStateInfo::_internal_mutable_error_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinationServiceError>(GetArena());
    _impl_.error_payload_ = reinterpret_cast<::tensorflow::CoordinationServiceError*>(p);
  }
  return _impl_.error_payload_;
}
inline ::tensorflow::CoordinationServiceError* CoordinatedTaskStateInfo::mutable_error_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::CoordinationServiceError* _msg = _internal_mutable_error_payload();
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTaskStateInfo.error_payload)
  return _msg;
}
inline void CoordinatedTaskStateInfo::set_allocated_error_payload(::tensorflow::CoordinationServiceError* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.error_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.error_payload_ = reinterpret_cast<::tensorflow::CoordinationServiceError*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTaskStateInfo.error_payload)
}

// -------------------------------------------------------------------

// DeviceInfo

// repeated .google.protobuf.Any device = 1;
inline int DeviceInfo::_internal_device_size() const {
  return _internal_device().size();
}
inline int DeviceInfo::device_size() const {
  return _internal_device_size();
}
inline ::google::protobuf::Any* DeviceInfo::mutable_device(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.DeviceInfo.device)
  return _internal_mutable_device()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* DeviceInfo::mutable_device()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.DeviceInfo.device)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device();
}
inline const ::google::protobuf::Any& DeviceInfo::device(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DeviceInfo.device)
  return _internal_device().Get(index);
}
inline ::google::protobuf::Any* DeviceInfo::add_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_device()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.DeviceInfo.device)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& DeviceInfo::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.DeviceInfo.device)
  return _internal_device();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
DeviceInfo::_internal_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
DeviceInfo::_internal_mutable_device() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_;
}

// -------------------------------------------------------------------

// RegisterTaskRequest

// fixed64 incarnation = 3;
inline void RegisterTaskRequest::clear_incarnation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.incarnation_ = ::uint64_t{0u};
}
inline ::uint64_t RegisterTaskRequest::incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskRequest.incarnation)
  return _internal_incarnation();
}
inline void RegisterTaskRequest::set_incarnation(::uint64_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:tensorflow.RegisterTaskRequest.incarnation)
}
inline ::uint64_t RegisterTaskRequest::_internal_incarnation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.incarnation_;
}
inline void RegisterTaskRequest::_internal_set_incarnation(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.incarnation_ = value;
}

// .tensorflow.CoordinatedTask source_task = 5;
inline bool RegisterTaskRequest::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void RegisterTaskRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& RegisterTaskRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& RegisterTaskRequest::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskRequest.source_task)
  return _internal_source_task();
}
inline void RegisterTaskRequest::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RegisterTaskRequest.source_task)
}
inline ::tensorflow::CoordinatedTask* RegisterTaskRequest::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* RegisterTaskRequest::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.RegisterTaskRequest.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* RegisterTaskRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* RegisterTaskRequest::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.RegisterTaskRequest.source_task)
  return _msg;
}
inline void RegisterTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RegisterTaskRequest.source_task)
}

// -------------------------------------------------------------------

// RegisterTaskResponse

// fixed64 leader_incarnation = 1;
inline void RegisterTaskResponse::clear_leader_incarnation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leader_incarnation_ = ::uint64_t{0u};
}
inline ::uint64_t RegisterTaskResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskResponse.leader_incarnation)
  return _internal_leader_incarnation();
}
inline void RegisterTaskResponse::set_leader_incarnation(::uint64_t value) {
  _internal_set_leader_incarnation(value);
  // @@protoc_insertion_point(field_set:tensorflow.RegisterTaskResponse.leader_incarnation)
}
inline ::uint64_t RegisterTaskResponse::_internal_leader_incarnation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.leader_incarnation_;
}
inline void RegisterTaskResponse::_internal_set_leader_incarnation(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leader_incarnation_ = value;
}

// -------------------------------------------------------------------

// HeartbeatRequest

// fixed64 incarnation = 3;
inline void HeartbeatRequest::clear_incarnation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.incarnation_ = ::uint64_t{0u};
}
inline ::uint64_t HeartbeatRequest::incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatRequest.incarnation)
  return _internal_incarnation();
}
inline void HeartbeatRequest::set_incarnation(::uint64_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:tensorflow.HeartbeatRequest.incarnation)
}
inline ::uint64_t HeartbeatRequest::_internal_incarnation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.incarnation_;
}
inline void HeartbeatRequest::_internal_set_incarnation(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.incarnation_ = value;
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool HeartbeatRequest::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void HeartbeatRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& HeartbeatRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& HeartbeatRequest::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatRequest.source_task)
  return _internal_source_task();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.HeartbeatRequest.source_task)
}
inline ::tensorflow::CoordinatedTask* HeartbeatRequest::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* HeartbeatRequest::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.HeartbeatRequest.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* HeartbeatRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* HeartbeatRequest::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.HeartbeatRequest.source_task)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.HeartbeatRequest.source_task)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// fixed64 leader_incarnation = 1;
inline void HeartbeatResponse::clear_leader_incarnation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leader_incarnation_ = ::uint64_t{0u};
}
inline ::uint64_t HeartbeatResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatResponse.leader_incarnation)
  return _internal_leader_incarnation();
}
inline void HeartbeatResponse::set_leader_incarnation(::uint64_t value) {
  _internal_set_leader_incarnation(value);
  // @@protoc_insertion_point(field_set:tensorflow.HeartbeatResponse.leader_incarnation)
}
inline ::uint64_t HeartbeatResponse::_internal_leader_incarnation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.leader_incarnation_;
}
inline void HeartbeatResponse::_internal_set_leader_incarnation(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leader_incarnation_ = value;
}

// -------------------------------------------------------------------

// PollForErrorRequest

// .tensorflow.CoordinatedTask source_task = 1;
inline bool PollForErrorRequest::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void PollForErrorRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& PollForErrorRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& PollForErrorRequest::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PollForErrorRequest.source_task)
  return _internal_source_task();
}
inline void PollForErrorRequest::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.PollForErrorRequest.source_task)
}
inline ::tensorflow::CoordinatedTask* PollForErrorRequest::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* PollForErrorRequest::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PollForErrorRequest.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* PollForErrorRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* PollForErrorRequest::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.PollForErrorRequest.source_task)
  return _msg;
}
inline void PollForErrorRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PollForErrorRequest.source_task)
}

// -------------------------------------------------------------------

// PollForErrorResponse

// -------------------------------------------------------------------

// WaitForAllTasksRequest

// .tensorflow.CoordinatedTask source_task = 5;
inline bool WaitForAllTasksRequest::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void WaitForAllTasksRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& WaitForAllTasksRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& WaitForAllTasksRequest::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksRequest.source_task)
  return _internal_source_task();
}
inline void WaitForAllTasksRequest::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.WaitForAllTasksRequest.source_task)
}
inline ::tensorflow::CoordinatedTask* WaitForAllTasksRequest::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* WaitForAllTasksRequest::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksRequest.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* WaitForAllTasksRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* WaitForAllTasksRequest::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksRequest.source_task)
  return _msg;
}
inline void WaitForAllTasksRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksRequest.source_task)
}

// .tensorflow.DeviceInfo device_info = 6;
inline bool WaitForAllTasksRequest::has_device_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_info_ != nullptr);
  return value;
}
inline void WaitForAllTasksRequest::clear_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_info_ != nullptr) _impl_.device_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tensorflow::DeviceInfo& WaitForAllTasksRequest::_internal_device_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::DeviceInfo* p = _impl_.device_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::DeviceInfo&>(::tensorflow::_DeviceInfo_default_instance_);
}
inline const ::tensorflow::DeviceInfo& WaitForAllTasksRequest::device_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksRequest.device_info)
  return _internal_device_info();
}
inline void WaitForAllTasksRequest::unsafe_arena_set_allocated_device_info(::tensorflow::DeviceInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_info_);
  }
  _impl_.device_info_ = reinterpret_cast<::tensorflow::DeviceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.WaitForAllTasksRequest.device_info)
}
inline ::tensorflow::DeviceInfo* WaitForAllTasksRequest::release_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::DeviceInfo* released = _impl_.device_info_;
  _impl_.device_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::DeviceInfo* WaitForAllTasksRequest::unsafe_arena_release_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksRequest.device_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::DeviceInfo* temp = _impl_.device_info_;
  _impl_.device_info_ = nullptr;
  return temp;
}
inline ::tensorflow::DeviceInfo* WaitForAllTasksRequest::_internal_mutable_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::DeviceInfo>(GetArena());
    _impl_.device_info_ = reinterpret_cast<::tensorflow::DeviceInfo*>(p);
  }
  return _impl_.device_info_;
}
inline ::tensorflow::DeviceInfo* WaitForAllTasksRequest::mutable_device_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::DeviceInfo* _msg = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksRequest.device_info)
  return _msg;
}
inline void WaitForAllTasksRequest::set_allocated_device_info(::tensorflow::DeviceInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.device_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.device_info_ = reinterpret_cast<::tensorflow::DeviceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksRequest.device_info)
}

// -------------------------------------------------------------------

// WaitForAllTasksResponse

// fixed64 leader_incarnation = 1;
inline void WaitForAllTasksResponse::clear_leader_incarnation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leader_incarnation_ = ::uint64_t{0u};
}
inline ::uint64_t WaitForAllTasksResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksResponse.leader_incarnation)
  return _internal_leader_incarnation();
}
inline void WaitForAllTasksResponse::set_leader_incarnation(::uint64_t value) {
  _internal_set_leader_incarnation(value);
  // @@protoc_insertion_point(field_set:tensorflow.WaitForAllTasksResponse.leader_incarnation)
}
inline ::uint64_t WaitForAllTasksResponse::_internal_leader_incarnation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.leader_incarnation_;
}
inline void WaitForAllTasksResponse::_internal_set_leader_incarnation(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leader_incarnation_ = value;
}

// .tensorflow.DeviceInfo device_info = 4;
inline bool WaitForAllTasksResponse::has_device_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_info_ != nullptr);
  return value;
}
inline void WaitForAllTasksResponse::clear_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_info_ != nullptr) _impl_.device_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::DeviceInfo& WaitForAllTasksResponse::_internal_device_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::DeviceInfo* p = _impl_.device_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::DeviceInfo&>(::tensorflow::_DeviceInfo_default_instance_);
}
inline const ::tensorflow::DeviceInfo& WaitForAllTasksResponse::device_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksResponse.device_info)
  return _internal_device_info();
}
inline void WaitForAllTasksResponse::unsafe_arena_set_allocated_device_info(::tensorflow::DeviceInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_info_);
  }
  _impl_.device_info_ = reinterpret_cast<::tensorflow::DeviceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.WaitForAllTasksResponse.device_info)
}
inline ::tensorflow::DeviceInfo* WaitForAllTasksResponse::release_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::DeviceInfo* released = _impl_.device_info_;
  _impl_.device_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::DeviceInfo* WaitForAllTasksResponse::unsafe_arena_release_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksResponse.device_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::DeviceInfo* temp = _impl_.device_info_;
  _impl_.device_info_ = nullptr;
  return temp;
}
inline ::tensorflow::DeviceInfo* WaitForAllTasksResponse::_internal_mutable_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::DeviceInfo>(GetArena());
    _impl_.device_info_ = reinterpret_cast<::tensorflow::DeviceInfo*>(p);
  }
  return _impl_.device_info_;
}
inline ::tensorflow::DeviceInfo* WaitForAllTasksResponse::mutable_device_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::DeviceInfo* _msg = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksResponse.device_info)
  return _msg;
}
inline void WaitForAllTasksResponse::set_allocated_device_info(::tensorflow::DeviceInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.device_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.device_info_ = reinterpret_cast<::tensorflow::DeviceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksResponse.device_info)
}

// -------------------------------------------------------------------

// ShutdownTaskRequest

// .tensorflow.CoordinatedTask source_task = 1;
inline bool ShutdownTaskRequest::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void ShutdownTaskRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& ShutdownTaskRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& ShutdownTaskRequest::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ShutdownTaskRequest.source_task)
  return _internal_source_task();
}
inline void ShutdownTaskRequest::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.ShutdownTaskRequest.source_task)
}
inline ::tensorflow::CoordinatedTask* ShutdownTaskRequest::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* ShutdownTaskRequest::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ShutdownTaskRequest.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ShutdownTaskRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* ShutdownTaskRequest::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.ShutdownTaskRequest.source_task)
  return _msg;
}
inline void ShutdownTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ShutdownTaskRequest.source_task)
}

// -------------------------------------------------------------------

// ShutdownTaskResponse

// -------------------------------------------------------------------

// ResetTaskRequest

// .tensorflow.CoordinatedTask source_task = 1;
inline bool ResetTaskRequest::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void ResetTaskRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& ResetTaskRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& ResetTaskRequest::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ResetTaskRequest.source_task)
  return _internal_source_task();
}
inline void ResetTaskRequest::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.ResetTaskRequest.source_task)
}
inline ::tensorflow::CoordinatedTask* ResetTaskRequest::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* ResetTaskRequest::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ResetTaskRequest.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ResetTaskRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* ResetTaskRequest::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.ResetTaskRequest.source_task)
  return _msg;
}
inline void ResetTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ResetTaskRequest.source_task)
}

// -------------------------------------------------------------------

// ResetTaskResponse

// -------------------------------------------------------------------

// ReportErrorToTaskRequest

// int32 error_code = 1;
inline void ReportErrorToTaskRequest::clear_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_ = 0;
}
inline ::int32_t ReportErrorToTaskRequest::error_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_code)
  return _internal_error_code();
}
inline void ReportErrorToTaskRequest::set_error_code(::int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToTaskRequest.error_code)
}
inline ::int32_t ReportErrorToTaskRequest::_internal_error_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_code_;
}
inline void ReportErrorToTaskRequest::_internal_set_error_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_ = value;
}

// string error_message = 2;
inline void ReportErrorToTaskRequest::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ReportErrorToTaskRequest::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportErrorToTaskRequest::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToTaskRequest.error_message)
}
inline std::string* ReportErrorToTaskRequest::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToTaskRequest.error_message)
  return _s;
}
inline const std::string& ReportErrorToTaskRequest::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void ReportErrorToTaskRequest::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* ReportErrorToTaskRequest::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* ReportErrorToTaskRequest::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToTaskRequest.error_message)
  return _impl_.error_message_.Release();
}
inline void ReportErrorToTaskRequest::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToTaskRequest.error_message)
}

// .tensorflow.CoordinationServiceError error_payload = 5;
inline bool ReportErrorToTaskRequest::has_error_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_payload_ != nullptr);
  return value;
}
inline void ReportErrorToTaskRequest::clear_error_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_payload_ != nullptr) _impl_.error_payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinationServiceError& ReportErrorToTaskRequest::_internal_error_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinationServiceError* p = _impl_.error_payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinationServiceError&>(::tensorflow::_CoordinationServiceError_default_instance_);
}
inline const ::tensorflow::CoordinationServiceError& ReportErrorToTaskRequest::error_payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_payload)
  return _internal_error_payload();
}
inline void ReportErrorToTaskRequest::unsafe_arena_set_allocated_error_payload(::tensorflow::CoordinationServiceError* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_payload_);
  }
  _impl_.error_payload_ = reinterpret_cast<::tensorflow::CoordinationServiceError*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.ReportErrorToTaskRequest.error_payload)
}
inline ::tensorflow::CoordinationServiceError* ReportErrorToTaskRequest::release_error_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinationServiceError* released = _impl_.error_payload_;
  _impl_.error_payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinationServiceError* ReportErrorToTaskRequest::unsafe_arena_release_error_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToTaskRequest.error_payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinationServiceError* temp = _impl_.error_payload_;
  _impl_.error_payload_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinationServiceError* ReportErrorToTaskRequest::_internal_mutable_error_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinationServiceError>(GetArena());
    _impl_.error_payload_ = reinterpret_cast<::tensorflow::CoordinationServiceError*>(p);
  }
  return _impl_.error_payload_;
}
inline ::tensorflow::CoordinationServiceError* ReportErrorToTaskRequest::mutable_error_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinationServiceError* _msg = _internal_mutable_error_payload();
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToTaskRequest.error_payload)
  return _msg;
}
inline void ReportErrorToTaskRequest::set_allocated_error_payload(::tensorflow::CoordinationServiceError* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.error_payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_payload_ = reinterpret_cast<::tensorflow::CoordinationServiceError*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToTaskRequest.error_payload)
}

// -------------------------------------------------------------------

// ReportErrorToTaskResponse

// -------------------------------------------------------------------

// ReportErrorToServiceRequest

// int32 error_code = 1;
inline void ReportErrorToServiceRequest::clear_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_ = 0;
}
inline ::int32_t ReportErrorToServiceRequest::error_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_code)
  return _internal_error_code();
}
inline void ReportErrorToServiceRequest::set_error_code(::int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToServiceRequest.error_code)
}
inline ::int32_t ReportErrorToServiceRequest::_internal_error_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_code_;
}
inline void ReportErrorToServiceRequest::_internal_set_error_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_ = value;
}

// string error_message = 2;
inline void ReportErrorToServiceRequest::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ReportErrorToServiceRequest::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportErrorToServiceRequest::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToServiceRequest.error_message)
}
inline std::string* ReportErrorToServiceRequest::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToServiceRequest.error_message)
  return _s;
}
inline const std::string& ReportErrorToServiceRequest::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void ReportErrorToServiceRequest::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* ReportErrorToServiceRequest::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* ReportErrorToServiceRequest::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToServiceRequest.error_message)
  return _impl_.error_message_.Release();
}
inline void ReportErrorToServiceRequest::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToServiceRequest.error_message)
}

// .tensorflow.CoordinatedTask error_origin = 5;
inline bool ReportErrorToServiceRequest::has_error_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_origin_ != nullptr);
  return value;
}
inline void ReportErrorToServiceRequest::clear_error_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_origin_ != nullptr) _impl_.error_origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& ReportErrorToServiceRequest::_internal_error_origin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.error_origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& ReportErrorToServiceRequest::error_origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_origin)
  return _internal_error_origin();
}
inline void ReportErrorToServiceRequest::unsafe_arena_set_allocated_error_origin(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_origin_);
  }
  _impl_.error_origin_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.ReportErrorToServiceRequest.error_origin)
}
inline ::tensorflow::CoordinatedTask* ReportErrorToServiceRequest::release_error_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.error_origin_;
  _impl_.error_origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* ReportErrorToServiceRequest::unsafe_arena_release_error_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToServiceRequest.error_origin)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.error_origin_;
  _impl_.error_origin_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ReportErrorToServiceRequest::_internal_mutable_error_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_origin_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.error_origin_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.error_origin_;
}
inline ::tensorflow::CoordinatedTask* ReportErrorToServiceRequest::mutable_error_origin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_error_origin();
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToServiceRequest.error_origin)
  return _msg;
}
inline void ReportErrorToServiceRequest::set_allocated_error_origin(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.error_origin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_origin_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToServiceRequest.error_origin)
}

// -------------------------------------------------------------------

// ReportErrorToServiceResponse

// -------------------------------------------------------------------

// GetTaskStateRequest

// repeated .tensorflow.CoordinatedTask source_task = 1;
inline int GetTaskStateRequest::_internal_source_task_size() const {
  return _internal_source_task().size();
}
inline int GetTaskStateRequest::source_task_size() const {
  return _internal_source_task_size();
}
inline void GetTaskStateRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_task_.Clear();
}
inline ::tensorflow::CoordinatedTask* GetTaskStateRequest::mutable_source_task(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetTaskStateRequest.source_task)
  return _internal_mutable_source_task()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* GetTaskStateRequest::mutable_source_task()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetTaskStateRequest.source_task)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_source_task();
}
inline const ::tensorflow::CoordinatedTask& GetTaskStateRequest::source_task(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetTaskStateRequest.source_task)
  return _internal_source_task().Get(index);
}
inline ::tensorflow::CoordinatedTask* GetTaskStateRequest::add_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::CoordinatedTask* _add = _internal_mutable_source_task()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.GetTaskStateRequest.source_task)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& GetTaskStateRequest::source_task() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GetTaskStateRequest.source_task)
  return _internal_source_task();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>&
GetTaskStateRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_task_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>*
GetTaskStateRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.source_task_;
}

// -------------------------------------------------------------------

// GetTaskStateResponse

// repeated .tensorflow.CoordinatedTaskStateInfo task_state = 1;
inline int GetTaskStateResponse::_internal_task_state_size() const {
  return _internal_task_state().size();
}
inline int GetTaskStateResponse::task_state_size() const {
  return _internal_task_state_size();
}
inline void GetTaskStateResponse::clear_task_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_state_.Clear();
}
inline ::tensorflow::CoordinatedTaskStateInfo* GetTaskStateResponse::mutable_task_state(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetTaskStateResponse.task_state)
  return _internal_mutable_task_state()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>* GetTaskStateResponse::mutable_task_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetTaskStateResponse.task_state)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_task_state();
}
inline const ::tensorflow::CoordinatedTaskStateInfo& GetTaskStateResponse::task_state(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetTaskStateResponse.task_state)
  return _internal_task_state().Get(index);
}
inline ::tensorflow::CoordinatedTaskStateInfo* GetTaskStateResponse::add_task_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::CoordinatedTaskStateInfo* _add = _internal_mutable_task_state()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.GetTaskStateResponse.task_state)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>& GetTaskStateResponse::task_state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GetTaskStateResponse.task_state)
  return _internal_task_state();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>&
GetTaskStateResponse::_internal_task_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_state_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>*
GetTaskStateResponse::_internal_mutable_task_state() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.task_state_;
}

// -------------------------------------------------------------------

// GetJobStateRequest

// string job_name = 1;
inline void GetJobStateRequest::clear_job_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_name_.ClearToEmpty();
}
inline const std::string& GetJobStateRequest::job_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetJobStateRequest.job_name)
  return _internal_job_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetJobStateRequest::set_job_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GetJobStateRequest.job_name)
}
inline std::string* GetJobStateRequest::mutable_job_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.GetJobStateRequest.job_name)
  return _s;
}
inline const std::string& GetJobStateRequest::_internal_job_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_name_.Get();
}
inline void GetJobStateRequest::_internal_set_job_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_name_.Set(value, GetArena());
}
inline std::string* GetJobStateRequest::_internal_mutable_job_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.job_name_.Mutable( GetArena());
}
inline std::string* GetJobStateRequest::release_job_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GetJobStateRequest.job_name)
  return _impl_.job_name_.Release();
}
inline void GetJobStateRequest::set_allocated_job_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.job_name_.IsDefault()) {
          _impl_.job_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetJobStateRequest.job_name)
}

// -------------------------------------------------------------------

// GetJobStateResponse

// repeated .tensorflow.CoordinatedTaskStateInfo task_state = 1;
inline int GetJobStateResponse::_internal_task_state_size() const {
  return _internal_task_state().size();
}
inline int GetJobStateResponse::task_state_size() const {
  return _internal_task_state_size();
}
inline void GetJobStateResponse::clear_task_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_state_.Clear();
}
inline ::tensorflow::CoordinatedTaskStateInfo* GetJobStateResponse::mutable_task_state(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetJobStateResponse.task_state)
  return _internal_mutable_task_state()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>* GetJobStateResponse::mutable_task_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetJobStateResponse.task_state)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_task_state();
}
inline const ::tensorflow::CoordinatedTaskStateInfo& GetJobStateResponse::task_state(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetJobStateResponse.task_state)
  return _internal_task_state().Get(index);
}
inline ::tensorflow::CoordinatedTaskStateInfo* GetJobStateResponse::add_task_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::CoordinatedTaskStateInfo* _add = _internal_mutable_task_state()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.GetJobStateResponse.task_state)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>& GetJobStateResponse::task_state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GetJobStateResponse.task_state)
  return _internal_task_state();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>&
GetJobStateResponse::_internal_task_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_state_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTaskStateInfo>*
GetJobStateResponse::_internal_mutable_task_state() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.task_state_;
}

// -------------------------------------------------------------------

// KeyValueEntry

// string key = 1;
inline void KeyValueEntry::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& KeyValueEntry::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.KeyValueEntry.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyValueEntry::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.KeyValueEntry.key)
}
inline std::string* KeyValueEntry::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tensorflow.KeyValueEntry.key)
  return _s;
}
inline const std::string& KeyValueEntry::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void KeyValueEntry::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* KeyValueEntry::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* KeyValueEntry::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.KeyValueEntry.key)
  return _impl_.key_.Release();
}
inline void KeyValueEntry::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.KeyValueEntry.key)
}

// bytes value = 2;
inline void KeyValueEntry::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& KeyValueEntry::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.KeyValueEntry.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyValueEntry::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.KeyValueEntry.value)
}
inline std::string* KeyValueEntry::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.KeyValueEntry.value)
  return _s;
}
inline const std::string& KeyValueEntry::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void KeyValueEntry::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* KeyValueEntry::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* KeyValueEntry::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.KeyValueEntry.value)
  return _impl_.value_.Release();
}
inline void KeyValueEntry::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.KeyValueEntry.value)
}

// -------------------------------------------------------------------

// InsertKeyValueRequest

// .tensorflow.KeyValueEntry kv = 1;
inline bool InsertKeyValueRequest::has_kv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kv_ != nullptr);
  return value;
}
inline void InsertKeyValueRequest::clear_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kv_ != nullptr) _impl_.kv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::KeyValueEntry& InsertKeyValueRequest::_internal_kv() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::KeyValueEntry* p = _impl_.kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::KeyValueEntry&>(::tensorflow::_KeyValueEntry_default_instance_);
}
inline const ::tensorflow::KeyValueEntry& InsertKeyValueRequest::kv() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.InsertKeyValueRequest.kv)
  return _internal_kv();
}
inline void InsertKeyValueRequest::unsafe_arena_set_allocated_kv(::tensorflow::KeyValueEntry* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kv_);
  }
  _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.InsertKeyValueRequest.kv)
}
inline ::tensorflow::KeyValueEntry* InsertKeyValueRequest::release_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::KeyValueEntry* released = _impl_.kv_;
  _impl_.kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::KeyValueEntry* InsertKeyValueRequest::unsafe_arena_release_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.InsertKeyValueRequest.kv)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::KeyValueEntry* temp = _impl_.kv_;
  _impl_.kv_ = nullptr;
  return temp;
}
inline ::tensorflow::KeyValueEntry* InsertKeyValueRequest::_internal_mutable_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kv_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::KeyValueEntry>(GetArena());
    _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(p);
  }
  return _impl_.kv_;
}
inline ::tensorflow::KeyValueEntry* InsertKeyValueRequest::mutable_kv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::KeyValueEntry* _msg = _internal_mutable_kv();
  // @@protoc_insertion_point(field_mutable:tensorflow.InsertKeyValueRequest.kv)
  return _msg;
}
inline void InsertKeyValueRequest::set_allocated_kv(::tensorflow::KeyValueEntry* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.kv_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.InsertKeyValueRequest.kv)
}

// bool allow_overwrite = 2;
inline void InsertKeyValueRequest::clear_allow_overwrite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_overwrite_ = false;
}
inline bool InsertKeyValueRequest::allow_overwrite() const {
  // @@protoc_insertion_point(field_get:tensorflow.InsertKeyValueRequest.allow_overwrite)
  return _internal_allow_overwrite();
}
inline void InsertKeyValueRequest::set_allow_overwrite(bool value) {
  _internal_set_allow_overwrite(value);
  // @@protoc_insertion_point(field_set:tensorflow.InsertKeyValueRequest.allow_overwrite)
}
inline bool InsertKeyValueRequest::_internal_allow_overwrite() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.allow_overwrite_;
}
inline void InsertKeyValueRequest::_internal_set_allow_overwrite(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_overwrite_ = value;
}

// -------------------------------------------------------------------

// InsertKeyValueResponse

// -------------------------------------------------------------------

// GetKeyValueRequest

// string key = 1;
inline void GetKeyValueRequest::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& GetKeyValueRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetKeyValueRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GetKeyValueRequest.key)
}
inline std::string* GetKeyValueRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueRequest.key)
  return _s;
}
inline const std::string& GetKeyValueRequest::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void GetKeyValueRequest::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* GetKeyValueRequest::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* GetKeyValueRequest::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueRequest.key)
  return _impl_.key_.Release();
}
inline void GetKeyValueRequest::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueRequest.key)
}

// -------------------------------------------------------------------

// GetKeyValueResponse

// .tensorflow.KeyValueEntry kv = 1;
inline bool GetKeyValueResponse::has_kv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kv_ != nullptr);
  return value;
}
inline void GetKeyValueResponse::clear_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kv_ != nullptr) _impl_.kv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::KeyValueEntry& GetKeyValueResponse::_internal_kv() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::KeyValueEntry* p = _impl_.kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::KeyValueEntry&>(::tensorflow::_KeyValueEntry_default_instance_);
}
inline const ::tensorflow::KeyValueEntry& GetKeyValueResponse::kv() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueResponse.kv)
  return _internal_kv();
}
inline void GetKeyValueResponse::unsafe_arena_set_allocated_kv(::tensorflow::KeyValueEntry* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kv_);
  }
  _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.GetKeyValueResponse.kv)
}
inline ::tensorflow::KeyValueEntry* GetKeyValueResponse::release_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::KeyValueEntry* released = _impl_.kv_;
  _impl_.kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::KeyValueEntry* GetKeyValueResponse::unsafe_arena_release_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueResponse.kv)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::KeyValueEntry* temp = _impl_.kv_;
  _impl_.kv_ = nullptr;
  return temp;
}
inline ::tensorflow::KeyValueEntry* GetKeyValueResponse::_internal_mutable_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kv_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::KeyValueEntry>(GetArena());
    _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(p);
  }
  return _impl_.kv_;
}
inline ::tensorflow::KeyValueEntry* GetKeyValueResponse::mutable_kv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::KeyValueEntry* _msg = _internal_mutable_kv();
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueResponse.kv)
  return _msg;
}
inline void GetKeyValueResponse::set_allocated_kv(::tensorflow::KeyValueEntry* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.kv_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueResponse.kv)
}

// -------------------------------------------------------------------

// TryGetKeyValueRequest

// string key = 1;
inline void TryGetKeyValueRequest::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& TryGetKeyValueRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TryGetKeyValueRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TryGetKeyValueRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TryGetKeyValueRequest.key)
}
inline std::string* TryGetKeyValueRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tensorflow.TryGetKeyValueRequest.key)
  return _s;
}
inline const std::string& TryGetKeyValueRequest::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void TryGetKeyValueRequest::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* TryGetKeyValueRequest::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* TryGetKeyValueRequest::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TryGetKeyValueRequest.key)
  return _impl_.key_.Release();
}
inline void TryGetKeyValueRequest::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TryGetKeyValueRequest.key)
}

// -------------------------------------------------------------------

// TryGetKeyValueResponse

// .tensorflow.KeyValueEntry kv = 1;
inline bool TryGetKeyValueResponse::has_kv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kv_ != nullptr);
  return value;
}
inline void TryGetKeyValueResponse::clear_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kv_ != nullptr) _impl_.kv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::KeyValueEntry& TryGetKeyValueResponse::_internal_kv() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::KeyValueEntry* p = _impl_.kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::KeyValueEntry&>(::tensorflow::_KeyValueEntry_default_instance_);
}
inline const ::tensorflow::KeyValueEntry& TryGetKeyValueResponse::kv() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TryGetKeyValueResponse.kv)
  return _internal_kv();
}
inline void TryGetKeyValueResponse::unsafe_arena_set_allocated_kv(::tensorflow::KeyValueEntry* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kv_);
  }
  _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TryGetKeyValueResponse.kv)
}
inline ::tensorflow::KeyValueEntry* TryGetKeyValueResponse::release_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::KeyValueEntry* released = _impl_.kv_;
  _impl_.kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::KeyValueEntry* TryGetKeyValueResponse::unsafe_arena_release_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TryGetKeyValueResponse.kv)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::KeyValueEntry* temp = _impl_.kv_;
  _impl_.kv_ = nullptr;
  return temp;
}
inline ::tensorflow::KeyValueEntry* TryGetKeyValueResponse::_internal_mutable_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kv_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::KeyValueEntry>(GetArena());
    _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(p);
  }
  return _impl_.kv_;
}
inline ::tensorflow::KeyValueEntry* TryGetKeyValueResponse::mutable_kv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::KeyValueEntry* _msg = _internal_mutable_kv();
  // @@protoc_insertion_point(field_mutable:tensorflow.TryGetKeyValueResponse.kv)
  return _msg;
}
inline void TryGetKeyValueResponse::set_allocated_kv(::tensorflow::KeyValueEntry* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.kv_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.kv_ = reinterpret_cast<::tensorflow::KeyValueEntry*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TryGetKeyValueResponse.kv)
}

// -------------------------------------------------------------------

// GetKeyValueDirRequest

// string directory_key = 1;
inline void GetKeyValueDirRequest::clear_directory_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.directory_key_.ClearToEmpty();
}
inline const std::string& GetKeyValueDirRequest::directory_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueDirRequest.directory_key)
  return _internal_directory_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetKeyValueDirRequest::set_directory_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.directory_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GetKeyValueDirRequest.directory_key)
}
inline std::string* GetKeyValueDirRequest::mutable_directory_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_directory_key();
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueDirRequest.directory_key)
  return _s;
}
inline const std::string& GetKeyValueDirRequest::_internal_directory_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.directory_key_.Get();
}
inline void GetKeyValueDirRequest::_internal_set_directory_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.directory_key_.Set(value, GetArena());
}
inline std::string* GetKeyValueDirRequest::_internal_mutable_directory_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.directory_key_.Mutable( GetArena());
}
inline std::string* GetKeyValueDirRequest::release_directory_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueDirRequest.directory_key)
  return _impl_.directory_key_.Release();
}
inline void GetKeyValueDirRequest::set_allocated_directory_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.directory_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.directory_key_.IsDefault()) {
          _impl_.directory_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueDirRequest.directory_key)
}

// -------------------------------------------------------------------

// GetKeyValueDirResponse

// string directory_key = 1;
inline void GetKeyValueDirResponse::clear_directory_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.directory_key_.ClearToEmpty();
}
inline const std::string& GetKeyValueDirResponse::directory_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueDirResponse.directory_key)
  return _internal_directory_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetKeyValueDirResponse::set_directory_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.directory_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GetKeyValueDirResponse.directory_key)
}
inline std::string* GetKeyValueDirResponse::mutable_directory_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_directory_key();
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueDirResponse.directory_key)
  return _s;
}
inline const std::string& GetKeyValueDirResponse::_internal_directory_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.directory_key_.Get();
}
inline void GetKeyValueDirResponse::_internal_set_directory_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.directory_key_.Set(value, GetArena());
}
inline std::string* GetKeyValueDirResponse::_internal_mutable_directory_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.directory_key_.Mutable( GetArena());
}
inline std::string* GetKeyValueDirResponse::release_directory_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueDirResponse.directory_key)
  return _impl_.directory_key_.Release();
}
inline void GetKeyValueDirResponse::set_allocated_directory_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.directory_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.directory_key_.IsDefault()) {
          _impl_.directory_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueDirResponse.directory_key)
}

// repeated .tensorflow.KeyValueEntry kv = 2;
inline int GetKeyValueDirResponse::_internal_kv_size() const {
  return _internal_kv().size();
}
inline int GetKeyValueDirResponse::kv_size() const {
  return _internal_kv_size();
}
inline void GetKeyValueDirResponse::clear_kv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kv_.Clear();
}
inline ::tensorflow::KeyValueEntry* GetKeyValueDirResponse::mutable_kv(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueDirResponse.kv)
  return _internal_mutable_kv()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::KeyValueEntry>* GetKeyValueDirResponse::mutable_kv()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetKeyValueDirResponse.kv)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_kv();
}
inline const ::tensorflow::KeyValueEntry& GetKeyValueDirResponse::kv(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueDirResponse.kv)
  return _internal_kv().Get(index);
}
inline ::tensorflow::KeyValueEntry* GetKeyValueDirResponse::add_kv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::KeyValueEntry* _add = _internal_mutable_kv()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.GetKeyValueDirResponse.kv)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::KeyValueEntry>& GetKeyValueDirResponse::kv() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GetKeyValueDirResponse.kv)
  return _internal_kv();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::KeyValueEntry>&
GetKeyValueDirResponse::_internal_kv() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.kv_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::KeyValueEntry>*
GetKeyValueDirResponse::_internal_mutable_kv() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.kv_;
}

// -------------------------------------------------------------------

// DeleteKeyValueRequest

// string key = 1;
inline void DeleteKeyValueRequest::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DeleteKeyValueRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DeleteKeyValueRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteKeyValueRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DeleteKeyValueRequest.key)
}
inline std::string* DeleteKeyValueRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tensorflow.DeleteKeyValueRequest.key)
  return _s;
}
inline const std::string& DeleteKeyValueRequest::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void DeleteKeyValueRequest::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* DeleteKeyValueRequest::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* DeleteKeyValueRequest::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DeleteKeyValueRequest.key)
  return _impl_.key_.Release();
}
inline void DeleteKeyValueRequest::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DeleteKeyValueRequest.key)
}

// bool is_directory = 2;
inline void DeleteKeyValueRequest::clear_is_directory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_directory_ = false;
}
inline bool DeleteKeyValueRequest::is_directory() const {
  // @@protoc_insertion_point(field_get:tensorflow.DeleteKeyValueRequest.is_directory)
  return _internal_is_directory();
}
inline void DeleteKeyValueRequest::set_is_directory(bool value) {
  _internal_set_is_directory(value);
  // @@protoc_insertion_point(field_set:tensorflow.DeleteKeyValueRequest.is_directory)
}
inline bool DeleteKeyValueRequest::_internal_is_directory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_directory_;
}
inline void DeleteKeyValueRequest::_internal_set_is_directory(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_directory_ = value;
}

// -------------------------------------------------------------------

// DeleteKeyValueResponse

// -------------------------------------------------------------------

// BarrierRequest

// string barrier_id = 1;
inline void BarrierRequest::clear_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.ClearToEmpty();
}
inline const std::string& BarrierRequest::barrier_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.barrier_id)
  return _internal_barrier_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BarrierRequest::set_barrier_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.BarrierRequest.barrier_id)
}
inline std::string* BarrierRequest::mutable_barrier_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_barrier_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.barrier_id)
  return _s;
}
inline const std::string& BarrierRequest::_internal_barrier_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.barrier_id_.Get();
}
inline void BarrierRequest::_internal_set_barrier_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.Set(value, GetArena());
}
inline std::string* BarrierRequest::_internal_mutable_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.barrier_id_.Mutable( GetArena());
}
inline std::string* BarrierRequest::release_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BarrierRequest.barrier_id)
  return _impl_.barrier_id_.Release();
}
inline void BarrierRequest::set_allocated_barrier_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.barrier_id_.IsDefault()) {
          _impl_.barrier_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BarrierRequest.barrier_id)
}

// int64 barrier_timeout_in_ms = 2;
inline void BarrierRequest::clear_barrier_timeout_in_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_timeout_in_ms_ = ::int64_t{0};
}
inline ::int64_t BarrierRequest::barrier_timeout_in_ms() const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.barrier_timeout_in_ms)
  return _internal_barrier_timeout_in_ms();
}
inline void BarrierRequest::set_barrier_timeout_in_ms(::int64_t value) {
  _internal_set_barrier_timeout_in_ms(value);
  // @@protoc_insertion_point(field_set:tensorflow.BarrierRequest.barrier_timeout_in_ms)
}
inline ::int64_t BarrierRequest::_internal_barrier_timeout_in_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.barrier_timeout_in_ms_;
}
inline void BarrierRequest::_internal_set_barrier_timeout_in_ms(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_timeout_in_ms_ = value;
}

// repeated .tensorflow.CoordinatedTask tasks = 3;
inline int BarrierRequest::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int BarrierRequest::tasks_size() const {
  return _internal_tasks_size();
}
inline void BarrierRequest::clear_tasks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tasks_.Clear();
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* BarrierRequest::mutable_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BarrierRequest.tasks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tasks();
}
inline const ::tensorflow::CoordinatedTask& BarrierRequest::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.tasks)
  return _internal_tasks().Get(index);
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::add_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::CoordinatedTask* _add = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.BarrierRequest.tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& BarrierRequest::tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.BarrierRequest.tasks)
  return _internal_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>&
BarrierRequest::_internal_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>*
BarrierRequest::_internal_mutable_tasks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tasks_;
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool BarrierRequest::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void BarrierRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& BarrierRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& BarrierRequest::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.source_task)
  return _internal_source_task();
}
inline void BarrierRequest::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.BarrierRequest.source_task)
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BarrierRequest.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.source_task)
  return _msg;
}
inline void BarrierRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BarrierRequest.source_task)
}

// int64 counter = 5;
inline void BarrierRequest::clear_counter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = ::int64_t{0};
}
inline ::int64_t BarrierRequest::counter() const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.counter)
  return _internal_counter();
}
inline void BarrierRequest::set_counter(::int64_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:tensorflow.BarrierRequest.counter)
}
inline ::int64_t BarrierRequest::_internal_counter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.counter_;
}
inline void BarrierRequest::_internal_set_counter(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = value;
}

// -------------------------------------------------------------------

// BarrierResponse

// int64 counter = 1;
inline void BarrierResponse::clear_counter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = ::int64_t{0};
}
inline ::int64_t BarrierResponse::counter() const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierResponse.counter)
  return _internal_counter();
}
inline void BarrierResponse::set_counter(::int64_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:tensorflow.BarrierResponse.counter)
}
inline ::int64_t BarrierResponse::_internal_counter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.counter_;
}
inline void BarrierResponse::_internal_set_counter(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = value;
}

// -------------------------------------------------------------------

// GetAliveTasksRequest

// .tensorflow.CoordinatedTask requesting_task = 1;
inline bool GetAliveTasksRequest::has_requesting_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requesting_task_ != nullptr);
  return value;
}
inline void GetAliveTasksRequest::clear_requesting_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.requesting_task_ != nullptr) _impl_.requesting_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& GetAliveTasksRequest::_internal_requesting_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.requesting_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& GetAliveTasksRequest::requesting_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetAliveTasksRequest.requesting_task)
  return _internal_requesting_task();
}
inline void GetAliveTasksRequest::unsafe_arena_set_allocated_requesting_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requesting_task_);
  }
  _impl_.requesting_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.GetAliveTasksRequest.requesting_task)
}
inline ::tensorflow::CoordinatedTask* GetAliveTasksRequest::release_requesting_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.requesting_task_;
  _impl_.requesting_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* GetAliveTasksRequest::unsafe_arena_release_requesting_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GetAliveTasksRequest.requesting_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.requesting_task_;
  _impl_.requesting_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* GetAliveTasksRequest::_internal_mutable_requesting_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.requesting_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.requesting_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.requesting_task_;
}
inline ::tensorflow::CoordinatedTask* GetAliveTasksRequest::mutable_requesting_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_requesting_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.GetAliveTasksRequest.requesting_task)
  return _msg;
}
inline void GetAliveTasksRequest::set_allocated_requesting_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.requesting_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.requesting_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetAliveTasksRequest.requesting_task)
}

// repeated .tensorflow.CoordinatedTask tasks = 2;
inline int GetAliveTasksRequest::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int GetAliveTasksRequest::tasks_size() const {
  return _internal_tasks_size();
}
inline void GetAliveTasksRequest::clear_tasks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tasks_.Clear();
}
inline ::tensorflow::CoordinatedTask* GetAliveTasksRequest::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetAliveTasksRequest.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* GetAliveTasksRequest::mutable_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetAliveTasksRequest.tasks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tasks();
}
inline const ::tensorflow::CoordinatedTask& GetAliveTasksRequest::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetAliveTasksRequest.tasks)
  return _internal_tasks().Get(index);
}
inline ::tensorflow::CoordinatedTask* GetAliveTasksRequest::add_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::CoordinatedTask* _add = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.GetAliveTasksRequest.tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& GetAliveTasksRequest::tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GetAliveTasksRequest.tasks)
  return _internal_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>&
GetAliveTasksRequest::_internal_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>*
GetAliveTasksRequest::_internal_mutable_tasks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tasks_;
}

// -------------------------------------------------------------------

// GetAliveTasksResponse

// repeated .tensorflow.CoordinatedTask alive_tasks = 1;
inline int GetAliveTasksResponse::_internal_alive_tasks_size() const {
  return _internal_alive_tasks().size();
}
inline int GetAliveTasksResponse::alive_tasks_size() const {
  return _internal_alive_tasks_size();
}
inline void GetAliveTasksResponse::clear_alive_tasks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alive_tasks_.Clear();
}
inline ::tensorflow::CoordinatedTask* GetAliveTasksResponse::mutable_alive_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetAliveTasksResponse.alive_tasks)
  return _internal_mutable_alive_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>* GetAliveTasksResponse::mutable_alive_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetAliveTasksResponse.alive_tasks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_alive_tasks();
}
inline const ::tensorflow::CoordinatedTask& GetAliveTasksResponse::alive_tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GetAliveTasksResponse.alive_tasks)
  return _internal_alive_tasks().Get(index);
}
inline ::tensorflow::CoordinatedTask* GetAliveTasksResponse::add_alive_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::CoordinatedTask* _add = _internal_mutable_alive_tasks()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.GetAliveTasksResponse.alive_tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>& GetAliveTasksResponse::alive_tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GetAliveTasksResponse.alive_tasks)
  return _internal_alive_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>&
GetAliveTasksResponse::_internal_alive_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alive_tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::CoordinatedTask>*
GetAliveTasksResponse::_internal_mutable_alive_tasks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.alive_tasks_;
}

// repeated fixed64 incarnations = 2;
inline int GetAliveTasksResponse::_internal_incarnations_size() const {
  return _internal_incarnations().size();
}
inline int GetAliveTasksResponse::incarnations_size() const {
  return _internal_incarnations_size();
}
inline void GetAliveTasksResponse::clear_incarnations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.incarnations_.Clear();
}
inline ::uint64_t GetAliveTasksResponse::incarnations(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.GetAliveTasksResponse.incarnations)
  return _internal_incarnations().Get(index);
}
inline void GetAliveTasksResponse::set_incarnations(int index, ::uint64_t value) {
  _internal_mutable_incarnations()->Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.GetAliveTasksResponse.incarnations)
}
inline void GetAliveTasksResponse::add_incarnations(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_incarnations()->Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.GetAliveTasksResponse.incarnations)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GetAliveTasksResponse::incarnations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GetAliveTasksResponse.incarnations)
  return _internal_incarnations();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GetAliveTasksResponse::mutable_incarnations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetAliveTasksResponse.incarnations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_incarnations();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
GetAliveTasksResponse::_internal_incarnations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.incarnations_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GetAliveTasksResponse::_internal_mutable_incarnations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.incarnations_;
}

// -------------------------------------------------------------------

// CancelBarrierRequest

// string barrier_id = 1;
inline void CancelBarrierRequest::clear_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.ClearToEmpty();
}
inline const std::string& CancelBarrierRequest::barrier_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CancelBarrierRequest.barrier_id)
  return _internal_barrier_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelBarrierRequest::set_barrier_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CancelBarrierRequest.barrier_id)
}
inline std::string* CancelBarrierRequest::mutable_barrier_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_barrier_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.CancelBarrierRequest.barrier_id)
  return _s;
}
inline const std::string& CancelBarrierRequest::_internal_barrier_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.barrier_id_.Get();
}
inline void CancelBarrierRequest::_internal_set_barrier_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.Set(value, GetArena());
}
inline std::string* CancelBarrierRequest::_internal_mutable_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.barrier_id_.Mutable( GetArena());
}
inline std::string* CancelBarrierRequest::release_barrier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CancelBarrierRequest.barrier_id)
  return _impl_.barrier_id_.Release();
}
inline void CancelBarrierRequest::set_allocated_barrier_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.barrier_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.barrier_id_.IsDefault()) {
          _impl_.barrier_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CancelBarrierRequest.barrier_id)
}

// int64 counter = 3;
inline void CancelBarrierRequest::clear_counter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = ::int64_t{0};
}
inline ::int64_t CancelBarrierRequest::counter() const {
  // @@protoc_insertion_point(field_get:tensorflow.CancelBarrierRequest.counter)
  return _internal_counter();
}
inline void CancelBarrierRequest::set_counter(::int64_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:tensorflow.CancelBarrierRequest.counter)
}
inline ::int64_t CancelBarrierRequest::_internal_counter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.counter_;
}
inline void CancelBarrierRequest::_internal_set_counter(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = value;
}

// .tensorflow.CoordinatedTask source_task = 2;
inline bool CancelBarrierRequest::has_source_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_task_ != nullptr);
  return value;
}
inline void CancelBarrierRequest::clear_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ != nullptr) _impl_.source_task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CoordinatedTask& CancelBarrierRequest::_internal_source_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CoordinatedTask* p = _impl_.source_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CoordinatedTask&>(::tensorflow::_CoordinatedTask_default_instance_);
}
inline const ::tensorflow::CoordinatedTask& CancelBarrierRequest::source_task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CancelBarrierRequest.source_task)
  return _internal_source_task();
}
inline void CancelBarrierRequest::unsafe_arena_set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_task_);
  }
  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CancelBarrierRequest.source_task)
}
inline ::tensorflow::CoordinatedTask* CancelBarrierRequest::release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* released = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CoordinatedTask* CancelBarrierRequest::unsafe_arena_release_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CancelBarrierRequest.source_task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CoordinatedTask* temp = _impl_.source_task_;
  _impl_.source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* CancelBarrierRequest::_internal_mutable_source_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CoordinatedTask>(GetArena());
    _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(p);
  }
  return _impl_.source_task_;
}
inline ::tensorflow::CoordinatedTask* CancelBarrierRequest::mutable_source_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CoordinatedTask* _msg = _internal_mutable_source_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.CancelBarrierRequest.source_task)
  return _msg;
}
inline void CancelBarrierRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.source_task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_task_ = reinterpret_cast<::tensorflow::CoordinatedTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CancelBarrierRequest.source_task)
}

// -------------------------------------------------------------------

// CancelBarrierResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tensorflow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tensorflow::CoordinatedTaskState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::CoordinatedTaskState>() {
  return ::tensorflow::CoordinatedTaskState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_xla_2ftsl_2fprotobuf_2fcoordination_5fservice_2eproto_2epb_2eh
