// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: tensorflow/core/framework/dataset_options.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "tensorflow/core/framework/model.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
namespace tensorflow {
namespace data {
class AutotuneOptions;
struct AutotuneOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern AutotuneOptionsDefaultTypeInternal _AutotuneOptions_default_instance_;
class CardinalityOptions;
struct CardinalityOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern CardinalityOptionsDefaultTypeInternal _CardinalityOptions_default_instance_;
class DistributeOptions;
struct DistributeOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern DistributeOptionsDefaultTypeInternal _DistributeOptions_default_instance_;
class OptimizationOptions;
struct OptimizationOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern OptimizationOptionsDefaultTypeInternal _OptimizationOptions_default_instance_;
class Options;
struct OptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern OptionsDefaultTypeInternal _Options_default_instance_;
class ServiceOptions;
struct ServiceOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern ServiceOptionsDefaultTypeInternal _ServiceOptions_default_instance_;
class ThreadingOptions;
struct ThreadingOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern ThreadingOptionsDefaultTypeInternal _ThreadingOptions_default_instance_;
}  // namespace data
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {
namespace data {
enum CardinalityOptions_ComputeLevel : int {
  CardinalityOptions_ComputeLevel_CARDINALITY_COMPUTE_UNSPECIFIED = 0,
  CardinalityOptions_ComputeLevel_CARDINALITY_COMPUTE_LOW = 1,
  CardinalityOptions_ComputeLevel_CARDINALITY_COMPUTE_MODERATE = 2,
  CardinalityOptions_ComputeLevel_CardinalityOptions_ComputeLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CardinalityOptions_ComputeLevel_CardinalityOptions_ComputeLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool CardinalityOptions_ComputeLevel_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t CardinalityOptions_ComputeLevel_internal_data_[];
constexpr CardinalityOptions_ComputeLevel CardinalityOptions_ComputeLevel_ComputeLevel_MIN = static_cast<CardinalityOptions_ComputeLevel>(0);
constexpr CardinalityOptions_ComputeLevel CardinalityOptions_ComputeLevel_ComputeLevel_MAX = static_cast<CardinalityOptions_ComputeLevel>(2);
constexpr int CardinalityOptions_ComputeLevel_ComputeLevel_ARRAYSIZE = 2 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
CardinalityOptions_ComputeLevel_descriptor();
template <typename T>
const std::string& CardinalityOptions_ComputeLevel_Name(T value) {
  static_assert(std::is_same<T, CardinalityOptions_ComputeLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ComputeLevel_Name().");
  return CardinalityOptions_ComputeLevel_Name(static_cast<CardinalityOptions_ComputeLevel>(value));
}
template <>
inline const std::string& CardinalityOptions_ComputeLevel_Name(CardinalityOptions_ComputeLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CardinalityOptions_ComputeLevel_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CardinalityOptions_ComputeLevel_Parse(absl::string_view name, CardinalityOptions_ComputeLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CardinalityOptions_ComputeLevel>(
      CardinalityOptions_ComputeLevel_descriptor(), name, value);
}
enum AutoShardPolicy : int {
  AUTO = 0,
  FILE = 1,
  DATA = 2,
  HINT = 3,
  OFF = -1,
  AutoShardPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AutoShardPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool AutoShardPolicy_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t AutoShardPolicy_internal_data_[];
constexpr AutoShardPolicy AutoShardPolicy_MIN = static_cast<AutoShardPolicy>(-1);
constexpr AutoShardPolicy AutoShardPolicy_MAX = static_cast<AutoShardPolicy>(3);
constexpr int AutoShardPolicy_ARRAYSIZE = 3 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
AutoShardPolicy_descriptor();
template <typename T>
const std::string& AutoShardPolicy_Name(T value) {
  static_assert(std::is_same<T, AutoShardPolicy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AutoShardPolicy_Name().");
  return AutoShardPolicy_Name(static_cast<AutoShardPolicy>(value));
}
template <>
inline const std::string& AutoShardPolicy_Name(AutoShardPolicy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AutoShardPolicy_descriptor,
                                                 -1, 3>(
      static_cast<int>(value));
}
inline bool AutoShardPolicy_Parse(absl::string_view name, AutoShardPolicy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AutoShardPolicy>(
      AutoShardPolicy_descriptor(), name, value);
}
enum ExternalStatePolicy : int {
  POLICY_WARN = 0,
  POLICY_IGNORE = 1,
  POLICY_FAIL = 2,
  ExternalStatePolicy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExternalStatePolicy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool ExternalStatePolicy_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t ExternalStatePolicy_internal_data_[];
constexpr ExternalStatePolicy ExternalStatePolicy_MIN = static_cast<ExternalStatePolicy>(0);
constexpr ExternalStatePolicy ExternalStatePolicy_MAX = static_cast<ExternalStatePolicy>(2);
constexpr int ExternalStatePolicy_ARRAYSIZE = 2 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
ExternalStatePolicy_descriptor();
template <typename T>
const std::string& ExternalStatePolicy_Name(T value) {
  static_assert(std::is_same<T, ExternalStatePolicy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExternalStatePolicy_Name().");
  return ExternalStatePolicy_Name(static_cast<ExternalStatePolicy>(value));
}
template <>
inline const std::string& ExternalStatePolicy_Name(ExternalStatePolicy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExternalStatePolicy_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ExternalStatePolicy_Parse(absl::string_view name, ExternalStatePolicy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalStatePolicy>(
      ExternalStatePolicy_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT ThreadingOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.data.ThreadingOptions) */ {
 public:
  inline ThreadingOptions() : ThreadingOptions(nullptr) {}
  ~ThreadingOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ThreadingOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ThreadingOptions(const ThreadingOptions& from) : ThreadingOptions(nullptr, from) {}
  inline ThreadingOptions(ThreadingOptions&& from) noexcept
      : ThreadingOptions(nullptr, std::move(from)) {}
  inline ThreadingOptions& operator=(const ThreadingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreadingOptions& operator=(ThreadingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThreadingOptions& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalMaxIntraOpParallelismCase {
    kMaxIntraOpParallelism = 1,
    OPTIONAL_MAX_INTRA_OP_PARALLELISM_NOT_SET = 0,
  };
  enum OptionalPrivateThreadpoolSizeCase {
    kPrivateThreadpoolSize = 2,
    OPTIONAL_PRIVATE_THREADPOOL_SIZE_NOT_SET = 0,
  };
  static inline const ThreadingOptions* internal_default_instance() {
    return reinterpret_cast<const ThreadingOptions*>(
        &_ThreadingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ThreadingOptions& a, ThreadingOptions& b) { a.Swap(&b); }
  inline void Swap(ThreadingOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreadingOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreadingOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ThreadingOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ThreadingOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ThreadingOptions& from) { ThreadingOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ThreadingOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.data.ThreadingOptions"; }

 protected:
  explicit ThreadingOptions(::google::protobuf::Arena* arena);
  ThreadingOptions(::google::protobuf::Arena* arena, const ThreadingOptions& from);
  ThreadingOptions(::google::protobuf::Arena* arena, ThreadingOptions&& from) noexcept
      : ThreadingOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxIntraOpParallelismFieldNumber = 1,
    kPrivateThreadpoolSizeFieldNumber = 2,
  };
  // int32 max_intra_op_parallelism = 1;
  bool has_max_intra_op_parallelism() const;
  void clear_max_intra_op_parallelism() ;
  ::int32_t max_intra_op_parallelism() const;
  void set_max_intra_op_parallelism(::int32_t value);

  private:
  ::int32_t _internal_max_intra_op_parallelism() const;
  void _internal_set_max_intra_op_parallelism(::int32_t value);

  public:
  // int32 private_threadpool_size = 2;
  bool has_private_threadpool_size() const;
  void clear_private_threadpool_size() ;
  ::int32_t private_threadpool_size() const;
  void set_private_threadpool_size(::int32_t value);

  private:
  ::int32_t _internal_private_threadpool_size() const;
  void _internal_set_private_threadpool_size(::int32_t value);

  public:
  void clear_optional_max_intra_op_parallelism();
  OptionalMaxIntraOpParallelismCase optional_max_intra_op_parallelism_case() const;
  void clear_optional_private_threadpool_size();
  OptionalPrivateThreadpoolSizeCase optional_private_threadpool_size_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.ThreadingOptions)
 private:
  class _Internal;
  void set_has_max_intra_op_parallelism();
  void set_has_private_threadpool_size();
  inline bool has_optional_max_intra_op_parallelism() const;
  inline void clear_has_optional_max_intra_op_parallelism();
  inline bool has_optional_private_threadpool_size() const;
  inline void clear_has_optional_private_threadpool_size();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ThreadingOptions& from_msg);
    union OptionalMaxIntraOpParallelismUnion {
      constexpr OptionalMaxIntraOpParallelismUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t max_intra_op_parallelism_;
    } optional_max_intra_op_parallelism_;
    union OptionalPrivateThreadpoolSizeUnion {
      constexpr OptionalPrivateThreadpoolSizeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t private_threadpool_size_;
    } optional_private_threadpool_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ServiceOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.data.ServiceOptions) */ {
 public:
  inline ServiceOptions() : ServiceOptions(nullptr) {}
  ~ServiceOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServiceOptions(const ServiceOptions& from) : ServiceOptions(nullptr, from) {}
  inline ServiceOptions(ServiceOptions&& from) noexcept
      : ServiceOptions(nullptr, std::move(from)) {}
  inline ServiceOptions& operator=(const ServiceOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceOptions& operator=(ServiceOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceOptions& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalPinnedCase {
    kPinned = 1,
    OPTIONAL_PINNED_NOT_SET = 0,
  };
  static inline const ServiceOptions* internal_default_instance() {
    return reinterpret_cast<const ServiceOptions*>(
        &_ServiceOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ServiceOptions& a, ServiceOptions& b) { a.Swap(&b); }
  inline void Swap(ServiceOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ServiceOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServiceOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServiceOptions& from) { ServiceOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServiceOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.data.ServiceOptions"; }

 protected:
  explicit ServiceOptions(::google::protobuf::Arena* arena);
  ServiceOptions(::google::protobuf::Arena* arena, const ServiceOptions& from);
  ServiceOptions(::google::protobuf::Arena* arena, ServiceOptions&& from) noexcept
      : ServiceOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPinnedFieldNumber = 1,
  };
  // bool pinned = 1;
  bool has_pinned() const;
  void clear_pinned() ;
  bool pinned() const;
  void set_pinned(bool value);

  private:
  bool _internal_pinned() const;
  void _internal_set_pinned(bool value);

  public:
  void clear_optional_pinned();
  OptionalPinnedCase optional_pinned_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.ServiceOptions)
 private:
  class _Internal;
  void set_has_pinned();
  inline bool has_optional_pinned() const;
  inline void clear_has_optional_pinned();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ServiceOptions& from_msg);
    union OptionalPinnedUnion {
      constexpr OptionalPinnedUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool pinned_;
    } optional_pinned_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OptimizationOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.data.OptimizationOptions) */ {
 public:
  inline OptimizationOptions() : OptimizationOptions(nullptr) {}
  ~OptimizationOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptimizationOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline OptimizationOptions(const OptimizationOptions& from) : OptimizationOptions(nullptr, from) {}
  inline OptimizationOptions(OptimizationOptions&& from) noexcept
      : OptimizationOptions(nullptr, std::move(from)) {}
  inline OptimizationOptions& operator=(const OptimizationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimizationOptions& operator=(OptimizationOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimizationOptions& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalApplyDefaultOptimizationsCase {
    kApplyDefaultOptimizations = 1,
    OPTIONAL_APPLY_DEFAULT_OPTIMIZATIONS_NOT_SET = 0,
  };
  enum OptionalFilterFusionCase {
    kFilterFusion = 6,
    OPTIONAL_FILTER_FUSION_NOT_SET = 0,
  };
  enum OptionalMapAndBatchFusionCase {
    kMapAndBatchFusion = 9,
    OPTIONAL_MAP_AND_BATCH_FUSION_NOT_SET = 0,
  };
  enum OptionalMapAndFilterFusionCase {
    kMapAndFilterFusion = 10,
    OPTIONAL_MAP_AND_FILTER_FUSION_NOT_SET = 0,
  };
  enum OptionalMapFusionCase {
    kMapFusion = 11,
    OPTIONAL_MAP_FUSION_NOT_SET = 0,
  };
  enum OptionalMapParallelizationCase {
    kMapParallelization = 12,
    OPTIONAL_MAP_PARALLELIZATION_NOT_SET = 0,
  };
  enum OptionalNoopEliminationCase {
    kNoopElimination = 14,
    OPTIONAL_NOOP_ELIMINATION_NOT_SET = 0,
  };
  enum OptionalParallelBatchCase {
    kParallelBatch = 15,
    OPTIONAL_PARALLEL_BATCH_NOT_SET = 0,
  };
  enum OptionalShuffleAndRepeatFusionCase {
    kShuffleAndRepeatFusion = 17,
    OPTIONAL_SHUFFLE_AND_REPEAT_FUSION_NOT_SET = 0,
  };
  enum OptionalFilterParallelizationCase {
    kFilterParallelization = 18,
    OPTIONAL_FILTER_PARALLELIZATION_NOT_SET = 0,
  };
  enum OptionalInjectPrefetchCase {
    kInjectPrefetch = 19,
    OPTIONAL_INJECT_PREFETCH_NOT_SET = 0,
  };
  enum OptionalSeqInterleavePrefetchCase {
    kSeqInterleavePrefetch = 21,
    OPTIONAL_SEQ_INTERLEAVE_PREFETCH_NOT_SET = 0,
  };
  static inline const OptimizationOptions* internal_default_instance() {
    return reinterpret_cast<const OptimizationOptions*>(
        &_OptimizationOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(OptimizationOptions& a, OptimizationOptions& b) { a.Swap(&b); }
  inline void Swap(OptimizationOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimizationOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimizationOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<OptimizationOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptimizationOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptimizationOptions& from) { OptimizationOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OptimizationOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.data.OptimizationOptions"; }

 protected:
  explicit OptimizationOptions(::google::protobuf::Arena* arena);
  OptimizationOptions(::google::protobuf::Arena* arena, const OptimizationOptions& from);
  OptimizationOptions(::google::protobuf::Arena* arena, OptimizationOptions&& from) noexcept
      : OptimizationOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kApplyDefaultOptimizationsFieldNumber = 1,
    kFilterFusionFieldNumber = 6,
    kMapAndBatchFusionFieldNumber = 9,
    kMapAndFilterFusionFieldNumber = 10,
    kMapFusionFieldNumber = 11,
    kMapParallelizationFieldNumber = 12,
    kNoopEliminationFieldNumber = 14,
    kParallelBatchFieldNumber = 15,
    kShuffleAndRepeatFusionFieldNumber = 17,
    kFilterParallelizationFieldNumber = 18,
    kInjectPrefetchFieldNumber = 19,
    kSeqInterleavePrefetchFieldNumber = 21,
  };
  // bool apply_default_optimizations = 1;
  bool has_apply_default_optimizations() const;
  void clear_apply_default_optimizations() ;
  bool apply_default_optimizations() const;
  void set_apply_default_optimizations(bool value);

  private:
  bool _internal_apply_default_optimizations() const;
  void _internal_set_apply_default_optimizations(bool value);

  public:
  // bool filter_fusion = 6;
  bool has_filter_fusion() const;
  void clear_filter_fusion() ;
  bool filter_fusion() const;
  void set_filter_fusion(bool value);

  private:
  bool _internal_filter_fusion() const;
  void _internal_set_filter_fusion(bool value);

  public:
  // bool map_and_batch_fusion = 9;
  bool has_map_and_batch_fusion() const;
  void clear_map_and_batch_fusion() ;
  bool map_and_batch_fusion() const;
  void set_map_and_batch_fusion(bool value);

  private:
  bool _internal_map_and_batch_fusion() const;
  void _internal_set_map_and_batch_fusion(bool value);

  public:
  // bool map_and_filter_fusion = 10;
  bool has_map_and_filter_fusion() const;
  void clear_map_and_filter_fusion() ;
  bool map_and_filter_fusion() const;
  void set_map_and_filter_fusion(bool value);

  private:
  bool _internal_map_and_filter_fusion() const;
  void _internal_set_map_and_filter_fusion(bool value);

  public:
  // bool map_fusion = 11;
  bool has_map_fusion() const;
  void clear_map_fusion() ;
  bool map_fusion() const;
  void set_map_fusion(bool value);

  private:
  bool _internal_map_fusion() const;
  void _internal_set_map_fusion(bool value);

  public:
  // bool map_parallelization = 12;
  bool has_map_parallelization() const;
  void clear_map_parallelization() ;
  bool map_parallelization() const;
  void set_map_parallelization(bool value);

  private:
  bool _internal_map_parallelization() const;
  void _internal_set_map_parallelization(bool value);

  public:
  // bool noop_elimination = 14;
  bool has_noop_elimination() const;
  void clear_noop_elimination() ;
  bool noop_elimination() const;
  void set_noop_elimination(bool value);

  private:
  bool _internal_noop_elimination() const;
  void _internal_set_noop_elimination(bool value);

  public:
  // bool parallel_batch = 15;
  bool has_parallel_batch() const;
  void clear_parallel_batch() ;
  bool parallel_batch() const;
  void set_parallel_batch(bool value);

  private:
  bool _internal_parallel_batch() const;
  void _internal_set_parallel_batch(bool value);

  public:
  // bool shuffle_and_repeat_fusion = 17;
  bool has_shuffle_and_repeat_fusion() const;
  void clear_shuffle_and_repeat_fusion() ;
  bool shuffle_and_repeat_fusion() const;
  void set_shuffle_and_repeat_fusion(bool value);

  private:
  bool _internal_shuffle_and_repeat_fusion() const;
  void _internal_set_shuffle_and_repeat_fusion(bool value);

  public:
  // bool filter_parallelization = 18;
  bool has_filter_parallelization() const;
  void clear_filter_parallelization() ;
  bool filter_parallelization() const;
  void set_filter_parallelization(bool value);

  private:
  bool _internal_filter_parallelization() const;
  void _internal_set_filter_parallelization(bool value);

  public:
  // bool inject_prefetch = 19;
  bool has_inject_prefetch() const;
  void clear_inject_prefetch() ;
  bool inject_prefetch() const;
  void set_inject_prefetch(bool value);

  private:
  bool _internal_inject_prefetch() const;
  void _internal_set_inject_prefetch(bool value);

  public:
  // bool seq_interleave_prefetch = 21;
  bool has_seq_interleave_prefetch() const;
  void clear_seq_interleave_prefetch() ;
  bool seq_interleave_prefetch() const;
  void set_seq_interleave_prefetch(bool value);

  private:
  bool _internal_seq_interleave_prefetch() const;
  void _internal_set_seq_interleave_prefetch(bool value);

  public:
  void clear_optional_apply_default_optimizations();
  OptionalApplyDefaultOptimizationsCase optional_apply_default_optimizations_case() const;
  void clear_optional_filter_fusion();
  OptionalFilterFusionCase optional_filter_fusion_case() const;
  void clear_optional_map_and_batch_fusion();
  OptionalMapAndBatchFusionCase optional_map_and_batch_fusion_case() const;
  void clear_optional_map_and_filter_fusion();
  OptionalMapAndFilterFusionCase optional_map_and_filter_fusion_case() const;
  void clear_optional_map_fusion();
  OptionalMapFusionCase optional_map_fusion_case() const;
  void clear_optional_map_parallelization();
  OptionalMapParallelizationCase optional_map_parallelization_case() const;
  void clear_optional_noop_elimination();
  OptionalNoopEliminationCase optional_noop_elimination_case() const;
  void clear_optional_parallel_batch();
  OptionalParallelBatchCase optional_parallel_batch_case() const;
  void clear_optional_shuffle_and_repeat_fusion();
  OptionalShuffleAndRepeatFusionCase optional_shuffle_and_repeat_fusion_case() const;
  void clear_optional_filter_parallelization();
  OptionalFilterParallelizationCase optional_filter_parallelization_case() const;
  void clear_optional_inject_prefetch();
  OptionalInjectPrefetchCase optional_inject_prefetch_case() const;
  void clear_optional_seq_interleave_prefetch();
  OptionalSeqInterleavePrefetchCase optional_seq_interleave_prefetch_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.OptimizationOptions)
 private:
  class _Internal;
  void set_has_apply_default_optimizations();
  void set_has_filter_fusion();
  void set_has_map_and_batch_fusion();
  void set_has_map_and_filter_fusion();
  void set_has_map_fusion();
  void set_has_map_parallelization();
  void set_has_noop_elimination();
  void set_has_parallel_batch();
  void set_has_shuffle_and_repeat_fusion();
  void set_has_filter_parallelization();
  void set_has_inject_prefetch();
  void set_has_seq_interleave_prefetch();
  inline bool has_optional_apply_default_optimizations() const;
  inline void clear_has_optional_apply_default_optimizations();
  inline bool has_optional_filter_fusion() const;
  inline void clear_has_optional_filter_fusion();
  inline bool has_optional_map_and_batch_fusion() const;
  inline void clear_has_optional_map_and_batch_fusion();
  inline bool has_optional_map_and_filter_fusion() const;
  inline void clear_has_optional_map_and_filter_fusion();
  inline bool has_optional_map_fusion() const;
  inline void clear_has_optional_map_fusion();
  inline bool has_optional_map_parallelization() const;
  inline void clear_has_optional_map_parallelization();
  inline bool has_optional_noop_elimination() const;
  inline void clear_has_optional_noop_elimination();
  inline bool has_optional_parallel_batch() const;
  inline void clear_has_optional_parallel_batch();
  inline bool has_optional_shuffle_and_repeat_fusion() const;
  inline void clear_has_optional_shuffle_and_repeat_fusion();
  inline bool has_optional_filter_parallelization() const;
  inline void clear_has_optional_filter_parallelization();
  inline bool has_optional_inject_prefetch() const;
  inline void clear_has_optional_inject_prefetch();
  inline bool has_optional_seq_interleave_prefetch() const;
  inline void clear_has_optional_seq_interleave_prefetch();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 12, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OptimizationOptions& from_msg);
    union OptionalApplyDefaultOptimizationsUnion {
      constexpr OptionalApplyDefaultOptimizationsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool apply_default_optimizations_;
    } optional_apply_default_optimizations_;
    union OptionalFilterFusionUnion {
      constexpr OptionalFilterFusionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool filter_fusion_;
    } optional_filter_fusion_;
    union OptionalMapAndBatchFusionUnion {
      constexpr OptionalMapAndBatchFusionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool map_and_batch_fusion_;
    } optional_map_and_batch_fusion_;
    union OptionalMapAndFilterFusionUnion {
      constexpr OptionalMapAndFilterFusionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool map_and_filter_fusion_;
    } optional_map_and_filter_fusion_;
    union OptionalMapFusionUnion {
      constexpr OptionalMapFusionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool map_fusion_;
    } optional_map_fusion_;
    union OptionalMapParallelizationUnion {
      constexpr OptionalMapParallelizationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool map_parallelization_;
    } optional_map_parallelization_;
    union OptionalNoopEliminationUnion {
      constexpr OptionalNoopEliminationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool noop_elimination_;
    } optional_noop_elimination_;
    union OptionalParallelBatchUnion {
      constexpr OptionalParallelBatchUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool parallel_batch_;
    } optional_parallel_batch_;
    union OptionalShuffleAndRepeatFusionUnion {
      constexpr OptionalShuffleAndRepeatFusionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool shuffle_and_repeat_fusion_;
    } optional_shuffle_and_repeat_fusion_;
    union OptionalFilterParallelizationUnion {
      constexpr OptionalFilterParallelizationUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool filter_parallelization_;
    } optional_filter_parallelization_;
    union OptionalInjectPrefetchUnion {
      constexpr OptionalInjectPrefetchUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool inject_prefetch_;
    } optional_inject_prefetch_;
    union OptionalSeqInterleavePrefetchUnion {
      constexpr OptionalSeqInterleavePrefetchUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool seq_interleave_prefetch_;
    } optional_seq_interleave_prefetch_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[12];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DistributeOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.data.DistributeOptions) */ {
 public:
  inline DistributeOptions() : DistributeOptions(nullptr) {}
  ~DistributeOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DistributeOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline DistributeOptions(const DistributeOptions& from) : DistributeOptions(nullptr, from) {}
  inline DistributeOptions(DistributeOptions&& from) noexcept
      : DistributeOptions(nullptr, std::move(from)) {}
  inline DistributeOptions& operator=(const DistributeOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistributeOptions& operator=(DistributeOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DistributeOptions& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalNumDevicesCase {
    kNumDevices = 2,
    OPTIONAL_NUM_DEVICES_NOT_SET = 0,
  };
  static inline const DistributeOptions* internal_default_instance() {
    return reinterpret_cast<const DistributeOptions*>(
        &_DistributeOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(DistributeOptions& a, DistributeOptions& b) { a.Swap(&b); }
  inline void Swap(DistributeOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistributeOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DistributeOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DistributeOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DistributeOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DistributeOptions& from) { DistributeOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DistributeOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.data.DistributeOptions"; }

 protected:
  explicit DistributeOptions(::google::protobuf::Arena* arena);
  DistributeOptions(::google::protobuf::Arena* arena, const DistributeOptions& from);
  DistributeOptions(::google::protobuf::Arena* arena, DistributeOptions&& from) noexcept
      : DistributeOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAutoShardPolicyFieldNumber = 1,
    kNumDevicesFieldNumber = 2,
  };
  // .tensorflow.data.AutoShardPolicy auto_shard_policy = 1;
  void clear_auto_shard_policy() ;
  ::tensorflow::data::AutoShardPolicy auto_shard_policy() const;
  void set_auto_shard_policy(::tensorflow::data::AutoShardPolicy value);

  private:
  ::tensorflow::data::AutoShardPolicy _internal_auto_shard_policy() const;
  void _internal_set_auto_shard_policy(::tensorflow::data::AutoShardPolicy value);

  public:
  // int32 num_devices = 2;
  bool has_num_devices() const;
  void clear_num_devices() ;
  ::int32_t num_devices() const;
  void set_num_devices(::int32_t value);

  private:
  ::int32_t _internal_num_devices() const;
  void _internal_set_num_devices(::int32_t value);

  public:
  void clear_optional_num_devices();
  OptionalNumDevicesCase optional_num_devices_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.DistributeOptions)
 private:
  class _Internal;
  void set_has_num_devices();
  inline bool has_optional_num_devices() const;
  inline void clear_has_optional_num_devices();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DistributeOptions& from_msg);
    int auto_shard_policy_;
    union OptionalNumDevicesUnion {
      constexpr OptionalNumDevicesUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t num_devices_;
    } optional_num_devices_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CardinalityOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.data.CardinalityOptions) */ {
 public:
  inline CardinalityOptions() : CardinalityOptions(nullptr) {}
  ~CardinalityOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CardinalityOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline CardinalityOptions(const CardinalityOptions& from) : CardinalityOptions(nullptr, from) {}
  inline CardinalityOptions(CardinalityOptions&& from) noexcept
      : CardinalityOptions(nullptr, std::move(from)) {}
  inline CardinalityOptions& operator=(const CardinalityOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CardinalityOptions& operator=(CardinalityOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CardinalityOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CardinalityOptions* internal_default_instance() {
    return reinterpret_cast<const CardinalityOptions*>(
        &_CardinalityOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CardinalityOptions& a, CardinalityOptions& b) { a.Swap(&b); }
  inline void Swap(CardinalityOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CardinalityOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CardinalityOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CardinalityOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CardinalityOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CardinalityOptions& from) { CardinalityOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CardinalityOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.data.CardinalityOptions"; }

 protected:
  explicit CardinalityOptions(::google::protobuf::Arena* arena);
  CardinalityOptions(::google::protobuf::Arena* arena, const CardinalityOptions& from);
  CardinalityOptions(::google::protobuf::Arena* arena, CardinalityOptions&& from) noexcept
      : CardinalityOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ComputeLevel = CardinalityOptions_ComputeLevel;
  static constexpr ComputeLevel CARDINALITY_COMPUTE_UNSPECIFIED = CardinalityOptions_ComputeLevel_CARDINALITY_COMPUTE_UNSPECIFIED;
  static constexpr ComputeLevel CARDINALITY_COMPUTE_LOW = CardinalityOptions_ComputeLevel_CARDINALITY_COMPUTE_LOW;
  static constexpr ComputeLevel CARDINALITY_COMPUTE_MODERATE = CardinalityOptions_ComputeLevel_CARDINALITY_COMPUTE_MODERATE;
  static inline bool ComputeLevel_IsValid(int value) {
    return CardinalityOptions_ComputeLevel_IsValid(value);
  }
  static constexpr ComputeLevel ComputeLevel_MIN = CardinalityOptions_ComputeLevel_ComputeLevel_MIN;
  static constexpr ComputeLevel ComputeLevel_MAX = CardinalityOptions_ComputeLevel_ComputeLevel_MAX;
  static constexpr int ComputeLevel_ARRAYSIZE = CardinalityOptions_ComputeLevel_ComputeLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ComputeLevel_descriptor() {
    return CardinalityOptions_ComputeLevel_descriptor();
  }
  template <typename T>
  static inline const std::string& ComputeLevel_Name(T value) {
    return CardinalityOptions_ComputeLevel_Name(value);
  }
  static inline bool ComputeLevel_Parse(absl::string_view name, ComputeLevel* value) {
    return CardinalityOptions_ComputeLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kComputeLevelFieldNumber = 1,
  };
  // .tensorflow.data.CardinalityOptions.ComputeLevel compute_level = 1;
  void clear_compute_level() ;
  ::tensorflow::data::CardinalityOptions_ComputeLevel compute_level() const;
  void set_compute_level(::tensorflow::data::CardinalityOptions_ComputeLevel value);

  private:
  ::tensorflow::data::CardinalityOptions_ComputeLevel _internal_compute_level() const;
  void _internal_set_compute_level(::tensorflow::data::CardinalityOptions_ComputeLevel value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.data.CardinalityOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CardinalityOptions& from_msg);
    int compute_level_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT AutotuneOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.data.AutotuneOptions) */ {
 public:
  inline AutotuneOptions() : AutotuneOptions(nullptr) {}
  ~AutotuneOptions() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AutotuneOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline AutotuneOptions(const AutotuneOptions& from) : AutotuneOptions(nullptr, from) {}
  inline AutotuneOptions(AutotuneOptions&& from) noexcept
      : AutotuneOptions(nullptr, std::move(from)) {}
  inline AutotuneOptions& operator=(const AutotuneOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutotuneOptions& operator=(AutotuneOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutotuneOptions& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalEnabledCase {
    kEnabled = 1,
    OPTIONAL_ENABLED_NOT_SET = 0,
  };
  enum OptionalCpuBudgetCase {
    kCpuBudget = 2,
    OPTIONAL_CPU_BUDGET_NOT_SET = 0,
  };
  enum OptionalRamBudgetCase {
    kRamBudget = 3,
    OPTIONAL_RAM_BUDGET_NOT_SET = 0,
  };
  enum OptionalAutotuneAlgorithmCase {
    kAutotuneAlgorithm = 4,
    OPTIONAL_AUTOTUNE_ALGORITHM_NOT_SET = 0,
  };
  enum OptionalInitialParallelismCase {
    kInitialParallelism = 5,
    OPTIONAL_INITIAL_PARALLELISM_NOT_SET = 0,
  };
  enum OptionalMinParallelismCase {
    kMinParallelism = 6,
    OPTIONAL_MIN_PARALLELISM_NOT_SET = 0,
  };
  static inline const AutotuneOptions* internal_default_instance() {
    return reinterpret_cast<const AutotuneOptions*>(
        &_AutotuneOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AutotuneOptions& a, AutotuneOptions& b) { a.Swap(&b); }
  inline void Swap(AutotuneOptions* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutotuneOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutotuneOptions* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AutotuneOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutotuneOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AutotuneOptions& from) { AutotuneOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AutotuneOptions* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.data.AutotuneOptions"; }

 protected:
  explicit AutotuneOptions(::google::protobuf::Arena* arena);
  AutotuneOptions(::google::protobuf::Arena* arena, const AutotuneOptions& from);
  AutotuneOptions(::google::protobuf::Arena* arena, AutotuneOptions&& from) noexcept
      : AutotuneOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnabledFieldNumber = 1,
    kCpuBudgetFieldNumber = 2,
    kRamBudgetFieldNumber = 3,
    kAutotuneAlgorithmFieldNumber = 4,
    kInitialParallelismFieldNumber = 5,
    kMinParallelismFieldNumber = 6,
  };
  // bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // int32 cpu_budget = 2;
  bool has_cpu_budget() const;
  void clear_cpu_budget() ;
  ::int32_t cpu_budget() const;
  void set_cpu_budget(::int32_t value);

  private:
  ::int32_t _internal_cpu_budget() const;
  void _internal_set_cpu_budget(::int32_t value);

  public:
  // int64 ram_budget = 3;
  bool has_ram_budget() const;
  void clear_ram_budget() ;
  ::int64_t ram_budget() const;
  void set_ram_budget(::int64_t value);

  private:
  ::int64_t _internal_ram_budget() const;
  void _internal_set_ram_budget(::int64_t value);

  public:
  // .tensorflow.data.model.AutotuneAlgorithm autotune_algorithm = 4;
  bool has_autotune_algorithm() const;
  void clear_autotune_algorithm() ;
  ::tensorflow::data::model::AutotuneAlgorithm autotune_algorithm() const;
  void set_autotune_algorithm(::tensorflow::data::model::AutotuneAlgorithm value);

  private:
  ::tensorflow::data::model::AutotuneAlgorithm _internal_autotune_algorithm() const;
  void _internal_set_autotune_algorithm(::tensorflow::data::model::AutotuneAlgorithm value);

  public:
  // int64 initial_parallelism = 5;
  bool has_initial_parallelism() const;
  void clear_initial_parallelism() ;
  ::int64_t initial_parallelism() const;
  void set_initial_parallelism(::int64_t value);

  private:
  ::int64_t _internal_initial_parallelism() const;
  void _internal_set_initial_parallelism(::int64_t value);

  public:
  // int64 min_parallelism = 6;
  bool has_min_parallelism() const;
  void clear_min_parallelism() ;
  ::int64_t min_parallelism() const;
  void set_min_parallelism(::int64_t value);

  private:
  ::int64_t _internal_min_parallelism() const;
  void _internal_set_min_parallelism(::int64_t value);

  public:
  void clear_optional_enabled();
  OptionalEnabledCase optional_enabled_case() const;
  void clear_optional_cpu_budget();
  OptionalCpuBudgetCase optional_cpu_budget_case() const;
  void clear_optional_ram_budget();
  OptionalRamBudgetCase optional_ram_budget_case() const;
  void clear_optional_autotune_algorithm();
  OptionalAutotuneAlgorithmCase optional_autotune_algorithm_case() const;
  void clear_optional_initial_parallelism();
  OptionalInitialParallelismCase optional_initial_parallelism_case() const;
  void clear_optional_min_parallelism();
  OptionalMinParallelismCase optional_min_parallelism_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.AutotuneOptions)
 private:
  class _Internal;
  void set_has_enabled();
  void set_has_cpu_budget();
  void set_has_ram_budget();
  void set_has_autotune_algorithm();
  void set_has_initial_parallelism();
  void set_has_min_parallelism();
  inline bool has_optional_enabled() const;
  inline void clear_has_optional_enabled();
  inline bool has_optional_cpu_budget() const;
  inline void clear_has_optional_cpu_budget();
  inline bool has_optional_ram_budget() const;
  inline void clear_has_optional_ram_budget();
  inline bool has_optional_autotune_algorithm() const;
  inline void clear_has_optional_autotune_algorithm();
  inline bool has_optional_initial_parallelism() const;
  inline void clear_has_optional_initial_parallelism();
  inline bool has_optional_min_parallelism() const;
  inline void clear_has_optional_min_parallelism();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AutotuneOptions& from_msg);
    union OptionalEnabledUnion {
      constexpr OptionalEnabledUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool enabled_;
    } optional_enabled_;
    union OptionalCpuBudgetUnion {
      constexpr OptionalCpuBudgetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t cpu_budget_;
    } optional_cpu_budget_;
    union OptionalRamBudgetUnion {
      constexpr OptionalRamBudgetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t ram_budget_;
    } optional_ram_budget_;
    union OptionalAutotuneAlgorithmUnion {
      constexpr OptionalAutotuneAlgorithmUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int autotune_algorithm_;
    } optional_autotune_algorithm_;
    union OptionalInitialParallelismUnion {
      constexpr OptionalInitialParallelismUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t initial_parallelism_;
    } optional_initial_parallelism_;
    union OptionalMinParallelismUnion {
      constexpr OptionalMinParallelismUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t min_parallelism_;
    } optional_min_parallelism_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[6];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT Options final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.data.Options) */ {
 public:
  inline Options() : Options(nullptr) {}
  ~Options() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Options(
      ::google::protobuf::internal::ConstantInitialized);

  inline Options(const Options& from) : Options(nullptr, from) {}
  inline Options(Options&& from) noexcept
      : Options(nullptr, std::move(from)) {}
  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline Options& operator=(Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Options& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalDatasetNameCase {
    kDatasetName = 10,
    OPTIONAL_DATASET_NAME_NOT_SET = 0,
  };
  enum OptionalDeterministicCase {
    kDeterministic = 1,
    OPTIONAL_DETERMINISTIC_NOT_SET = 0,
  };
  enum OptionalSlackCase {
    kSlack = 4,
    OPTIONAL_SLACK_NOT_SET = 0,
  };
  enum OptionalExternalStatePolicyCase {
    kExternalStatePolicy = 6,
    OPTIONAL_EXTERNAL_STATE_POLICY_NOT_SET = 0,
  };
  enum OptionalSymbolicCheckpointCase {
    kSymbolicCheckpoint = 8,
    OPTIONAL_SYMBOLIC_CHECKPOINT_NOT_SET = 0,
  };
  enum OptionalWarmStartCase {
    kWarmStart = 9,
    OPTIONAL_WARM_START_NOT_SET = 0,
  };
  static inline const Options* internal_default_instance() {
    return reinterpret_cast<const Options*>(
        &_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Options& a, Options& b) { a.Swap(&b); }
  inline void Swap(Options* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Options* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Options* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Options>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Options& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Options& from) { Options::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Options* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.data.Options"; }

 protected:
  explicit Options(::google::protobuf::Arena* arena);
  Options(::google::protobuf::Arena* arena, const Options& from);
  Options(::google::protobuf::Arena* arena, Options&& from) noexcept
      : Options(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFrameworkTypeFieldNumber = 11,
    kDistributeOptionsFieldNumber = 2,
    kOptimizationOptionsFieldNumber = 3,
    kThreadingOptionsFieldNumber = 5,
    kAutotuneOptionsFieldNumber = 7,
    kServiceOptionsFieldNumber = 12,
    kDatasetNameFieldNumber = 10,
    kDeterministicFieldNumber = 1,
    kSlackFieldNumber = 4,
    kExternalStatePolicyFieldNumber = 6,
    kSymbolicCheckpointFieldNumber = 8,
    kWarmStartFieldNumber = 9,
  };
  // repeated string framework_type = 11;
  int framework_type_size() const;
  private:
  int _internal_framework_type_size() const;

  public:
  void clear_framework_type() ;
  const std::string& framework_type(int index) const;
  std::string* mutable_framework_type(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_framework_type(int index, Arg_&& value, Args_... args);
  std::string* add_framework_type();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_framework_type(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& framework_type() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_framework_type();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_framework_type() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_framework_type();

  public:
  // .tensorflow.data.DistributeOptions distribute_options = 2;
  bool has_distribute_options() const;
  void clear_distribute_options() ;
  const ::tensorflow::data::DistributeOptions& distribute_options() const;
  PROTOBUF_NODISCARD ::tensorflow::data::DistributeOptions* release_distribute_options();
  ::tensorflow::data::DistributeOptions* mutable_distribute_options();
  void set_allocated_distribute_options(::tensorflow::data::DistributeOptions* value);
  void unsafe_arena_set_allocated_distribute_options(::tensorflow::data::DistributeOptions* value);
  ::tensorflow::data::DistributeOptions* unsafe_arena_release_distribute_options();

  private:
  const ::tensorflow::data::DistributeOptions& _internal_distribute_options() const;
  ::tensorflow::data::DistributeOptions* _internal_mutable_distribute_options();

  public:
  // .tensorflow.data.OptimizationOptions optimization_options = 3;
  bool has_optimization_options() const;
  void clear_optimization_options() ;
  const ::tensorflow::data::OptimizationOptions& optimization_options() const;
  PROTOBUF_NODISCARD ::tensorflow::data::OptimizationOptions* release_optimization_options();
  ::tensorflow::data::OptimizationOptions* mutable_optimization_options();
  void set_allocated_optimization_options(::tensorflow::data::OptimizationOptions* value);
  void unsafe_arena_set_allocated_optimization_options(::tensorflow::data::OptimizationOptions* value);
  ::tensorflow::data::OptimizationOptions* unsafe_arena_release_optimization_options();

  private:
  const ::tensorflow::data::OptimizationOptions& _internal_optimization_options() const;
  ::tensorflow::data::OptimizationOptions* _internal_mutable_optimization_options();

  public:
  // .tensorflow.data.ThreadingOptions threading_options = 5;
  bool has_threading_options() const;
  void clear_threading_options() ;
  const ::tensorflow::data::ThreadingOptions& threading_options() const;
  PROTOBUF_NODISCARD ::tensorflow::data::ThreadingOptions* release_threading_options();
  ::tensorflow::data::ThreadingOptions* mutable_threading_options();
  void set_allocated_threading_options(::tensorflow::data::ThreadingOptions* value);
  void unsafe_arena_set_allocated_threading_options(::tensorflow::data::ThreadingOptions* value);
  ::tensorflow::data::ThreadingOptions* unsafe_arena_release_threading_options();

  private:
  const ::tensorflow::data::ThreadingOptions& _internal_threading_options() const;
  ::tensorflow::data::ThreadingOptions* _internal_mutable_threading_options();

  public:
  // .tensorflow.data.AutotuneOptions autotune_options = 7;
  bool has_autotune_options() const;
  void clear_autotune_options() ;
  const ::tensorflow::data::AutotuneOptions& autotune_options() const;
  PROTOBUF_NODISCARD ::tensorflow::data::AutotuneOptions* release_autotune_options();
  ::tensorflow::data::AutotuneOptions* mutable_autotune_options();
  void set_allocated_autotune_options(::tensorflow::data::AutotuneOptions* value);
  void unsafe_arena_set_allocated_autotune_options(::tensorflow::data::AutotuneOptions* value);
  ::tensorflow::data::AutotuneOptions* unsafe_arena_release_autotune_options();

  private:
  const ::tensorflow::data::AutotuneOptions& _internal_autotune_options() const;
  ::tensorflow::data::AutotuneOptions* _internal_mutable_autotune_options();

  public:
  // .tensorflow.data.ServiceOptions service_options = 12;
  bool has_service_options() const;
  void clear_service_options() ;
  const ::tensorflow::data::ServiceOptions& service_options() const;
  PROTOBUF_NODISCARD ::tensorflow::data::ServiceOptions* release_service_options();
  ::tensorflow::data::ServiceOptions* mutable_service_options();
  void set_allocated_service_options(::tensorflow::data::ServiceOptions* value);
  void unsafe_arena_set_allocated_service_options(::tensorflow::data::ServiceOptions* value);
  ::tensorflow::data::ServiceOptions* unsafe_arena_release_service_options();

  private:
  const ::tensorflow::data::ServiceOptions& _internal_service_options() const;
  ::tensorflow::data::ServiceOptions* _internal_mutable_service_options();

  public:
  // string dataset_name = 10;
  bool has_dataset_name() const;
  void clear_dataset_name() ;
  const std::string& dataset_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dataset_name(Arg_&& arg, Args_... args);
  std::string* mutable_dataset_name();
  PROTOBUF_NODISCARD std::string* release_dataset_name();
  void set_allocated_dataset_name(std::string* value);

  private:
  const std::string& _internal_dataset_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dataset_name(
      const std::string& value);
  std::string* _internal_mutable_dataset_name();

  public:
  // bool deterministic = 1;
  bool has_deterministic() const;
  void clear_deterministic() ;
  bool deterministic() const;
  void set_deterministic(bool value);

  private:
  bool _internal_deterministic() const;
  void _internal_set_deterministic(bool value);

  public:
  // bool slack = 4;
  bool has_slack() const;
  void clear_slack() ;
  bool slack() const;
  void set_slack(bool value);

  private:
  bool _internal_slack() const;
  void _internal_set_slack(bool value);

  public:
  // .tensorflow.data.ExternalStatePolicy external_state_policy = 6;
  bool has_external_state_policy() const;
  void clear_external_state_policy() ;
  ::tensorflow::data::ExternalStatePolicy external_state_policy() const;
  void set_external_state_policy(::tensorflow::data::ExternalStatePolicy value);

  private:
  ::tensorflow::data::ExternalStatePolicy _internal_external_state_policy() const;
  void _internal_set_external_state_policy(::tensorflow::data::ExternalStatePolicy value);

  public:
  // bool symbolic_checkpoint = 8;
  bool has_symbolic_checkpoint() const;
  void clear_symbolic_checkpoint() ;
  bool symbolic_checkpoint() const;
  void set_symbolic_checkpoint(bool value);

  private:
  bool _internal_symbolic_checkpoint() const;
  void _internal_set_symbolic_checkpoint(bool value);

  public:
  // bool warm_start = 9;
  bool has_warm_start() const;
  void clear_warm_start() ;
  bool warm_start() const;
  void set_warm_start(bool value);

  private:
  bool _internal_warm_start() const;
  void _internal_set_warm_start(bool value);

  public:
  void clear_optional_dataset_name();
  OptionalDatasetNameCase optional_dataset_name_case() const;
  void clear_optional_deterministic();
  OptionalDeterministicCase optional_deterministic_case() const;
  void clear_optional_slack();
  OptionalSlackCase optional_slack_case() const;
  void clear_optional_external_state_policy();
  OptionalExternalStatePolicyCase optional_external_state_policy_case() const;
  void clear_optional_symbolic_checkpoint();
  OptionalSymbolicCheckpointCase optional_symbolic_checkpoint_case() const;
  void clear_optional_warm_start();
  OptionalWarmStartCase optional_warm_start_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.Options)
 private:
  class _Internal;
  void set_has_dataset_name();
  void set_has_deterministic();
  void set_has_slack();
  void set_has_external_state_policy();
  void set_has_symbolic_checkpoint();
  void set_has_warm_start();
  inline bool has_optional_dataset_name() const;
  inline void clear_has_optional_dataset_name();
  inline bool has_optional_deterministic() const;
  inline void clear_has_optional_deterministic();
  inline bool has_optional_slack() const;
  inline void clear_has_optional_slack();
  inline bool has_optional_external_state_policy() const;
  inline void clear_has_optional_external_state_policy();
  inline bool has_optional_symbolic_checkpoint() const;
  inline void clear_has_optional_symbolic_checkpoint();
  inline bool has_optional_warm_start() const;
  inline void clear_has_optional_warm_start();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 5,
      66, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Options& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> framework_type_;
    ::tensorflow::data::DistributeOptions* distribute_options_;
    ::tensorflow::data::OptimizationOptions* optimization_options_;
    ::tensorflow::data::ThreadingOptions* threading_options_;
    ::tensorflow::data::AutotuneOptions* autotune_options_;
    ::tensorflow::data::ServiceOptions* service_options_;
    union OptionalDatasetNameUnion {
      constexpr OptionalDatasetNameUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr dataset_name_;
    } optional_dataset_name_;
    union OptionalDeterministicUnion {
      constexpr OptionalDeterministicUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool deterministic_;
    } optional_deterministic_;
    union OptionalSlackUnion {
      constexpr OptionalSlackUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool slack_;
    } optional_slack_;
    union OptionalExternalStatePolicyUnion {
      constexpr OptionalExternalStatePolicyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int external_state_policy_;
    } optional_external_state_policy_;
    union OptionalSymbolicCheckpointUnion {
      constexpr OptionalSymbolicCheckpointUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool symbolic_checkpoint_;
    } optional_symbolic_checkpoint_;
    union OptionalWarmStartUnion {
      constexpr OptionalWarmStartUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool warm_start_;
    } optional_warm_start_;
    ::uint32_t _oneof_case_[6];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AutotuneOptions

// bool enabled = 1;
inline bool AutotuneOptions::has_enabled() const {
  return optional_enabled_case() == kEnabled;
}
inline void AutotuneOptions::set_has_enabled() {
  _impl_._oneof_case_[0] = kEnabled;
}
inline void AutotuneOptions::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_enabled_case() == kEnabled) {
    _impl_.optional_enabled_.enabled_ = false;
    clear_has_optional_enabled();
  }
}
inline bool AutotuneOptions::enabled() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.AutotuneOptions.enabled)
  return _internal_enabled();
}
inline void AutotuneOptions::set_enabled(bool value) {
  if (optional_enabled_case() != kEnabled) {
    clear_optional_enabled();
    set_has_enabled();
  }
  _impl_.optional_enabled_.enabled_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.AutotuneOptions.enabled)
}
inline bool AutotuneOptions::_internal_enabled() const {
  if (optional_enabled_case() == kEnabled) {
    return _impl_.optional_enabled_.enabled_;
  }
  return false;
}

// int32 cpu_budget = 2;
inline bool AutotuneOptions::has_cpu_budget() const {
  return optional_cpu_budget_case() == kCpuBudget;
}
inline void AutotuneOptions::set_has_cpu_budget() {
  _impl_._oneof_case_[1] = kCpuBudget;
}
inline void AutotuneOptions::clear_cpu_budget() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_cpu_budget_case() == kCpuBudget) {
    _impl_.optional_cpu_budget_.cpu_budget_ = 0;
    clear_has_optional_cpu_budget();
  }
}
inline ::int32_t AutotuneOptions::cpu_budget() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.AutotuneOptions.cpu_budget)
  return _internal_cpu_budget();
}
inline void AutotuneOptions::set_cpu_budget(::int32_t value) {
  if (optional_cpu_budget_case() != kCpuBudget) {
    clear_optional_cpu_budget();
    set_has_cpu_budget();
  }
  _impl_.optional_cpu_budget_.cpu_budget_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.AutotuneOptions.cpu_budget)
}
inline ::int32_t AutotuneOptions::_internal_cpu_budget() const {
  if (optional_cpu_budget_case() == kCpuBudget) {
    return _impl_.optional_cpu_budget_.cpu_budget_;
  }
  return 0;
}

// int64 ram_budget = 3;
inline bool AutotuneOptions::has_ram_budget() const {
  return optional_ram_budget_case() == kRamBudget;
}
inline void AutotuneOptions::set_has_ram_budget() {
  _impl_._oneof_case_[2] = kRamBudget;
}
inline void AutotuneOptions::clear_ram_budget() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_ram_budget_case() == kRamBudget) {
    _impl_.optional_ram_budget_.ram_budget_ = ::int64_t{0};
    clear_has_optional_ram_budget();
  }
}
inline ::int64_t AutotuneOptions::ram_budget() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.AutotuneOptions.ram_budget)
  return _internal_ram_budget();
}
inline void AutotuneOptions::set_ram_budget(::int64_t value) {
  if (optional_ram_budget_case() != kRamBudget) {
    clear_optional_ram_budget();
    set_has_ram_budget();
  }
  _impl_.optional_ram_budget_.ram_budget_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.AutotuneOptions.ram_budget)
}
inline ::int64_t AutotuneOptions::_internal_ram_budget() const {
  if (optional_ram_budget_case() == kRamBudget) {
    return _impl_.optional_ram_budget_.ram_budget_;
  }
  return ::int64_t{0};
}

// .tensorflow.data.model.AutotuneAlgorithm autotune_algorithm = 4;
inline bool AutotuneOptions::has_autotune_algorithm() const {
  return optional_autotune_algorithm_case() == kAutotuneAlgorithm;
}
inline void AutotuneOptions::set_has_autotune_algorithm() {
  _impl_._oneof_case_[3] = kAutotuneAlgorithm;
}
inline void AutotuneOptions::clear_autotune_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_autotune_algorithm_case() == kAutotuneAlgorithm) {
    _impl_.optional_autotune_algorithm_.autotune_algorithm_ = 0;
    clear_has_optional_autotune_algorithm();
  }
}
inline ::tensorflow::data::model::AutotuneAlgorithm AutotuneOptions::autotune_algorithm() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.AutotuneOptions.autotune_algorithm)
  return _internal_autotune_algorithm();
}
inline void AutotuneOptions::set_autotune_algorithm(::tensorflow::data::model::AutotuneAlgorithm value) {
  if (optional_autotune_algorithm_case() != kAutotuneAlgorithm) {
    clear_optional_autotune_algorithm();
    set_has_autotune_algorithm();
  }
  _impl_.optional_autotune_algorithm_.autotune_algorithm_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.AutotuneOptions.autotune_algorithm)
}
inline ::tensorflow::data::model::AutotuneAlgorithm AutotuneOptions::_internal_autotune_algorithm() const {
  if (optional_autotune_algorithm_case() == kAutotuneAlgorithm) {
    return static_cast<::tensorflow::data::model::AutotuneAlgorithm>(_impl_.optional_autotune_algorithm_.autotune_algorithm_);
  }
  return static_cast<::tensorflow::data::model::AutotuneAlgorithm>(0);
}

// int64 initial_parallelism = 5;
inline bool AutotuneOptions::has_initial_parallelism() const {
  return optional_initial_parallelism_case() == kInitialParallelism;
}
inline void AutotuneOptions::set_has_initial_parallelism() {
  _impl_._oneof_case_[4] = kInitialParallelism;
}
inline void AutotuneOptions::clear_initial_parallelism() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_initial_parallelism_case() == kInitialParallelism) {
    _impl_.optional_initial_parallelism_.initial_parallelism_ = ::int64_t{0};
    clear_has_optional_initial_parallelism();
  }
}
inline ::int64_t AutotuneOptions::initial_parallelism() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.AutotuneOptions.initial_parallelism)
  return _internal_initial_parallelism();
}
inline void AutotuneOptions::set_initial_parallelism(::int64_t value) {
  if (optional_initial_parallelism_case() != kInitialParallelism) {
    clear_optional_initial_parallelism();
    set_has_initial_parallelism();
  }
  _impl_.optional_initial_parallelism_.initial_parallelism_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.AutotuneOptions.initial_parallelism)
}
inline ::int64_t AutotuneOptions::_internal_initial_parallelism() const {
  if (optional_initial_parallelism_case() == kInitialParallelism) {
    return _impl_.optional_initial_parallelism_.initial_parallelism_;
  }
  return ::int64_t{0};
}

// int64 min_parallelism = 6;
inline bool AutotuneOptions::has_min_parallelism() const {
  return optional_min_parallelism_case() == kMinParallelism;
}
inline void AutotuneOptions::set_has_min_parallelism() {
  _impl_._oneof_case_[5] = kMinParallelism;
}
inline void AutotuneOptions::clear_min_parallelism() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_min_parallelism_case() == kMinParallelism) {
    _impl_.optional_min_parallelism_.min_parallelism_ = ::int64_t{0};
    clear_has_optional_min_parallelism();
  }
}
inline ::int64_t AutotuneOptions::min_parallelism() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.AutotuneOptions.min_parallelism)
  return _internal_min_parallelism();
}
inline void AutotuneOptions::set_min_parallelism(::int64_t value) {
  if (optional_min_parallelism_case() != kMinParallelism) {
    clear_optional_min_parallelism();
    set_has_min_parallelism();
  }
  _impl_.optional_min_parallelism_.min_parallelism_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.AutotuneOptions.min_parallelism)
}
inline ::int64_t AutotuneOptions::_internal_min_parallelism() const {
  if (optional_min_parallelism_case() == kMinParallelism) {
    return _impl_.optional_min_parallelism_.min_parallelism_;
  }
  return ::int64_t{0};
}

inline bool AutotuneOptions::has_optional_enabled() const {
  return optional_enabled_case() != OPTIONAL_ENABLED_NOT_SET;
}
inline void AutotuneOptions::clear_has_optional_enabled() {
  _impl_._oneof_case_[0] = OPTIONAL_ENABLED_NOT_SET;
}
inline bool AutotuneOptions::has_optional_cpu_budget() const {
  return optional_cpu_budget_case() != OPTIONAL_CPU_BUDGET_NOT_SET;
}
inline void AutotuneOptions::clear_has_optional_cpu_budget() {
  _impl_._oneof_case_[1] = OPTIONAL_CPU_BUDGET_NOT_SET;
}
inline bool AutotuneOptions::has_optional_ram_budget() const {
  return optional_ram_budget_case() != OPTIONAL_RAM_BUDGET_NOT_SET;
}
inline void AutotuneOptions::clear_has_optional_ram_budget() {
  _impl_._oneof_case_[2] = OPTIONAL_RAM_BUDGET_NOT_SET;
}
inline bool AutotuneOptions::has_optional_autotune_algorithm() const {
  return optional_autotune_algorithm_case() != OPTIONAL_AUTOTUNE_ALGORITHM_NOT_SET;
}
inline void AutotuneOptions::clear_has_optional_autotune_algorithm() {
  _impl_._oneof_case_[3] = OPTIONAL_AUTOTUNE_ALGORITHM_NOT_SET;
}
inline bool AutotuneOptions::has_optional_initial_parallelism() const {
  return optional_initial_parallelism_case() != OPTIONAL_INITIAL_PARALLELISM_NOT_SET;
}
inline void AutotuneOptions::clear_has_optional_initial_parallelism() {
  _impl_._oneof_case_[4] = OPTIONAL_INITIAL_PARALLELISM_NOT_SET;
}
inline bool AutotuneOptions::has_optional_min_parallelism() const {
  return optional_min_parallelism_case() != OPTIONAL_MIN_PARALLELISM_NOT_SET;
}
inline void AutotuneOptions::clear_has_optional_min_parallelism() {
  _impl_._oneof_case_[5] = OPTIONAL_MIN_PARALLELISM_NOT_SET;
}
inline AutotuneOptions::OptionalEnabledCase AutotuneOptions::optional_enabled_case() const {
  return AutotuneOptions::OptionalEnabledCase(_impl_._oneof_case_[0]);
}
inline AutotuneOptions::OptionalCpuBudgetCase AutotuneOptions::optional_cpu_budget_case() const {
  return AutotuneOptions::OptionalCpuBudgetCase(_impl_._oneof_case_[1]);
}
inline AutotuneOptions::OptionalRamBudgetCase AutotuneOptions::optional_ram_budget_case() const {
  return AutotuneOptions::OptionalRamBudgetCase(_impl_._oneof_case_[2]);
}
inline AutotuneOptions::OptionalAutotuneAlgorithmCase AutotuneOptions::optional_autotune_algorithm_case() const {
  return AutotuneOptions::OptionalAutotuneAlgorithmCase(_impl_._oneof_case_[3]);
}
inline AutotuneOptions::OptionalInitialParallelismCase AutotuneOptions::optional_initial_parallelism_case() const {
  return AutotuneOptions::OptionalInitialParallelismCase(_impl_._oneof_case_[4]);
}
inline AutotuneOptions::OptionalMinParallelismCase AutotuneOptions::optional_min_parallelism_case() const {
  return AutotuneOptions::OptionalMinParallelismCase(_impl_._oneof_case_[5]);
}
// -------------------------------------------------------------------

// CardinalityOptions

// .tensorflow.data.CardinalityOptions.ComputeLevel compute_level = 1;
inline void CardinalityOptions::clear_compute_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compute_level_ = 0;
}
inline ::tensorflow::data::CardinalityOptions_ComputeLevel CardinalityOptions::compute_level() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CardinalityOptions.compute_level)
  return _internal_compute_level();
}
inline void CardinalityOptions::set_compute_level(::tensorflow::data::CardinalityOptions_ComputeLevel value) {
  _internal_set_compute_level(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.CardinalityOptions.compute_level)
}
inline ::tensorflow::data::CardinalityOptions_ComputeLevel CardinalityOptions::_internal_compute_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::data::CardinalityOptions_ComputeLevel>(_impl_.compute_level_);
}
inline void CardinalityOptions::_internal_set_compute_level(::tensorflow::data::CardinalityOptions_ComputeLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compute_level_ = value;
}

// -------------------------------------------------------------------

// DistributeOptions

// .tensorflow.data.AutoShardPolicy auto_shard_policy = 1;
inline void DistributeOptions::clear_auto_shard_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_shard_policy_ = 0;
}
inline ::tensorflow::data::AutoShardPolicy DistributeOptions::auto_shard_policy() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.DistributeOptions.auto_shard_policy)
  return _internal_auto_shard_policy();
}
inline void DistributeOptions::set_auto_shard_policy(::tensorflow::data::AutoShardPolicy value) {
  _internal_set_auto_shard_policy(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.DistributeOptions.auto_shard_policy)
}
inline ::tensorflow::data::AutoShardPolicy DistributeOptions::_internal_auto_shard_policy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::data::AutoShardPolicy>(_impl_.auto_shard_policy_);
}
inline void DistributeOptions::_internal_set_auto_shard_policy(::tensorflow::data::AutoShardPolicy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_shard_policy_ = value;
}

// int32 num_devices = 2;
inline bool DistributeOptions::has_num_devices() const {
  return optional_num_devices_case() == kNumDevices;
}
inline void DistributeOptions::set_has_num_devices() {
  _impl_._oneof_case_[0] = kNumDevices;
}
inline void DistributeOptions::clear_num_devices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_num_devices_case() == kNumDevices) {
    _impl_.optional_num_devices_.num_devices_ = 0;
    clear_has_optional_num_devices();
  }
}
inline ::int32_t DistributeOptions::num_devices() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.DistributeOptions.num_devices)
  return _internal_num_devices();
}
inline void DistributeOptions::set_num_devices(::int32_t value) {
  if (optional_num_devices_case() != kNumDevices) {
    clear_optional_num_devices();
    set_has_num_devices();
  }
  _impl_.optional_num_devices_.num_devices_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.DistributeOptions.num_devices)
}
inline ::int32_t DistributeOptions::_internal_num_devices() const {
  if (optional_num_devices_case() == kNumDevices) {
    return _impl_.optional_num_devices_.num_devices_;
  }
  return 0;
}

inline bool DistributeOptions::has_optional_num_devices() const {
  return optional_num_devices_case() != OPTIONAL_NUM_DEVICES_NOT_SET;
}
inline void DistributeOptions::clear_has_optional_num_devices() {
  _impl_._oneof_case_[0] = OPTIONAL_NUM_DEVICES_NOT_SET;
}
inline DistributeOptions::OptionalNumDevicesCase DistributeOptions::optional_num_devices_case() const {
  return DistributeOptions::OptionalNumDevicesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OptimizationOptions

// bool apply_default_optimizations = 1;
inline bool OptimizationOptions::has_apply_default_optimizations() const {
  return optional_apply_default_optimizations_case() == kApplyDefaultOptimizations;
}
inline void OptimizationOptions::set_has_apply_default_optimizations() {
  _impl_._oneof_case_[0] = kApplyDefaultOptimizations;
}
inline void OptimizationOptions::clear_apply_default_optimizations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_apply_default_optimizations_case() == kApplyDefaultOptimizations) {
    _impl_.optional_apply_default_optimizations_.apply_default_optimizations_ = false;
    clear_has_optional_apply_default_optimizations();
  }
}
inline bool OptimizationOptions::apply_default_optimizations() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.apply_default_optimizations)
  return _internal_apply_default_optimizations();
}
inline void OptimizationOptions::set_apply_default_optimizations(bool value) {
  if (optional_apply_default_optimizations_case() != kApplyDefaultOptimizations) {
    clear_optional_apply_default_optimizations();
    set_has_apply_default_optimizations();
  }
  _impl_.optional_apply_default_optimizations_.apply_default_optimizations_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.apply_default_optimizations)
}
inline bool OptimizationOptions::_internal_apply_default_optimizations() const {
  if (optional_apply_default_optimizations_case() == kApplyDefaultOptimizations) {
    return _impl_.optional_apply_default_optimizations_.apply_default_optimizations_;
  }
  return false;
}

// bool filter_fusion = 6;
inline bool OptimizationOptions::has_filter_fusion() const {
  return optional_filter_fusion_case() == kFilterFusion;
}
inline void OptimizationOptions::set_has_filter_fusion() {
  _impl_._oneof_case_[1] = kFilterFusion;
}
inline void OptimizationOptions::clear_filter_fusion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_filter_fusion_case() == kFilterFusion) {
    _impl_.optional_filter_fusion_.filter_fusion_ = false;
    clear_has_optional_filter_fusion();
  }
}
inline bool OptimizationOptions::filter_fusion() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.filter_fusion)
  return _internal_filter_fusion();
}
inline void OptimizationOptions::set_filter_fusion(bool value) {
  if (optional_filter_fusion_case() != kFilterFusion) {
    clear_optional_filter_fusion();
    set_has_filter_fusion();
  }
  _impl_.optional_filter_fusion_.filter_fusion_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.filter_fusion)
}
inline bool OptimizationOptions::_internal_filter_fusion() const {
  if (optional_filter_fusion_case() == kFilterFusion) {
    return _impl_.optional_filter_fusion_.filter_fusion_;
  }
  return false;
}

// bool map_and_batch_fusion = 9;
inline bool OptimizationOptions::has_map_and_batch_fusion() const {
  return optional_map_and_batch_fusion_case() == kMapAndBatchFusion;
}
inline void OptimizationOptions::set_has_map_and_batch_fusion() {
  _impl_._oneof_case_[2] = kMapAndBatchFusion;
}
inline void OptimizationOptions::clear_map_and_batch_fusion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_map_and_batch_fusion_case() == kMapAndBatchFusion) {
    _impl_.optional_map_and_batch_fusion_.map_and_batch_fusion_ = false;
    clear_has_optional_map_and_batch_fusion();
  }
}
inline bool OptimizationOptions::map_and_batch_fusion() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.map_and_batch_fusion)
  return _internal_map_and_batch_fusion();
}
inline void OptimizationOptions::set_map_and_batch_fusion(bool value) {
  if (optional_map_and_batch_fusion_case() != kMapAndBatchFusion) {
    clear_optional_map_and_batch_fusion();
    set_has_map_and_batch_fusion();
  }
  _impl_.optional_map_and_batch_fusion_.map_and_batch_fusion_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.map_and_batch_fusion)
}
inline bool OptimizationOptions::_internal_map_and_batch_fusion() const {
  if (optional_map_and_batch_fusion_case() == kMapAndBatchFusion) {
    return _impl_.optional_map_and_batch_fusion_.map_and_batch_fusion_;
  }
  return false;
}

// bool map_and_filter_fusion = 10;
inline bool OptimizationOptions::has_map_and_filter_fusion() const {
  return optional_map_and_filter_fusion_case() == kMapAndFilterFusion;
}
inline void OptimizationOptions::set_has_map_and_filter_fusion() {
  _impl_._oneof_case_[3] = kMapAndFilterFusion;
}
inline void OptimizationOptions::clear_map_and_filter_fusion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_map_and_filter_fusion_case() == kMapAndFilterFusion) {
    _impl_.optional_map_and_filter_fusion_.map_and_filter_fusion_ = false;
    clear_has_optional_map_and_filter_fusion();
  }
}
inline bool OptimizationOptions::map_and_filter_fusion() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.map_and_filter_fusion)
  return _internal_map_and_filter_fusion();
}
inline void OptimizationOptions::set_map_and_filter_fusion(bool value) {
  if (optional_map_and_filter_fusion_case() != kMapAndFilterFusion) {
    clear_optional_map_and_filter_fusion();
    set_has_map_and_filter_fusion();
  }
  _impl_.optional_map_and_filter_fusion_.map_and_filter_fusion_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.map_and_filter_fusion)
}
inline bool OptimizationOptions::_internal_map_and_filter_fusion() const {
  if (optional_map_and_filter_fusion_case() == kMapAndFilterFusion) {
    return _impl_.optional_map_and_filter_fusion_.map_and_filter_fusion_;
  }
  return false;
}

// bool map_fusion = 11;
inline bool OptimizationOptions::has_map_fusion() const {
  return optional_map_fusion_case() == kMapFusion;
}
inline void OptimizationOptions::set_has_map_fusion() {
  _impl_._oneof_case_[4] = kMapFusion;
}
inline void OptimizationOptions::clear_map_fusion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_map_fusion_case() == kMapFusion) {
    _impl_.optional_map_fusion_.map_fusion_ = false;
    clear_has_optional_map_fusion();
  }
}
inline bool OptimizationOptions::map_fusion() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.map_fusion)
  return _internal_map_fusion();
}
inline void OptimizationOptions::set_map_fusion(bool value) {
  if (optional_map_fusion_case() != kMapFusion) {
    clear_optional_map_fusion();
    set_has_map_fusion();
  }
  _impl_.optional_map_fusion_.map_fusion_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.map_fusion)
}
inline bool OptimizationOptions::_internal_map_fusion() const {
  if (optional_map_fusion_case() == kMapFusion) {
    return _impl_.optional_map_fusion_.map_fusion_;
  }
  return false;
}

// bool map_parallelization = 12;
inline bool OptimizationOptions::has_map_parallelization() const {
  return optional_map_parallelization_case() == kMapParallelization;
}
inline void OptimizationOptions::set_has_map_parallelization() {
  _impl_._oneof_case_[5] = kMapParallelization;
}
inline void OptimizationOptions::clear_map_parallelization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_map_parallelization_case() == kMapParallelization) {
    _impl_.optional_map_parallelization_.map_parallelization_ = false;
    clear_has_optional_map_parallelization();
  }
}
inline bool OptimizationOptions::map_parallelization() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.map_parallelization)
  return _internal_map_parallelization();
}
inline void OptimizationOptions::set_map_parallelization(bool value) {
  if (optional_map_parallelization_case() != kMapParallelization) {
    clear_optional_map_parallelization();
    set_has_map_parallelization();
  }
  _impl_.optional_map_parallelization_.map_parallelization_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.map_parallelization)
}
inline bool OptimizationOptions::_internal_map_parallelization() const {
  if (optional_map_parallelization_case() == kMapParallelization) {
    return _impl_.optional_map_parallelization_.map_parallelization_;
  }
  return false;
}

// bool noop_elimination = 14;
inline bool OptimizationOptions::has_noop_elimination() const {
  return optional_noop_elimination_case() == kNoopElimination;
}
inline void OptimizationOptions::set_has_noop_elimination() {
  _impl_._oneof_case_[6] = kNoopElimination;
}
inline void OptimizationOptions::clear_noop_elimination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_noop_elimination_case() == kNoopElimination) {
    _impl_.optional_noop_elimination_.noop_elimination_ = false;
    clear_has_optional_noop_elimination();
  }
}
inline bool OptimizationOptions::noop_elimination() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.noop_elimination)
  return _internal_noop_elimination();
}
inline void OptimizationOptions::set_noop_elimination(bool value) {
  if (optional_noop_elimination_case() != kNoopElimination) {
    clear_optional_noop_elimination();
    set_has_noop_elimination();
  }
  _impl_.optional_noop_elimination_.noop_elimination_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.noop_elimination)
}
inline bool OptimizationOptions::_internal_noop_elimination() const {
  if (optional_noop_elimination_case() == kNoopElimination) {
    return _impl_.optional_noop_elimination_.noop_elimination_;
  }
  return false;
}

// bool parallel_batch = 15;
inline bool OptimizationOptions::has_parallel_batch() const {
  return optional_parallel_batch_case() == kParallelBatch;
}
inline void OptimizationOptions::set_has_parallel_batch() {
  _impl_._oneof_case_[7] = kParallelBatch;
}
inline void OptimizationOptions::clear_parallel_batch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_parallel_batch_case() == kParallelBatch) {
    _impl_.optional_parallel_batch_.parallel_batch_ = false;
    clear_has_optional_parallel_batch();
  }
}
inline bool OptimizationOptions::parallel_batch() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.parallel_batch)
  return _internal_parallel_batch();
}
inline void OptimizationOptions::set_parallel_batch(bool value) {
  if (optional_parallel_batch_case() != kParallelBatch) {
    clear_optional_parallel_batch();
    set_has_parallel_batch();
  }
  _impl_.optional_parallel_batch_.parallel_batch_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.parallel_batch)
}
inline bool OptimizationOptions::_internal_parallel_batch() const {
  if (optional_parallel_batch_case() == kParallelBatch) {
    return _impl_.optional_parallel_batch_.parallel_batch_;
  }
  return false;
}

// bool shuffle_and_repeat_fusion = 17;
inline bool OptimizationOptions::has_shuffle_and_repeat_fusion() const {
  return optional_shuffle_and_repeat_fusion_case() == kShuffleAndRepeatFusion;
}
inline void OptimizationOptions::set_has_shuffle_and_repeat_fusion() {
  _impl_._oneof_case_[8] = kShuffleAndRepeatFusion;
}
inline void OptimizationOptions::clear_shuffle_and_repeat_fusion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_shuffle_and_repeat_fusion_case() == kShuffleAndRepeatFusion) {
    _impl_.optional_shuffle_and_repeat_fusion_.shuffle_and_repeat_fusion_ = false;
    clear_has_optional_shuffle_and_repeat_fusion();
  }
}
inline bool OptimizationOptions::shuffle_and_repeat_fusion() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.shuffle_and_repeat_fusion)
  return _internal_shuffle_and_repeat_fusion();
}
inline void OptimizationOptions::set_shuffle_and_repeat_fusion(bool value) {
  if (optional_shuffle_and_repeat_fusion_case() != kShuffleAndRepeatFusion) {
    clear_optional_shuffle_and_repeat_fusion();
    set_has_shuffle_and_repeat_fusion();
  }
  _impl_.optional_shuffle_and_repeat_fusion_.shuffle_and_repeat_fusion_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.shuffle_and_repeat_fusion)
}
inline bool OptimizationOptions::_internal_shuffle_and_repeat_fusion() const {
  if (optional_shuffle_and_repeat_fusion_case() == kShuffleAndRepeatFusion) {
    return _impl_.optional_shuffle_and_repeat_fusion_.shuffle_and_repeat_fusion_;
  }
  return false;
}

// bool filter_parallelization = 18;
inline bool OptimizationOptions::has_filter_parallelization() const {
  return optional_filter_parallelization_case() == kFilterParallelization;
}
inline void OptimizationOptions::set_has_filter_parallelization() {
  _impl_._oneof_case_[9] = kFilterParallelization;
}
inline void OptimizationOptions::clear_filter_parallelization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_filter_parallelization_case() == kFilterParallelization) {
    _impl_.optional_filter_parallelization_.filter_parallelization_ = false;
    clear_has_optional_filter_parallelization();
  }
}
inline bool OptimizationOptions::filter_parallelization() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.filter_parallelization)
  return _internal_filter_parallelization();
}
inline void OptimizationOptions::set_filter_parallelization(bool value) {
  if (optional_filter_parallelization_case() != kFilterParallelization) {
    clear_optional_filter_parallelization();
    set_has_filter_parallelization();
  }
  _impl_.optional_filter_parallelization_.filter_parallelization_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.filter_parallelization)
}
inline bool OptimizationOptions::_internal_filter_parallelization() const {
  if (optional_filter_parallelization_case() == kFilterParallelization) {
    return _impl_.optional_filter_parallelization_.filter_parallelization_;
  }
  return false;
}

// bool inject_prefetch = 19;
inline bool OptimizationOptions::has_inject_prefetch() const {
  return optional_inject_prefetch_case() == kInjectPrefetch;
}
inline void OptimizationOptions::set_has_inject_prefetch() {
  _impl_._oneof_case_[10] = kInjectPrefetch;
}
inline void OptimizationOptions::clear_inject_prefetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_inject_prefetch_case() == kInjectPrefetch) {
    _impl_.optional_inject_prefetch_.inject_prefetch_ = false;
    clear_has_optional_inject_prefetch();
  }
}
inline bool OptimizationOptions::inject_prefetch() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.inject_prefetch)
  return _internal_inject_prefetch();
}
inline void OptimizationOptions::set_inject_prefetch(bool value) {
  if (optional_inject_prefetch_case() != kInjectPrefetch) {
    clear_optional_inject_prefetch();
    set_has_inject_prefetch();
  }
  _impl_.optional_inject_prefetch_.inject_prefetch_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.inject_prefetch)
}
inline bool OptimizationOptions::_internal_inject_prefetch() const {
  if (optional_inject_prefetch_case() == kInjectPrefetch) {
    return _impl_.optional_inject_prefetch_.inject_prefetch_;
  }
  return false;
}

// bool seq_interleave_prefetch = 21;
inline bool OptimizationOptions::has_seq_interleave_prefetch() const {
  return optional_seq_interleave_prefetch_case() == kSeqInterleavePrefetch;
}
inline void OptimizationOptions::set_has_seq_interleave_prefetch() {
  _impl_._oneof_case_[11] = kSeqInterleavePrefetch;
}
inline void OptimizationOptions::clear_seq_interleave_prefetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_seq_interleave_prefetch_case() == kSeqInterleavePrefetch) {
    _impl_.optional_seq_interleave_prefetch_.seq_interleave_prefetch_ = false;
    clear_has_optional_seq_interleave_prefetch();
  }
}
inline bool OptimizationOptions::seq_interleave_prefetch() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.OptimizationOptions.seq_interleave_prefetch)
  return _internal_seq_interleave_prefetch();
}
inline void OptimizationOptions::set_seq_interleave_prefetch(bool value) {
  if (optional_seq_interleave_prefetch_case() != kSeqInterleavePrefetch) {
    clear_optional_seq_interleave_prefetch();
    set_has_seq_interleave_prefetch();
  }
  _impl_.optional_seq_interleave_prefetch_.seq_interleave_prefetch_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.OptimizationOptions.seq_interleave_prefetch)
}
inline bool OptimizationOptions::_internal_seq_interleave_prefetch() const {
  if (optional_seq_interleave_prefetch_case() == kSeqInterleavePrefetch) {
    return _impl_.optional_seq_interleave_prefetch_.seq_interleave_prefetch_;
  }
  return false;
}

inline bool OptimizationOptions::has_optional_apply_default_optimizations() const {
  return optional_apply_default_optimizations_case() != OPTIONAL_APPLY_DEFAULT_OPTIMIZATIONS_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_apply_default_optimizations() {
  _impl_._oneof_case_[0] = OPTIONAL_APPLY_DEFAULT_OPTIMIZATIONS_NOT_SET;
}
inline bool OptimizationOptions::has_optional_filter_fusion() const {
  return optional_filter_fusion_case() != OPTIONAL_FILTER_FUSION_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_filter_fusion() {
  _impl_._oneof_case_[1] = OPTIONAL_FILTER_FUSION_NOT_SET;
}
inline bool OptimizationOptions::has_optional_map_and_batch_fusion() const {
  return optional_map_and_batch_fusion_case() != OPTIONAL_MAP_AND_BATCH_FUSION_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_map_and_batch_fusion() {
  _impl_._oneof_case_[2] = OPTIONAL_MAP_AND_BATCH_FUSION_NOT_SET;
}
inline bool OptimizationOptions::has_optional_map_and_filter_fusion() const {
  return optional_map_and_filter_fusion_case() != OPTIONAL_MAP_AND_FILTER_FUSION_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_map_and_filter_fusion() {
  _impl_._oneof_case_[3] = OPTIONAL_MAP_AND_FILTER_FUSION_NOT_SET;
}
inline bool OptimizationOptions::has_optional_map_fusion() const {
  return optional_map_fusion_case() != OPTIONAL_MAP_FUSION_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_map_fusion() {
  _impl_._oneof_case_[4] = OPTIONAL_MAP_FUSION_NOT_SET;
}
inline bool OptimizationOptions::has_optional_map_parallelization() const {
  return optional_map_parallelization_case() != OPTIONAL_MAP_PARALLELIZATION_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_map_parallelization() {
  _impl_._oneof_case_[5] = OPTIONAL_MAP_PARALLELIZATION_NOT_SET;
}
inline bool OptimizationOptions::has_optional_noop_elimination() const {
  return optional_noop_elimination_case() != OPTIONAL_NOOP_ELIMINATION_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_noop_elimination() {
  _impl_._oneof_case_[6] = OPTIONAL_NOOP_ELIMINATION_NOT_SET;
}
inline bool OptimizationOptions::has_optional_parallel_batch() const {
  return optional_parallel_batch_case() != OPTIONAL_PARALLEL_BATCH_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_parallel_batch() {
  _impl_._oneof_case_[7] = OPTIONAL_PARALLEL_BATCH_NOT_SET;
}
inline bool OptimizationOptions::has_optional_shuffle_and_repeat_fusion() const {
  return optional_shuffle_and_repeat_fusion_case() != OPTIONAL_SHUFFLE_AND_REPEAT_FUSION_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_shuffle_and_repeat_fusion() {
  _impl_._oneof_case_[8] = OPTIONAL_SHUFFLE_AND_REPEAT_FUSION_NOT_SET;
}
inline bool OptimizationOptions::has_optional_filter_parallelization() const {
  return optional_filter_parallelization_case() != OPTIONAL_FILTER_PARALLELIZATION_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_filter_parallelization() {
  _impl_._oneof_case_[9] = OPTIONAL_FILTER_PARALLELIZATION_NOT_SET;
}
inline bool OptimizationOptions::has_optional_inject_prefetch() const {
  return optional_inject_prefetch_case() != OPTIONAL_INJECT_PREFETCH_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_inject_prefetch() {
  _impl_._oneof_case_[10] = OPTIONAL_INJECT_PREFETCH_NOT_SET;
}
inline bool OptimizationOptions::has_optional_seq_interleave_prefetch() const {
  return optional_seq_interleave_prefetch_case() != OPTIONAL_SEQ_INTERLEAVE_PREFETCH_NOT_SET;
}
inline void OptimizationOptions::clear_has_optional_seq_interleave_prefetch() {
  _impl_._oneof_case_[11] = OPTIONAL_SEQ_INTERLEAVE_PREFETCH_NOT_SET;
}
inline OptimizationOptions::OptionalApplyDefaultOptimizationsCase OptimizationOptions::optional_apply_default_optimizations_case() const {
  return OptimizationOptions::OptionalApplyDefaultOptimizationsCase(_impl_._oneof_case_[0]);
}
inline OptimizationOptions::OptionalFilterFusionCase OptimizationOptions::optional_filter_fusion_case() const {
  return OptimizationOptions::OptionalFilterFusionCase(_impl_._oneof_case_[1]);
}
inline OptimizationOptions::OptionalMapAndBatchFusionCase OptimizationOptions::optional_map_and_batch_fusion_case() const {
  return OptimizationOptions::OptionalMapAndBatchFusionCase(_impl_._oneof_case_[2]);
}
inline OptimizationOptions::OptionalMapAndFilterFusionCase OptimizationOptions::optional_map_and_filter_fusion_case() const {
  return OptimizationOptions::OptionalMapAndFilterFusionCase(_impl_._oneof_case_[3]);
}
inline OptimizationOptions::OptionalMapFusionCase OptimizationOptions::optional_map_fusion_case() const {
  return OptimizationOptions::OptionalMapFusionCase(_impl_._oneof_case_[4]);
}
inline OptimizationOptions::OptionalMapParallelizationCase OptimizationOptions::optional_map_parallelization_case() const {
  return OptimizationOptions::OptionalMapParallelizationCase(_impl_._oneof_case_[5]);
}
inline OptimizationOptions::OptionalNoopEliminationCase OptimizationOptions::optional_noop_elimination_case() const {
  return OptimizationOptions::OptionalNoopEliminationCase(_impl_._oneof_case_[6]);
}
inline OptimizationOptions::OptionalParallelBatchCase OptimizationOptions::optional_parallel_batch_case() const {
  return OptimizationOptions::OptionalParallelBatchCase(_impl_._oneof_case_[7]);
}
inline OptimizationOptions::OptionalShuffleAndRepeatFusionCase OptimizationOptions::optional_shuffle_and_repeat_fusion_case() const {
  return OptimizationOptions::OptionalShuffleAndRepeatFusionCase(_impl_._oneof_case_[8]);
}
inline OptimizationOptions::OptionalFilterParallelizationCase OptimizationOptions::optional_filter_parallelization_case() const {
  return OptimizationOptions::OptionalFilterParallelizationCase(_impl_._oneof_case_[9]);
}
inline OptimizationOptions::OptionalInjectPrefetchCase OptimizationOptions::optional_inject_prefetch_case() const {
  return OptimizationOptions::OptionalInjectPrefetchCase(_impl_._oneof_case_[10]);
}
inline OptimizationOptions::OptionalSeqInterleavePrefetchCase OptimizationOptions::optional_seq_interleave_prefetch_case() const {
  return OptimizationOptions::OptionalSeqInterleavePrefetchCase(_impl_._oneof_case_[11]);
}
// -------------------------------------------------------------------

// ServiceOptions

// bool pinned = 1;
inline bool ServiceOptions::has_pinned() const {
  return optional_pinned_case() == kPinned;
}
inline void ServiceOptions::set_has_pinned() {
  _impl_._oneof_case_[0] = kPinned;
}
inline void ServiceOptions::clear_pinned() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_pinned_case() == kPinned) {
    _impl_.optional_pinned_.pinned_ = false;
    clear_has_optional_pinned();
  }
}
inline bool ServiceOptions::pinned() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ServiceOptions.pinned)
  return _internal_pinned();
}
inline void ServiceOptions::set_pinned(bool value) {
  if (optional_pinned_case() != kPinned) {
    clear_optional_pinned();
    set_has_pinned();
  }
  _impl_.optional_pinned_.pinned_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ServiceOptions.pinned)
}
inline bool ServiceOptions::_internal_pinned() const {
  if (optional_pinned_case() == kPinned) {
    return _impl_.optional_pinned_.pinned_;
  }
  return false;
}

inline bool ServiceOptions::has_optional_pinned() const {
  return optional_pinned_case() != OPTIONAL_PINNED_NOT_SET;
}
inline void ServiceOptions::clear_has_optional_pinned() {
  _impl_._oneof_case_[0] = OPTIONAL_PINNED_NOT_SET;
}
inline ServiceOptions::OptionalPinnedCase ServiceOptions::optional_pinned_case() const {
  return ServiceOptions::OptionalPinnedCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ThreadingOptions

// int32 max_intra_op_parallelism = 1;
inline bool ThreadingOptions::has_max_intra_op_parallelism() const {
  return optional_max_intra_op_parallelism_case() == kMaxIntraOpParallelism;
}
inline void ThreadingOptions::set_has_max_intra_op_parallelism() {
  _impl_._oneof_case_[0] = kMaxIntraOpParallelism;
}
inline void ThreadingOptions::clear_max_intra_op_parallelism() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_max_intra_op_parallelism_case() == kMaxIntraOpParallelism) {
    _impl_.optional_max_intra_op_parallelism_.max_intra_op_parallelism_ = 0;
    clear_has_optional_max_intra_op_parallelism();
  }
}
inline ::int32_t ThreadingOptions::max_intra_op_parallelism() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ThreadingOptions.max_intra_op_parallelism)
  return _internal_max_intra_op_parallelism();
}
inline void ThreadingOptions::set_max_intra_op_parallelism(::int32_t value) {
  if (optional_max_intra_op_parallelism_case() != kMaxIntraOpParallelism) {
    clear_optional_max_intra_op_parallelism();
    set_has_max_intra_op_parallelism();
  }
  _impl_.optional_max_intra_op_parallelism_.max_intra_op_parallelism_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ThreadingOptions.max_intra_op_parallelism)
}
inline ::int32_t ThreadingOptions::_internal_max_intra_op_parallelism() const {
  if (optional_max_intra_op_parallelism_case() == kMaxIntraOpParallelism) {
    return _impl_.optional_max_intra_op_parallelism_.max_intra_op_parallelism_;
  }
  return 0;
}

// int32 private_threadpool_size = 2;
inline bool ThreadingOptions::has_private_threadpool_size() const {
  return optional_private_threadpool_size_case() == kPrivateThreadpoolSize;
}
inline void ThreadingOptions::set_has_private_threadpool_size() {
  _impl_._oneof_case_[1] = kPrivateThreadpoolSize;
}
inline void ThreadingOptions::clear_private_threadpool_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_private_threadpool_size_case() == kPrivateThreadpoolSize) {
    _impl_.optional_private_threadpool_size_.private_threadpool_size_ = 0;
    clear_has_optional_private_threadpool_size();
  }
}
inline ::int32_t ThreadingOptions::private_threadpool_size() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ThreadingOptions.private_threadpool_size)
  return _internal_private_threadpool_size();
}
inline void ThreadingOptions::set_private_threadpool_size(::int32_t value) {
  if (optional_private_threadpool_size_case() != kPrivateThreadpoolSize) {
    clear_optional_private_threadpool_size();
    set_has_private_threadpool_size();
  }
  _impl_.optional_private_threadpool_size_.private_threadpool_size_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ThreadingOptions.private_threadpool_size)
}
inline ::int32_t ThreadingOptions::_internal_private_threadpool_size() const {
  if (optional_private_threadpool_size_case() == kPrivateThreadpoolSize) {
    return _impl_.optional_private_threadpool_size_.private_threadpool_size_;
  }
  return 0;
}

inline bool ThreadingOptions::has_optional_max_intra_op_parallelism() const {
  return optional_max_intra_op_parallelism_case() != OPTIONAL_MAX_INTRA_OP_PARALLELISM_NOT_SET;
}
inline void ThreadingOptions::clear_has_optional_max_intra_op_parallelism() {
  _impl_._oneof_case_[0] = OPTIONAL_MAX_INTRA_OP_PARALLELISM_NOT_SET;
}
inline bool ThreadingOptions::has_optional_private_threadpool_size() const {
  return optional_private_threadpool_size_case() != OPTIONAL_PRIVATE_THREADPOOL_SIZE_NOT_SET;
}
inline void ThreadingOptions::clear_has_optional_private_threadpool_size() {
  _impl_._oneof_case_[1] = OPTIONAL_PRIVATE_THREADPOOL_SIZE_NOT_SET;
}
inline ThreadingOptions::OptionalMaxIntraOpParallelismCase ThreadingOptions::optional_max_intra_op_parallelism_case() const {
  return ThreadingOptions::OptionalMaxIntraOpParallelismCase(_impl_._oneof_case_[0]);
}
inline ThreadingOptions::OptionalPrivateThreadpoolSizeCase ThreadingOptions::optional_private_threadpool_size_case() const {
  return ThreadingOptions::OptionalPrivateThreadpoolSizeCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Options

// string dataset_name = 10;
inline bool Options::has_dataset_name() const {
  return optional_dataset_name_case() == kDatasetName;
}
inline void Options::set_has_dataset_name() {
  _impl_._oneof_case_[0] = kDatasetName;
}
inline void Options::clear_dataset_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_dataset_name_case() == kDatasetName) {
    _impl_.optional_dataset_name_.dataset_name_.Destroy();
    clear_has_optional_dataset_name();
  }
}
inline const std::string& Options::dataset_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.dataset_name)
  return _internal_dataset_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Options::set_dataset_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_dataset_name_case() != kDatasetName) {
    clear_optional_dataset_name();

    set_has_dataset_name();
    _impl_.optional_dataset_name_.dataset_name_.InitDefault();
  }
  _impl_.optional_dataset_name_.dataset_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.data.Options.dataset_name)
}
inline std::string* Options::mutable_dataset_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dataset_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Options.dataset_name)
  return _s;
}
inline const std::string& Options::_internal_dataset_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (optional_dataset_name_case() != kDatasetName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.optional_dataset_name_.dataset_name_.Get();
}
inline void Options::_internal_set_dataset_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_dataset_name_case() != kDatasetName) {
    clear_optional_dataset_name();

    set_has_dataset_name();
    _impl_.optional_dataset_name_.dataset_name_.InitDefault();
  }
  _impl_.optional_dataset_name_.dataset_name_.Set(value, GetArena());
}
inline std::string* Options::_internal_mutable_dataset_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_dataset_name_case() != kDatasetName) {
    clear_optional_dataset_name();

    set_has_dataset_name();
    _impl_.optional_dataset_name_.dataset_name_.InitDefault();
  }
  return _impl_.optional_dataset_name_.dataset_name_.Mutable( GetArena());
}
inline std::string* Options::release_dataset_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.data.Options.dataset_name)
  if (optional_dataset_name_case() != kDatasetName) {
    return nullptr;
  }
  clear_has_optional_dataset_name();
  return _impl_.optional_dataset_name_.dataset_name_.Release();
}
inline void Options::set_allocated_dataset_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_optional_dataset_name()) {
    clear_optional_dataset_name();
  }
  if (value != nullptr) {
    set_has_dataset_name();
    _impl_.optional_dataset_name_.dataset_name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.Options.dataset_name)
}

// repeated string framework_type = 11;
inline int Options::_internal_framework_type_size() const {
  return _internal_framework_type().size();
}
inline int Options::framework_type_size() const {
  return _internal_framework_type_size();
}
inline void Options::clear_framework_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.framework_type_.Clear();
}
inline std::string* Options::add_framework_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_framework_type()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.data.Options.framework_type)
  return _s;
}
inline const std::string& Options::framework_type(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.framework_type)
  return _internal_framework_type().Get(index);
}
inline std::string* Options::mutable_framework_type(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Options.framework_type)
  return _internal_mutable_framework_type()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Options::set_framework_type(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_framework_type()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.data.Options.framework_type)
}
template <typename Arg_, typename... Args_>
inline void Options::add_framework_type(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_framework_type(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.data.Options.framework_type)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Options::framework_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.data.Options.framework_type)
  return _internal_framework_type();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Options::mutable_framework_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.Options.framework_type)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_framework_type();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Options::_internal_framework_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.framework_type_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Options::_internal_mutable_framework_type() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.framework_type_;
}

// bool deterministic = 1;
inline bool Options::has_deterministic() const {
  return optional_deterministic_case() == kDeterministic;
}
inline void Options::set_has_deterministic() {
  _impl_._oneof_case_[1] = kDeterministic;
}
inline void Options::clear_deterministic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_deterministic_case() == kDeterministic) {
    _impl_.optional_deterministic_.deterministic_ = false;
    clear_has_optional_deterministic();
  }
}
inline bool Options::deterministic() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.deterministic)
  return _internal_deterministic();
}
inline void Options::set_deterministic(bool value) {
  if (optional_deterministic_case() != kDeterministic) {
    clear_optional_deterministic();
    set_has_deterministic();
  }
  _impl_.optional_deterministic_.deterministic_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.Options.deterministic)
}
inline bool Options::_internal_deterministic() const {
  if (optional_deterministic_case() == kDeterministic) {
    return _impl_.optional_deterministic_.deterministic_;
  }
  return false;
}

// .tensorflow.data.AutotuneOptions autotune_options = 7;
inline bool Options::has_autotune_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.autotune_options_ != nullptr);
  return value;
}
inline void Options::clear_autotune_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.autotune_options_ != nullptr) _impl_.autotune_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::tensorflow::data::AutotuneOptions& Options::_internal_autotune_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::data::AutotuneOptions* p = _impl_.autotune_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::AutotuneOptions&>(::tensorflow::data::_AutotuneOptions_default_instance_);
}
inline const ::tensorflow::data::AutotuneOptions& Options::autotune_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.autotune_options)
  return _internal_autotune_options();
}
inline void Options::unsafe_arena_set_allocated_autotune_options(::tensorflow::data::AutotuneOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.autotune_options_);
  }
  _impl_.autotune_options_ = reinterpret_cast<::tensorflow::data::AutotuneOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.Options.autotune_options)
}
inline ::tensorflow::data::AutotuneOptions* Options::release_autotune_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tensorflow::data::AutotuneOptions* released = _impl_.autotune_options_;
  _impl_.autotune_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::data::AutotuneOptions* Options::unsafe_arena_release_autotune_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.data.Options.autotune_options)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tensorflow::data::AutotuneOptions* temp = _impl_.autotune_options_;
  _impl_.autotune_options_ = nullptr;
  return temp;
}
inline ::tensorflow::data::AutotuneOptions* Options::_internal_mutable_autotune_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.autotune_options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::data::AutotuneOptions>(GetArena());
    _impl_.autotune_options_ = reinterpret_cast<::tensorflow::data::AutotuneOptions*>(p);
  }
  return _impl_.autotune_options_;
}
inline ::tensorflow::data::AutotuneOptions* Options::mutable_autotune_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::tensorflow::data::AutotuneOptions* _msg = _internal_mutable_autotune_options();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Options.autotune_options)
  return _msg;
}
inline void Options::set_allocated_autotune_options(::tensorflow::data::AutotuneOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.autotune_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.autotune_options_ = reinterpret_cast<::tensorflow::data::AutotuneOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.Options.autotune_options)
}

// .tensorflow.data.DistributeOptions distribute_options = 2;
inline bool Options::has_distribute_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distribute_options_ != nullptr);
  return value;
}
inline void Options::clear_distribute_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.distribute_options_ != nullptr) _impl_.distribute_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::data::DistributeOptions& Options::_internal_distribute_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::data::DistributeOptions* p = _impl_.distribute_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::DistributeOptions&>(::tensorflow::data::_DistributeOptions_default_instance_);
}
inline const ::tensorflow::data::DistributeOptions& Options::distribute_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.distribute_options)
  return _internal_distribute_options();
}
inline void Options::unsafe_arena_set_allocated_distribute_options(::tensorflow::data::DistributeOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distribute_options_);
  }
  _impl_.distribute_options_ = reinterpret_cast<::tensorflow::data::DistributeOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.Options.distribute_options)
}
inline ::tensorflow::data::DistributeOptions* Options::release_distribute_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::data::DistributeOptions* released = _impl_.distribute_options_;
  _impl_.distribute_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::data::DistributeOptions* Options::unsafe_arena_release_distribute_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.data.Options.distribute_options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::data::DistributeOptions* temp = _impl_.distribute_options_;
  _impl_.distribute_options_ = nullptr;
  return temp;
}
inline ::tensorflow::data::DistributeOptions* Options::_internal_mutable_distribute_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.distribute_options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::data::DistributeOptions>(GetArena());
    _impl_.distribute_options_ = reinterpret_cast<::tensorflow::data::DistributeOptions*>(p);
  }
  return _impl_.distribute_options_;
}
inline ::tensorflow::data::DistributeOptions* Options::mutable_distribute_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::data::DistributeOptions* _msg = _internal_mutable_distribute_options();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Options.distribute_options)
  return _msg;
}
inline void Options::set_allocated_distribute_options(::tensorflow::data::DistributeOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.distribute_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.distribute_options_ = reinterpret_cast<::tensorflow::data::DistributeOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.Options.distribute_options)
}

// .tensorflow.data.OptimizationOptions optimization_options = 3;
inline bool Options::has_optimization_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.optimization_options_ != nullptr);
  return value;
}
inline void Options::clear_optimization_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimization_options_ != nullptr) _impl_.optimization_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tensorflow::data::OptimizationOptions& Options::_internal_optimization_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::data::OptimizationOptions* p = _impl_.optimization_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::OptimizationOptions&>(::tensorflow::data::_OptimizationOptions_default_instance_);
}
inline const ::tensorflow::data::OptimizationOptions& Options::optimization_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.optimization_options)
  return _internal_optimization_options();
}
inline void Options::unsafe_arena_set_allocated_optimization_options(::tensorflow::data::OptimizationOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.optimization_options_);
  }
  _impl_.optimization_options_ = reinterpret_cast<::tensorflow::data::OptimizationOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.Options.optimization_options)
}
inline ::tensorflow::data::OptimizationOptions* Options::release_optimization_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::data::OptimizationOptions* released = _impl_.optimization_options_;
  _impl_.optimization_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::data::OptimizationOptions* Options::unsafe_arena_release_optimization_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.data.Options.optimization_options)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::data::OptimizationOptions* temp = _impl_.optimization_options_;
  _impl_.optimization_options_ = nullptr;
  return temp;
}
inline ::tensorflow::data::OptimizationOptions* Options::_internal_mutable_optimization_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.optimization_options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::data::OptimizationOptions>(GetArena());
    _impl_.optimization_options_ = reinterpret_cast<::tensorflow::data::OptimizationOptions*>(p);
  }
  return _impl_.optimization_options_;
}
inline ::tensorflow::data::OptimizationOptions* Options::mutable_optimization_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::data::OptimizationOptions* _msg = _internal_mutable_optimization_options();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Options.optimization_options)
  return _msg;
}
inline void Options::set_allocated_optimization_options(::tensorflow::data::OptimizationOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.optimization_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.optimization_options_ = reinterpret_cast<::tensorflow::data::OptimizationOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.Options.optimization_options)
}

// .tensorflow.data.ServiceOptions service_options = 12;
inline bool Options::has_service_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.service_options_ != nullptr);
  return value;
}
inline void Options::clear_service_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.service_options_ != nullptr) _impl_.service_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::tensorflow::data::ServiceOptions& Options::_internal_service_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::data::ServiceOptions* p = _impl_.service_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::ServiceOptions&>(::tensorflow::data::_ServiceOptions_default_instance_);
}
inline const ::tensorflow::data::ServiceOptions& Options::service_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.service_options)
  return _internal_service_options();
}
inline void Options::unsafe_arena_set_allocated_service_options(::tensorflow::data::ServiceOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.service_options_);
  }
  _impl_.service_options_ = reinterpret_cast<::tensorflow::data::ServiceOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.Options.service_options)
}
inline ::tensorflow::data::ServiceOptions* Options::release_service_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::tensorflow::data::ServiceOptions* released = _impl_.service_options_;
  _impl_.service_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::data::ServiceOptions* Options::unsafe_arena_release_service_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.data.Options.service_options)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::tensorflow::data::ServiceOptions* temp = _impl_.service_options_;
  _impl_.service_options_ = nullptr;
  return temp;
}
inline ::tensorflow::data::ServiceOptions* Options::_internal_mutable_service_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.service_options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::data::ServiceOptions>(GetArena());
    _impl_.service_options_ = reinterpret_cast<::tensorflow::data::ServiceOptions*>(p);
  }
  return _impl_.service_options_;
}
inline ::tensorflow::data::ServiceOptions* Options::mutable_service_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::tensorflow::data::ServiceOptions* _msg = _internal_mutable_service_options();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Options.service_options)
  return _msg;
}
inline void Options::set_allocated_service_options(::tensorflow::data::ServiceOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.service_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.service_options_ = reinterpret_cast<::tensorflow::data::ServiceOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.Options.service_options)
}

// bool slack = 4;
inline bool Options::has_slack() const {
  return optional_slack_case() == kSlack;
}
inline void Options::set_has_slack() {
  _impl_._oneof_case_[2] = kSlack;
}
inline void Options::clear_slack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_slack_case() == kSlack) {
    _impl_.optional_slack_.slack_ = false;
    clear_has_optional_slack();
  }
}
inline bool Options::slack() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.slack)
  return _internal_slack();
}
inline void Options::set_slack(bool value) {
  if (optional_slack_case() != kSlack) {
    clear_optional_slack();
    set_has_slack();
  }
  _impl_.optional_slack_.slack_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.Options.slack)
}
inline bool Options::_internal_slack() const {
  if (optional_slack_case() == kSlack) {
    return _impl_.optional_slack_.slack_;
  }
  return false;
}

// .tensorflow.data.ThreadingOptions threading_options = 5;
inline bool Options::has_threading_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.threading_options_ != nullptr);
  return value;
}
inline void Options::clear_threading_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.threading_options_ != nullptr) _impl_.threading_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::tensorflow::data::ThreadingOptions& Options::_internal_threading_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::data::ThreadingOptions* p = _impl_.threading_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::ThreadingOptions&>(::tensorflow::data::_ThreadingOptions_default_instance_);
}
inline const ::tensorflow::data::ThreadingOptions& Options::threading_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.threading_options)
  return _internal_threading_options();
}
inline void Options::unsafe_arena_set_allocated_threading_options(::tensorflow::data::ThreadingOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.threading_options_);
  }
  _impl_.threading_options_ = reinterpret_cast<::tensorflow::data::ThreadingOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.Options.threading_options)
}
inline ::tensorflow::data::ThreadingOptions* Options::release_threading_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::data::ThreadingOptions* released = _impl_.threading_options_;
  _impl_.threading_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::data::ThreadingOptions* Options::unsafe_arena_release_threading_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.data.Options.threading_options)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::data::ThreadingOptions* temp = _impl_.threading_options_;
  _impl_.threading_options_ = nullptr;
  return temp;
}
inline ::tensorflow::data::ThreadingOptions* Options::_internal_mutable_threading_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.threading_options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::data::ThreadingOptions>(GetArena());
    _impl_.threading_options_ = reinterpret_cast<::tensorflow::data::ThreadingOptions*>(p);
  }
  return _impl_.threading_options_;
}
inline ::tensorflow::data::ThreadingOptions* Options::mutable_threading_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tensorflow::data::ThreadingOptions* _msg = _internal_mutable_threading_options();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Options.threading_options)
  return _msg;
}
inline void Options::set_allocated_threading_options(::tensorflow::data::ThreadingOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.threading_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.threading_options_ = reinterpret_cast<::tensorflow::data::ThreadingOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.Options.threading_options)
}

// .tensorflow.data.ExternalStatePolicy external_state_policy = 6;
inline bool Options::has_external_state_policy() const {
  return optional_external_state_policy_case() == kExternalStatePolicy;
}
inline void Options::set_has_external_state_policy() {
  _impl_._oneof_case_[3] = kExternalStatePolicy;
}
inline void Options::clear_external_state_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_external_state_policy_case() == kExternalStatePolicy) {
    _impl_.optional_external_state_policy_.external_state_policy_ = 0;
    clear_has_optional_external_state_policy();
  }
}
inline ::tensorflow::data::ExternalStatePolicy Options::external_state_policy() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.external_state_policy)
  return _internal_external_state_policy();
}
inline void Options::set_external_state_policy(::tensorflow::data::ExternalStatePolicy value) {
  if (optional_external_state_policy_case() != kExternalStatePolicy) {
    clear_optional_external_state_policy();
    set_has_external_state_policy();
  }
  _impl_.optional_external_state_policy_.external_state_policy_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.Options.external_state_policy)
}
inline ::tensorflow::data::ExternalStatePolicy Options::_internal_external_state_policy() const {
  if (optional_external_state_policy_case() == kExternalStatePolicy) {
    return static_cast<::tensorflow::data::ExternalStatePolicy>(_impl_.optional_external_state_policy_.external_state_policy_);
  }
  return static_cast<::tensorflow::data::ExternalStatePolicy>(0);
}

// bool symbolic_checkpoint = 8;
inline bool Options::has_symbolic_checkpoint() const {
  return optional_symbolic_checkpoint_case() == kSymbolicCheckpoint;
}
inline void Options::set_has_symbolic_checkpoint() {
  _impl_._oneof_case_[4] = kSymbolicCheckpoint;
}
inline void Options::clear_symbolic_checkpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_symbolic_checkpoint_case() == kSymbolicCheckpoint) {
    _impl_.optional_symbolic_checkpoint_.symbolic_checkpoint_ = false;
    clear_has_optional_symbolic_checkpoint();
  }
}
inline bool Options::symbolic_checkpoint() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.symbolic_checkpoint)
  return _internal_symbolic_checkpoint();
}
inline void Options::set_symbolic_checkpoint(bool value) {
  if (optional_symbolic_checkpoint_case() != kSymbolicCheckpoint) {
    clear_optional_symbolic_checkpoint();
    set_has_symbolic_checkpoint();
  }
  _impl_.optional_symbolic_checkpoint_.symbolic_checkpoint_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.Options.symbolic_checkpoint)
}
inline bool Options::_internal_symbolic_checkpoint() const {
  if (optional_symbolic_checkpoint_case() == kSymbolicCheckpoint) {
    return _impl_.optional_symbolic_checkpoint_.symbolic_checkpoint_;
  }
  return false;
}

// bool warm_start = 9;
inline bool Options::has_warm_start() const {
  return optional_warm_start_case() == kWarmStart;
}
inline void Options::set_has_warm_start() {
  _impl_._oneof_case_[5] = kWarmStart;
}
inline void Options::clear_warm_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (optional_warm_start_case() == kWarmStart) {
    _impl_.optional_warm_start_.warm_start_ = false;
    clear_has_optional_warm_start();
  }
}
inline bool Options::warm_start() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Options.warm_start)
  return _internal_warm_start();
}
inline void Options::set_warm_start(bool value) {
  if (optional_warm_start_case() != kWarmStart) {
    clear_optional_warm_start();
    set_has_warm_start();
  }
  _impl_.optional_warm_start_.warm_start_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.Options.warm_start)
}
inline bool Options::_internal_warm_start() const {
  if (optional_warm_start_case() == kWarmStart) {
    return _impl_.optional_warm_start_.warm_start_;
  }
  return false;
}

inline bool Options::has_optional_dataset_name() const {
  return optional_dataset_name_case() != OPTIONAL_DATASET_NAME_NOT_SET;
}
inline void Options::clear_has_optional_dataset_name() {
  _impl_._oneof_case_[0] = OPTIONAL_DATASET_NAME_NOT_SET;
}
inline bool Options::has_optional_deterministic() const {
  return optional_deterministic_case() != OPTIONAL_DETERMINISTIC_NOT_SET;
}
inline void Options::clear_has_optional_deterministic() {
  _impl_._oneof_case_[1] = OPTIONAL_DETERMINISTIC_NOT_SET;
}
inline bool Options::has_optional_slack() const {
  return optional_slack_case() != OPTIONAL_SLACK_NOT_SET;
}
inline void Options::clear_has_optional_slack() {
  _impl_._oneof_case_[2] = OPTIONAL_SLACK_NOT_SET;
}
inline bool Options::has_optional_external_state_policy() const {
  return optional_external_state_policy_case() != OPTIONAL_EXTERNAL_STATE_POLICY_NOT_SET;
}
inline void Options::clear_has_optional_external_state_policy() {
  _impl_._oneof_case_[3] = OPTIONAL_EXTERNAL_STATE_POLICY_NOT_SET;
}
inline bool Options::has_optional_symbolic_checkpoint() const {
  return optional_symbolic_checkpoint_case() != OPTIONAL_SYMBOLIC_CHECKPOINT_NOT_SET;
}
inline void Options::clear_has_optional_symbolic_checkpoint() {
  _impl_._oneof_case_[4] = OPTIONAL_SYMBOLIC_CHECKPOINT_NOT_SET;
}
inline bool Options::has_optional_warm_start() const {
  return optional_warm_start_case() != OPTIONAL_WARM_START_NOT_SET;
}
inline void Options::clear_has_optional_warm_start() {
  _impl_._oneof_case_[5] = OPTIONAL_WARM_START_NOT_SET;
}
inline Options::OptionalDatasetNameCase Options::optional_dataset_name_case() const {
  return Options::OptionalDatasetNameCase(_impl_._oneof_case_[0]);
}
inline Options::OptionalDeterministicCase Options::optional_deterministic_case() const {
  return Options::OptionalDeterministicCase(_impl_._oneof_case_[1]);
}
inline Options::OptionalSlackCase Options::optional_slack_case() const {
  return Options::OptionalSlackCase(_impl_._oneof_case_[2]);
}
inline Options::OptionalExternalStatePolicyCase Options::optional_external_state_policy_case() const {
  return Options::OptionalExternalStatePolicyCase(_impl_._oneof_case_[3]);
}
inline Options::OptionalSymbolicCheckpointCase Options::optional_symbolic_checkpoint_case() const {
  return Options::OptionalSymbolicCheckpointCase(_impl_._oneof_case_[4]);
}
inline Options::OptionalWarmStartCase Options::optional_warm_start_case() const {
  return Options::OptionalWarmStartCase(_impl_._oneof_case_[5]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace data
}  // namespace tensorflow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tensorflow::data::CardinalityOptions_ComputeLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::data::CardinalityOptions_ComputeLevel>() {
  return ::tensorflow::data::CardinalityOptions_ComputeLevel_descriptor();
}
template <>
struct is_proto_enum<::tensorflow::data::AutoShardPolicy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::data::AutoShardPolicy>() {
  return ::tensorflow::data::AutoShardPolicy_descriptor();
}
template <>
struct is_proto_enum<::tensorflow::data::ExternalStatePolicy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::data::ExternalStatePolicy>() {
  return ::tensorflow::data::ExternalStatePolicy_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fframework_2fdataset_5foptions_2eproto_2epb_2eh
