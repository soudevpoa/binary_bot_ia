// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: tensorflow/core/protobuf/debug_event.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "tensorflow/core/framework/graph_debug_info.pb.h"
#include "tensorflow/core/framework/tensor.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
namespace tensorflow {
class CodeLocation;
struct CodeLocationDefaultTypeInternal;
PROTOBUF_EXPORT extern CodeLocationDefaultTypeInternal _CodeLocation_default_instance_;
class DebugEvent;
struct DebugEventDefaultTypeInternal;
PROTOBUF_EXPORT extern DebugEventDefaultTypeInternal _DebugEvent_default_instance_;
class DebugMetadata;
struct DebugMetadataDefaultTypeInternal;
PROTOBUF_EXPORT extern DebugMetadataDefaultTypeInternal _DebugMetadata_default_instance_;
class DebuggedDevice;
struct DebuggedDeviceDefaultTypeInternal;
PROTOBUF_EXPORT extern DebuggedDeviceDefaultTypeInternal _DebuggedDevice_default_instance_;
class DebuggedGraph;
struct DebuggedGraphDefaultTypeInternal;
PROTOBUF_EXPORT extern DebuggedGraphDefaultTypeInternal _DebuggedGraph_default_instance_;
class Execution;
struct ExecutionDefaultTypeInternal;
PROTOBUF_EXPORT extern ExecutionDefaultTypeInternal _Execution_default_instance_;
class GraphExecutionTrace;
struct GraphExecutionTraceDefaultTypeInternal;
PROTOBUF_EXPORT extern GraphExecutionTraceDefaultTypeInternal _GraphExecutionTrace_default_instance_;
class GraphOpCreation;
struct GraphOpCreationDefaultTypeInternal;
PROTOBUF_EXPORT extern GraphOpCreationDefaultTypeInternal _GraphOpCreation_default_instance_;
class SourceFile;
struct SourceFileDefaultTypeInternal;
PROTOBUF_EXPORT extern SourceFileDefaultTypeInternal _SourceFile_default_instance_;
class StackFrameWithId;
struct StackFrameWithIdDefaultTypeInternal;
PROTOBUF_EXPORT extern StackFrameWithIdDefaultTypeInternal _StackFrameWithId_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {
enum TensorDebugMode : int {
  UNSPECIFIED = 0,
  NO_TENSOR = 1,
  CURT_HEALTH = 2,
  CONCISE_HEALTH = 3,
  FULL_HEALTH = 4,
  SHAPE = 5,
  FULL_NUMERICS = 6,
  FULL_TENSOR = 7,
  REDUCE_INF_NAN_THREE_SLOTS = 8,
  TensorDebugMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TensorDebugMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool TensorDebugMode_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t TensorDebugMode_internal_data_[];
constexpr TensorDebugMode TensorDebugMode_MIN = static_cast<TensorDebugMode>(0);
constexpr TensorDebugMode TensorDebugMode_MAX = static_cast<TensorDebugMode>(8);
constexpr int TensorDebugMode_ARRAYSIZE = 8 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
TensorDebugMode_descriptor();
template <typename T>
const std::string& TensorDebugMode_Name(T value) {
  static_assert(std::is_same<T, TensorDebugMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TensorDebugMode_Name().");
  return TensorDebugMode_Name(static_cast<TensorDebugMode>(value));
}
template <>
inline const std::string& TensorDebugMode_Name(TensorDebugMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TensorDebugMode_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool TensorDebugMode_Parse(absl::string_view name, TensorDebugMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TensorDebugMode>(
      TensorDebugMode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT SourceFile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SourceFile) */ {
 public:
  inline SourceFile() : SourceFile(nullptr) {}
  ~SourceFile() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SourceFile(
      ::google::protobuf::internal::ConstantInitialized);

  inline SourceFile(const SourceFile& from) : SourceFile(nullptr, from) {}
  inline SourceFile(SourceFile&& from) noexcept
      : SourceFile(nullptr, std::move(from)) {}
  inline SourceFile& operator=(const SourceFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceFile& operator=(SourceFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceFile* internal_default_instance() {
    return reinterpret_cast<const SourceFile*>(
        &_SourceFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(SourceFile& a, SourceFile& b) { a.Swap(&b); }
  inline void Swap(SourceFile* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceFile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceFile* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SourceFile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SourceFile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SourceFile& from) { SourceFile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SourceFile* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SourceFile"; }

 protected:
  explicit SourceFile(::google::protobuf::Arena* arena);
  SourceFile(::google::protobuf::Arena* arena, const SourceFile& from);
  SourceFile(::google::protobuf::Arena* arena, SourceFile&& from) noexcept
      : SourceFile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLinesFieldNumber = 3,
    kFilePathFieldNumber = 1,
    kHostNameFieldNumber = 2,
  };
  // repeated string lines = 3;
  int lines_size() const;
  private:
  int _internal_lines_size() const;

  public:
  void clear_lines() ;
  const std::string& lines(int index) const;
  std::string* mutable_lines(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lines(int index, Arg_&& value, Args_... args);
  std::string* add_lines();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_lines(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& lines() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_lines();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_lines() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_lines();

  public:
  // string file_path = 1;
  void clear_file_path() ;
  const std::string& file_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_path(Arg_&& arg, Args_... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* value);

  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(
      const std::string& value);
  std::string* _internal_mutable_file_path();

  public:
  // string host_name = 2;
  void clear_host_name() ;
  const std::string& host_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host_name(Arg_&& arg, Args_... args);
  std::string* mutable_host_name();
  PROTOBUF_NODISCARD std::string* release_host_name();
  void set_allocated_host_name(std::string* value);

  private:
  const std::string& _internal_host_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_name(
      const std::string& value);
  std::string* _internal_mutable_host_name();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SourceFile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      53, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SourceFile& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> lines_;
    ::google::protobuf::internal::ArenaStringPtr file_path_;
    ::google::protobuf::internal::ArenaStringPtr host_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DebuggedGraph final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.DebuggedGraph) */ {
 public:
  inline DebuggedGraph() : DebuggedGraph(nullptr) {}
  ~DebuggedGraph() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DebuggedGraph(
      ::google::protobuf::internal::ConstantInitialized);

  inline DebuggedGraph(const DebuggedGraph& from) : DebuggedGraph(nullptr, from) {}
  inline DebuggedGraph(DebuggedGraph&& from) noexcept
      : DebuggedGraph(nullptr, std::move(from)) {}
  inline DebuggedGraph& operator=(const DebuggedGraph& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebuggedGraph& operator=(DebuggedGraph&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebuggedGraph& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebuggedGraph* internal_default_instance() {
    return reinterpret_cast<const DebuggedGraph*>(
        &_DebuggedGraph_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(DebuggedGraph& a, DebuggedGraph& b) { a.Swap(&b); }
  inline void Swap(DebuggedGraph* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebuggedGraph* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebuggedGraph* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DebuggedGraph>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DebuggedGraph& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DebuggedGraph& from) { DebuggedGraph::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DebuggedGraph* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.DebuggedGraph"; }

 protected:
  explicit DebuggedGraph(::google::protobuf::Arena* arena);
  DebuggedGraph(::google::protobuf::Arena* arena, const DebuggedGraph& from);
  DebuggedGraph(::google::protobuf::Arena* arena, DebuggedGraph&& from) noexcept
      : DebuggedGraph(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInstrumentedOpsFieldNumber = 3,
    kGraphIdFieldNumber = 1,
    kGraphNameFieldNumber = 2,
    kOriginalGraphDefFieldNumber = 4,
    kInstrumentedGraphDefFieldNumber = 5,
    kOuterContextIdFieldNumber = 6,
  };
  // repeated string instrumented_ops = 3;
  int instrumented_ops_size() const;
  private:
  int _internal_instrumented_ops_size() const;

  public:
  void clear_instrumented_ops() ;
  const std::string& instrumented_ops(int index) const;
  std::string* mutable_instrumented_ops(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_instrumented_ops(int index, Arg_&& value, Args_... args);
  std::string* add_instrumented_ops();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_instrumented_ops(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& instrumented_ops() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_instrumented_ops();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_instrumented_ops() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_instrumented_ops();

  public:
  // string graph_id = 1;
  void clear_graph_id() ;
  const std::string& graph_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_graph_id(Arg_&& arg, Args_... args);
  std::string* mutable_graph_id();
  PROTOBUF_NODISCARD std::string* release_graph_id();
  void set_allocated_graph_id(std::string* value);

  private:
  const std::string& _internal_graph_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_graph_id(
      const std::string& value);
  std::string* _internal_mutable_graph_id();

  public:
  // string graph_name = 2;
  void clear_graph_name() ;
  const std::string& graph_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_graph_name(Arg_&& arg, Args_... args);
  std::string* mutable_graph_name();
  PROTOBUF_NODISCARD std::string* release_graph_name();
  void set_allocated_graph_name(std::string* value);

  private:
  const std::string& _internal_graph_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_graph_name(
      const std::string& value);
  std::string* _internal_mutable_graph_name();

  public:
  // bytes original_graph_def = 4;
  void clear_original_graph_def() ;
  const std::string& original_graph_def() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_graph_def(Arg_&& arg, Args_... args);
  std::string* mutable_original_graph_def();
  PROTOBUF_NODISCARD std::string* release_original_graph_def();
  void set_allocated_original_graph_def(std::string* value);

  private:
  const std::string& _internal_original_graph_def() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_graph_def(
      const std::string& value);
  std::string* _internal_mutable_original_graph_def();

  public:
  // bytes instrumented_graph_def = 5;
  void clear_instrumented_graph_def() ;
  const std::string& instrumented_graph_def() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_instrumented_graph_def(Arg_&& arg, Args_... args);
  std::string* mutable_instrumented_graph_def();
  PROTOBUF_NODISCARD std::string* release_instrumented_graph_def();
  void set_allocated_instrumented_graph_def(std::string* value);

  private:
  const std::string& _internal_instrumented_graph_def() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrumented_graph_def(
      const std::string& value);
  std::string* _internal_mutable_instrumented_graph_def();

  public:
  // string outer_context_id = 6;
  void clear_outer_context_id() ;
  const std::string& outer_context_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_outer_context_id(Arg_&& arg, Args_... args);
  std::string* mutable_outer_context_id();
  PROTOBUF_NODISCARD std::string* release_outer_context_id();
  void set_allocated_outer_context_id(std::string* value);

  private:
  const std::string& _internal_outer_context_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_outer_context_id(
      const std::string& value);
  std::string* _internal_mutable_outer_context_id();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.DebuggedGraph)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      83, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DebuggedGraph& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> instrumented_ops_;
    ::google::protobuf::internal::ArenaStringPtr graph_id_;
    ::google::protobuf::internal::ArenaStringPtr graph_name_;
    ::google::protobuf::internal::ArenaStringPtr original_graph_def_;
    ::google::protobuf::internal::ArenaStringPtr instrumented_graph_def_;
    ::google::protobuf::internal::ArenaStringPtr outer_context_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DebuggedDevice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.DebuggedDevice) */ {
 public:
  inline DebuggedDevice() : DebuggedDevice(nullptr) {}
  ~DebuggedDevice() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DebuggedDevice(
      ::google::protobuf::internal::ConstantInitialized);

  inline DebuggedDevice(const DebuggedDevice& from) : DebuggedDevice(nullptr, from) {}
  inline DebuggedDevice(DebuggedDevice&& from) noexcept
      : DebuggedDevice(nullptr, std::move(from)) {}
  inline DebuggedDevice& operator=(const DebuggedDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebuggedDevice& operator=(DebuggedDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebuggedDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebuggedDevice* internal_default_instance() {
    return reinterpret_cast<const DebuggedDevice*>(
        &_DebuggedDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DebuggedDevice& a, DebuggedDevice& b) { a.Swap(&b); }
  inline void Swap(DebuggedDevice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebuggedDevice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebuggedDevice* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DebuggedDevice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DebuggedDevice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DebuggedDevice& from) { DebuggedDevice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DebuggedDevice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.DebuggedDevice"; }

 protected:
  explicit DebuggedDevice(::google::protobuf::Arena* arena);
  DebuggedDevice(::google::protobuf::Arena* arena, const DebuggedDevice& from);
  DebuggedDevice(::google::protobuf::Arena* arena, DebuggedDevice&& from) noexcept
      : DebuggedDevice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceNameFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
  };
  // string device_name = 1;
  void clear_device_name() ;
  const std::string& device_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_name(Arg_&& arg, Args_... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* value);

  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(
      const std::string& value);
  std::string* _internal_mutable_device_name();

  public:
  // int32 device_id = 2;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.DebuggedDevice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DebuggedDevice& from_msg);
    ::google::protobuf::internal::ArenaStringPtr device_name_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DebugMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.DebugMetadata) */ {
 public:
  inline DebugMetadata() : DebugMetadata(nullptr) {}
  ~DebugMetadata() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DebugMetadata(
      ::google::protobuf::internal::ConstantInitialized);

  inline DebugMetadata(const DebugMetadata& from) : DebugMetadata(nullptr, from) {}
  inline DebugMetadata(DebugMetadata&& from) noexcept
      : DebugMetadata(nullptr, std::move(from)) {}
  inline DebugMetadata& operator=(const DebugMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugMetadata& operator=(DebugMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugMetadata* internal_default_instance() {
    return reinterpret_cast<const DebugMetadata*>(
        &_DebugMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(DebugMetadata& a, DebugMetadata& b) { a.Swap(&b); }
  inline void Swap(DebugMetadata* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugMetadata* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DebugMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DebugMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DebugMetadata& from) { DebugMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DebugMetadata* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.DebugMetadata"; }

 protected:
  explicit DebugMetadata(::google::protobuf::Arena* arena);
  DebugMetadata(::google::protobuf::Arena* arena, const DebugMetadata& from);
  DebugMetadata(::google::protobuf::Arena* arena, DebugMetadata&& from) noexcept
      : DebugMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTensorflowVersionFieldNumber = 1,
    kFileVersionFieldNumber = 2,
    kTfdbgRunIdFieldNumber = 3,
  };
  // string tensorflow_version = 1;
  void clear_tensorflow_version() ;
  const std::string& tensorflow_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tensorflow_version(Arg_&& arg, Args_... args);
  std::string* mutable_tensorflow_version();
  PROTOBUF_NODISCARD std::string* release_tensorflow_version();
  void set_allocated_tensorflow_version(std::string* value);

  private:
  const std::string& _internal_tensorflow_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tensorflow_version(
      const std::string& value);
  std::string* _internal_mutable_tensorflow_version();

  public:
  // string file_version = 2;
  void clear_file_version() ;
  const std::string& file_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_version(Arg_&& arg, Args_... args);
  std::string* mutable_file_version();
  PROTOBUF_NODISCARD std::string* release_file_version();
  void set_allocated_file_version(std::string* value);

  private:
  const std::string& _internal_file_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_version(
      const std::string& value);
  std::string* _internal_mutable_file_version();

  public:
  // string tfdbg_run_id = 3;
  void clear_tfdbg_run_id() ;
  const std::string& tfdbg_run_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tfdbg_run_id(Arg_&& arg, Args_... args);
  std::string* mutable_tfdbg_run_id();
  PROTOBUF_NODISCARD std::string* release_tfdbg_run_id();
  void set_allocated_tfdbg_run_id(std::string* value);

  private:
  const std::string& _internal_tfdbg_run_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tfdbg_run_id(
      const std::string& value);
  std::string* _internal_mutable_tfdbg_run_id();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.DebugMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      75, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DebugMetadata& from_msg);
    ::google::protobuf::internal::ArenaStringPtr tensorflow_version_;
    ::google::protobuf::internal::ArenaStringPtr file_version_;
    ::google::protobuf::internal::ArenaStringPtr tfdbg_run_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CodeLocation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CodeLocation) */ {
 public:
  inline CodeLocation() : CodeLocation(nullptr) {}
  ~CodeLocation() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CodeLocation(
      ::google::protobuf::internal::ConstantInitialized);

  inline CodeLocation(const CodeLocation& from) : CodeLocation(nullptr, from) {}
  inline CodeLocation(CodeLocation&& from) noexcept
      : CodeLocation(nullptr, std::move(from)) {}
  inline CodeLocation& operator=(const CodeLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodeLocation& operator=(CodeLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CodeLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CodeLocation* internal_default_instance() {
    return reinterpret_cast<const CodeLocation*>(
        &_CodeLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(CodeLocation& a, CodeLocation& b) { a.Swap(&b); }
  inline void Swap(CodeLocation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodeLocation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CodeLocation* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CodeLocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CodeLocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CodeLocation& from) { CodeLocation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CodeLocation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CodeLocation"; }

 protected:
  explicit CodeLocation(::google::protobuf::Arena* arena);
  CodeLocation(::google::protobuf::Arena* arena, const CodeLocation& from);
  CodeLocation(::google::protobuf::Arena* arena, CodeLocation&& from) noexcept
      : CodeLocation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStackFrameIdsFieldNumber = 2,
    kHostNameFieldNumber = 1,
  };
  // repeated string stack_frame_ids = 2;
  int stack_frame_ids_size() const;
  private:
  int _internal_stack_frame_ids_size() const;

  public:
  void clear_stack_frame_ids() ;
  const std::string& stack_frame_ids(int index) const;
  std::string* mutable_stack_frame_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stack_frame_ids(int index, Arg_&& value, Args_... args);
  std::string* add_stack_frame_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_stack_frame_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& stack_frame_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_stack_frame_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_stack_frame_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_stack_frame_ids();

  public:
  // string host_name = 1;
  void clear_host_name() ;
  const std::string& host_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host_name(Arg_&& arg, Args_... args);
  std::string* mutable_host_name();
  PROTOBUF_NODISCARD std::string* release_host_name();
  void set_allocated_host_name(std::string* value);

  private:
  const std::string& _internal_host_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_name(
      const std::string& value);
  std::string* _internal_mutable_host_name();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CodeLocation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CodeLocation& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> stack_frame_ids_;
    ::google::protobuf::internal::ArenaStringPtr host_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT StackFrameWithId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.StackFrameWithId) */ {
 public:
  inline StackFrameWithId() : StackFrameWithId(nullptr) {}
  ~StackFrameWithId() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StackFrameWithId(
      ::google::protobuf::internal::ConstantInitialized);

  inline StackFrameWithId(const StackFrameWithId& from) : StackFrameWithId(nullptr, from) {}
  inline StackFrameWithId(StackFrameWithId&& from) noexcept
      : StackFrameWithId(nullptr, std::move(from)) {}
  inline StackFrameWithId& operator=(const StackFrameWithId& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackFrameWithId& operator=(StackFrameWithId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StackFrameWithId& default_instance() {
    return *internal_default_instance();
  }
  static inline const StackFrameWithId* internal_default_instance() {
    return reinterpret_cast<const StackFrameWithId*>(
        &_StackFrameWithId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(StackFrameWithId& a, StackFrameWithId& b) { a.Swap(&b); }
  inline void Swap(StackFrameWithId* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StackFrameWithId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StackFrameWithId* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<StackFrameWithId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StackFrameWithId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StackFrameWithId& from) { StackFrameWithId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StackFrameWithId* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.StackFrameWithId"; }

 protected:
  explicit StackFrameWithId(::google::protobuf::Arena* arena);
  StackFrameWithId(::google::protobuf::Arena* arena, const StackFrameWithId& from);
  StackFrameWithId(::google::protobuf::Arena* arena, StackFrameWithId&& from) noexcept
      : StackFrameWithId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kFileLineColFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .tensorflow.GraphDebugInfo.FileLineCol file_line_col = 2;
  bool has_file_line_col() const;
  void clear_file_line_col() ;
  const ::tensorflow::GraphDebugInfo_FileLineCol& file_line_col() const;
  PROTOBUF_NODISCARD ::tensorflow::GraphDebugInfo_FileLineCol* release_file_line_col();
  ::tensorflow::GraphDebugInfo_FileLineCol* mutable_file_line_col();
  void set_allocated_file_line_col(::tensorflow::GraphDebugInfo_FileLineCol* value);
  void unsafe_arena_set_allocated_file_line_col(::tensorflow::GraphDebugInfo_FileLineCol* value);
  ::tensorflow::GraphDebugInfo_FileLineCol* unsafe_arena_release_file_line_col();

  private:
  const ::tensorflow::GraphDebugInfo_FileLineCol& _internal_file_line_col() const;
  ::tensorflow::GraphDebugInfo_FileLineCol* _internal_mutable_file_line_col();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.StackFrameWithId)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      38, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StackFrameWithId& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::tensorflow::GraphDebugInfo_FileLineCol* file_line_col_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GraphOpCreation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GraphOpCreation) */ {
 public:
  inline GraphOpCreation() : GraphOpCreation(nullptr) {}
  ~GraphOpCreation() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GraphOpCreation(
      ::google::protobuf::internal::ConstantInitialized);

  inline GraphOpCreation(const GraphOpCreation& from) : GraphOpCreation(nullptr, from) {}
  inline GraphOpCreation(GraphOpCreation&& from) noexcept
      : GraphOpCreation(nullptr, std::move(from)) {}
  inline GraphOpCreation& operator=(const GraphOpCreation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphOpCreation& operator=(GraphOpCreation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphOpCreation& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphOpCreation* internal_default_instance() {
    return reinterpret_cast<const GraphOpCreation*>(
        &_GraphOpCreation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GraphOpCreation& a, GraphOpCreation& b) { a.Swap(&b); }
  inline void Swap(GraphOpCreation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphOpCreation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphOpCreation* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GraphOpCreation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GraphOpCreation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GraphOpCreation& from) { GraphOpCreation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GraphOpCreation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GraphOpCreation"; }

 protected:
  explicit GraphOpCreation(::google::protobuf::Arena* arena);
  GraphOpCreation(::google::protobuf::Arena* arena, const GraphOpCreation& from);
  GraphOpCreation(::google::protobuf::Arena* arena, GraphOpCreation&& from) noexcept
      : GraphOpCreation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputNamesFieldNumber = 6,
    kOutputTensorIdsFieldNumber = 9,
    kOpTypeFieldNumber = 1,
    kOpNameFieldNumber = 2,
    kGraphNameFieldNumber = 3,
    kGraphIdFieldNumber = 4,
    kDeviceNameFieldNumber = 5,
    kCodeLocationFieldNumber = 8,
    kNumOutputsFieldNumber = 7,
  };
  // repeated string input_names = 6;
  int input_names_size() const;
  private:
  int _internal_input_names_size() const;

  public:
  void clear_input_names() ;
  const std::string& input_names(int index) const;
  std::string* mutable_input_names(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_input_names(int index, Arg_&& value, Args_... args);
  std::string* add_input_names();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_input_names(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& input_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_input_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_input_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_input_names();

  public:
  // repeated int32 output_tensor_ids = 9;
  int output_tensor_ids_size() const;
  private:
  int _internal_output_tensor_ids_size() const;

  public:
  void clear_output_tensor_ids() ;
  ::int32_t output_tensor_ids(int index) const;
  void set_output_tensor_ids(int index, ::int32_t value);
  void add_output_tensor_ids(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& output_tensor_ids() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_output_tensor_ids();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_output_tensor_ids() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_output_tensor_ids();

  public:
  // string op_type = 1;
  void clear_op_type() ;
  const std::string& op_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_op_type(Arg_&& arg, Args_... args);
  std::string* mutable_op_type();
  PROTOBUF_NODISCARD std::string* release_op_type();
  void set_allocated_op_type(std::string* value);

  private:
  const std::string& _internal_op_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_type(
      const std::string& value);
  std::string* _internal_mutable_op_type();

  public:
  // string op_name = 2;
  void clear_op_name() ;
  const std::string& op_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_op_name(Arg_&& arg, Args_... args);
  std::string* mutable_op_name();
  PROTOBUF_NODISCARD std::string* release_op_name();
  void set_allocated_op_name(std::string* value);

  private:
  const std::string& _internal_op_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_name(
      const std::string& value);
  std::string* _internal_mutable_op_name();

  public:
  // string graph_name = 3;
  void clear_graph_name() ;
  const std::string& graph_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_graph_name(Arg_&& arg, Args_... args);
  std::string* mutable_graph_name();
  PROTOBUF_NODISCARD std::string* release_graph_name();
  void set_allocated_graph_name(std::string* value);

  private:
  const std::string& _internal_graph_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_graph_name(
      const std::string& value);
  std::string* _internal_mutable_graph_name();

  public:
  // string graph_id = 4;
  void clear_graph_id() ;
  const std::string& graph_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_graph_id(Arg_&& arg, Args_... args);
  std::string* mutable_graph_id();
  PROTOBUF_NODISCARD std::string* release_graph_id();
  void set_allocated_graph_id(std::string* value);

  private:
  const std::string& _internal_graph_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_graph_id(
      const std::string& value);
  std::string* _internal_mutable_graph_id();

  public:
  // string device_name = 5;
  void clear_device_name() ;
  const std::string& device_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_name(Arg_&& arg, Args_... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* value);

  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(
      const std::string& value);
  std::string* _internal_mutable_device_name();

  public:
  // .tensorflow.CodeLocation code_location = 8;
  bool has_code_location() const;
  void clear_code_location() ;
  const ::tensorflow::CodeLocation& code_location() const;
  PROTOBUF_NODISCARD ::tensorflow::CodeLocation* release_code_location();
  ::tensorflow::CodeLocation* mutable_code_location();
  void set_allocated_code_location(::tensorflow::CodeLocation* value);
  void unsafe_arena_set_allocated_code_location(::tensorflow::CodeLocation* value);
  ::tensorflow::CodeLocation* unsafe_arena_release_code_location();

  private:
  const ::tensorflow::CodeLocation& _internal_code_location() const;
  ::tensorflow::CodeLocation* _internal_mutable_code_location();

  public:
  // int32 num_outputs = 7;
  void clear_num_outputs() ;
  ::int32_t num_outputs() const;
  void set_num_outputs(::int32_t value);

  private:
  ::int32_t _internal_num_outputs() const;
  void _internal_set_num_outputs(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GraphOpCreation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      97, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GraphOpCreation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> input_names_;
    ::google::protobuf::RepeatedField<::int32_t> output_tensor_ids_;
    mutable ::google::protobuf::internal::CachedSize _output_tensor_ids_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr op_type_;
    ::google::protobuf::internal::ArenaStringPtr op_name_;
    ::google::protobuf::internal::ArenaStringPtr graph_name_;
    ::google::protobuf::internal::ArenaStringPtr graph_id_;
    ::google::protobuf::internal::ArenaStringPtr device_name_;
    ::tensorflow::CodeLocation* code_location_;
    ::int32_t num_outputs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GraphExecutionTrace final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GraphExecutionTrace) */ {
 public:
  inline GraphExecutionTrace() : GraphExecutionTrace(nullptr) {}
  ~GraphExecutionTrace() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GraphExecutionTrace(
      ::google::protobuf::internal::ConstantInitialized);

  inline GraphExecutionTrace(const GraphExecutionTrace& from) : GraphExecutionTrace(nullptr, from) {}
  inline GraphExecutionTrace(GraphExecutionTrace&& from) noexcept
      : GraphExecutionTrace(nullptr, std::move(from)) {}
  inline GraphExecutionTrace& operator=(const GraphExecutionTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphExecutionTrace& operator=(GraphExecutionTrace&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphExecutionTrace& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphExecutionTrace* internal_default_instance() {
    return reinterpret_cast<const GraphExecutionTrace*>(
        &_GraphExecutionTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GraphExecutionTrace& a, GraphExecutionTrace& b) { a.Swap(&b); }
  inline void Swap(GraphExecutionTrace* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphExecutionTrace* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphExecutionTrace* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GraphExecutionTrace>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GraphExecutionTrace& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GraphExecutionTrace& from) { GraphExecutionTrace::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GraphExecutionTrace* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GraphExecutionTrace"; }

 protected:
  explicit GraphExecutionTrace(::google::protobuf::Arena* arena);
  GraphExecutionTrace(::google::protobuf::Arena* arena, const GraphExecutionTrace& from);
  GraphExecutionTrace(::google::protobuf::Arena* arena, GraphExecutionTrace&& from) noexcept
      : GraphExecutionTrace(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTfdbgContextIdFieldNumber = 1,
    kOpNameFieldNumber = 2,
    kDeviceNameFieldNumber = 6,
    kTensorProtoFieldNumber = 5,
    kOutputSlotFieldNumber = 3,
    kTensorDebugModeFieldNumber = 4,
  };
  // string tfdbg_context_id = 1;
  void clear_tfdbg_context_id() ;
  const std::string& tfdbg_context_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tfdbg_context_id(Arg_&& arg, Args_... args);
  std::string* mutable_tfdbg_context_id();
  PROTOBUF_NODISCARD std::string* release_tfdbg_context_id();
  void set_allocated_tfdbg_context_id(std::string* value);

  private:
  const std::string& _internal_tfdbg_context_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tfdbg_context_id(
      const std::string& value);
  std::string* _internal_mutable_tfdbg_context_id();

  public:
  // string op_name = 2;
  void clear_op_name() ;
  const std::string& op_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_op_name(Arg_&& arg, Args_... args);
  std::string* mutable_op_name();
  PROTOBUF_NODISCARD std::string* release_op_name();
  void set_allocated_op_name(std::string* value);

  private:
  const std::string& _internal_op_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_name(
      const std::string& value);
  std::string* _internal_mutable_op_name();

  public:
  // string device_name = 6;
  void clear_device_name() ;
  const std::string& device_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_name(Arg_&& arg, Args_... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* value);

  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(
      const std::string& value);
  std::string* _internal_mutable_device_name();

  public:
  // .tensorflow.TensorProto tensor_proto = 5;
  bool has_tensor_proto() const;
  void clear_tensor_proto() ;
  const ::tensorflow::TensorProto& tensor_proto() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorProto* release_tensor_proto();
  ::tensorflow::TensorProto* mutable_tensor_proto();
  void set_allocated_tensor_proto(::tensorflow::TensorProto* value);
  void unsafe_arena_set_allocated_tensor_proto(::tensorflow::TensorProto* value);
  ::tensorflow::TensorProto* unsafe_arena_release_tensor_proto();

  private:
  const ::tensorflow::TensorProto& _internal_tensor_proto() const;
  ::tensorflow::TensorProto* _internal_mutable_tensor_proto();

  public:
  // int32 output_slot = 3;
  void clear_output_slot() ;
  ::int32_t output_slot() const;
  void set_output_slot(::int32_t value);

  private:
  ::int32_t _internal_output_slot() const;
  void _internal_set_output_slot(::int32_t value);

  public:
  // .tensorflow.TensorDebugMode tensor_debug_mode = 4;
  void clear_tensor_debug_mode() ;
  ::tensorflow::TensorDebugMode tensor_debug_mode() const;
  void set_tensor_debug_mode(::tensorflow::TensorDebugMode value);

  private:
  ::tensorflow::TensorDebugMode _internal_tensor_debug_mode() const;
  void _internal_set_tensor_debug_mode(::tensorflow::TensorDebugMode value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GraphExecutionTrace)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      73, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GraphExecutionTrace& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr tfdbg_context_id_;
    ::google::protobuf::internal::ArenaStringPtr op_name_;
    ::google::protobuf::internal::ArenaStringPtr device_name_;
    ::tensorflow::TensorProto* tensor_proto_;
    ::int32_t output_slot_;
    int tensor_debug_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT Execution final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.Execution) */ {
 public:
  inline Execution() : Execution(nullptr) {}
  ~Execution() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Execution(
      ::google::protobuf::internal::ConstantInitialized);

  inline Execution(const Execution& from) : Execution(nullptr, from) {}
  inline Execution(Execution&& from) noexcept
      : Execution(nullptr, std::move(from)) {}
  inline Execution& operator=(const Execution& from) {
    CopyFrom(from);
    return *this;
  }
  inline Execution& operator=(Execution&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Execution& default_instance() {
    return *internal_default_instance();
  }
  static inline const Execution* internal_default_instance() {
    return reinterpret_cast<const Execution*>(
        &_Execution_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Execution& a, Execution& b) { a.Swap(&b); }
  inline void Swap(Execution* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Execution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Execution* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Execution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Execution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Execution& from) { Execution::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Execution* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.Execution"; }

 protected:
  explicit Execution(::google::protobuf::Arena* arena);
  Execution(::google::protobuf::Arena* arena, const Execution& from);
  Execution(::google::protobuf::Arena* arena, Execution&& from) noexcept
      : Execution(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputTensorIdsFieldNumber = 4,
    kOutputTensorIdsFieldNumber = 5,
    kTensorProtosFieldNumber = 7,
    kOutputTensorDeviceIdsFieldNumber = 9,
    kOpTypeFieldNumber = 1,
    kGraphIdFieldNumber = 3,
    kCodeLocationFieldNumber = 8,
    kNumOutputsFieldNumber = 2,
    kTensorDebugModeFieldNumber = 6,
  };
  // repeated int64 input_tensor_ids = 4;
  int input_tensor_ids_size() const;
  private:
  int _internal_input_tensor_ids_size() const;

  public:
  void clear_input_tensor_ids() ;
  ::int64_t input_tensor_ids(int index) const;
  void set_input_tensor_ids(int index, ::int64_t value);
  void add_input_tensor_ids(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& input_tensor_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_input_tensor_ids();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_input_tensor_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_input_tensor_ids();

  public:
  // repeated int64 output_tensor_ids = 5;
  int output_tensor_ids_size() const;
  private:
  int _internal_output_tensor_ids_size() const;

  public:
  void clear_output_tensor_ids() ;
  ::int64_t output_tensor_ids(int index) const;
  void set_output_tensor_ids(int index, ::int64_t value);
  void add_output_tensor_ids(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& output_tensor_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_output_tensor_ids();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_output_tensor_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_output_tensor_ids();

  public:
  // repeated .tensorflow.TensorProto tensor_protos = 7;
  int tensor_protos_size() const;
  private:
  int _internal_tensor_protos_size() const;

  public:
  void clear_tensor_protos() ;
  ::tensorflow::TensorProto* mutable_tensor_protos(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* mutable_tensor_protos();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& _internal_tensor_protos() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* _internal_mutable_tensor_protos();
  public:
  const ::tensorflow::TensorProto& tensor_protos(int index) const;
  ::tensorflow::TensorProto* add_tensor_protos();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& tensor_protos() const;
  // repeated int32 output_tensor_device_ids = 9;
  int output_tensor_device_ids_size() const;
  private:
  int _internal_output_tensor_device_ids_size() const;

  public:
  void clear_output_tensor_device_ids() ;
  ::int32_t output_tensor_device_ids(int index) const;
  void set_output_tensor_device_ids(int index, ::int32_t value);
  void add_output_tensor_device_ids(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& output_tensor_device_ids() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_output_tensor_device_ids();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_output_tensor_device_ids() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_output_tensor_device_ids();

  public:
  // string op_type = 1;
  void clear_op_type() ;
  const std::string& op_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_op_type(Arg_&& arg, Args_... args);
  std::string* mutable_op_type();
  PROTOBUF_NODISCARD std::string* release_op_type();
  void set_allocated_op_type(std::string* value);

  private:
  const std::string& _internal_op_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_type(
      const std::string& value);
  std::string* _internal_mutable_op_type();

  public:
  // string graph_id = 3;
  void clear_graph_id() ;
  const std::string& graph_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_graph_id(Arg_&& arg, Args_... args);
  std::string* mutable_graph_id();
  PROTOBUF_NODISCARD std::string* release_graph_id();
  void set_allocated_graph_id(std::string* value);

  private:
  const std::string& _internal_graph_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_graph_id(
      const std::string& value);
  std::string* _internal_mutable_graph_id();

  public:
  // .tensorflow.CodeLocation code_location = 8;
  bool has_code_location() const;
  void clear_code_location() ;
  const ::tensorflow::CodeLocation& code_location() const;
  PROTOBUF_NODISCARD ::tensorflow::CodeLocation* release_code_location();
  ::tensorflow::CodeLocation* mutable_code_location();
  void set_allocated_code_location(::tensorflow::CodeLocation* value);
  void unsafe_arena_set_allocated_code_location(::tensorflow::CodeLocation* value);
  ::tensorflow::CodeLocation* unsafe_arena_release_code_location();

  private:
  const ::tensorflow::CodeLocation& _internal_code_location() const;
  ::tensorflow::CodeLocation* _internal_mutable_code_location();

  public:
  // int32 num_outputs = 2;
  void clear_num_outputs() ;
  ::int32_t num_outputs() const;
  void set_num_outputs(::int32_t value);

  private:
  ::int32_t _internal_num_outputs() const;
  void _internal_set_num_outputs(::int32_t value);

  public:
  // .tensorflow.TensorDebugMode tensor_debug_mode = 6;
  void clear_tensor_debug_mode() ;
  ::tensorflow::TensorDebugMode tensor_debug_mode() const;
  void set_tensor_debug_mode(::tensorflow::TensorDebugMode value);

  private:
  ::tensorflow::TensorDebugMode _internal_tensor_debug_mode() const;
  void _internal_set_tensor_debug_mode(::tensorflow::TensorDebugMode value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.Execution)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      52, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Execution& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> input_tensor_ids_;
    mutable ::google::protobuf::internal::CachedSize _input_tensor_ids_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> output_tensor_ids_;
    mutable ::google::protobuf::internal::CachedSize _output_tensor_ids_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > tensor_protos_;
    ::google::protobuf::RepeatedField<::int32_t> output_tensor_device_ids_;
    mutable ::google::protobuf::internal::CachedSize _output_tensor_device_ids_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr op_type_;
    ::google::protobuf::internal::ArenaStringPtr graph_id_;
    ::tensorflow::CodeLocation* code_location_;
    ::int32_t num_outputs_;
    int tensor_debug_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DebugEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.DebugEvent) */ {
 public:
  inline DebugEvent() : DebugEvent(nullptr) {}
  ~DebugEvent() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DebugEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline DebugEvent(const DebugEvent& from) : DebugEvent(nullptr, from) {}
  inline DebugEvent(DebugEvent&& from) noexcept
      : DebugEvent(nullptr, std::move(from)) {}
  inline DebugEvent& operator=(const DebugEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugEvent& operator=(DebugEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugEvent& default_instance() {
    return *internal_default_instance();
  }
  enum WhatCase {
    kDebugMetadata = 3,
    kSourceFile = 4,
    kStackFrameWithId = 6,
    kGraphOpCreation = 7,
    kDebuggedGraph = 8,
    kExecution = 9,
    kGraphExecutionTrace = 10,
    kGraphId = 11,
    kDebuggedDevice = 12,
    WHAT_NOT_SET = 0,
  };
  static inline const DebugEvent* internal_default_instance() {
    return reinterpret_cast<const DebugEvent*>(
        &_DebugEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(DebugEvent& a, DebugEvent& b) { a.Swap(&b); }
  inline void Swap(DebugEvent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugEvent* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DebugEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DebugEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DebugEvent& from) { DebugEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DebugEvent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.DebugEvent"; }

 protected:
  explicit DebugEvent(::google::protobuf::Arena* arena);
  DebugEvent(::google::protobuf::Arena* arena, const DebugEvent& from);
  DebugEvent(::google::protobuf::Arena* arena, DebugEvent&& from) noexcept
      : DebugEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWallTimeFieldNumber = 1,
    kStepFieldNumber = 2,
    kDebugMetadataFieldNumber = 3,
    kSourceFileFieldNumber = 4,
    kStackFrameWithIdFieldNumber = 6,
    kGraphOpCreationFieldNumber = 7,
    kDebuggedGraphFieldNumber = 8,
    kExecutionFieldNumber = 9,
    kGraphExecutionTraceFieldNumber = 10,
    kGraphIdFieldNumber = 11,
    kDebuggedDeviceFieldNumber = 12,
  };
  // double wall_time = 1;
  void clear_wall_time() ;
  double wall_time() const;
  void set_wall_time(double value);

  private:
  double _internal_wall_time() const;
  void _internal_set_wall_time(double value);

  public:
  // int64 step = 2;
  void clear_step() ;
  ::int64_t step() const;
  void set_step(::int64_t value);

  private:
  ::int64_t _internal_step() const;
  void _internal_set_step(::int64_t value);

  public:
  // .tensorflow.DebugMetadata debug_metadata = 3;
  bool has_debug_metadata() const;
  private:
  bool _internal_has_debug_metadata() const;

  public:
  void clear_debug_metadata() ;
  const ::tensorflow::DebugMetadata& debug_metadata() const;
  PROTOBUF_NODISCARD ::tensorflow::DebugMetadata* release_debug_metadata();
  ::tensorflow::DebugMetadata* mutable_debug_metadata();
  void set_allocated_debug_metadata(::tensorflow::DebugMetadata* value);
  void unsafe_arena_set_allocated_debug_metadata(::tensorflow::DebugMetadata* value);
  ::tensorflow::DebugMetadata* unsafe_arena_release_debug_metadata();

  private:
  const ::tensorflow::DebugMetadata& _internal_debug_metadata() const;
  ::tensorflow::DebugMetadata* _internal_mutable_debug_metadata();

  public:
  // .tensorflow.SourceFile source_file = 4;
  bool has_source_file() const;
  private:
  bool _internal_has_source_file() const;

  public:
  void clear_source_file() ;
  const ::tensorflow::SourceFile& source_file() const;
  PROTOBUF_NODISCARD ::tensorflow::SourceFile* release_source_file();
  ::tensorflow::SourceFile* mutable_source_file();
  void set_allocated_source_file(::tensorflow::SourceFile* value);
  void unsafe_arena_set_allocated_source_file(::tensorflow::SourceFile* value);
  ::tensorflow::SourceFile* unsafe_arena_release_source_file();

  private:
  const ::tensorflow::SourceFile& _internal_source_file() const;
  ::tensorflow::SourceFile* _internal_mutable_source_file();

  public:
  // .tensorflow.StackFrameWithId stack_frame_with_id = 6;
  bool has_stack_frame_with_id() const;
  private:
  bool _internal_has_stack_frame_with_id() const;

  public:
  void clear_stack_frame_with_id() ;
  const ::tensorflow::StackFrameWithId& stack_frame_with_id() const;
  PROTOBUF_NODISCARD ::tensorflow::StackFrameWithId* release_stack_frame_with_id();
  ::tensorflow::StackFrameWithId* mutable_stack_frame_with_id();
  void set_allocated_stack_frame_with_id(::tensorflow::StackFrameWithId* value);
  void unsafe_arena_set_allocated_stack_frame_with_id(::tensorflow::StackFrameWithId* value);
  ::tensorflow::StackFrameWithId* unsafe_arena_release_stack_frame_with_id();

  private:
  const ::tensorflow::StackFrameWithId& _internal_stack_frame_with_id() const;
  ::tensorflow::StackFrameWithId* _internal_mutable_stack_frame_with_id();

  public:
  // .tensorflow.GraphOpCreation graph_op_creation = 7;
  bool has_graph_op_creation() const;
  private:
  bool _internal_has_graph_op_creation() const;

  public:
  void clear_graph_op_creation() ;
  const ::tensorflow::GraphOpCreation& graph_op_creation() const;
  PROTOBUF_NODISCARD ::tensorflow::GraphOpCreation* release_graph_op_creation();
  ::tensorflow::GraphOpCreation* mutable_graph_op_creation();
  void set_allocated_graph_op_creation(::tensorflow::GraphOpCreation* value);
  void unsafe_arena_set_allocated_graph_op_creation(::tensorflow::GraphOpCreation* value);
  ::tensorflow::GraphOpCreation* unsafe_arena_release_graph_op_creation();

  private:
  const ::tensorflow::GraphOpCreation& _internal_graph_op_creation() const;
  ::tensorflow::GraphOpCreation* _internal_mutable_graph_op_creation();

  public:
  // .tensorflow.DebuggedGraph debugged_graph = 8;
  bool has_debugged_graph() const;
  private:
  bool _internal_has_debugged_graph() const;

  public:
  void clear_debugged_graph() ;
  const ::tensorflow::DebuggedGraph& debugged_graph() const;
  PROTOBUF_NODISCARD ::tensorflow::DebuggedGraph* release_debugged_graph();
  ::tensorflow::DebuggedGraph* mutable_debugged_graph();
  void set_allocated_debugged_graph(::tensorflow::DebuggedGraph* value);
  void unsafe_arena_set_allocated_debugged_graph(::tensorflow::DebuggedGraph* value);
  ::tensorflow::DebuggedGraph* unsafe_arena_release_debugged_graph();

  private:
  const ::tensorflow::DebuggedGraph& _internal_debugged_graph() const;
  ::tensorflow::DebuggedGraph* _internal_mutable_debugged_graph();

  public:
  // .tensorflow.Execution execution = 9;
  bool has_execution() const;
  private:
  bool _internal_has_execution() const;

  public:
  void clear_execution() ;
  const ::tensorflow::Execution& execution() const;
  PROTOBUF_NODISCARD ::tensorflow::Execution* release_execution();
  ::tensorflow::Execution* mutable_execution();
  void set_allocated_execution(::tensorflow::Execution* value);
  void unsafe_arena_set_allocated_execution(::tensorflow::Execution* value);
  ::tensorflow::Execution* unsafe_arena_release_execution();

  private:
  const ::tensorflow::Execution& _internal_execution() const;
  ::tensorflow::Execution* _internal_mutable_execution();

  public:
  // .tensorflow.GraphExecutionTrace graph_execution_trace = 10;
  bool has_graph_execution_trace() const;
  private:
  bool _internal_has_graph_execution_trace() const;

  public:
  void clear_graph_execution_trace() ;
  const ::tensorflow::GraphExecutionTrace& graph_execution_trace() const;
  PROTOBUF_NODISCARD ::tensorflow::GraphExecutionTrace* release_graph_execution_trace();
  ::tensorflow::GraphExecutionTrace* mutable_graph_execution_trace();
  void set_allocated_graph_execution_trace(::tensorflow::GraphExecutionTrace* value);
  void unsafe_arena_set_allocated_graph_execution_trace(::tensorflow::GraphExecutionTrace* value);
  ::tensorflow::GraphExecutionTrace* unsafe_arena_release_graph_execution_trace();

  private:
  const ::tensorflow::GraphExecutionTrace& _internal_graph_execution_trace() const;
  ::tensorflow::GraphExecutionTrace* _internal_mutable_graph_execution_trace();

  public:
  // string graph_id = 11;
  bool has_graph_id() const;
  void clear_graph_id() ;
  const std::string& graph_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_graph_id(Arg_&& arg, Args_... args);
  std::string* mutable_graph_id();
  PROTOBUF_NODISCARD std::string* release_graph_id();
  void set_allocated_graph_id(std::string* value);

  private:
  const std::string& _internal_graph_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_graph_id(
      const std::string& value);
  std::string* _internal_mutable_graph_id();

  public:
  // .tensorflow.DebuggedDevice debugged_device = 12;
  bool has_debugged_device() const;
  private:
  bool _internal_has_debugged_device() const;

  public:
  void clear_debugged_device() ;
  const ::tensorflow::DebuggedDevice& debugged_device() const;
  PROTOBUF_NODISCARD ::tensorflow::DebuggedDevice* release_debugged_device();
  ::tensorflow::DebuggedDevice* mutable_debugged_device();
  void set_allocated_debugged_device(::tensorflow::DebuggedDevice* value);
  void unsafe_arena_set_allocated_debugged_device(::tensorflow::DebuggedDevice* value);
  ::tensorflow::DebuggedDevice* unsafe_arena_release_debugged_device();

  private:
  const ::tensorflow::DebuggedDevice& _internal_debugged_device() const;
  ::tensorflow::DebuggedDevice* _internal_mutable_debugged_device();

  public:
  void clear_what();
  WhatCase what_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.DebugEvent)
 private:
  class _Internal;
  void set_has_debug_metadata();
  void set_has_source_file();
  void set_has_stack_frame_with_id();
  void set_has_graph_op_creation();
  void set_has_debugged_graph();
  void set_has_execution();
  void set_has_graph_execution_trace();
  void set_has_graph_id();
  void set_has_debugged_device();
  inline bool has_what() const;
  inline void clear_has_what();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 11, 8,
      46, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DebugEvent& from_msg);
    double wall_time_;
    ::int64_t step_;
    union WhatUnion {
      constexpr WhatUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tensorflow::DebugMetadata* debug_metadata_;
      ::tensorflow::SourceFile* source_file_;
      ::tensorflow::StackFrameWithId* stack_frame_with_id_;
      ::tensorflow::GraphOpCreation* graph_op_creation_;
      ::tensorflow::DebuggedGraph* debugged_graph_;
      ::tensorflow::Execution* execution_;
      ::tensorflow::GraphExecutionTrace* graph_execution_trace_;
      ::google::protobuf::internal::ArenaStringPtr graph_id_;
      ::tensorflow::DebuggedDevice* debugged_device_;
    } what_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DebugEvent

// double wall_time = 1;
inline void DebugEvent::clear_wall_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wall_time_ = 0;
}
inline double DebugEvent::wall_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.wall_time)
  return _internal_wall_time();
}
inline void DebugEvent::set_wall_time(double value) {
  _internal_set_wall_time(value);
  // @@protoc_insertion_point(field_set:tensorflow.DebugEvent.wall_time)
}
inline double DebugEvent::_internal_wall_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wall_time_;
}
inline void DebugEvent::_internal_set_wall_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wall_time_ = value;
}

// int64 step = 2;
inline void DebugEvent::clear_step() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.step_ = ::int64_t{0};
}
inline ::int64_t DebugEvent::step() const {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.step)
  return _internal_step();
}
inline void DebugEvent::set_step(::int64_t value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:tensorflow.DebugEvent.step)
}
inline ::int64_t DebugEvent::_internal_step() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.step_;
}
inline void DebugEvent::_internal_set_step(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.step_ = value;
}

// .tensorflow.DebugMetadata debug_metadata = 3;
inline bool DebugEvent::has_debug_metadata() const {
  return what_case() == kDebugMetadata;
}
inline bool DebugEvent::_internal_has_debug_metadata() const {
  return what_case() == kDebugMetadata;
}
inline void DebugEvent::set_has_debug_metadata() {
  _impl_._oneof_case_[0] = kDebugMetadata;
}
inline void DebugEvent::clear_debug_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kDebugMetadata) {
    if (GetArena() == nullptr) {
      delete _impl_.what_.debug_metadata_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.what_.debug_metadata_);
    }
    clear_has_what();
  }
}
inline ::tensorflow::DebugMetadata* DebugEvent::release_debug_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.debug_metadata)
  if (what_case() == kDebugMetadata) {
    clear_has_what();
    auto* temp = _impl_.what_.debug_metadata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.what_.debug_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::DebugMetadata& DebugEvent::_internal_debug_metadata() const {
  return what_case() == kDebugMetadata ? *_impl_.what_.debug_metadata_ : reinterpret_cast<::tensorflow::DebugMetadata&>(::tensorflow::_DebugMetadata_default_instance_);
}
inline const ::tensorflow::DebugMetadata& DebugEvent::debug_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.debug_metadata)
  return _internal_debug_metadata();
}
inline ::tensorflow::DebugMetadata* DebugEvent::unsafe_arena_release_debug_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DebugEvent.debug_metadata)
  if (what_case() == kDebugMetadata) {
    clear_has_what();
    auto* temp = _impl_.what_.debug_metadata_;
    _impl_.what_.debug_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugEvent::unsafe_arena_set_allocated_debug_metadata(::tensorflow::DebugMetadata* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_what();
  if (value) {
    set_has_debug_metadata();
    _impl_.what_.debug_metadata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DebugEvent.debug_metadata)
}
inline ::tensorflow::DebugMetadata* DebugEvent::_internal_mutable_debug_metadata() {
  if (what_case() != kDebugMetadata) {
    clear_what();
    set_has_debug_metadata();
    _impl_.what_.debug_metadata_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::DebugMetadata>(GetArena());
  }
  return _impl_.what_.debug_metadata_;
}
inline ::tensorflow::DebugMetadata* DebugEvent::mutable_debug_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::DebugMetadata* _msg = _internal_mutable_debug_metadata();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.debug_metadata)
  return _msg;
}

// .tensorflow.SourceFile source_file = 4;
inline bool DebugEvent::has_source_file() const {
  return what_case() == kSourceFile;
}
inline bool DebugEvent::_internal_has_source_file() const {
  return what_case() == kSourceFile;
}
inline void DebugEvent::set_has_source_file() {
  _impl_._oneof_case_[0] = kSourceFile;
}
inline void DebugEvent::clear_source_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kSourceFile) {
    if (GetArena() == nullptr) {
      delete _impl_.what_.source_file_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.what_.source_file_);
    }
    clear_has_what();
  }
}
inline ::tensorflow::SourceFile* DebugEvent::release_source_file() {
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.source_file)
  if (what_case() == kSourceFile) {
    clear_has_what();
    auto* temp = _impl_.what_.source_file_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.what_.source_file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::SourceFile& DebugEvent::_internal_source_file() const {
  return what_case() == kSourceFile ? *_impl_.what_.source_file_ : reinterpret_cast<::tensorflow::SourceFile&>(::tensorflow::_SourceFile_default_instance_);
}
inline const ::tensorflow::SourceFile& DebugEvent::source_file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.source_file)
  return _internal_source_file();
}
inline ::tensorflow::SourceFile* DebugEvent::unsafe_arena_release_source_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DebugEvent.source_file)
  if (what_case() == kSourceFile) {
    clear_has_what();
    auto* temp = _impl_.what_.source_file_;
    _impl_.what_.source_file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugEvent::unsafe_arena_set_allocated_source_file(::tensorflow::SourceFile* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_what();
  if (value) {
    set_has_source_file();
    _impl_.what_.source_file_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DebugEvent.source_file)
}
inline ::tensorflow::SourceFile* DebugEvent::_internal_mutable_source_file() {
  if (what_case() != kSourceFile) {
    clear_what();
    set_has_source_file();
    _impl_.what_.source_file_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::SourceFile>(GetArena());
  }
  return _impl_.what_.source_file_;
}
inline ::tensorflow::SourceFile* DebugEvent::mutable_source_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::SourceFile* _msg = _internal_mutable_source_file();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.source_file)
  return _msg;
}

// .tensorflow.StackFrameWithId stack_frame_with_id = 6;
inline bool DebugEvent::has_stack_frame_with_id() const {
  return what_case() == kStackFrameWithId;
}
inline bool DebugEvent::_internal_has_stack_frame_with_id() const {
  return what_case() == kStackFrameWithId;
}
inline void DebugEvent::set_has_stack_frame_with_id() {
  _impl_._oneof_case_[0] = kStackFrameWithId;
}
inline void DebugEvent::clear_stack_frame_with_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kStackFrameWithId) {
    if (GetArena() == nullptr) {
      delete _impl_.what_.stack_frame_with_id_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.what_.stack_frame_with_id_);
    }
    clear_has_what();
  }
}
inline ::tensorflow::StackFrameWithId* DebugEvent::release_stack_frame_with_id() {
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.stack_frame_with_id)
  if (what_case() == kStackFrameWithId) {
    clear_has_what();
    auto* temp = _impl_.what_.stack_frame_with_id_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.what_.stack_frame_with_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::StackFrameWithId& DebugEvent::_internal_stack_frame_with_id() const {
  return what_case() == kStackFrameWithId ? *_impl_.what_.stack_frame_with_id_ : reinterpret_cast<::tensorflow::StackFrameWithId&>(::tensorflow::_StackFrameWithId_default_instance_);
}
inline const ::tensorflow::StackFrameWithId& DebugEvent::stack_frame_with_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.stack_frame_with_id)
  return _internal_stack_frame_with_id();
}
inline ::tensorflow::StackFrameWithId* DebugEvent::unsafe_arena_release_stack_frame_with_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DebugEvent.stack_frame_with_id)
  if (what_case() == kStackFrameWithId) {
    clear_has_what();
    auto* temp = _impl_.what_.stack_frame_with_id_;
    _impl_.what_.stack_frame_with_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugEvent::unsafe_arena_set_allocated_stack_frame_with_id(::tensorflow::StackFrameWithId* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_what();
  if (value) {
    set_has_stack_frame_with_id();
    _impl_.what_.stack_frame_with_id_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DebugEvent.stack_frame_with_id)
}
inline ::tensorflow::StackFrameWithId* DebugEvent::_internal_mutable_stack_frame_with_id() {
  if (what_case() != kStackFrameWithId) {
    clear_what();
    set_has_stack_frame_with_id();
    _impl_.what_.stack_frame_with_id_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::StackFrameWithId>(GetArena());
  }
  return _impl_.what_.stack_frame_with_id_;
}
inline ::tensorflow::StackFrameWithId* DebugEvent::mutable_stack_frame_with_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::StackFrameWithId* _msg = _internal_mutable_stack_frame_with_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.stack_frame_with_id)
  return _msg;
}

// .tensorflow.GraphOpCreation graph_op_creation = 7;
inline bool DebugEvent::has_graph_op_creation() const {
  return what_case() == kGraphOpCreation;
}
inline bool DebugEvent::_internal_has_graph_op_creation() const {
  return what_case() == kGraphOpCreation;
}
inline void DebugEvent::set_has_graph_op_creation() {
  _impl_._oneof_case_[0] = kGraphOpCreation;
}
inline void DebugEvent::clear_graph_op_creation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kGraphOpCreation) {
    if (GetArena() == nullptr) {
      delete _impl_.what_.graph_op_creation_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.what_.graph_op_creation_);
    }
    clear_has_what();
  }
}
inline ::tensorflow::GraphOpCreation* DebugEvent::release_graph_op_creation() {
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.graph_op_creation)
  if (what_case() == kGraphOpCreation) {
    clear_has_what();
    auto* temp = _impl_.what_.graph_op_creation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.what_.graph_op_creation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::GraphOpCreation& DebugEvent::_internal_graph_op_creation() const {
  return what_case() == kGraphOpCreation ? *_impl_.what_.graph_op_creation_ : reinterpret_cast<::tensorflow::GraphOpCreation&>(::tensorflow::_GraphOpCreation_default_instance_);
}
inline const ::tensorflow::GraphOpCreation& DebugEvent::graph_op_creation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.graph_op_creation)
  return _internal_graph_op_creation();
}
inline ::tensorflow::GraphOpCreation* DebugEvent::unsafe_arena_release_graph_op_creation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DebugEvent.graph_op_creation)
  if (what_case() == kGraphOpCreation) {
    clear_has_what();
    auto* temp = _impl_.what_.graph_op_creation_;
    _impl_.what_.graph_op_creation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugEvent::unsafe_arena_set_allocated_graph_op_creation(::tensorflow::GraphOpCreation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_what();
  if (value) {
    set_has_graph_op_creation();
    _impl_.what_.graph_op_creation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DebugEvent.graph_op_creation)
}
inline ::tensorflow::GraphOpCreation* DebugEvent::_internal_mutable_graph_op_creation() {
  if (what_case() != kGraphOpCreation) {
    clear_what();
    set_has_graph_op_creation();
    _impl_.what_.graph_op_creation_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::GraphOpCreation>(GetArena());
  }
  return _impl_.what_.graph_op_creation_;
}
inline ::tensorflow::GraphOpCreation* DebugEvent::mutable_graph_op_creation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::GraphOpCreation* _msg = _internal_mutable_graph_op_creation();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.graph_op_creation)
  return _msg;
}

// .tensorflow.DebuggedGraph debugged_graph = 8;
inline bool DebugEvent::has_debugged_graph() const {
  return what_case() == kDebuggedGraph;
}
inline bool DebugEvent::_internal_has_debugged_graph() const {
  return what_case() == kDebuggedGraph;
}
inline void DebugEvent::set_has_debugged_graph() {
  _impl_._oneof_case_[0] = kDebuggedGraph;
}
inline void DebugEvent::clear_debugged_graph() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kDebuggedGraph) {
    if (GetArena() == nullptr) {
      delete _impl_.what_.debugged_graph_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.what_.debugged_graph_);
    }
    clear_has_what();
  }
}
inline ::tensorflow::DebuggedGraph* DebugEvent::release_debugged_graph() {
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.debugged_graph)
  if (what_case() == kDebuggedGraph) {
    clear_has_what();
    auto* temp = _impl_.what_.debugged_graph_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.what_.debugged_graph_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::DebuggedGraph& DebugEvent::_internal_debugged_graph() const {
  return what_case() == kDebuggedGraph ? *_impl_.what_.debugged_graph_ : reinterpret_cast<::tensorflow::DebuggedGraph&>(::tensorflow::_DebuggedGraph_default_instance_);
}
inline const ::tensorflow::DebuggedGraph& DebugEvent::debugged_graph() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.debugged_graph)
  return _internal_debugged_graph();
}
inline ::tensorflow::DebuggedGraph* DebugEvent::unsafe_arena_release_debugged_graph() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DebugEvent.debugged_graph)
  if (what_case() == kDebuggedGraph) {
    clear_has_what();
    auto* temp = _impl_.what_.debugged_graph_;
    _impl_.what_.debugged_graph_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugEvent::unsafe_arena_set_allocated_debugged_graph(::tensorflow::DebuggedGraph* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_what();
  if (value) {
    set_has_debugged_graph();
    _impl_.what_.debugged_graph_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DebugEvent.debugged_graph)
}
inline ::tensorflow::DebuggedGraph* DebugEvent::_internal_mutable_debugged_graph() {
  if (what_case() != kDebuggedGraph) {
    clear_what();
    set_has_debugged_graph();
    _impl_.what_.debugged_graph_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::DebuggedGraph>(GetArena());
  }
  return _impl_.what_.debugged_graph_;
}
inline ::tensorflow::DebuggedGraph* DebugEvent::mutable_debugged_graph() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::DebuggedGraph* _msg = _internal_mutable_debugged_graph();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.debugged_graph)
  return _msg;
}

// .tensorflow.Execution execution = 9;
inline bool DebugEvent::has_execution() const {
  return what_case() == kExecution;
}
inline bool DebugEvent::_internal_has_execution() const {
  return what_case() == kExecution;
}
inline void DebugEvent::set_has_execution() {
  _impl_._oneof_case_[0] = kExecution;
}
inline void DebugEvent::clear_execution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kExecution) {
    if (GetArena() == nullptr) {
      delete _impl_.what_.execution_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.what_.execution_);
    }
    clear_has_what();
  }
}
inline ::tensorflow::Execution* DebugEvent::release_execution() {
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.execution)
  if (what_case() == kExecution) {
    clear_has_what();
    auto* temp = _impl_.what_.execution_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.what_.execution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::Execution& DebugEvent::_internal_execution() const {
  return what_case() == kExecution ? *_impl_.what_.execution_ : reinterpret_cast<::tensorflow::Execution&>(::tensorflow::_Execution_default_instance_);
}
inline const ::tensorflow::Execution& DebugEvent::execution() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.execution)
  return _internal_execution();
}
inline ::tensorflow::Execution* DebugEvent::unsafe_arena_release_execution() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DebugEvent.execution)
  if (what_case() == kExecution) {
    clear_has_what();
    auto* temp = _impl_.what_.execution_;
    _impl_.what_.execution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugEvent::unsafe_arena_set_allocated_execution(::tensorflow::Execution* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_what();
  if (value) {
    set_has_execution();
    _impl_.what_.execution_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DebugEvent.execution)
}
inline ::tensorflow::Execution* DebugEvent::_internal_mutable_execution() {
  if (what_case() != kExecution) {
    clear_what();
    set_has_execution();
    _impl_.what_.execution_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::Execution>(GetArena());
  }
  return _impl_.what_.execution_;
}
inline ::tensorflow::Execution* DebugEvent::mutable_execution() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::Execution* _msg = _internal_mutable_execution();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.execution)
  return _msg;
}

// .tensorflow.GraphExecutionTrace graph_execution_trace = 10;
inline bool DebugEvent::has_graph_execution_trace() const {
  return what_case() == kGraphExecutionTrace;
}
inline bool DebugEvent::_internal_has_graph_execution_trace() const {
  return what_case() == kGraphExecutionTrace;
}
inline void DebugEvent::set_has_graph_execution_trace() {
  _impl_._oneof_case_[0] = kGraphExecutionTrace;
}
inline void DebugEvent::clear_graph_execution_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kGraphExecutionTrace) {
    if (GetArena() == nullptr) {
      delete _impl_.what_.graph_execution_trace_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.what_.graph_execution_trace_);
    }
    clear_has_what();
  }
}
inline ::tensorflow::GraphExecutionTrace* DebugEvent::release_graph_execution_trace() {
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.graph_execution_trace)
  if (what_case() == kGraphExecutionTrace) {
    clear_has_what();
    auto* temp = _impl_.what_.graph_execution_trace_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.what_.graph_execution_trace_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::GraphExecutionTrace& DebugEvent::_internal_graph_execution_trace() const {
  return what_case() == kGraphExecutionTrace ? *_impl_.what_.graph_execution_trace_ : reinterpret_cast<::tensorflow::GraphExecutionTrace&>(::tensorflow::_GraphExecutionTrace_default_instance_);
}
inline const ::tensorflow::GraphExecutionTrace& DebugEvent::graph_execution_trace() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.graph_execution_trace)
  return _internal_graph_execution_trace();
}
inline ::tensorflow::GraphExecutionTrace* DebugEvent::unsafe_arena_release_graph_execution_trace() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DebugEvent.graph_execution_trace)
  if (what_case() == kGraphExecutionTrace) {
    clear_has_what();
    auto* temp = _impl_.what_.graph_execution_trace_;
    _impl_.what_.graph_execution_trace_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugEvent::unsafe_arena_set_allocated_graph_execution_trace(::tensorflow::GraphExecutionTrace* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_what();
  if (value) {
    set_has_graph_execution_trace();
    _impl_.what_.graph_execution_trace_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DebugEvent.graph_execution_trace)
}
inline ::tensorflow::GraphExecutionTrace* DebugEvent::_internal_mutable_graph_execution_trace() {
  if (what_case() != kGraphExecutionTrace) {
    clear_what();
    set_has_graph_execution_trace();
    _impl_.what_.graph_execution_trace_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::GraphExecutionTrace>(GetArena());
  }
  return _impl_.what_.graph_execution_trace_;
}
inline ::tensorflow::GraphExecutionTrace* DebugEvent::mutable_graph_execution_trace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::GraphExecutionTrace* _msg = _internal_mutable_graph_execution_trace();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.graph_execution_trace)
  return _msg;
}

// string graph_id = 11;
inline bool DebugEvent::has_graph_id() const {
  return what_case() == kGraphId;
}
inline void DebugEvent::set_has_graph_id() {
  _impl_._oneof_case_[0] = kGraphId;
}
inline void DebugEvent::clear_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kGraphId) {
    _impl_.what_.graph_id_.Destroy();
    clear_has_what();
  }
}
inline const std::string& DebugEvent::graph_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.graph_id)
  return _internal_graph_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebugEvent::set_graph_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() != kGraphId) {
    clear_what();

    set_has_graph_id();
    _impl_.what_.graph_id_.InitDefault();
  }
  _impl_.what_.graph_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebugEvent.graph_id)
}
inline std::string* DebugEvent::mutable_graph_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_graph_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.graph_id)
  return _s;
}
inline const std::string& DebugEvent::_internal_graph_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (what_case() != kGraphId) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.what_.graph_id_.Get();
}
inline void DebugEvent::_internal_set_graph_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() != kGraphId) {
    clear_what();

    set_has_graph_id();
    _impl_.what_.graph_id_.InitDefault();
  }
  _impl_.what_.graph_id_.Set(value, GetArena());
}
inline std::string* DebugEvent::_internal_mutable_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() != kGraphId) {
    clear_what();

    set_has_graph_id();
    _impl_.what_.graph_id_.InitDefault();
  }
  return _impl_.what_.graph_id_.Mutable( GetArena());
}
inline std::string* DebugEvent::release_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.graph_id)
  if (what_case() != kGraphId) {
    return nullptr;
  }
  clear_has_what();
  return _impl_.what_.graph_id_.Release();
}
inline void DebugEvent::set_allocated_graph_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_what()) {
    clear_what();
  }
  if (value != nullptr) {
    set_has_graph_id();
    _impl_.what_.graph_id_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebugEvent.graph_id)
}

// .tensorflow.DebuggedDevice debugged_device = 12;
inline bool DebugEvent::has_debugged_device() const {
  return what_case() == kDebuggedDevice;
}
inline bool DebugEvent::_internal_has_debugged_device() const {
  return what_case() == kDebuggedDevice;
}
inline void DebugEvent::set_has_debugged_device() {
  _impl_._oneof_case_[0] = kDebuggedDevice;
}
inline void DebugEvent::clear_debugged_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (what_case() == kDebuggedDevice) {
    if (GetArena() == nullptr) {
      delete _impl_.what_.debugged_device_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.what_.debugged_device_);
    }
    clear_has_what();
  }
}
inline ::tensorflow::DebuggedDevice* DebugEvent::release_debugged_device() {
  // @@protoc_insertion_point(field_release:tensorflow.DebugEvent.debugged_device)
  if (what_case() == kDebuggedDevice) {
    clear_has_what();
    auto* temp = _impl_.what_.debugged_device_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.what_.debugged_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::DebuggedDevice& DebugEvent::_internal_debugged_device() const {
  return what_case() == kDebuggedDevice ? *_impl_.what_.debugged_device_ : reinterpret_cast<::tensorflow::DebuggedDevice&>(::tensorflow::_DebuggedDevice_default_instance_);
}
inline const ::tensorflow::DebuggedDevice& DebugEvent::debugged_device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugEvent.debugged_device)
  return _internal_debugged_device();
}
inline ::tensorflow::DebuggedDevice* DebugEvent::unsafe_arena_release_debugged_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.DebugEvent.debugged_device)
  if (what_case() == kDebuggedDevice) {
    clear_has_what();
    auto* temp = _impl_.what_.debugged_device_;
    _impl_.what_.debugged_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugEvent::unsafe_arena_set_allocated_debugged_device(::tensorflow::DebuggedDevice* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_what();
  if (value) {
    set_has_debugged_device();
    _impl_.what_.debugged_device_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.DebugEvent.debugged_device)
}
inline ::tensorflow::DebuggedDevice* DebugEvent::_internal_mutable_debugged_device() {
  if (what_case() != kDebuggedDevice) {
    clear_what();
    set_has_debugged_device();
    _impl_.what_.debugged_device_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::DebuggedDevice>(GetArena());
  }
  return _impl_.what_.debugged_device_;
}
inline ::tensorflow::DebuggedDevice* DebugEvent::mutable_debugged_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::DebuggedDevice* _msg = _internal_mutable_debugged_device();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugEvent.debugged_device)
  return _msg;
}

inline bool DebugEvent::has_what() const {
  return what_case() != WHAT_NOT_SET;
}
inline void DebugEvent::clear_has_what() {
  _impl_._oneof_case_[0] = WHAT_NOT_SET;
}
inline DebugEvent::WhatCase DebugEvent::what_case() const {
  return DebugEvent::WhatCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DebugMetadata

// string tensorflow_version = 1;
inline void DebugMetadata::clear_tensorflow_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_version_.ClearToEmpty();
}
inline const std::string& DebugMetadata::tensorflow_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugMetadata.tensorflow_version)
  return _internal_tensorflow_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebugMetadata::set_tensorflow_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebugMetadata.tensorflow_version)
}
inline std::string* DebugMetadata::mutable_tensorflow_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tensorflow_version();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugMetadata.tensorflow_version)
  return _s;
}
inline const std::string& DebugMetadata::_internal_tensorflow_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tensorflow_version_.Get();
}
inline void DebugMetadata::_internal_set_tensorflow_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_version_.Set(value, GetArena());
}
inline std::string* DebugMetadata::_internal_mutable_tensorflow_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tensorflow_version_.Mutable( GetArena());
}
inline std::string* DebugMetadata::release_tensorflow_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebugMetadata.tensorflow_version)
  return _impl_.tensorflow_version_.Release();
}
inline void DebugMetadata::set_allocated_tensorflow_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tensorflow_version_.IsDefault()) {
          _impl_.tensorflow_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebugMetadata.tensorflow_version)
}

// string file_version = 2;
inline void DebugMetadata::clear_file_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_version_.ClearToEmpty();
}
inline const std::string& DebugMetadata::file_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugMetadata.file_version)
  return _internal_file_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebugMetadata::set_file_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebugMetadata.file_version)
}
inline std::string* DebugMetadata::mutable_file_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_version();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugMetadata.file_version)
  return _s;
}
inline const std::string& DebugMetadata::_internal_file_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_version_.Get();
}
inline void DebugMetadata::_internal_set_file_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_version_.Set(value, GetArena());
}
inline std::string* DebugMetadata::_internal_mutable_file_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.file_version_.Mutable( GetArena());
}
inline std::string* DebugMetadata::release_file_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebugMetadata.file_version)
  return _impl_.file_version_.Release();
}
inline void DebugMetadata::set_allocated_file_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_version_.IsDefault()) {
          _impl_.file_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebugMetadata.file_version)
}

// string tfdbg_run_id = 3;
inline void DebugMetadata::clear_tfdbg_run_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tfdbg_run_id_.ClearToEmpty();
}
inline const std::string& DebugMetadata::tfdbg_run_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebugMetadata.tfdbg_run_id)
  return _internal_tfdbg_run_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebugMetadata::set_tfdbg_run_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tfdbg_run_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebugMetadata.tfdbg_run_id)
}
inline std::string* DebugMetadata::mutable_tfdbg_run_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tfdbg_run_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebugMetadata.tfdbg_run_id)
  return _s;
}
inline const std::string& DebugMetadata::_internal_tfdbg_run_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tfdbg_run_id_.Get();
}
inline void DebugMetadata::_internal_set_tfdbg_run_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tfdbg_run_id_.Set(value, GetArena());
}
inline std::string* DebugMetadata::_internal_mutable_tfdbg_run_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tfdbg_run_id_.Mutable( GetArena());
}
inline std::string* DebugMetadata::release_tfdbg_run_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebugMetadata.tfdbg_run_id)
  return _impl_.tfdbg_run_id_.Release();
}
inline void DebugMetadata::set_allocated_tfdbg_run_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tfdbg_run_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tfdbg_run_id_.IsDefault()) {
          _impl_.tfdbg_run_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebugMetadata.tfdbg_run_id)
}

// -------------------------------------------------------------------

// SourceFile

// string file_path = 1;
inline void SourceFile::clear_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_path_.ClearToEmpty();
}
inline const std::string& SourceFile::file_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SourceFile.file_path)
  return _internal_file_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SourceFile::set_file_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SourceFile.file_path)
}
inline std::string* SourceFile::mutable_file_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:tensorflow.SourceFile.file_path)
  return _s;
}
inline const std::string& SourceFile::_internal_file_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_path_.Get();
}
inline void SourceFile::_internal_set_file_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_path_.Set(value, GetArena());
}
inline std::string* SourceFile::_internal_mutable_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.file_path_.Mutable( GetArena());
}
inline std::string* SourceFile::release_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SourceFile.file_path)
  return _impl_.file_path_.Release();
}
inline void SourceFile::set_allocated_file_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_path_.IsDefault()) {
          _impl_.file_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SourceFile.file_path)
}

// string host_name = 2;
inline void SourceFile::clear_host_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_name_.ClearToEmpty();
}
inline const std::string& SourceFile::host_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SourceFile.host_name)
  return _internal_host_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SourceFile::set_host_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SourceFile.host_name)
}
inline std::string* SourceFile::mutable_host_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.SourceFile.host_name)
  return _s;
}
inline const std::string& SourceFile::_internal_host_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_name_.Get();
}
inline void SourceFile::_internal_set_host_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_name_.Set(value, GetArena());
}
inline std::string* SourceFile::_internal_mutable_host_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_name_.Mutable( GetArena());
}
inline std::string* SourceFile::release_host_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SourceFile.host_name)
  return _impl_.host_name_.Release();
}
inline void SourceFile::set_allocated_host_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_name_.IsDefault()) {
          _impl_.host_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SourceFile.host_name)
}

// repeated string lines = 3;
inline int SourceFile::_internal_lines_size() const {
  return _internal_lines().size();
}
inline int SourceFile::lines_size() const {
  return _internal_lines_size();
}
inline void SourceFile::clear_lines() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lines_.Clear();
}
inline std::string* SourceFile::add_lines() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_lines()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.SourceFile.lines)
  return _s;
}
inline const std::string& SourceFile::lines(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SourceFile.lines)
  return _internal_lines().Get(index);
}
inline std::string* SourceFile::mutable_lines(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.SourceFile.lines)
  return _internal_mutable_lines()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SourceFile::set_lines(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_lines()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.SourceFile.lines)
}
template <typename Arg_, typename... Args_>
inline void SourceFile::add_lines(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_lines(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.SourceFile.lines)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SourceFile::lines() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SourceFile.lines)
  return _internal_lines();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SourceFile::mutable_lines() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SourceFile.lines)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lines();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SourceFile::_internal_lines() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lines_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SourceFile::_internal_mutable_lines() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lines_;
}

// -------------------------------------------------------------------

// StackFrameWithId

// string id = 1;
inline void StackFrameWithId::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& StackFrameWithId::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StackFrameWithId.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StackFrameWithId::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.StackFrameWithId.id)
}
inline std::string* StackFrameWithId::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.StackFrameWithId.id)
  return _s;
}
inline const std::string& StackFrameWithId::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void StackFrameWithId::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* StackFrameWithId::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* StackFrameWithId::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.StackFrameWithId.id)
  return _impl_.id_.Release();
}
inline void StackFrameWithId::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StackFrameWithId.id)
}

// .tensorflow.GraphDebugInfo.FileLineCol file_line_col = 2;
inline bool StackFrameWithId::has_file_line_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.file_line_col_ != nullptr);
  return value;
}
inline const ::tensorflow::GraphDebugInfo_FileLineCol& StackFrameWithId::_internal_file_line_col() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::GraphDebugInfo_FileLineCol* p = _impl_.file_line_col_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::GraphDebugInfo_FileLineCol&>(::tensorflow::_GraphDebugInfo_FileLineCol_default_instance_);
}
inline const ::tensorflow::GraphDebugInfo_FileLineCol& StackFrameWithId::file_line_col() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StackFrameWithId.file_line_col)
  return _internal_file_line_col();
}
inline void StackFrameWithId::unsafe_arena_set_allocated_file_line_col(::tensorflow::GraphDebugInfo_FileLineCol* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.file_line_col_);
  }
  _impl_.file_line_col_ = reinterpret_cast<::tensorflow::GraphDebugInfo_FileLineCol*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StackFrameWithId.file_line_col)
}
inline ::tensorflow::GraphDebugInfo_FileLineCol* StackFrameWithId::release_file_line_col() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::GraphDebugInfo_FileLineCol* released = _impl_.file_line_col_;
  _impl_.file_line_col_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::GraphDebugInfo_FileLineCol* StackFrameWithId::unsafe_arena_release_file_line_col() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.StackFrameWithId.file_line_col)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::GraphDebugInfo_FileLineCol* temp = _impl_.file_line_col_;
  _impl_.file_line_col_ = nullptr;
  return temp;
}
inline ::tensorflow::GraphDebugInfo_FileLineCol* StackFrameWithId::_internal_mutable_file_line_col() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.file_line_col_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::GraphDebugInfo_FileLineCol>(GetArena());
    _impl_.file_line_col_ = reinterpret_cast<::tensorflow::GraphDebugInfo_FileLineCol*>(p);
  }
  return _impl_.file_line_col_;
}
inline ::tensorflow::GraphDebugInfo_FileLineCol* StackFrameWithId::mutable_file_line_col() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::GraphDebugInfo_FileLineCol* _msg = _internal_mutable_file_line_col();
  // @@protoc_insertion_point(field_mutable:tensorflow.StackFrameWithId.file_line_col)
  return _msg;
}
inline void StackFrameWithId::set_allocated_file_line_col(::tensorflow::GraphDebugInfo_FileLineCol* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.file_line_col_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.file_line_col_ = reinterpret_cast<::tensorflow::GraphDebugInfo_FileLineCol*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StackFrameWithId.file_line_col)
}

// -------------------------------------------------------------------

// CodeLocation

// string host_name = 1;
inline void CodeLocation::clear_host_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_name_.ClearToEmpty();
}
inline const std::string& CodeLocation::host_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CodeLocation.host_name)
  return _internal_host_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CodeLocation::set_host_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CodeLocation.host_name)
}
inline std::string* CodeLocation::mutable_host_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.CodeLocation.host_name)
  return _s;
}
inline const std::string& CodeLocation::_internal_host_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_name_.Get();
}
inline void CodeLocation::_internal_set_host_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_name_.Set(value, GetArena());
}
inline std::string* CodeLocation::_internal_mutable_host_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_name_.Mutable( GetArena());
}
inline std::string* CodeLocation::release_host_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CodeLocation.host_name)
  return _impl_.host_name_.Release();
}
inline void CodeLocation::set_allocated_host_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_name_.IsDefault()) {
          _impl_.host_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CodeLocation.host_name)
}

// repeated string stack_frame_ids = 2;
inline int CodeLocation::_internal_stack_frame_ids_size() const {
  return _internal_stack_frame_ids().size();
}
inline int CodeLocation::stack_frame_ids_size() const {
  return _internal_stack_frame_ids_size();
}
inline void CodeLocation::clear_stack_frame_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stack_frame_ids_.Clear();
}
inline std::string* CodeLocation::add_stack_frame_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_stack_frame_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.CodeLocation.stack_frame_ids)
  return _s;
}
inline const std::string& CodeLocation::stack_frame_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CodeLocation.stack_frame_ids)
  return _internal_stack_frame_ids().Get(index);
}
inline std::string* CodeLocation::mutable_stack_frame_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.CodeLocation.stack_frame_ids)
  return _internal_mutable_stack_frame_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CodeLocation::set_stack_frame_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_stack_frame_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.CodeLocation.stack_frame_ids)
}
template <typename Arg_, typename... Args_>
inline void CodeLocation::add_stack_frame_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_stack_frame_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.CodeLocation.stack_frame_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CodeLocation::stack_frame_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.CodeLocation.stack_frame_ids)
  return _internal_stack_frame_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CodeLocation::mutable_stack_frame_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CodeLocation.stack_frame_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stack_frame_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CodeLocation::_internal_stack_frame_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stack_frame_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CodeLocation::_internal_mutable_stack_frame_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stack_frame_ids_;
}

// -------------------------------------------------------------------

// GraphOpCreation

// string op_type = 1;
inline void GraphOpCreation::clear_op_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_type_.ClearToEmpty();
}
inline const std::string& GraphOpCreation::op_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.op_type)
  return _internal_op_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphOpCreation::set_op_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GraphOpCreation.op_type)
}
inline std::string* GraphOpCreation::mutable_op_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_op_type();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphOpCreation.op_type)
  return _s;
}
inline const std::string& GraphOpCreation::_internal_op_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.op_type_.Get();
}
inline void GraphOpCreation::_internal_set_op_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_type_.Set(value, GetArena());
}
inline std::string* GraphOpCreation::_internal_mutable_op_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.op_type_.Mutable( GetArena());
}
inline std::string* GraphOpCreation::release_op_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphOpCreation.op_type)
  return _impl_.op_type_.Release();
}
inline void GraphOpCreation::set_allocated_op_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.op_type_.IsDefault()) {
          _impl_.op_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphOpCreation.op_type)
}

// string op_name = 2;
inline void GraphOpCreation::clear_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.ClearToEmpty();
}
inline const std::string& GraphOpCreation::op_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.op_name)
  return _internal_op_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphOpCreation::set_op_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GraphOpCreation.op_name)
}
inline std::string* GraphOpCreation::mutable_op_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_op_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphOpCreation.op_name)
  return _s;
}
inline const std::string& GraphOpCreation::_internal_op_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.op_name_.Get();
}
inline void GraphOpCreation::_internal_set_op_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.Set(value, GetArena());
}
inline std::string* GraphOpCreation::_internal_mutable_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.op_name_.Mutable( GetArena());
}
inline std::string* GraphOpCreation::release_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphOpCreation.op_name)
  return _impl_.op_name_.Release();
}
inline void GraphOpCreation::set_allocated_op_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.op_name_.IsDefault()) {
          _impl_.op_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphOpCreation.op_name)
}

// string graph_name = 3;
inline void GraphOpCreation::clear_graph_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_name_.ClearToEmpty();
}
inline const std::string& GraphOpCreation::graph_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.graph_name)
  return _internal_graph_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphOpCreation::set_graph_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GraphOpCreation.graph_name)
}
inline std::string* GraphOpCreation::mutable_graph_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_graph_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphOpCreation.graph_name)
  return _s;
}
inline const std::string& GraphOpCreation::_internal_graph_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.graph_name_.Get();
}
inline void GraphOpCreation::_internal_set_graph_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_name_.Set(value, GetArena());
}
inline std::string* GraphOpCreation::_internal_mutable_graph_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.graph_name_.Mutable( GetArena());
}
inline std::string* GraphOpCreation::release_graph_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphOpCreation.graph_name)
  return _impl_.graph_name_.Release();
}
inline void GraphOpCreation::set_allocated_graph_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.graph_name_.IsDefault()) {
          _impl_.graph_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphOpCreation.graph_name)
}

// string graph_id = 4;
inline void GraphOpCreation::clear_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.ClearToEmpty();
}
inline const std::string& GraphOpCreation::graph_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.graph_id)
  return _internal_graph_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphOpCreation::set_graph_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GraphOpCreation.graph_id)
}
inline std::string* GraphOpCreation::mutable_graph_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_graph_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphOpCreation.graph_id)
  return _s;
}
inline const std::string& GraphOpCreation::_internal_graph_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.graph_id_.Get();
}
inline void GraphOpCreation::_internal_set_graph_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.Set(value, GetArena());
}
inline std::string* GraphOpCreation::_internal_mutable_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.graph_id_.Mutable( GetArena());
}
inline std::string* GraphOpCreation::release_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphOpCreation.graph_id)
  return _impl_.graph_id_.Release();
}
inline void GraphOpCreation::set_allocated_graph_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.graph_id_.IsDefault()) {
          _impl_.graph_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphOpCreation.graph_id)
}

// string device_name = 5;
inline void GraphOpCreation::clear_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.ClearToEmpty();
}
inline const std::string& GraphOpCreation::device_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.device_name)
  return _internal_device_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphOpCreation::set_device_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GraphOpCreation.device_name)
}
inline std::string* GraphOpCreation::mutable_device_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphOpCreation.device_name)
  return _s;
}
inline const std::string& GraphOpCreation::_internal_device_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_name_.Get();
}
inline void GraphOpCreation::_internal_set_device_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Set(value, GetArena());
}
inline std::string* GraphOpCreation::_internal_mutable_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_name_.Mutable( GetArena());
}
inline std::string* GraphOpCreation::release_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphOpCreation.device_name)
  return _impl_.device_name_.Release();
}
inline void GraphOpCreation::set_allocated_device_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_name_.IsDefault()) {
          _impl_.device_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphOpCreation.device_name)
}

// repeated string input_names = 6;
inline int GraphOpCreation::_internal_input_names_size() const {
  return _internal_input_names().size();
}
inline int GraphOpCreation::input_names_size() const {
  return _internal_input_names_size();
}
inline void GraphOpCreation::clear_input_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_names_.Clear();
}
inline std::string* GraphOpCreation::add_input_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_input_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.GraphOpCreation.input_names)
  return _s;
}
inline const std::string& GraphOpCreation::input_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.input_names)
  return _internal_input_names().Get(index);
}
inline std::string* GraphOpCreation::mutable_input_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphOpCreation.input_names)
  return _internal_mutable_input_names()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GraphOpCreation::set_input_names(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_input_names()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.GraphOpCreation.input_names)
}
template <typename Arg_, typename... Args_>
inline void GraphOpCreation::add_input_names(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_input_names(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.GraphOpCreation.input_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GraphOpCreation::input_names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GraphOpCreation.input_names)
  return _internal_input_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GraphOpCreation::mutable_input_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GraphOpCreation.input_names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_input_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GraphOpCreation::_internal_input_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GraphOpCreation::_internal_mutable_input_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.input_names_;
}

// int32 num_outputs = 7;
inline void GraphOpCreation::clear_num_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_outputs_ = 0;
}
inline ::int32_t GraphOpCreation::num_outputs() const {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.num_outputs)
  return _internal_num_outputs();
}
inline void GraphOpCreation::set_num_outputs(::int32_t value) {
  _internal_set_num_outputs(value);
  // @@protoc_insertion_point(field_set:tensorflow.GraphOpCreation.num_outputs)
}
inline ::int32_t GraphOpCreation::_internal_num_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_outputs_;
}
inline void GraphOpCreation::_internal_set_num_outputs(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_outputs_ = value;
}

// .tensorflow.CodeLocation code_location = 8;
inline bool GraphOpCreation::has_code_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.code_location_ != nullptr);
  return value;
}
inline void GraphOpCreation::clear_code_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.code_location_ != nullptr) _impl_.code_location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CodeLocation& GraphOpCreation::_internal_code_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CodeLocation* p = _impl_.code_location_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CodeLocation&>(::tensorflow::_CodeLocation_default_instance_);
}
inline const ::tensorflow::CodeLocation& GraphOpCreation::code_location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.code_location)
  return _internal_code_location();
}
inline void GraphOpCreation::unsafe_arena_set_allocated_code_location(::tensorflow::CodeLocation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.code_location_);
  }
  _impl_.code_location_ = reinterpret_cast<::tensorflow::CodeLocation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.GraphOpCreation.code_location)
}
inline ::tensorflow::CodeLocation* GraphOpCreation::release_code_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CodeLocation* released = _impl_.code_location_;
  _impl_.code_location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CodeLocation* GraphOpCreation::unsafe_arena_release_code_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphOpCreation.code_location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CodeLocation* temp = _impl_.code_location_;
  _impl_.code_location_ = nullptr;
  return temp;
}
inline ::tensorflow::CodeLocation* GraphOpCreation::_internal_mutable_code_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.code_location_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CodeLocation>(GetArena());
    _impl_.code_location_ = reinterpret_cast<::tensorflow::CodeLocation*>(p);
  }
  return _impl_.code_location_;
}
inline ::tensorflow::CodeLocation* GraphOpCreation::mutable_code_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CodeLocation* _msg = _internal_mutable_code_location();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphOpCreation.code_location)
  return _msg;
}
inline void GraphOpCreation::set_allocated_code_location(::tensorflow::CodeLocation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.code_location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.code_location_ = reinterpret_cast<::tensorflow::CodeLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphOpCreation.code_location)
}

// repeated int32 output_tensor_ids = 9;
inline int GraphOpCreation::_internal_output_tensor_ids_size() const {
  return _internal_output_tensor_ids().size();
}
inline int GraphOpCreation::output_tensor_ids_size() const {
  return _internal_output_tensor_ids_size();
}
inline void GraphOpCreation::clear_output_tensor_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_tensor_ids_.Clear();
}
inline ::int32_t GraphOpCreation::output_tensor_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.GraphOpCreation.output_tensor_ids)
  return _internal_output_tensor_ids().Get(index);
}
inline void GraphOpCreation::set_output_tensor_ids(int index, ::int32_t value) {
  _internal_mutable_output_tensor_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.GraphOpCreation.output_tensor_ids)
}
inline void GraphOpCreation::add_output_tensor_ids(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_tensor_ids()->Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.GraphOpCreation.output_tensor_ids)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& GraphOpCreation::output_tensor_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.GraphOpCreation.output_tensor_ids)
  return _internal_output_tensor_ids();
}
inline ::google::protobuf::RepeatedField<::int32_t>* GraphOpCreation::mutable_output_tensor_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GraphOpCreation.output_tensor_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_output_tensor_ids();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
GraphOpCreation::_internal_output_tensor_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_tensor_ids_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* GraphOpCreation::_internal_mutable_output_tensor_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.output_tensor_ids_;
}

// -------------------------------------------------------------------

// DebuggedGraph

// string graph_id = 1;
inline void DebuggedGraph::clear_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.ClearToEmpty();
}
inline const std::string& DebuggedGraph::graph_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebuggedGraph.graph_id)
  return _internal_graph_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebuggedGraph::set_graph_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebuggedGraph.graph_id)
}
inline std::string* DebuggedGraph::mutable_graph_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_graph_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebuggedGraph.graph_id)
  return _s;
}
inline const std::string& DebuggedGraph::_internal_graph_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.graph_id_.Get();
}
inline void DebuggedGraph::_internal_set_graph_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.Set(value, GetArena());
}
inline std::string* DebuggedGraph::_internal_mutable_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.graph_id_.Mutable( GetArena());
}
inline std::string* DebuggedGraph::release_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebuggedGraph.graph_id)
  return _impl_.graph_id_.Release();
}
inline void DebuggedGraph::set_allocated_graph_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.graph_id_.IsDefault()) {
          _impl_.graph_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebuggedGraph.graph_id)
}

// string graph_name = 2;
inline void DebuggedGraph::clear_graph_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_name_.ClearToEmpty();
}
inline const std::string& DebuggedGraph::graph_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebuggedGraph.graph_name)
  return _internal_graph_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebuggedGraph::set_graph_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebuggedGraph.graph_name)
}
inline std::string* DebuggedGraph::mutable_graph_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_graph_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebuggedGraph.graph_name)
  return _s;
}
inline const std::string& DebuggedGraph::_internal_graph_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.graph_name_.Get();
}
inline void DebuggedGraph::_internal_set_graph_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_name_.Set(value, GetArena());
}
inline std::string* DebuggedGraph::_internal_mutable_graph_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.graph_name_.Mutable( GetArena());
}
inline std::string* DebuggedGraph::release_graph_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebuggedGraph.graph_name)
  return _impl_.graph_name_.Release();
}
inline void DebuggedGraph::set_allocated_graph_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.graph_name_.IsDefault()) {
          _impl_.graph_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebuggedGraph.graph_name)
}

// repeated string instrumented_ops = 3;
inline int DebuggedGraph::_internal_instrumented_ops_size() const {
  return _internal_instrumented_ops().size();
}
inline int DebuggedGraph::instrumented_ops_size() const {
  return _internal_instrumented_ops_size();
}
inline void DebuggedGraph::clear_instrumented_ops() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumented_ops_.Clear();
}
inline std::string* DebuggedGraph::add_instrumented_ops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_instrumented_ops()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.DebuggedGraph.instrumented_ops)
  return _s;
}
inline const std::string& DebuggedGraph::instrumented_ops(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebuggedGraph.instrumented_ops)
  return _internal_instrumented_ops().Get(index);
}
inline std::string* DebuggedGraph::mutable_instrumented_ops(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.DebuggedGraph.instrumented_ops)
  return _internal_mutable_instrumented_ops()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void DebuggedGraph::set_instrumented_ops(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_instrumented_ops()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.DebuggedGraph.instrumented_ops)
}
template <typename Arg_, typename... Args_>
inline void DebuggedGraph::add_instrumented_ops(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_instrumented_ops(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.DebuggedGraph.instrumented_ops)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DebuggedGraph::instrumented_ops() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.DebuggedGraph.instrumented_ops)
  return _internal_instrumented_ops();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DebuggedGraph::mutable_instrumented_ops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.DebuggedGraph.instrumented_ops)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_instrumented_ops();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DebuggedGraph::_internal_instrumented_ops() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.instrumented_ops_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DebuggedGraph::_internal_mutable_instrumented_ops() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.instrumented_ops_;
}

// bytes original_graph_def = 4;
inline void DebuggedGraph::clear_original_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.original_graph_def_.ClearToEmpty();
}
inline const std::string& DebuggedGraph::original_graph_def() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebuggedGraph.original_graph_def)
  return _internal_original_graph_def();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebuggedGraph::set_original_graph_def(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.original_graph_def_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebuggedGraph.original_graph_def)
}
inline std::string* DebuggedGraph::mutable_original_graph_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_graph_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebuggedGraph.original_graph_def)
  return _s;
}
inline const std::string& DebuggedGraph::_internal_original_graph_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.original_graph_def_.Get();
}
inline void DebuggedGraph::_internal_set_original_graph_def(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.original_graph_def_.Set(value, GetArena());
}
inline std::string* DebuggedGraph::_internal_mutable_original_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.original_graph_def_.Mutable( GetArena());
}
inline std::string* DebuggedGraph::release_original_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebuggedGraph.original_graph_def)
  return _impl_.original_graph_def_.Release();
}
inline void DebuggedGraph::set_allocated_original_graph_def(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.original_graph_def_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_graph_def_.IsDefault()) {
          _impl_.original_graph_def_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebuggedGraph.original_graph_def)
}

// bytes instrumented_graph_def = 5;
inline void DebuggedGraph::clear_instrumented_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumented_graph_def_.ClearToEmpty();
}
inline const std::string& DebuggedGraph::instrumented_graph_def() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebuggedGraph.instrumented_graph_def)
  return _internal_instrumented_graph_def();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebuggedGraph::set_instrumented_graph_def(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumented_graph_def_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebuggedGraph.instrumented_graph_def)
}
inline std::string* DebuggedGraph::mutable_instrumented_graph_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_instrumented_graph_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebuggedGraph.instrumented_graph_def)
  return _s;
}
inline const std::string& DebuggedGraph::_internal_instrumented_graph_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.instrumented_graph_def_.Get();
}
inline void DebuggedGraph::_internal_set_instrumented_graph_def(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumented_graph_def_.Set(value, GetArena());
}
inline std::string* DebuggedGraph::_internal_mutable_instrumented_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.instrumented_graph_def_.Mutable( GetArena());
}
inline std::string* DebuggedGraph::release_instrumented_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebuggedGraph.instrumented_graph_def)
  return _impl_.instrumented_graph_def_.Release();
}
inline void DebuggedGraph::set_allocated_instrumented_graph_def(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instrumented_graph_def_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.instrumented_graph_def_.IsDefault()) {
          _impl_.instrumented_graph_def_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebuggedGraph.instrumented_graph_def)
}

// string outer_context_id = 6;
inline void DebuggedGraph::clear_outer_context_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outer_context_id_.ClearToEmpty();
}
inline const std::string& DebuggedGraph::outer_context_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebuggedGraph.outer_context_id)
  return _internal_outer_context_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebuggedGraph::set_outer_context_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outer_context_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebuggedGraph.outer_context_id)
}
inline std::string* DebuggedGraph::mutable_outer_context_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_outer_context_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebuggedGraph.outer_context_id)
  return _s;
}
inline const std::string& DebuggedGraph::_internal_outer_context_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outer_context_id_.Get();
}
inline void DebuggedGraph::_internal_set_outer_context_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outer_context_id_.Set(value, GetArena());
}
inline std::string* DebuggedGraph::_internal_mutable_outer_context_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.outer_context_id_.Mutable( GetArena());
}
inline std::string* DebuggedGraph::release_outer_context_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebuggedGraph.outer_context_id)
  return _impl_.outer_context_id_.Release();
}
inline void DebuggedGraph::set_allocated_outer_context_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outer_context_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.outer_context_id_.IsDefault()) {
          _impl_.outer_context_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebuggedGraph.outer_context_id)
}

// -------------------------------------------------------------------

// DebuggedDevice

// string device_name = 1;
inline void DebuggedDevice::clear_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.ClearToEmpty();
}
inline const std::string& DebuggedDevice::device_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.DebuggedDevice.device_name)
  return _internal_device_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebuggedDevice::set_device_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.DebuggedDevice.device_name)
}
inline std::string* DebuggedDevice::mutable_device_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.DebuggedDevice.device_name)
  return _s;
}
inline const std::string& DebuggedDevice::_internal_device_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_name_.Get();
}
inline void DebuggedDevice::_internal_set_device_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Set(value, GetArena());
}
inline std::string* DebuggedDevice::_internal_mutable_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_name_.Mutable( GetArena());
}
inline std::string* DebuggedDevice::release_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.DebuggedDevice.device_name)
  return _impl_.device_name_.Release();
}
inline void DebuggedDevice::set_allocated_device_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_name_.IsDefault()) {
          _impl_.device_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DebuggedDevice.device_name)
}

// int32 device_id = 2;
inline void DebuggedDevice::clear_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_ = 0;
}
inline ::int32_t DebuggedDevice::device_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.DebuggedDevice.device_id)
  return _internal_device_id();
}
inline void DebuggedDevice::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.DebuggedDevice.device_id)
}
inline ::int32_t DebuggedDevice::_internal_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_;
}
inline void DebuggedDevice::_internal_set_device_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_ = value;
}

// -------------------------------------------------------------------

// Execution

// string op_type = 1;
inline void Execution::clear_op_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_type_.ClearToEmpty();
}
inline const std::string& Execution::op_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.op_type)
  return _internal_op_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Execution::set_op_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.Execution.op_type)
}
inline std::string* Execution::mutable_op_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_op_type();
  // @@protoc_insertion_point(field_mutable:tensorflow.Execution.op_type)
  return _s;
}
inline const std::string& Execution::_internal_op_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.op_type_.Get();
}
inline void Execution::_internal_set_op_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_type_.Set(value, GetArena());
}
inline std::string* Execution::_internal_mutable_op_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.op_type_.Mutable( GetArena());
}
inline std::string* Execution::release_op_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.Execution.op_type)
  return _impl_.op_type_.Release();
}
inline void Execution::set_allocated_op_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.op_type_.IsDefault()) {
          _impl_.op_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Execution.op_type)
}

// int32 num_outputs = 2;
inline void Execution::clear_num_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_outputs_ = 0;
}
inline ::int32_t Execution::num_outputs() const {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.num_outputs)
  return _internal_num_outputs();
}
inline void Execution::set_num_outputs(::int32_t value) {
  _internal_set_num_outputs(value);
  // @@protoc_insertion_point(field_set:tensorflow.Execution.num_outputs)
}
inline ::int32_t Execution::_internal_num_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_outputs_;
}
inline void Execution::_internal_set_num_outputs(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_outputs_ = value;
}

// string graph_id = 3;
inline void Execution::clear_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.ClearToEmpty();
}
inline const std::string& Execution::graph_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.graph_id)
  return _internal_graph_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Execution::set_graph_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.Execution.graph_id)
}
inline std::string* Execution::mutable_graph_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_graph_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.Execution.graph_id)
  return _s;
}
inline const std::string& Execution::_internal_graph_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.graph_id_.Get();
}
inline void Execution::_internal_set_graph_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.Set(value, GetArena());
}
inline std::string* Execution::_internal_mutable_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.graph_id_.Mutable( GetArena());
}
inline std::string* Execution::release_graph_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.Execution.graph_id)
  return _impl_.graph_id_.Release();
}
inline void Execution::set_allocated_graph_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.graph_id_.IsDefault()) {
          _impl_.graph_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Execution.graph_id)
}

// repeated int64 input_tensor_ids = 4;
inline int Execution::_internal_input_tensor_ids_size() const {
  return _internal_input_tensor_ids().size();
}
inline int Execution::input_tensor_ids_size() const {
  return _internal_input_tensor_ids_size();
}
inline void Execution::clear_input_tensor_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_tensor_ids_.Clear();
}
inline ::int64_t Execution::input_tensor_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.input_tensor_ids)
  return _internal_input_tensor_ids().Get(index);
}
inline void Execution::set_input_tensor_ids(int index, ::int64_t value) {
  _internal_mutable_input_tensor_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.Execution.input_tensor_ids)
}
inline void Execution::add_input_tensor_ids(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_input_tensor_ids()->Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.Execution.input_tensor_ids)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Execution::input_tensor_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.Execution.input_tensor_ids)
  return _internal_input_tensor_ids();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Execution::mutable_input_tensor_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.Execution.input_tensor_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_input_tensor_ids();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
Execution::_internal_input_tensor_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_tensor_ids_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Execution::_internal_mutable_input_tensor_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.input_tensor_ids_;
}

// repeated int64 output_tensor_ids = 5;
inline int Execution::_internal_output_tensor_ids_size() const {
  return _internal_output_tensor_ids().size();
}
inline int Execution::output_tensor_ids_size() const {
  return _internal_output_tensor_ids_size();
}
inline void Execution::clear_output_tensor_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_tensor_ids_.Clear();
}
inline ::int64_t Execution::output_tensor_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.output_tensor_ids)
  return _internal_output_tensor_ids().Get(index);
}
inline void Execution::set_output_tensor_ids(int index, ::int64_t value) {
  _internal_mutable_output_tensor_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.Execution.output_tensor_ids)
}
inline void Execution::add_output_tensor_ids(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_tensor_ids()->Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.Execution.output_tensor_ids)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Execution::output_tensor_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.Execution.output_tensor_ids)
  return _internal_output_tensor_ids();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Execution::mutable_output_tensor_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.Execution.output_tensor_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_output_tensor_ids();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
Execution::_internal_output_tensor_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_tensor_ids_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Execution::_internal_mutable_output_tensor_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.output_tensor_ids_;
}

// .tensorflow.TensorDebugMode tensor_debug_mode = 6;
inline void Execution::clear_tensor_debug_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensor_debug_mode_ = 0;
}
inline ::tensorflow::TensorDebugMode Execution::tensor_debug_mode() const {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.tensor_debug_mode)
  return _internal_tensor_debug_mode();
}
inline void Execution::set_tensor_debug_mode(::tensorflow::TensorDebugMode value) {
  _internal_set_tensor_debug_mode(value);
  // @@protoc_insertion_point(field_set:tensorflow.Execution.tensor_debug_mode)
}
inline ::tensorflow::TensorDebugMode Execution::_internal_tensor_debug_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::TensorDebugMode>(_impl_.tensor_debug_mode_);
}
inline void Execution::_internal_set_tensor_debug_mode(::tensorflow::TensorDebugMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensor_debug_mode_ = value;
}

// repeated .tensorflow.TensorProto tensor_protos = 7;
inline int Execution::_internal_tensor_protos_size() const {
  return _internal_tensor_protos().size();
}
inline int Execution::tensor_protos_size() const {
  return _internal_tensor_protos_size();
}
inline ::tensorflow::TensorProto* Execution::mutable_tensor_protos(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.Execution.tensor_protos)
  return _internal_mutable_tensor_protos()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* Execution::mutable_tensor_protos()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.Execution.tensor_protos)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tensor_protos();
}
inline const ::tensorflow::TensorProto& Execution::tensor_protos(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.tensor_protos)
  return _internal_tensor_protos().Get(index);
}
inline ::tensorflow::TensorProto* Execution::add_tensor_protos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::TensorProto* _add = _internal_mutable_tensor_protos()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.Execution.tensor_protos)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& Execution::tensor_protos() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.Execution.tensor_protos)
  return _internal_tensor_protos();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>&
Execution::_internal_tensor_protos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tensor_protos_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>*
Execution::_internal_mutable_tensor_protos() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tensor_protos_;
}

// .tensorflow.CodeLocation code_location = 8;
inline bool Execution::has_code_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.code_location_ != nullptr);
  return value;
}
inline void Execution::clear_code_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.code_location_ != nullptr) _impl_.code_location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::CodeLocation& Execution::_internal_code_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CodeLocation* p = _impl_.code_location_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CodeLocation&>(::tensorflow::_CodeLocation_default_instance_);
}
inline const ::tensorflow::CodeLocation& Execution::code_location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.code_location)
  return _internal_code_location();
}
inline void Execution::unsafe_arena_set_allocated_code_location(::tensorflow::CodeLocation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.code_location_);
  }
  _impl_.code_location_ = reinterpret_cast<::tensorflow::CodeLocation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Execution.code_location)
}
inline ::tensorflow::CodeLocation* Execution::release_code_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CodeLocation* released = _impl_.code_location_;
  _impl_.code_location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CodeLocation* Execution::unsafe_arena_release_code_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.Execution.code_location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CodeLocation* temp = _impl_.code_location_;
  _impl_.code_location_ = nullptr;
  return temp;
}
inline ::tensorflow::CodeLocation* Execution::_internal_mutable_code_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.code_location_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CodeLocation>(GetArena());
    _impl_.code_location_ = reinterpret_cast<::tensorflow::CodeLocation*>(p);
  }
  return _impl_.code_location_;
}
inline ::tensorflow::CodeLocation* Execution::mutable_code_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CodeLocation* _msg = _internal_mutable_code_location();
  // @@protoc_insertion_point(field_mutable:tensorflow.Execution.code_location)
  return _msg;
}
inline void Execution::set_allocated_code_location(::tensorflow::CodeLocation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.code_location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.code_location_ = reinterpret_cast<::tensorflow::CodeLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Execution.code_location)
}

// repeated int32 output_tensor_device_ids = 9;
inline int Execution::_internal_output_tensor_device_ids_size() const {
  return _internal_output_tensor_device_ids().size();
}
inline int Execution::output_tensor_device_ids_size() const {
  return _internal_output_tensor_device_ids_size();
}
inline void Execution::clear_output_tensor_device_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_tensor_device_ids_.Clear();
}
inline ::int32_t Execution::output_tensor_device_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.Execution.output_tensor_device_ids)
  return _internal_output_tensor_device_ids().Get(index);
}
inline void Execution::set_output_tensor_device_ids(int index, ::int32_t value) {
  _internal_mutable_output_tensor_device_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.Execution.output_tensor_device_ids)
}
inline void Execution::add_output_tensor_device_ids(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_tensor_device_ids()->Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.Execution.output_tensor_device_ids)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Execution::output_tensor_device_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.Execution.output_tensor_device_ids)
  return _internal_output_tensor_device_ids();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Execution::mutable_output_tensor_device_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.Execution.output_tensor_device_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_output_tensor_device_ids();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Execution::_internal_output_tensor_device_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_tensor_device_ids_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Execution::_internal_mutable_output_tensor_device_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.output_tensor_device_ids_;
}

// -------------------------------------------------------------------

// GraphExecutionTrace

// string tfdbg_context_id = 1;
inline void GraphExecutionTrace::clear_tfdbg_context_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tfdbg_context_id_.ClearToEmpty();
}
inline const std::string& GraphExecutionTrace::tfdbg_context_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphExecutionTrace.tfdbg_context_id)
  return _internal_tfdbg_context_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphExecutionTrace::set_tfdbg_context_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tfdbg_context_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GraphExecutionTrace.tfdbg_context_id)
}
inline std::string* GraphExecutionTrace::mutable_tfdbg_context_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tfdbg_context_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphExecutionTrace.tfdbg_context_id)
  return _s;
}
inline const std::string& GraphExecutionTrace::_internal_tfdbg_context_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tfdbg_context_id_.Get();
}
inline void GraphExecutionTrace::_internal_set_tfdbg_context_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tfdbg_context_id_.Set(value, GetArena());
}
inline std::string* GraphExecutionTrace::_internal_mutable_tfdbg_context_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tfdbg_context_id_.Mutable( GetArena());
}
inline std::string* GraphExecutionTrace::release_tfdbg_context_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphExecutionTrace.tfdbg_context_id)
  return _impl_.tfdbg_context_id_.Release();
}
inline void GraphExecutionTrace::set_allocated_tfdbg_context_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tfdbg_context_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tfdbg_context_id_.IsDefault()) {
          _impl_.tfdbg_context_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphExecutionTrace.tfdbg_context_id)
}

// string op_name = 2;
inline void GraphExecutionTrace::clear_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.ClearToEmpty();
}
inline const std::string& GraphExecutionTrace::op_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphExecutionTrace.op_name)
  return _internal_op_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphExecutionTrace::set_op_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GraphExecutionTrace.op_name)
}
inline std::string* GraphExecutionTrace::mutable_op_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_op_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphExecutionTrace.op_name)
  return _s;
}
inline const std::string& GraphExecutionTrace::_internal_op_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.op_name_.Get();
}
inline void GraphExecutionTrace::_internal_set_op_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.Set(value, GetArena());
}
inline std::string* GraphExecutionTrace::_internal_mutable_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.op_name_.Mutable( GetArena());
}
inline std::string* GraphExecutionTrace::release_op_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphExecutionTrace.op_name)
  return _impl_.op_name_.Release();
}
inline void GraphExecutionTrace::set_allocated_op_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.op_name_.IsDefault()) {
          _impl_.op_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphExecutionTrace.op_name)
}

// int32 output_slot = 3;
inline void GraphExecutionTrace::clear_output_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_slot_ = 0;
}
inline ::int32_t GraphExecutionTrace::output_slot() const {
  // @@protoc_insertion_point(field_get:tensorflow.GraphExecutionTrace.output_slot)
  return _internal_output_slot();
}
inline void GraphExecutionTrace::set_output_slot(::int32_t value) {
  _internal_set_output_slot(value);
  // @@protoc_insertion_point(field_set:tensorflow.GraphExecutionTrace.output_slot)
}
inline ::int32_t GraphExecutionTrace::_internal_output_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_slot_;
}
inline void GraphExecutionTrace::_internal_set_output_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_slot_ = value;
}

// .tensorflow.TensorDebugMode tensor_debug_mode = 4;
inline void GraphExecutionTrace::clear_tensor_debug_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensor_debug_mode_ = 0;
}
inline ::tensorflow::TensorDebugMode GraphExecutionTrace::tensor_debug_mode() const {
  // @@protoc_insertion_point(field_get:tensorflow.GraphExecutionTrace.tensor_debug_mode)
  return _internal_tensor_debug_mode();
}
inline void GraphExecutionTrace::set_tensor_debug_mode(::tensorflow::TensorDebugMode value) {
  _internal_set_tensor_debug_mode(value);
  // @@protoc_insertion_point(field_set:tensorflow.GraphExecutionTrace.tensor_debug_mode)
}
inline ::tensorflow::TensorDebugMode GraphExecutionTrace::_internal_tensor_debug_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::TensorDebugMode>(_impl_.tensor_debug_mode_);
}
inline void GraphExecutionTrace::_internal_set_tensor_debug_mode(::tensorflow::TensorDebugMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensor_debug_mode_ = value;
}

// .tensorflow.TensorProto tensor_proto = 5;
inline bool GraphExecutionTrace::has_tensor_proto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tensor_proto_ != nullptr);
  return value;
}
inline const ::tensorflow::TensorProto& GraphExecutionTrace::_internal_tensor_proto() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TensorProto* p = _impl_.tensor_proto_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TensorProto&>(::tensorflow::_TensorProto_default_instance_);
}
inline const ::tensorflow::TensorProto& GraphExecutionTrace::tensor_proto() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphExecutionTrace.tensor_proto)
  return _internal_tensor_proto();
}
inline void GraphExecutionTrace::unsafe_arena_set_allocated_tensor_proto(::tensorflow::TensorProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tensor_proto_);
  }
  _impl_.tensor_proto_ = reinterpret_cast<::tensorflow::TensorProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.GraphExecutionTrace.tensor_proto)
}
inline ::tensorflow::TensorProto* GraphExecutionTrace::release_tensor_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorProto* released = _impl_.tensor_proto_;
  _impl_.tensor_proto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TensorProto* GraphExecutionTrace::unsafe_arena_release_tensor_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphExecutionTrace.tensor_proto)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorProto* temp = _impl_.tensor_proto_;
  _impl_.tensor_proto_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorProto* GraphExecutionTrace::_internal_mutable_tensor_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tensor_proto_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorProto>(GetArena());
    _impl_.tensor_proto_ = reinterpret_cast<::tensorflow::TensorProto*>(p);
  }
  return _impl_.tensor_proto_;
}
inline ::tensorflow::TensorProto* GraphExecutionTrace::mutable_tensor_proto() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::TensorProto* _msg = _internal_mutable_tensor_proto();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphExecutionTrace.tensor_proto)
  return _msg;
}
inline void GraphExecutionTrace::set_allocated_tensor_proto(::tensorflow::TensorProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tensor_proto_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tensor_proto_ = reinterpret_cast<::tensorflow::TensorProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphExecutionTrace.tensor_proto)
}

// string device_name = 6;
inline void GraphExecutionTrace::clear_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.ClearToEmpty();
}
inline const std::string& GraphExecutionTrace::device_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GraphExecutionTrace.device_name)
  return _internal_device_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphExecutionTrace::set_device_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GraphExecutionTrace.device_name)
}
inline std::string* GraphExecutionTrace::mutable_device_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphExecutionTrace.device_name)
  return _s;
}
inline const std::string& GraphExecutionTrace::_internal_device_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_name_.Get();
}
inline void GraphExecutionTrace::_internal_set_device_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Set(value, GetArena());
}
inline std::string* GraphExecutionTrace::_internal_mutable_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_name_.Mutable( GetArena());
}
inline std::string* GraphExecutionTrace::release_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GraphExecutionTrace.device_name)
  return _impl_.device_name_.Release();
}
inline void GraphExecutionTrace::set_allocated_device_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_name_.IsDefault()) {
          _impl_.device_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphExecutionTrace.device_name)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tensorflow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tensorflow::TensorDebugMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::TensorDebugMode>() {
  return ::tensorflow::TensorDebugMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fdebug_5fevent_2eproto_2epb_2eh
