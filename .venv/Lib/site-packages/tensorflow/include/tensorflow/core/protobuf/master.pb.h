// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: tensorflow/core/protobuf/master.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "tensorflow/core/framework/device_attributes.pb.h"
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/framework/tensor.pb.h"
#include "tensorflow/core/protobuf/config.pb.h"
#include "tensorflow/core/protobuf/error_codes.pb.h"
#include "tensorflow/core/protobuf/named_tensor.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
namespace tensorflow {
class CloseSessionRequest;
struct CloseSessionRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern CloseSessionRequestDefaultTypeInternal _CloseSessionRequest_default_instance_;
class CloseSessionResponse;
struct CloseSessionResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern CloseSessionResponseDefaultTypeInternal _CloseSessionResponse_default_instance_;
class CreateSessionRequest;
struct CreateSessionRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern CreateSessionRequestDefaultTypeInternal _CreateSessionRequest_default_instance_;
class CreateSessionResponse;
struct CreateSessionResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern CreateSessionResponseDefaultTypeInternal _CreateSessionResponse_default_instance_;
class ExtendSessionRequest;
struct ExtendSessionRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern ExtendSessionRequestDefaultTypeInternal _ExtendSessionRequest_default_instance_;
class ExtendSessionResponse;
struct ExtendSessionResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern ExtendSessionResponseDefaultTypeInternal _ExtendSessionResponse_default_instance_;
class ListDevicesRequest;
struct ListDevicesRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern ListDevicesRequestDefaultTypeInternal _ListDevicesRequest_default_instance_;
class ListDevicesResponse;
struct ListDevicesResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern ListDevicesResponseDefaultTypeInternal _ListDevicesResponse_default_instance_;
class MakeCallableRequest;
struct MakeCallableRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern MakeCallableRequestDefaultTypeInternal _MakeCallableRequest_default_instance_;
class MakeCallableResponse;
struct MakeCallableResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern MakeCallableResponseDefaultTypeInternal _MakeCallableResponse_default_instance_;
class PartialRunSetupRequest;
struct PartialRunSetupRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern PartialRunSetupRequestDefaultTypeInternal _PartialRunSetupRequest_default_instance_;
class PartialRunSetupResponse;
struct PartialRunSetupResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern PartialRunSetupResponseDefaultTypeInternal _PartialRunSetupResponse_default_instance_;
class ReleaseCallableRequest;
struct ReleaseCallableRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern ReleaseCallableRequestDefaultTypeInternal _ReleaseCallableRequest_default_instance_;
class ReleaseCallableResponse;
struct ReleaseCallableResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern ReleaseCallableResponseDefaultTypeInternal _ReleaseCallableResponse_default_instance_;
class ResetRequest;
struct ResetRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern ResetRequestDefaultTypeInternal _ResetRequest_default_instance_;
class ResetResponse;
struct ResetResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern ResetResponseDefaultTypeInternal _ResetResponse_default_instance_;
class RunCallableRequest;
struct RunCallableRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern RunCallableRequestDefaultTypeInternal _RunCallableRequest_default_instance_;
class RunCallableResponse;
struct RunCallableResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern RunCallableResponseDefaultTypeInternal _RunCallableResponse_default_instance_;
class RunStepRequest;
struct RunStepRequestDefaultTypeInternal;
PROTOBUF_EXPORT extern RunStepRequestDefaultTypeInternal _RunStepRequest_default_instance_;
class RunStepResponse;
struct RunStepResponseDefaultTypeInternal;
PROTOBUF_EXPORT extern RunStepResponseDefaultTypeInternal _RunStepResponse_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT ResetResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.ResetResponse) */ {
 public:
  inline ResetResponse() : ResetResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResetResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResetResponse(const ResetResponse& from) : ResetResponse(nullptr, from) {}
  inline ResetResponse(ResetResponse&& from) noexcept
      : ResetResponse(nullptr, std::move(from)) {}
  inline ResetResponse& operator=(const ResetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetResponse& operator=(ResetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetResponse* internal_default_instance() {
    return reinterpret_cast<const ResetResponse*>(
        &_ResetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ResetResponse& a, ResetResponse& b) { a.Swap(&b); }
  inline void Swap(ResetResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ResetResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ResetResponse"; }

 protected:
  explicit ResetResponse(::google::protobuf::Arena* arena);
  ResetResponse(::google::protobuf::Arena* arena, const ResetResponse& from);
  ResetResponse(::google::protobuf::Arena* arena, ResetResponse&& from) noexcept
      : ResetResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.ResetResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResetResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ResetRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ResetRequest) */ {
 public:
  inline ResetRequest() : ResetRequest(nullptr) {}
  ~ResetRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResetRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResetRequest(const ResetRequest& from) : ResetRequest(nullptr, from) {}
  inline ResetRequest(ResetRequest&& from) noexcept
      : ResetRequest(nullptr, std::move(from)) {}
  inline ResetRequest& operator=(const ResetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetRequest& operator=(ResetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetRequest* internal_default_instance() {
    return reinterpret_cast<const ResetRequest*>(
        &_ResetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ResetRequest& a, ResetRequest& b) { a.Swap(&b); }
  inline void Swap(ResetRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ResetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResetRequest& from) { ResetRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResetRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ResetRequest"; }

 protected:
  explicit ResetRequest(::google::protobuf::Arena* arena);
  ResetRequest(::google::protobuf::Arena* arena, const ResetRequest& from);
  ResetRequest(::google::protobuf::Arena* arena, ResetRequest&& from) noexcept
      : ResetRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContainerFieldNumber = 1,
    kDeviceFiltersFieldNumber = 2,
  };
  // repeated string container = 1;
  int container_size() const;
  private:
  int _internal_container_size() const;

  public:
  void clear_container() ;
  const std::string& container(int index) const;
  std::string* mutable_container(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_container(int index, Arg_&& value, Args_... args);
  std::string* add_container();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_container(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& container() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_container();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_container() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_container();

  public:
  // repeated string device_filters = 2;
  int device_filters_size() const;
  private:
  int _internal_device_filters_size() const;

  public:
  void clear_device_filters() ;
  const std::string& device_filters(int index) const;
  std::string* mutable_device_filters(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_filters(int index, Arg_&& value, Args_... args);
  std::string* add_device_filters();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_device_filters(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& device_filters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_device_filters();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_device_filters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_device_filters();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ResetRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResetRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> container_;
    ::google::protobuf::RepeatedPtrField<std::string> device_filters_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ReleaseCallableResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.ReleaseCallableResponse) */ {
 public:
  inline ReleaseCallableResponse() : ReleaseCallableResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleaseCallableResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReleaseCallableResponse(const ReleaseCallableResponse& from) : ReleaseCallableResponse(nullptr, from) {}
  inline ReleaseCallableResponse(ReleaseCallableResponse&& from) noexcept
      : ReleaseCallableResponse(nullptr, std::move(from)) {}
  inline ReleaseCallableResponse& operator=(const ReleaseCallableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseCallableResponse& operator=(ReleaseCallableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseCallableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseCallableResponse* internal_default_instance() {
    return reinterpret_cast<const ReleaseCallableResponse*>(
        &_ReleaseCallableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ReleaseCallableResponse& a, ReleaseCallableResponse& b) { a.Swap(&b); }
  inline void Swap(ReleaseCallableResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseCallableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseCallableResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ReleaseCallableResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReleaseCallableResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReleaseCallableResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ReleaseCallableResponse"; }

 protected:
  explicit ReleaseCallableResponse(::google::protobuf::Arena* arena);
  ReleaseCallableResponse(::google::protobuf::Arena* arena, const ReleaseCallableResponse& from);
  ReleaseCallableResponse(::google::protobuf::Arena* arena, ReleaseCallableResponse&& from) noexcept
      : ReleaseCallableResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.ReleaseCallableResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReleaseCallableResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ReleaseCallableRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ReleaseCallableRequest) */ {
 public:
  inline ReleaseCallableRequest() : ReleaseCallableRequest(nullptr) {}
  ~ReleaseCallableRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleaseCallableRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReleaseCallableRequest(const ReleaseCallableRequest& from) : ReleaseCallableRequest(nullptr, from) {}
  inline ReleaseCallableRequest(ReleaseCallableRequest&& from) noexcept
      : ReleaseCallableRequest(nullptr, std::move(from)) {}
  inline ReleaseCallableRequest& operator=(const ReleaseCallableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseCallableRequest& operator=(ReleaseCallableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseCallableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseCallableRequest* internal_default_instance() {
    return reinterpret_cast<const ReleaseCallableRequest*>(
        &_ReleaseCallableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ReleaseCallableRequest& a, ReleaseCallableRequest& b) { a.Swap(&b); }
  inline void Swap(ReleaseCallableRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseCallableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseCallableRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ReleaseCallableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReleaseCallableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReleaseCallableRequest& from) { ReleaseCallableRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReleaseCallableRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ReleaseCallableRequest"; }

 protected:
  explicit ReleaseCallableRequest(::google::protobuf::Arena* arena);
  ReleaseCallableRequest(::google::protobuf::Arena* arena, const ReleaseCallableRequest& from);
  ReleaseCallableRequest(::google::protobuf::Arena* arena, ReleaseCallableRequest&& from) noexcept
      : ReleaseCallableRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionHandleFieldNumber = 1,
    kHandleFieldNumber = 2,
  };
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // int64 handle = 2;
  void clear_handle() ;
  ::int64_t handle() const;
  void set_handle(::int64_t value);

  private:
  ::int64_t _internal_handle() const;
  void _internal_set_handle(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ReleaseCallableRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReleaseCallableRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    ::int64_t handle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PartialRunSetupResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.PartialRunSetupResponse) */ {
 public:
  inline PartialRunSetupResponse() : PartialRunSetupResponse(nullptr) {}
  ~PartialRunSetupResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PartialRunSetupResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PartialRunSetupResponse(const PartialRunSetupResponse& from) : PartialRunSetupResponse(nullptr, from) {}
  inline PartialRunSetupResponse(PartialRunSetupResponse&& from) noexcept
      : PartialRunSetupResponse(nullptr, std::move(from)) {}
  inline PartialRunSetupResponse& operator=(const PartialRunSetupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartialRunSetupResponse& operator=(PartialRunSetupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartialRunSetupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartialRunSetupResponse* internal_default_instance() {
    return reinterpret_cast<const PartialRunSetupResponse*>(
        &_PartialRunSetupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PartialRunSetupResponse& a, PartialRunSetupResponse& b) { a.Swap(&b); }
  inline void Swap(PartialRunSetupResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartialRunSetupResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartialRunSetupResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PartialRunSetupResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PartialRunSetupResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PartialRunSetupResponse& from) { PartialRunSetupResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PartialRunSetupResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.PartialRunSetupResponse"; }

 protected:
  explicit PartialRunSetupResponse(::google::protobuf::Arena* arena);
  PartialRunSetupResponse(::google::protobuf::Arena* arena, const PartialRunSetupResponse& from);
  PartialRunSetupResponse(::google::protobuf::Arena* arena, PartialRunSetupResponse&& from) noexcept
      : PartialRunSetupResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPartialRunHandleFieldNumber = 1,
  };
  // string partial_run_handle = 1;
  void clear_partial_run_handle() ;
  const std::string& partial_run_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partial_run_handle(Arg_&& arg, Args_... args);
  std::string* mutable_partial_run_handle();
  PROTOBUF_NODISCARD std::string* release_partial_run_handle();
  void set_allocated_partial_run_handle(std::string* value);

  private:
  const std::string& _internal_partial_run_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partial_run_handle(
      const std::string& value);
  std::string* _internal_mutable_partial_run_handle();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.PartialRunSetupResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      61, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PartialRunSetupResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr partial_run_handle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PartialRunSetupRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.PartialRunSetupRequest) */ {
 public:
  inline PartialRunSetupRequest() : PartialRunSetupRequest(nullptr) {}
  ~PartialRunSetupRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PartialRunSetupRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PartialRunSetupRequest(const PartialRunSetupRequest& from) : PartialRunSetupRequest(nullptr, from) {}
  inline PartialRunSetupRequest(PartialRunSetupRequest&& from) noexcept
      : PartialRunSetupRequest(nullptr, std::move(from)) {}
  inline PartialRunSetupRequest& operator=(const PartialRunSetupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartialRunSetupRequest& operator=(PartialRunSetupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartialRunSetupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartialRunSetupRequest* internal_default_instance() {
    return reinterpret_cast<const PartialRunSetupRequest*>(
        &_PartialRunSetupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PartialRunSetupRequest& a, PartialRunSetupRequest& b) { a.Swap(&b); }
  inline void Swap(PartialRunSetupRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartialRunSetupRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartialRunSetupRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PartialRunSetupRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PartialRunSetupRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PartialRunSetupRequest& from) { PartialRunSetupRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PartialRunSetupRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.PartialRunSetupRequest"; }

 protected:
  explicit PartialRunSetupRequest(::google::protobuf::Arena* arena);
  PartialRunSetupRequest(::google::protobuf::Arena* arena, const PartialRunSetupRequest& from);
  PartialRunSetupRequest(::google::protobuf::Arena* arena, PartialRunSetupRequest&& from) noexcept
      : PartialRunSetupRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFeedFieldNumber = 2,
    kFetchFieldNumber = 3,
    kTargetFieldNumber = 4,
    kSessionHandleFieldNumber = 1,
    kRequestIdFieldNumber = 5,
  };
  // repeated string feed = 2;
  int feed_size() const;
  private:
  int _internal_feed_size() const;

  public:
  void clear_feed() ;
  const std::string& feed(int index) const;
  std::string* mutable_feed(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed(int index, Arg_&& value, Args_... args);
  std::string* add_feed();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_feed(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& feed() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_feed();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_feed() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_feed();

  public:
  // repeated string fetch = 3;
  int fetch_size() const;
  private:
  int _internal_fetch_size() const;

  public:
  void clear_fetch() ;
  const std::string& fetch(int index) const;
  std::string* mutable_fetch(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fetch(int index, Arg_&& value, Args_... args);
  std::string* add_fetch();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_fetch(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& fetch() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_fetch();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_fetch() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_fetch();

  public:
  // repeated string target = 4;
  int target_size() const;
  private:
  int _internal_target_size() const;

  public:
  void clear_target() ;
  const std::string& target(int index) const;
  std::string* mutable_target(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(int index, Arg_&& value, Args_... args);
  std::string* add_target();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_target(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& target() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_target();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_target() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_target();

  public:
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // int64 request_id = 5;
  void clear_request_id() ;
  ::int64_t request_id() const;
  void set_request_id(::int64_t value);

  private:
  ::int64_t _internal_request_id() const;
  void _internal_set_request_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.PartialRunSetupRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      71, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PartialRunSetupRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> feed_;
    ::google::protobuf::RepeatedPtrField<std::string> fetch_;
    ::google::protobuf::RepeatedPtrField<std::string> target_;
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    ::int64_t request_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MakeCallableResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.MakeCallableResponse) */ {
 public:
  inline MakeCallableResponse() : MakeCallableResponse(nullptr) {}
  ~MakeCallableResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MakeCallableResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MakeCallableResponse(const MakeCallableResponse& from) : MakeCallableResponse(nullptr, from) {}
  inline MakeCallableResponse(MakeCallableResponse&& from) noexcept
      : MakeCallableResponse(nullptr, std::move(from)) {}
  inline MakeCallableResponse& operator=(const MakeCallableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeCallableResponse& operator=(MakeCallableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeCallableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeCallableResponse* internal_default_instance() {
    return reinterpret_cast<const MakeCallableResponse*>(
        &_MakeCallableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(MakeCallableResponse& a, MakeCallableResponse& b) { a.Swap(&b); }
  inline void Swap(MakeCallableResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeCallableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeCallableResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MakeCallableResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MakeCallableResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MakeCallableResponse& from) { MakeCallableResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MakeCallableResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.MakeCallableResponse"; }

 protected:
  explicit MakeCallableResponse(::google::protobuf::Arena* arena);
  MakeCallableResponse(::google::protobuf::Arena* arena, const MakeCallableResponse& from);
  MakeCallableResponse(::google::protobuf::Arena* arena, MakeCallableResponse&& from) noexcept
      : MakeCallableResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHandleFieldNumber = 1,
  };
  // int64 handle = 1;
  void clear_handle() ;
  ::int64_t handle() const;
  void set_handle(::int64_t value);

  private:
  ::int64_t _internal_handle() const;
  void _internal_set_handle(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.MakeCallableResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MakeCallableResponse& from_msg);
    ::int64_t handle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ListDevicesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ListDevicesRequest) */ {
 public:
  inline ListDevicesRequest() : ListDevicesRequest(nullptr) {}
  ~ListDevicesRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListDevicesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListDevicesRequest(const ListDevicesRequest& from) : ListDevicesRequest(nullptr, from) {}
  inline ListDevicesRequest(ListDevicesRequest&& from) noexcept
      : ListDevicesRequest(nullptr, std::move(from)) {}
  inline ListDevicesRequest& operator=(const ListDevicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDevicesRequest& operator=(ListDevicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDevicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDevicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListDevicesRequest*>(
        &_ListDevicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ListDevicesRequest& a, ListDevicesRequest& b) { a.Swap(&b); }
  inline void Swap(ListDevicesRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDevicesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDevicesRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ListDevicesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListDevicesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListDevicesRequest& from) { ListDevicesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListDevicesRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ListDevicesRequest"; }

 protected:
  explicit ListDevicesRequest(::google::protobuf::Arena* arena);
  ListDevicesRequest(::google::protobuf::Arena* arena, const ListDevicesRequest& from);
  ListDevicesRequest(::google::protobuf::Arena* arena, ListDevicesRequest&& from) noexcept
      : ListDevicesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionHandleFieldNumber = 1,
  };
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ListDevicesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      52, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListDevicesRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ExtendSessionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ExtendSessionResponse) */ {
 public:
  inline ExtendSessionResponse() : ExtendSessionResponse(nullptr) {}
  ~ExtendSessionResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtendSessionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExtendSessionResponse(const ExtendSessionResponse& from) : ExtendSessionResponse(nullptr, from) {}
  inline ExtendSessionResponse(ExtendSessionResponse&& from) noexcept
      : ExtendSessionResponse(nullptr, std::move(from)) {}
  inline ExtendSessionResponse& operator=(const ExtendSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendSessionResponse& operator=(ExtendSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtendSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtendSessionResponse* internal_default_instance() {
    return reinterpret_cast<const ExtendSessionResponse*>(
        &_ExtendSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ExtendSessionResponse& a, ExtendSessionResponse& b) { a.Swap(&b); }
  inline void Swap(ExtendSessionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendSessionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtendSessionResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ExtendSessionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExtendSessionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExtendSessionResponse& from) { ExtendSessionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExtendSessionResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ExtendSessionResponse"; }

 protected:
  explicit ExtendSessionResponse(::google::protobuf::Arena* arena);
  ExtendSessionResponse(::google::protobuf::Arena* arena, const ExtendSessionResponse& from);
  ExtendSessionResponse(::google::protobuf::Arena* arena, ExtendSessionResponse&& from) noexcept
      : ExtendSessionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewGraphVersionFieldNumber = 4,
  };
  // int64 new_graph_version = 4;
  void clear_new_graph_version() ;
  ::int64_t new_graph_version() const;
  void set_new_graph_version(::int64_t value);

  private:
  ::int64_t _internal_new_graph_version() const;
  void _internal_set_new_graph_version(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ExtendSessionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExtendSessionResponse& from_msg);
    ::int64_t new_graph_version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CreateSessionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CreateSessionResponse) */ {
 public:
  inline CreateSessionResponse() : CreateSessionResponse(nullptr) {}
  ~CreateSessionResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateSessionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateSessionResponse(const CreateSessionResponse& from) : CreateSessionResponse(nullptr, from) {}
  inline CreateSessionResponse(CreateSessionResponse&& from) noexcept
      : CreateSessionResponse(nullptr, std::move(from)) {}
  inline CreateSessionResponse& operator=(const CreateSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSessionResponse& operator=(CreateSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSessionResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSessionResponse*>(
        &_CreateSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CreateSessionResponse& a, CreateSessionResponse& b) { a.Swap(&b); }
  inline void Swap(CreateSessionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSessionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSessionResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CreateSessionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateSessionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateSessionResponse& from) { CreateSessionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateSessionResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CreateSessionResponse"; }

 protected:
  explicit CreateSessionResponse(::google::protobuf::Arena* arena);
  CreateSessionResponse(::google::protobuf::Arena* arena, const CreateSessionResponse& from);
  CreateSessionResponse(::google::protobuf::Arena* arena, CreateSessionResponse&& from) noexcept
      : CreateSessionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionHandleFieldNumber = 1,
    kGraphVersionFieldNumber = 2,
  };
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // int64 graph_version = 2;
  void clear_graph_version() ;
  ::int64_t graph_version() const;
  void set_graph_version(::int64_t value);

  private:
  ::int64_t _internal_graph_version() const;
  void _internal_set_graph_version(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CreateSessionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateSessionResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    ::int64_t graph_version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CloseSessionResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.CloseSessionResponse) */ {
 public:
  inline CloseSessionResponse() : CloseSessionResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CloseSessionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CloseSessionResponse(const CloseSessionResponse& from) : CloseSessionResponse(nullptr, from) {}
  inline CloseSessionResponse(CloseSessionResponse&& from) noexcept
      : CloseSessionResponse(nullptr, std::move(from)) {}
  inline CloseSessionResponse& operator=(const CloseSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseSessionResponse& operator=(CloseSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseSessionResponse* internal_default_instance() {
    return reinterpret_cast<const CloseSessionResponse*>(
        &_CloseSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CloseSessionResponse& a, CloseSessionResponse& b) { a.Swap(&b); }
  inline void Swap(CloseSessionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseSessionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseSessionResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CloseSessionResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CloseSessionResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CloseSessionResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CloseSessionResponse"; }

 protected:
  explicit CloseSessionResponse(::google::protobuf::Arena* arena);
  CloseSessionResponse(::google::protobuf::Arena* arena, const CloseSessionResponse& from);
  CloseSessionResponse(::google::protobuf::Arena* arena, CloseSessionResponse&& from) noexcept
      : CloseSessionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.CloseSessionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CloseSessionResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CloseSessionRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CloseSessionRequest) */ {
 public:
  inline CloseSessionRequest() : CloseSessionRequest(nullptr) {}
  ~CloseSessionRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CloseSessionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CloseSessionRequest(const CloseSessionRequest& from) : CloseSessionRequest(nullptr, from) {}
  inline CloseSessionRequest(CloseSessionRequest&& from) noexcept
      : CloseSessionRequest(nullptr, std::move(from)) {}
  inline CloseSessionRequest& operator=(const CloseSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseSessionRequest& operator=(CloseSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseSessionRequest* internal_default_instance() {
    return reinterpret_cast<const CloseSessionRequest*>(
        &_CloseSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CloseSessionRequest& a, CloseSessionRequest& b) { a.Swap(&b); }
  inline void Swap(CloseSessionRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseSessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseSessionRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CloseSessionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CloseSessionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CloseSessionRequest& from) { CloseSessionRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CloseSessionRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CloseSessionRequest"; }

 protected:
  explicit CloseSessionRequest(::google::protobuf::Arena* arena);
  CloseSessionRequest(::google::protobuf::Arena* arena, const CloseSessionRequest& from);
  CloseSessionRequest(::google::protobuf::Arena* arena, CloseSessionRequest&& from) noexcept
      : CloseSessionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionHandleFieldNumber = 1,
  };
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CloseSessionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CloseSessionRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MakeCallableRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.MakeCallableRequest) */ {
 public:
  inline MakeCallableRequest() : MakeCallableRequest(nullptr) {}
  ~MakeCallableRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MakeCallableRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MakeCallableRequest(const MakeCallableRequest& from) : MakeCallableRequest(nullptr, from) {}
  inline MakeCallableRequest(MakeCallableRequest&& from) noexcept
      : MakeCallableRequest(nullptr, std::move(from)) {}
  inline MakeCallableRequest& operator=(const MakeCallableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeCallableRequest& operator=(MakeCallableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeCallableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeCallableRequest* internal_default_instance() {
    return reinterpret_cast<const MakeCallableRequest*>(
        &_MakeCallableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(MakeCallableRequest& a, MakeCallableRequest& b) { a.Swap(&b); }
  inline void Swap(MakeCallableRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeCallableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeCallableRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MakeCallableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MakeCallableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MakeCallableRequest& from) { MakeCallableRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MakeCallableRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.MakeCallableRequest"; }

 protected:
  explicit MakeCallableRequest(::google::protobuf::Arena* arena);
  MakeCallableRequest(::google::protobuf::Arena* arena, const MakeCallableRequest& from);
  MakeCallableRequest(::google::protobuf::Arena* arena, MakeCallableRequest&& from) noexcept
      : MakeCallableRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionHandleFieldNumber = 1,
    kOptionsFieldNumber = 2,
    kRequestIdFieldNumber = 3,
  };
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // .tensorflow.CallableOptions options = 2;
  bool has_options() const;
  void clear_options() ;
  const ::tensorflow::CallableOptions& options() const;
  PROTOBUF_NODISCARD ::tensorflow::CallableOptions* release_options();
  ::tensorflow::CallableOptions* mutable_options();
  void set_allocated_options(::tensorflow::CallableOptions* value);
  void unsafe_arena_set_allocated_options(::tensorflow::CallableOptions* value);
  ::tensorflow::CallableOptions* unsafe_arena_release_options();

  private:
  const ::tensorflow::CallableOptions& _internal_options() const;
  ::tensorflow::CallableOptions* _internal_mutable_options();

  public:
  // int64 request_id = 3;
  void clear_request_id() ;
  ::int64_t request_id() const;
  void set_request_id(::int64_t value);

  private:
  ::int64_t _internal_request_id() const;
  void _internal_set_request_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.MakeCallableRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      53, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MakeCallableRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    ::tensorflow::CallableOptions* options_;
    ::int64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ListDevicesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ListDevicesResponse) */ {
 public:
  inline ListDevicesResponse() : ListDevicesResponse(nullptr) {}
  ~ListDevicesResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListDevicesResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListDevicesResponse(const ListDevicesResponse& from) : ListDevicesResponse(nullptr, from) {}
  inline ListDevicesResponse(ListDevicesResponse&& from) noexcept
      : ListDevicesResponse(nullptr, std::move(from)) {}
  inline ListDevicesResponse& operator=(const ListDevicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDevicesResponse& operator=(ListDevicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDevicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDevicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListDevicesResponse*>(
        &_ListDevicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ListDevicesResponse& a, ListDevicesResponse& b) { a.Swap(&b); }
  inline void Swap(ListDevicesResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDevicesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDevicesResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ListDevicesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListDevicesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListDevicesResponse& from) { ListDevicesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListDevicesResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ListDevicesResponse"; }

 protected:
  explicit ListDevicesResponse(::google::protobuf::Arena* arena);
  ListDevicesResponse(::google::protobuf::Arena* arena, const ListDevicesResponse& from);
  ListDevicesResponse(::google::protobuf::Arena* arena, ListDevicesResponse&& from) noexcept
      : ListDevicesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLocalDeviceFieldNumber = 1,
    kRemoteDeviceFieldNumber = 2,
  };
  // repeated .tensorflow.DeviceAttributes local_device = 1;
  int local_device_size() const;
  private:
  int _internal_local_device_size() const;

  public:
  void clear_local_device() ;
  ::tensorflow::DeviceAttributes* mutable_local_device(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>* mutable_local_device();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>& _internal_local_device() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>* _internal_mutable_local_device();
  public:
  const ::tensorflow::DeviceAttributes& local_device(int index) const;
  ::tensorflow::DeviceAttributes* add_local_device();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>& local_device() const;
  // repeated .tensorflow.DeviceAttributes remote_device = 2;
  int remote_device_size() const;
  private:
  int _internal_remote_device_size() const;

  public:
  void clear_remote_device() ;
  ::tensorflow::DeviceAttributes* mutable_remote_device(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>* mutable_remote_device();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>& _internal_remote_device() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>* _internal_mutable_remote_device();
  public:
  const ::tensorflow::DeviceAttributes& remote_device(int index) const;
  ::tensorflow::DeviceAttributes* add_remote_device();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>& remote_device() const;
  // @@protoc_insertion_point(class_scope:tensorflow.ListDevicesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListDevicesResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes > local_device_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes > remote_device_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT RunCallableRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.RunCallableRequest) */ {
 public:
  inline RunCallableRequest() : RunCallableRequest(nullptr) {}
  ~RunCallableRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunCallableRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RunCallableRequest(const RunCallableRequest& from) : RunCallableRequest(nullptr, from) {}
  inline RunCallableRequest(RunCallableRequest&& from) noexcept
      : RunCallableRequest(nullptr, std::move(from)) {}
  inline RunCallableRequest& operator=(const RunCallableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunCallableRequest& operator=(RunCallableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunCallableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunCallableRequest* internal_default_instance() {
    return reinterpret_cast<const RunCallableRequest*>(
        &_RunCallableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RunCallableRequest& a, RunCallableRequest& b) { a.Swap(&b); }
  inline void Swap(RunCallableRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunCallableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunCallableRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RunCallableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunCallableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RunCallableRequest& from) { RunCallableRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunCallableRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.RunCallableRequest"; }

 protected:
  explicit RunCallableRequest(::google::protobuf::Arena* arena);
  RunCallableRequest(::google::protobuf::Arena* arena, const RunCallableRequest& from);
  RunCallableRequest(::google::protobuf::Arena* arena, RunCallableRequest&& from) noexcept
      : RunCallableRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFeedFieldNumber = 3,
    kSessionHandleFieldNumber = 1,
    kHandleFieldNumber = 2,
    kRequestIdFieldNumber = 4,
  };
  // repeated .tensorflow.TensorProto feed = 3;
  int feed_size() const;
  private:
  int _internal_feed_size() const;

  public:
  void clear_feed() ;
  ::tensorflow::TensorProto* mutable_feed(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* mutable_feed();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& _internal_feed() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* _internal_mutable_feed();
  public:
  const ::tensorflow::TensorProto& feed(int index) const;
  ::tensorflow::TensorProto* add_feed();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& feed() const;
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // int64 handle = 2;
  void clear_handle() ;
  ::int64_t handle() const;
  void set_handle(::int64_t value);

  private:
  ::int64_t _internal_handle() const;
  void _internal_set_handle(::int64_t value);

  public:
  // int64 request_id = 4;
  void clear_request_id() ;
  ::int64_t request_id() const;
  void set_request_id(::int64_t value);

  private:
  ::int64_t _internal_request_id() const;
  void _internal_set_request_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.RunCallableRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      52, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RunCallableRequest& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > feed_;
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    ::int64_t handle_;
    ::int64_t request_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT RunStepRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.RunStepRequest) */ {
 public:
  inline RunStepRequest() : RunStepRequest(nullptr) {}
  ~RunStepRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunStepRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RunStepRequest(const RunStepRequest& from) : RunStepRequest(nullptr, from) {}
  inline RunStepRequest(RunStepRequest&& from) noexcept
      : RunStepRequest(nullptr, std::move(from)) {}
  inline RunStepRequest& operator=(const RunStepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunStepRequest& operator=(RunStepRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunStepRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunStepRequest* internal_default_instance() {
    return reinterpret_cast<const RunStepRequest*>(
        &_RunStepRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RunStepRequest& a, RunStepRequest& b) { a.Swap(&b); }
  inline void Swap(RunStepRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunStepRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunStepRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RunStepRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunStepRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RunStepRequest& from) { RunStepRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunStepRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.RunStepRequest"; }

 protected:
  explicit RunStepRequest(::google::protobuf::Arena* arena);
  RunStepRequest(::google::protobuf::Arena* arena, const RunStepRequest& from);
  RunStepRequest(::google::protobuf::Arena* arena, RunStepRequest&& from) noexcept
      : RunStepRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFeedFieldNumber = 2,
    kFetchFieldNumber = 3,
    kTargetFieldNumber = 4,
    kSessionHandleFieldNumber = 1,
    kPartialRunHandleFieldNumber = 6,
    kOptionsFieldNumber = 5,
    kRequestIdFieldNumber = 8,
    kStoreErrorsInResponseBodyFieldNumber = 7,
  };
  // repeated .tensorflow.NamedTensorProto feed = 2;
  int feed_size() const;
  private:
  int _internal_feed_size() const;

  public:
  void clear_feed() ;
  ::tensorflow::NamedTensorProto* mutable_feed(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>* mutable_feed();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>& _internal_feed() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>* _internal_mutable_feed();
  public:
  const ::tensorflow::NamedTensorProto& feed(int index) const;
  ::tensorflow::NamedTensorProto* add_feed();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>& feed() const;
  // repeated string fetch = 3;
  int fetch_size() const;
  private:
  int _internal_fetch_size() const;

  public:
  void clear_fetch() ;
  const std::string& fetch(int index) const;
  std::string* mutable_fetch(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fetch(int index, Arg_&& value, Args_... args);
  std::string* add_fetch();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_fetch(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& fetch() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_fetch();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_fetch() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_fetch();

  public:
  // repeated string target = 4;
  int target_size() const;
  private:
  int _internal_target_size() const;

  public:
  void clear_target() ;
  const std::string& target(int index) const;
  std::string* mutable_target(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(int index, Arg_&& value, Args_... args);
  std::string* add_target();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_target(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& target() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_target();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_target() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_target();

  public:
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // string partial_run_handle = 6;
  void clear_partial_run_handle() ;
  const std::string& partial_run_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partial_run_handle(Arg_&& arg, Args_... args);
  std::string* mutable_partial_run_handle();
  PROTOBUF_NODISCARD std::string* release_partial_run_handle();
  void set_allocated_partial_run_handle(std::string* value);

  private:
  const std::string& _internal_partial_run_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partial_run_handle(
      const std::string& value);
  std::string* _internal_mutable_partial_run_handle();

  public:
  // .tensorflow.RunOptions options = 5;
  bool has_options() const;
  void clear_options() ;
  const ::tensorflow::RunOptions& options() const;
  PROTOBUF_NODISCARD ::tensorflow::RunOptions* release_options();
  ::tensorflow::RunOptions* mutable_options();
  void set_allocated_options(::tensorflow::RunOptions* value);
  void unsafe_arena_set_allocated_options(::tensorflow::RunOptions* value);
  ::tensorflow::RunOptions* unsafe_arena_release_options();

  private:
  const ::tensorflow::RunOptions& _internal_options() const;
  ::tensorflow::RunOptions* _internal_mutable_options();

  public:
  // int64 request_id = 8;
  void clear_request_id() ;
  ::int64_t request_id() const;
  void set_request_id(::int64_t value);

  private:
  ::int64_t _internal_request_id() const;
  void _internal_set_request_id(::int64_t value);

  public:
  // bool store_errors_in_response_body = 7;
  void clear_store_errors_in_response_body() ;
  bool store_errors_in_response_body() const;
  void set_store_errors_in_response_body(bool value);

  private:
  bool _internal_store_errors_in_response_body() const;
  void _internal_set_store_errors_in_response_body(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.RunStepRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 2,
      85, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RunStepRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto > feed_;
    ::google::protobuf::RepeatedPtrField<std::string> fetch_;
    ::google::protobuf::RepeatedPtrField<std::string> target_;
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    ::google::protobuf::internal::ArenaStringPtr partial_run_handle_;
    ::tensorflow::RunOptions* options_;
    ::int64_t request_id_;
    bool store_errors_in_response_body_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ExtendSessionRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ExtendSessionRequest) */ {
 public:
  inline ExtendSessionRequest() : ExtendSessionRequest(nullptr) {}
  ~ExtendSessionRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtendSessionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExtendSessionRequest(const ExtendSessionRequest& from) : ExtendSessionRequest(nullptr, from) {}
  inline ExtendSessionRequest(ExtendSessionRequest&& from) noexcept
      : ExtendSessionRequest(nullptr, std::move(from)) {}
  inline ExtendSessionRequest& operator=(const ExtendSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendSessionRequest& operator=(ExtendSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtendSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtendSessionRequest* internal_default_instance() {
    return reinterpret_cast<const ExtendSessionRequest*>(
        &_ExtendSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ExtendSessionRequest& a, ExtendSessionRequest& b) { a.Swap(&b); }
  inline void Swap(ExtendSessionRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendSessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtendSessionRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ExtendSessionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExtendSessionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExtendSessionRequest& from) { ExtendSessionRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExtendSessionRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ExtendSessionRequest"; }

 protected:
  explicit ExtendSessionRequest(::google::protobuf::Arena* arena);
  ExtendSessionRequest(::google::protobuf::Arena* arena, const ExtendSessionRequest& from);
  ExtendSessionRequest(::google::protobuf::Arena* arena, ExtendSessionRequest&& from) noexcept
      : ExtendSessionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionHandleFieldNumber = 1,
    kGraphDefFieldNumber = 2,
    kCurrentGraphVersionFieldNumber = 3,
  };
  // string session_handle = 1;
  void clear_session_handle() ;
  const std::string& session_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_handle(Arg_&& arg, Args_... args);
  std::string* mutable_session_handle();
  PROTOBUF_NODISCARD std::string* release_session_handle();
  void set_allocated_session_handle(std::string* value);

  private:
  const std::string& _internal_session_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_handle(
      const std::string& value);
  std::string* _internal_mutable_session_handle();

  public:
  // .tensorflow.GraphDef graph_def = 2;
  bool has_graph_def() const;
  void clear_graph_def() ;
  const ::tensorflow::GraphDef& graph_def() const;
  PROTOBUF_NODISCARD ::tensorflow::GraphDef* release_graph_def();
  ::tensorflow::GraphDef* mutable_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* value);
  void unsafe_arena_set_allocated_graph_def(::tensorflow::GraphDef* value);
  ::tensorflow::GraphDef* unsafe_arena_release_graph_def();

  private:
  const ::tensorflow::GraphDef& _internal_graph_def() const;
  ::tensorflow::GraphDef* _internal_mutable_graph_def();

  public:
  // int64 current_graph_version = 3;
  void clear_current_graph_version() ;
  ::int64_t current_graph_version() const;
  void set_current_graph_version(::int64_t value);

  private:
  ::int64_t _internal_current_graph_version() const;
  void _internal_set_current_graph_version(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.ExtendSessionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      54, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExtendSessionRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr session_handle_;
    ::tensorflow::GraphDef* graph_def_;
    ::int64_t current_graph_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CreateSessionRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CreateSessionRequest) */ {
 public:
  inline CreateSessionRequest() : CreateSessionRequest(nullptr) {}
  ~CreateSessionRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateSessionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateSessionRequest(const CreateSessionRequest& from) : CreateSessionRequest(nullptr, from) {}
  inline CreateSessionRequest(CreateSessionRequest&& from) noexcept
      : CreateSessionRequest(nullptr, std::move(from)) {}
  inline CreateSessionRequest& operator=(const CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSessionRequest& operator=(CreateSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSessionRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSessionRequest*>(
        &_CreateSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CreateSessionRequest& a, CreateSessionRequest& b) { a.Swap(&b); }
  inline void Swap(CreateSessionRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSessionRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CreateSessionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateSessionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateSessionRequest& from) { CreateSessionRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateSessionRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CreateSessionRequest"; }

 protected:
  explicit CreateSessionRequest(::google::protobuf::Arena* arena);
  CreateSessionRequest(::google::protobuf::Arena* arena, const CreateSessionRequest& from);
  CreateSessionRequest(::google::protobuf::Arena* arena, CreateSessionRequest&& from) noexcept
      : CreateSessionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 3,
    kGraphDefFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // string target = 3;
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // .tensorflow.GraphDef graph_def = 1;
  bool has_graph_def() const;
  void clear_graph_def() ;
  const ::tensorflow::GraphDef& graph_def() const;
  PROTOBUF_NODISCARD ::tensorflow::GraphDef* release_graph_def();
  ::tensorflow::GraphDef* mutable_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* value);
  void unsafe_arena_set_allocated_graph_def(::tensorflow::GraphDef* value);
  ::tensorflow::GraphDef* unsafe_arena_release_graph_def();

  private:
  const ::tensorflow::GraphDef& _internal_graph_def() const;
  ::tensorflow::GraphDef* _internal_mutable_graph_def();

  public:
  // .tensorflow.ConfigProto config = 2;
  bool has_config() const;
  void clear_config() ;
  const ::tensorflow::ConfigProto& config() const;
  PROTOBUF_NODISCARD ::tensorflow::ConfigProto* release_config();
  ::tensorflow::ConfigProto* mutable_config();
  void set_allocated_config(::tensorflow::ConfigProto* value);
  void unsafe_arena_set_allocated_config(::tensorflow::ConfigProto* value);
  ::tensorflow::ConfigProto* unsafe_arena_release_config();

  private:
  const ::tensorflow::ConfigProto& _internal_config() const;
  ::tensorflow::ConfigProto* _internal_mutable_config();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CreateSessionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      46, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateSessionRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::tensorflow::GraphDef* graph_def_;
    ::tensorflow::ConfigProto* config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT RunStepResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.RunStepResponse) */ {
 public:
  inline RunStepResponse() : RunStepResponse(nullptr) {}
  ~RunStepResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunStepResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RunStepResponse(const RunStepResponse& from) : RunStepResponse(nullptr, from) {}
  inline RunStepResponse(RunStepResponse&& from) noexcept
      : RunStepResponse(nullptr, std::move(from)) {}
  inline RunStepResponse& operator=(const RunStepResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunStepResponse& operator=(RunStepResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunStepResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunStepResponse* internal_default_instance() {
    return reinterpret_cast<const RunStepResponse*>(
        &_RunStepResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RunStepResponse& a, RunStepResponse& b) { a.Swap(&b); }
  inline void Swap(RunStepResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunStepResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunStepResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RunStepResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunStepResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RunStepResponse& from) { RunStepResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunStepResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.RunStepResponse"; }

 protected:
  explicit RunStepResponse(::google::protobuf::Arena* arena);
  RunStepResponse(::google::protobuf::Arena* arena, const RunStepResponse& from);
  RunStepResponse(::google::protobuf::Arena* arena, RunStepResponse&& from) noexcept
      : RunStepResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTensorFieldNumber = 1,
    kStatusErrorMessageFieldNumber = 4,
    kMetadataFieldNumber = 2,
    kStatusCodeFieldNumber = 3,
  };
  // repeated .tensorflow.NamedTensorProto tensor = 1;
  int tensor_size() const;
  private:
  int _internal_tensor_size() const;

  public:
  void clear_tensor() ;
  ::tensorflow::NamedTensorProto* mutable_tensor(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>* mutable_tensor();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>& _internal_tensor() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>* _internal_mutable_tensor();
  public:
  const ::tensorflow::NamedTensorProto& tensor(int index) const;
  ::tensorflow::NamedTensorProto* add_tensor();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>& tensor() const;
  // string status_error_message = 4;
  void clear_status_error_message() ;
  const std::string& status_error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_status_error_message();
  PROTOBUF_NODISCARD std::string* release_status_error_message();
  void set_allocated_status_error_message(std::string* value);

  private:
  const std::string& _internal_status_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_error_message(
      const std::string& value);
  std::string* _internal_mutable_status_error_message();

  public:
  // .tensorflow.RunMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata() ;
  const ::tensorflow::RunMetadata& metadata() const;
  PROTOBUF_NODISCARD ::tensorflow::RunMetadata* release_metadata();
  ::tensorflow::RunMetadata* mutable_metadata();
  void set_allocated_metadata(::tensorflow::RunMetadata* value);
  void unsafe_arena_set_allocated_metadata(::tensorflow::RunMetadata* value);
  ::tensorflow::RunMetadata* unsafe_arena_release_metadata();

  private:
  const ::tensorflow::RunMetadata& _internal_metadata() const;
  ::tensorflow::RunMetadata* _internal_mutable_metadata();

  public:
  // .tensorflow.error.Code status_code = 3;
  void clear_status_code() ;
  ::tensorflow::error::Code status_code() const;
  void set_status_code(::tensorflow::error::Code value);

  private:
  ::tensorflow::error::Code _internal_status_code() const;
  void _internal_set_status_code(::tensorflow::error::Code value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.RunStepResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      55, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RunStepResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto > tensor_;
    ::google::protobuf::internal::ArenaStringPtr status_error_message_;
    ::tensorflow::RunMetadata* metadata_;
    int status_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT RunCallableResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.RunCallableResponse) */ {
 public:
  inline RunCallableResponse() : RunCallableResponse(nullptr) {}
  ~RunCallableResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunCallableResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RunCallableResponse(const RunCallableResponse& from) : RunCallableResponse(nullptr, from) {}
  inline RunCallableResponse(RunCallableResponse&& from) noexcept
      : RunCallableResponse(nullptr, std::move(from)) {}
  inline RunCallableResponse& operator=(const RunCallableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunCallableResponse& operator=(RunCallableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunCallableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunCallableResponse* internal_default_instance() {
    return reinterpret_cast<const RunCallableResponse*>(
        &_RunCallableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RunCallableResponse& a, RunCallableResponse& b) { a.Swap(&b); }
  inline void Swap(RunCallableResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunCallableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunCallableResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RunCallableResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunCallableResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RunCallableResponse& from) { RunCallableResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunCallableResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.RunCallableResponse"; }

 protected:
  explicit RunCallableResponse(::google::protobuf::Arena* arena);
  RunCallableResponse(::google::protobuf::Arena* arena, const RunCallableResponse& from);
  RunCallableResponse(::google::protobuf::Arena* arena, RunCallableResponse&& from) noexcept
      : RunCallableResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFetchFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // repeated .tensorflow.TensorProto fetch = 1;
  int fetch_size() const;
  private:
  int _internal_fetch_size() const;

  public:
  void clear_fetch() ;
  ::tensorflow::TensorProto* mutable_fetch(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* mutable_fetch();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& _internal_fetch() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* _internal_mutable_fetch();
  public:
  const ::tensorflow::TensorProto& fetch(int index) const;
  ::tensorflow::TensorProto* add_fetch();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& fetch() const;
  // .tensorflow.RunMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata() ;
  const ::tensorflow::RunMetadata& metadata() const;
  PROTOBUF_NODISCARD ::tensorflow::RunMetadata* release_metadata();
  ::tensorflow::RunMetadata* mutable_metadata();
  void set_allocated_metadata(::tensorflow::RunMetadata* value);
  void unsafe_arena_set_allocated_metadata(::tensorflow::RunMetadata* value);
  ::tensorflow::RunMetadata* unsafe_arena_release_metadata();

  private:
  const ::tensorflow::RunMetadata& _internal_metadata() const;
  ::tensorflow::RunMetadata* _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.RunCallableResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RunCallableResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > fetch_;
    ::tensorflow::RunMetadata* metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CreateSessionRequest

// .tensorflow.GraphDef graph_def = 1;
inline bool CreateSessionRequest::has_graph_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.graph_def_ != nullptr);
  return value;
}
inline const ::tensorflow::GraphDef& CreateSessionRequest::_internal_graph_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::GraphDef* p = _impl_.graph_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::GraphDef&>(::tensorflow::_GraphDef_default_instance_);
}
inline const ::tensorflow::GraphDef& CreateSessionRequest::graph_def() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionRequest.graph_def)
  return _internal_graph_def();
}
inline void CreateSessionRequest::unsafe_arena_set_allocated_graph_def(::tensorflow::GraphDef* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.graph_def_);
  }
  _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CreateSessionRequest.graph_def)
}
inline ::tensorflow::GraphDef* CreateSessionRequest::release_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::GraphDef* released = _impl_.graph_def_;
  _impl_.graph_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::GraphDef* CreateSessionRequest::unsafe_arena_release_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionRequest.graph_def)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::GraphDef* temp = _impl_.graph_def_;
  _impl_.graph_def_ = nullptr;
  return temp;
}
inline ::tensorflow::GraphDef* CreateSessionRequest::_internal_mutable_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.graph_def_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::GraphDef>(GetArena());
    _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(p);
  }
  return _impl_.graph_def_;
}
inline ::tensorflow::GraphDef* CreateSessionRequest::mutable_graph_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::GraphDef* _msg = _internal_mutable_graph_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionRequest.graph_def)
  return _msg;
}
inline void CreateSessionRequest::set_allocated_graph_def(::tensorflow::GraphDef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.graph_def_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionRequest.graph_def)
}

// .tensorflow.ConfigProto config = 2;
inline bool CreateSessionRequest::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline const ::tensorflow::ConfigProto& CreateSessionRequest::_internal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::ConfigProto* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::ConfigProto&>(::tensorflow::_ConfigProto_default_instance_);
}
inline const ::tensorflow::ConfigProto& CreateSessionRequest::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionRequest.config)
  return _internal_config();
}
inline void CreateSessionRequest::unsafe_arena_set_allocated_config(::tensorflow::ConfigProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::tensorflow::ConfigProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CreateSessionRequest.config)
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::ConfigProto* released = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::unsafe_arena_release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionRequest.config)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::ConfigProto* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::_internal_mutable_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::ConfigProto>(GetArena());
    _impl_.config_ = reinterpret_cast<::tensorflow::ConfigProto*>(p);
  }
  return _impl_.config_;
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::ConfigProto* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionRequest.config)
  return _msg;
}
inline void CreateSessionRequest::set_allocated_config(::tensorflow::ConfigProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.config_ = reinterpret_cast<::tensorflow::ConfigProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionRequest.config)
}

// string target = 3;
inline void CreateSessionRequest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& CreateSessionRequest::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionRequest.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateSessionRequest::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CreateSessionRequest.target)
}
inline std::string* CreateSessionRequest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionRequest.target)
  return _s;
}
inline const std::string& CreateSessionRequest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void CreateSessionRequest::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* CreateSessionRequest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* CreateSessionRequest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionRequest.target)
  return _impl_.target_.Release();
}
inline void CreateSessionRequest::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_.IsDefault()) {
          _impl_.target_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionRequest.target)
}

// -------------------------------------------------------------------

// CreateSessionResponse

// string session_handle = 1;
inline void CreateSessionResponse::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& CreateSessionResponse::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionResponse.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateSessionResponse::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CreateSessionResponse.session_handle)
}
inline std::string* CreateSessionResponse::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionResponse.session_handle)
  return _s;
}
inline const std::string& CreateSessionResponse::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void CreateSessionResponse::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* CreateSessionResponse::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* CreateSessionResponse::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionResponse.session_handle)
  return _impl_.session_handle_.Release();
}
inline void CreateSessionResponse::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionResponse.session_handle)
}

// int64 graph_version = 2;
inline void CreateSessionResponse::clear_graph_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_version_ = ::int64_t{0};
}
inline ::int64_t CreateSessionResponse::graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionResponse.graph_version)
  return _internal_graph_version();
}
inline void CreateSessionResponse::set_graph_version(::int64_t value) {
  _internal_set_graph_version(value);
  // @@protoc_insertion_point(field_set:tensorflow.CreateSessionResponse.graph_version)
}
inline ::int64_t CreateSessionResponse::_internal_graph_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.graph_version_;
}
inline void CreateSessionResponse::_internal_set_graph_version(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.graph_version_ = value;
}

// -------------------------------------------------------------------

// ExtendSessionRequest

// string session_handle = 1;
inline void ExtendSessionRequest::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& ExtendSessionRequest::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExtendSessionRequest::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionRequest.session_handle)
}
inline std::string* ExtendSessionRequest::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.ExtendSessionRequest.session_handle)
  return _s;
}
inline const std::string& ExtendSessionRequest::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void ExtendSessionRequest::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* ExtendSessionRequest::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* ExtendSessionRequest::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ExtendSessionRequest.session_handle)
  return _impl_.session_handle_.Release();
}
inline void ExtendSessionRequest::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ExtendSessionRequest.session_handle)
}

// .tensorflow.GraphDef graph_def = 2;
inline bool ExtendSessionRequest::has_graph_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.graph_def_ != nullptr);
  return value;
}
inline const ::tensorflow::GraphDef& ExtendSessionRequest::_internal_graph_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::GraphDef* p = _impl_.graph_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::GraphDef&>(::tensorflow::_GraphDef_default_instance_);
}
inline const ::tensorflow::GraphDef& ExtendSessionRequest::graph_def() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.graph_def)
  return _internal_graph_def();
}
inline void ExtendSessionRequest::unsafe_arena_set_allocated_graph_def(::tensorflow::GraphDef* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.graph_def_);
  }
  _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.ExtendSessionRequest.graph_def)
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::release_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::GraphDef* released = _impl_.graph_def_;
  _impl_.graph_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::unsafe_arena_release_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ExtendSessionRequest.graph_def)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::GraphDef* temp = _impl_.graph_def_;
  _impl_.graph_def_ = nullptr;
  return temp;
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::_internal_mutable_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.graph_def_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::GraphDef>(GetArena());
    _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(p);
  }
  return _impl_.graph_def_;
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::mutable_graph_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::GraphDef* _msg = _internal_mutable_graph_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.ExtendSessionRequest.graph_def)
  return _msg;
}
inline void ExtendSessionRequest::set_allocated_graph_def(::tensorflow::GraphDef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.graph_def_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ExtendSessionRequest.graph_def)
}

// int64 current_graph_version = 3;
inline void ExtendSessionRequest::clear_current_graph_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_graph_version_ = ::int64_t{0};
}
inline ::int64_t ExtendSessionRequest::current_graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.current_graph_version)
  return _internal_current_graph_version();
}
inline void ExtendSessionRequest::set_current_graph_version(::int64_t value) {
  _internal_set_current_graph_version(value);
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionRequest.current_graph_version)
}
inline ::int64_t ExtendSessionRequest::_internal_current_graph_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_graph_version_;
}
inline void ExtendSessionRequest::_internal_set_current_graph_version(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_graph_version_ = value;
}

// -------------------------------------------------------------------

// ExtendSessionResponse

// int64 new_graph_version = 4;
inline void ExtendSessionResponse::clear_new_graph_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_graph_version_ = ::int64_t{0};
}
inline ::int64_t ExtendSessionResponse::new_graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionResponse.new_graph_version)
  return _internal_new_graph_version();
}
inline void ExtendSessionResponse::set_new_graph_version(::int64_t value) {
  _internal_set_new_graph_version(value);
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionResponse.new_graph_version)
}
inline ::int64_t ExtendSessionResponse::_internal_new_graph_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_graph_version_;
}
inline void ExtendSessionResponse::_internal_set_new_graph_version(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_graph_version_ = value;
}

// -------------------------------------------------------------------

// RunStepRequest

// string session_handle = 1;
inline void RunStepRequest::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& RunStepRequest::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RunStepRequest::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.session_handle)
}
inline std::string* RunStepRequest::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.session_handle)
  return _s;
}
inline const std::string& RunStepRequest::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void RunStepRequest::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* RunStepRequest::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* RunStepRequest::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.RunStepRequest.session_handle)
  return _impl_.session_handle_.Release();
}
inline void RunStepRequest::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepRequest.session_handle)
}

// repeated .tensorflow.NamedTensorProto feed = 2;
inline int RunStepRequest::_internal_feed_size() const {
  return _internal_feed().size();
}
inline int RunStepRequest::feed_size() const {
  return _internal_feed_size();
}
inline ::tensorflow::NamedTensorProto* RunStepRequest::mutable_feed(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.feed)
  return _internal_mutable_feed()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>* RunStepRequest::mutable_feed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.feed)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_feed();
}
inline const ::tensorflow::NamedTensorProto& RunStepRequest::feed(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.feed)
  return _internal_feed().Get(index);
}
inline ::tensorflow::NamedTensorProto* RunStepRequest::add_feed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::NamedTensorProto* _add = _internal_mutable_feed()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.feed)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>& RunStepRequest::feed() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.feed)
  return _internal_feed();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>&
RunStepRequest::_internal_feed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feed_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>*
RunStepRequest::_internal_mutable_feed() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.feed_;
}

// repeated string fetch = 3;
inline int RunStepRequest::_internal_fetch_size() const {
  return _internal_fetch().size();
}
inline int RunStepRequest::fetch_size() const {
  return _internal_fetch_size();
}
inline void RunStepRequest::clear_fetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fetch_.Clear();
}
inline std::string* RunStepRequest::add_fetch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_fetch()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunStepRequest.fetch)
  return _s;
}
inline const std::string& RunStepRequest::fetch(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.fetch)
  return _internal_fetch().Get(index);
}
inline std::string* RunStepRequest::mutable_fetch(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.fetch)
  return _internal_mutable_fetch()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RunStepRequest::set_fetch(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_fetch()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.fetch)
}
template <typename Arg_, typename... Args_>
inline void RunStepRequest::add_fetch(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_fetch(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.fetch)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RunStepRequest::fetch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.fetch)
  return _internal_fetch();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RunStepRequest::mutable_fetch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.fetch)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fetch();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RunStepRequest::_internal_fetch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fetch_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RunStepRequest::_internal_mutable_fetch() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fetch_;
}

// repeated string target = 4;
inline int RunStepRequest::_internal_target_size() const {
  return _internal_target().size();
}
inline int RunStepRequest::target_size() const {
  return _internal_target_size();
}
inline void RunStepRequest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Clear();
}
inline std::string* RunStepRequest::add_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_target()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunStepRequest.target)
  return _s;
}
inline const std::string& RunStepRequest::target(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.target)
  return _internal_target().Get(index);
}
inline std::string* RunStepRequest::mutable_target(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.target)
  return _internal_mutable_target()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RunStepRequest::set_target(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_target()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.target)
}
template <typename Arg_, typename... Args_>
inline void RunStepRequest::add_target(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_target(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.target)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RunStepRequest::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.target)
  return _internal_target();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RunStepRequest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.target)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_target();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RunStepRequest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RunStepRequest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.target_;
}

// .tensorflow.RunOptions options = 5;
inline bool RunStepRequest::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline const ::tensorflow::RunOptions& RunStepRequest::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::RunOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::RunOptions&>(::tensorflow::_RunOptions_default_instance_);
}
inline const ::tensorflow::RunOptions& RunStepRequest::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.options)
  return _internal_options();
}
inline void RunStepRequest::unsafe_arena_set_allocated_options(::tensorflow::RunOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::tensorflow::RunOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RunStepRequest.options)
}
inline ::tensorflow::RunOptions* RunStepRequest::release_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::RunOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::RunOptions* RunStepRequest::unsafe_arena_release_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.RunStepRequest.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::RunOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::tensorflow::RunOptions* RunStepRequest::_internal_mutable_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::RunOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::tensorflow::RunOptions*>(p);
  }
  return _impl_.options_;
}
inline ::tensorflow::RunOptions* RunStepRequest::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::RunOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.options)
  return _msg;
}
inline void RunStepRequest::set_allocated_options(::tensorflow::RunOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::tensorflow::RunOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepRequest.options)
}

// string partial_run_handle = 6;
inline void RunStepRequest::clear_partial_run_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_run_handle_.ClearToEmpty();
}
inline const std::string& RunStepRequest::partial_run_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.partial_run_handle)
  return _internal_partial_run_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RunStepRequest::set_partial_run_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_run_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.partial_run_handle)
}
inline std::string* RunStepRequest::mutable_partial_run_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_partial_run_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.partial_run_handle)
  return _s;
}
inline const std::string& RunStepRequest::_internal_partial_run_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partial_run_handle_.Get();
}
inline void RunStepRequest::_internal_set_partial_run_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_run_handle_.Set(value, GetArena());
}
inline std::string* RunStepRequest::_internal_mutable_partial_run_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.partial_run_handle_.Mutable( GetArena());
}
inline std::string* RunStepRequest::release_partial_run_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.RunStepRequest.partial_run_handle)
  return _impl_.partial_run_handle_.Release();
}
inline void RunStepRequest::set_allocated_partial_run_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_run_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.partial_run_handle_.IsDefault()) {
          _impl_.partial_run_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepRequest.partial_run_handle)
}

// bool store_errors_in_response_body = 7;
inline void RunStepRequest::clear_store_errors_in_response_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.store_errors_in_response_body_ = false;
}
inline bool RunStepRequest::store_errors_in_response_body() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.store_errors_in_response_body)
  return _internal_store_errors_in_response_body();
}
inline void RunStepRequest::set_store_errors_in_response_body(bool value) {
  _internal_set_store_errors_in_response_body(value);
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.store_errors_in_response_body)
}
inline bool RunStepRequest::_internal_store_errors_in_response_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.store_errors_in_response_body_;
}
inline void RunStepRequest::_internal_set_store_errors_in_response_body(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.store_errors_in_response_body_ = value;
}

// int64 request_id = 8;
inline void RunStepRequest::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = ::int64_t{0};
}
inline ::int64_t RunStepRequest::request_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.request_id)
  return _internal_request_id();
}
inline void RunStepRequest::set_request_id(::int64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.request_id)
}
inline ::int64_t RunStepRequest::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_;
}
inline void RunStepRequest::_internal_set_request_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// RunStepResponse

// repeated .tensorflow.NamedTensorProto tensor = 1;
inline int RunStepResponse::_internal_tensor_size() const {
  return _internal_tensor().size();
}
inline int RunStepResponse::tensor_size() const {
  return _internal_tensor_size();
}
inline ::tensorflow::NamedTensorProto* RunStepResponse::mutable_tensor(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepResponse.tensor)
  return _internal_mutable_tensor()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>* RunStepResponse::mutable_tensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepResponse.tensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tensor();
}
inline const ::tensorflow::NamedTensorProto& RunStepResponse::tensor(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.tensor)
  return _internal_tensor().Get(index);
}
inline ::tensorflow::NamedTensorProto* RunStepResponse::add_tensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::NamedTensorProto* _add = _internal_mutable_tensor()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.RunStepResponse.tensor)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>& RunStepResponse::tensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepResponse.tensor)
  return _internal_tensor();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>&
RunStepResponse::_internal_tensor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tensor_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::NamedTensorProto>*
RunStepResponse::_internal_mutable_tensor() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tensor_;
}

// .tensorflow.RunMetadata metadata = 2;
inline bool RunStepResponse::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::tensorflow::RunMetadata& RunStepResponse::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::RunMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::RunMetadata&>(::tensorflow::_RunMetadata_default_instance_);
}
inline const ::tensorflow::RunMetadata& RunStepResponse::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.metadata)
  return _internal_metadata();
}
inline void RunStepResponse::unsafe_arena_set_allocated_metadata(::tensorflow::RunMetadata* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::tensorflow::RunMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RunStepResponse.metadata)
}
inline ::tensorflow::RunMetadata* RunStepResponse::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::RunMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::RunMetadata* RunStepResponse::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.RunStepResponse.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::RunMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::tensorflow::RunMetadata* RunStepResponse::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::RunMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::tensorflow::RunMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::tensorflow::RunMetadata* RunStepResponse::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::RunMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepResponse.metadata)
  return _msg;
}
inline void RunStepResponse::set_allocated_metadata(::tensorflow::RunMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::tensorflow::RunMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepResponse.metadata)
}

// .tensorflow.error.Code status_code = 3;
inline void RunStepResponse::clear_status_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_code_ = 0;
}
inline ::tensorflow::error::Code RunStepResponse::status_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.status_code)
  return _internal_status_code();
}
inline void RunStepResponse::set_status_code(::tensorflow::error::Code value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:tensorflow.RunStepResponse.status_code)
}
inline ::tensorflow::error::Code RunStepResponse::_internal_status_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::error::Code>(_impl_.status_code_);
}
inline void RunStepResponse::_internal_set_status_code(::tensorflow::error::Code value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_code_ = value;
}

// string status_error_message = 4;
inline void RunStepResponse::clear_status_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_error_message_.ClearToEmpty();
}
inline const std::string& RunStepResponse::status_error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.status_error_message)
  return _internal_status_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RunStepResponse::set_status_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.RunStepResponse.status_error_message)
}
inline std::string* RunStepResponse::mutable_status_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status_error_message();
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepResponse.status_error_message)
  return _s;
}
inline const std::string& RunStepResponse::_internal_status_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_error_message_.Get();
}
inline void RunStepResponse::_internal_set_status_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_error_message_.Set(value, GetArena());
}
inline std::string* RunStepResponse::_internal_mutable_status_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_error_message_.Mutable( GetArena());
}
inline std::string* RunStepResponse::release_status_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.RunStepResponse.status_error_message)
  return _impl_.status_error_message_.Release();
}
inline void RunStepResponse::set_allocated_status_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_error_message_.IsDefault()) {
          _impl_.status_error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepResponse.status_error_message)
}

// -------------------------------------------------------------------

// PartialRunSetupRequest

// string session_handle = 1;
inline void PartialRunSetupRequest::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& PartialRunSetupRequest::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartialRunSetupRequest::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.session_handle)
}
inline std::string* PartialRunSetupRequest::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupRequest.session_handle)
  return _s;
}
inline const std::string& PartialRunSetupRequest::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void PartialRunSetupRequest::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* PartialRunSetupRequest::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* PartialRunSetupRequest::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PartialRunSetupRequest.session_handle)
  return _impl_.session_handle_.Release();
}
inline void PartialRunSetupRequest::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PartialRunSetupRequest.session_handle)
}

// repeated string feed = 2;
inline int PartialRunSetupRequest::_internal_feed_size() const {
  return _internal_feed().size();
}
inline int PartialRunSetupRequest::feed_size() const {
  return _internal_feed_size();
}
inline void PartialRunSetupRequest::clear_feed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feed_.Clear();
}
inline std::string* PartialRunSetupRequest::add_feed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_feed()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.PartialRunSetupRequest.feed)
  return _s;
}
inline const std::string& PartialRunSetupRequest::feed(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.feed)
  return _internal_feed().Get(index);
}
inline std::string* PartialRunSetupRequest::mutable_feed(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupRequest.feed)
  return _internal_mutable_feed()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PartialRunSetupRequest::set_feed(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_feed()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.feed)
}
template <typename Arg_, typename... Args_>
inline void PartialRunSetupRequest::add_feed(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_feed(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.feed)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PartialRunSetupRequest::feed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.PartialRunSetupRequest.feed)
  return _internal_feed();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PartialRunSetupRequest::mutable_feed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.PartialRunSetupRequest.feed)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_feed();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PartialRunSetupRequest::_internal_feed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feed_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PartialRunSetupRequest::_internal_mutable_feed() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.feed_;
}

// repeated string fetch = 3;
inline int PartialRunSetupRequest::_internal_fetch_size() const {
  return _internal_fetch().size();
}
inline int PartialRunSetupRequest::fetch_size() const {
  return _internal_fetch_size();
}
inline void PartialRunSetupRequest::clear_fetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fetch_.Clear();
}
inline std::string* PartialRunSetupRequest::add_fetch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_fetch()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.PartialRunSetupRequest.fetch)
  return _s;
}
inline const std::string& PartialRunSetupRequest::fetch(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.fetch)
  return _internal_fetch().Get(index);
}
inline std::string* PartialRunSetupRequest::mutable_fetch(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupRequest.fetch)
  return _internal_mutable_fetch()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PartialRunSetupRequest::set_fetch(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_fetch()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.fetch)
}
template <typename Arg_, typename... Args_>
inline void PartialRunSetupRequest::add_fetch(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_fetch(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.fetch)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PartialRunSetupRequest::fetch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.PartialRunSetupRequest.fetch)
  return _internal_fetch();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PartialRunSetupRequest::mutable_fetch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.PartialRunSetupRequest.fetch)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fetch();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PartialRunSetupRequest::_internal_fetch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fetch_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PartialRunSetupRequest::_internal_mutable_fetch() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fetch_;
}

// repeated string target = 4;
inline int PartialRunSetupRequest::_internal_target_size() const {
  return _internal_target().size();
}
inline int PartialRunSetupRequest::target_size() const {
  return _internal_target_size();
}
inline void PartialRunSetupRequest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Clear();
}
inline std::string* PartialRunSetupRequest::add_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_target()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.PartialRunSetupRequest.target)
  return _s;
}
inline const std::string& PartialRunSetupRequest::target(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.target)
  return _internal_target().Get(index);
}
inline std::string* PartialRunSetupRequest::mutable_target(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupRequest.target)
  return _internal_mutable_target()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PartialRunSetupRequest::set_target(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_target()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.target)
}
template <typename Arg_, typename... Args_>
inline void PartialRunSetupRequest::add_target(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_target(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.target)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PartialRunSetupRequest::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.PartialRunSetupRequest.target)
  return _internal_target();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PartialRunSetupRequest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.PartialRunSetupRequest.target)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_target();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PartialRunSetupRequest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PartialRunSetupRequest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.target_;
}

// int64 request_id = 5;
inline void PartialRunSetupRequest::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = ::int64_t{0};
}
inline ::int64_t PartialRunSetupRequest::request_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.request_id)
  return _internal_request_id();
}
inline void PartialRunSetupRequest::set_request_id(::int64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.request_id)
}
inline ::int64_t PartialRunSetupRequest::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_;
}
inline void PartialRunSetupRequest::_internal_set_request_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// PartialRunSetupResponse

// string partial_run_handle = 1;
inline void PartialRunSetupResponse::clear_partial_run_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_run_handle_.ClearToEmpty();
}
inline const std::string& PartialRunSetupResponse::partial_run_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupResponse.partial_run_handle)
  return _internal_partial_run_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartialRunSetupResponse::set_partial_run_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_run_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupResponse.partial_run_handle)
}
inline std::string* PartialRunSetupResponse::mutable_partial_run_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_partial_run_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupResponse.partial_run_handle)
  return _s;
}
inline const std::string& PartialRunSetupResponse::_internal_partial_run_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partial_run_handle_.Get();
}
inline void PartialRunSetupResponse::_internal_set_partial_run_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_run_handle_.Set(value, GetArena());
}
inline std::string* PartialRunSetupResponse::_internal_mutable_partial_run_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.partial_run_handle_.Mutable( GetArena());
}
inline std::string* PartialRunSetupResponse::release_partial_run_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PartialRunSetupResponse.partial_run_handle)
  return _impl_.partial_run_handle_.Release();
}
inline void PartialRunSetupResponse::set_allocated_partial_run_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_run_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.partial_run_handle_.IsDefault()) {
          _impl_.partial_run_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PartialRunSetupResponse.partial_run_handle)
}

// -------------------------------------------------------------------

// CloseSessionRequest

// string session_handle = 1;
inline void CloseSessionRequest::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& CloseSessionRequest::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CloseSessionRequest.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloseSessionRequest::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CloseSessionRequest.session_handle)
}
inline std::string* CloseSessionRequest::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.CloseSessionRequest.session_handle)
  return _s;
}
inline const std::string& CloseSessionRequest::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void CloseSessionRequest::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* CloseSessionRequest::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* CloseSessionRequest::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CloseSessionRequest.session_handle)
  return _impl_.session_handle_.Release();
}
inline void CloseSessionRequest::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CloseSessionRequest.session_handle)
}

// -------------------------------------------------------------------

// CloseSessionResponse

// -------------------------------------------------------------------

// ResetRequest

// repeated string container = 1;
inline int ResetRequest::_internal_container_size() const {
  return _internal_container().size();
}
inline int ResetRequest::container_size() const {
  return _internal_container_size();
}
inline void ResetRequest::clear_container() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.container_.Clear();
}
inline std::string* ResetRequest::add_container() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_container()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.ResetRequest.container)
  return _s;
}
inline const std::string& ResetRequest::container(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ResetRequest.container)
  return _internal_container().Get(index);
}
inline std::string* ResetRequest::mutable_container(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.ResetRequest.container)
  return _internal_mutable_container()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ResetRequest::set_container(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_container()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.ResetRequest.container)
}
template <typename Arg_, typename... Args_>
inline void ResetRequest::add_container(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_container(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.ResetRequest.container)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ResetRequest::container() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.ResetRequest.container)
  return _internal_container();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ResetRequest::mutable_container() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ResetRequest.container)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_container();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ResetRequest::_internal_container() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.container_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ResetRequest::_internal_mutable_container() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.container_;
}

// repeated string device_filters = 2;
inline int ResetRequest::_internal_device_filters_size() const {
  return _internal_device_filters().size();
}
inline int ResetRequest::device_filters_size() const {
  return _internal_device_filters_size();
}
inline void ResetRequest::clear_device_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_filters_.Clear();
}
inline std::string* ResetRequest::add_device_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_device_filters()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.ResetRequest.device_filters)
  return _s;
}
inline const std::string& ResetRequest::device_filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ResetRequest.device_filters)
  return _internal_device_filters().Get(index);
}
inline std::string* ResetRequest::mutable_device_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.ResetRequest.device_filters)
  return _internal_mutable_device_filters()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ResetRequest::set_device_filters(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_device_filters()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.ResetRequest.device_filters)
}
template <typename Arg_, typename... Args_>
inline void ResetRequest::add_device_filters(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_device_filters(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.ResetRequest.device_filters)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ResetRequest::device_filters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.ResetRequest.device_filters)
  return _internal_device_filters();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ResetRequest::mutable_device_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ResetRequest.device_filters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_filters();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ResetRequest::_internal_device_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_filters_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ResetRequest::_internal_mutable_device_filters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_filters_;
}

// -------------------------------------------------------------------

// ResetResponse

// -------------------------------------------------------------------

// ListDevicesRequest

// string session_handle = 1;
inline void ListDevicesRequest::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& ListDevicesRequest::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ListDevicesRequest.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListDevicesRequest::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.ListDevicesRequest.session_handle)
}
inline std::string* ListDevicesRequest::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.ListDevicesRequest.session_handle)
  return _s;
}
inline const std::string& ListDevicesRequest::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void ListDevicesRequest::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* ListDevicesRequest::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* ListDevicesRequest::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ListDevicesRequest.session_handle)
  return _impl_.session_handle_.Release();
}
inline void ListDevicesRequest::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ListDevicesRequest.session_handle)
}

// -------------------------------------------------------------------

// ListDevicesResponse

// repeated .tensorflow.DeviceAttributes local_device = 1;
inline int ListDevicesResponse::_internal_local_device_size() const {
  return _internal_local_device().size();
}
inline int ListDevicesResponse::local_device_size() const {
  return _internal_local_device_size();
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::mutable_local_device(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.ListDevicesResponse.local_device)
  return _internal_mutable_local_device()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>* ListDevicesResponse::mutable_local_device()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ListDevicesResponse.local_device)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_local_device();
}
inline const ::tensorflow::DeviceAttributes& ListDevicesResponse::local_device(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ListDevicesResponse.local_device)
  return _internal_local_device().Get(index);
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::add_local_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::DeviceAttributes* _add = _internal_mutable_local_device()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.ListDevicesResponse.local_device)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>& ListDevicesResponse::local_device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.ListDevicesResponse.local_device)
  return _internal_local_device();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>&
ListDevicesResponse::_internal_local_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_device_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>*
ListDevicesResponse::_internal_mutable_local_device() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.local_device_;
}

// repeated .tensorflow.DeviceAttributes remote_device = 2;
inline int ListDevicesResponse::_internal_remote_device_size() const {
  return _internal_remote_device().size();
}
inline int ListDevicesResponse::remote_device_size() const {
  return _internal_remote_device_size();
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::mutable_remote_device(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.ListDevicesResponse.remote_device)
  return _internal_mutable_remote_device()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>* ListDevicesResponse::mutable_remote_device()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ListDevicesResponse.remote_device)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_remote_device();
}
inline const ::tensorflow::DeviceAttributes& ListDevicesResponse::remote_device(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ListDevicesResponse.remote_device)
  return _internal_remote_device().Get(index);
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::add_remote_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::DeviceAttributes* _add = _internal_mutable_remote_device()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.ListDevicesResponse.remote_device)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>& ListDevicesResponse::remote_device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.ListDevicesResponse.remote_device)
  return _internal_remote_device();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>&
ListDevicesResponse::_internal_remote_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_device_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::DeviceAttributes>*
ListDevicesResponse::_internal_mutable_remote_device() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.remote_device_;
}

// -------------------------------------------------------------------

// MakeCallableRequest

// string session_handle = 1;
inline void MakeCallableRequest::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& MakeCallableRequest::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MakeCallableRequest.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MakeCallableRequest::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.MakeCallableRequest.session_handle)
}
inline std::string* MakeCallableRequest::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.MakeCallableRequest.session_handle)
  return _s;
}
inline const std::string& MakeCallableRequest::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void MakeCallableRequest::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* MakeCallableRequest::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* MakeCallableRequest::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MakeCallableRequest.session_handle)
  return _impl_.session_handle_.Release();
}
inline void MakeCallableRequest::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MakeCallableRequest.session_handle)
}

// .tensorflow.CallableOptions options = 2;
inline bool MakeCallableRequest::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline const ::tensorflow::CallableOptions& MakeCallableRequest::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CallableOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CallableOptions&>(::tensorflow::_CallableOptions_default_instance_);
}
inline const ::tensorflow::CallableOptions& MakeCallableRequest::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MakeCallableRequest.options)
  return _internal_options();
}
inline void MakeCallableRequest::unsafe_arena_set_allocated_options(::tensorflow::CallableOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::tensorflow::CallableOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MakeCallableRequest.options)
}
inline ::tensorflow::CallableOptions* MakeCallableRequest::release_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CallableOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CallableOptions* MakeCallableRequest::unsafe_arena_release_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MakeCallableRequest.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::CallableOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::tensorflow::CallableOptions* MakeCallableRequest::_internal_mutable_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CallableOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::tensorflow::CallableOptions*>(p);
  }
  return _impl_.options_;
}
inline ::tensorflow::CallableOptions* MakeCallableRequest::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::CallableOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:tensorflow.MakeCallableRequest.options)
  return _msg;
}
inline void MakeCallableRequest::set_allocated_options(::tensorflow::CallableOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::tensorflow::CallableOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MakeCallableRequest.options)
}

// int64 request_id = 3;
inline void MakeCallableRequest::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = ::int64_t{0};
}
inline ::int64_t MakeCallableRequest::request_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.MakeCallableRequest.request_id)
  return _internal_request_id();
}
inline void MakeCallableRequest::set_request_id(::int64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.MakeCallableRequest.request_id)
}
inline ::int64_t MakeCallableRequest::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_;
}
inline void MakeCallableRequest::_internal_set_request_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// MakeCallableResponse

// int64 handle = 1;
inline void MakeCallableResponse::clear_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handle_ = ::int64_t{0};
}
inline ::int64_t MakeCallableResponse::handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.MakeCallableResponse.handle)
  return _internal_handle();
}
inline void MakeCallableResponse::set_handle(::int64_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:tensorflow.MakeCallableResponse.handle)
}
inline ::int64_t MakeCallableResponse::_internal_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.handle_;
}
inline void MakeCallableResponse::_internal_set_handle(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handle_ = value;
}

// -------------------------------------------------------------------

// RunCallableRequest

// string session_handle = 1;
inline void RunCallableRequest::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& RunCallableRequest::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunCallableRequest.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RunCallableRequest::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.RunCallableRequest.session_handle)
}
inline std::string* RunCallableRequest::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.RunCallableRequest.session_handle)
  return _s;
}
inline const std::string& RunCallableRequest::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void RunCallableRequest::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* RunCallableRequest::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* RunCallableRequest::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.RunCallableRequest.session_handle)
  return _impl_.session_handle_.Release();
}
inline void RunCallableRequest::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunCallableRequest.session_handle)
}

// int64 handle = 2;
inline void RunCallableRequest::clear_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handle_ = ::int64_t{0};
}
inline ::int64_t RunCallableRequest::handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunCallableRequest.handle)
  return _internal_handle();
}
inline void RunCallableRequest::set_handle(::int64_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:tensorflow.RunCallableRequest.handle)
}
inline ::int64_t RunCallableRequest::_internal_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.handle_;
}
inline void RunCallableRequest::_internal_set_handle(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handle_ = value;
}

// repeated .tensorflow.TensorProto feed = 3;
inline int RunCallableRequest::_internal_feed_size() const {
  return _internal_feed().size();
}
inline int RunCallableRequest::feed_size() const {
  return _internal_feed_size();
}
inline ::tensorflow::TensorProto* RunCallableRequest::mutable_feed(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunCallableRequest.feed)
  return _internal_mutable_feed()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* RunCallableRequest::mutable_feed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunCallableRequest.feed)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_feed();
}
inline const ::tensorflow::TensorProto& RunCallableRequest::feed(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunCallableRequest.feed)
  return _internal_feed().Get(index);
}
inline ::tensorflow::TensorProto* RunCallableRequest::add_feed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::TensorProto* _add = _internal_mutable_feed()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.RunCallableRequest.feed)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& RunCallableRequest::feed() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.RunCallableRequest.feed)
  return _internal_feed();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>&
RunCallableRequest::_internal_feed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feed_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>*
RunCallableRequest::_internal_mutable_feed() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.feed_;
}

// int64 request_id = 4;
inline void RunCallableRequest::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = ::int64_t{0};
}
inline ::int64_t RunCallableRequest::request_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunCallableRequest.request_id)
  return _internal_request_id();
}
inline void RunCallableRequest::set_request_id(::int64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.RunCallableRequest.request_id)
}
inline ::int64_t RunCallableRequest::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_;
}
inline void RunCallableRequest::_internal_set_request_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// RunCallableResponse

// repeated .tensorflow.TensorProto fetch = 1;
inline int RunCallableResponse::_internal_fetch_size() const {
  return _internal_fetch().size();
}
inline int RunCallableResponse::fetch_size() const {
  return _internal_fetch_size();
}
inline ::tensorflow::TensorProto* RunCallableResponse::mutable_fetch(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunCallableResponse.fetch)
  return _internal_mutable_fetch()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>* RunCallableResponse::mutable_fetch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunCallableResponse.fetch)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fetch();
}
inline const ::tensorflow::TensorProto& RunCallableResponse::fetch(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunCallableResponse.fetch)
  return _internal_fetch().Get(index);
}
inline ::tensorflow::TensorProto* RunCallableResponse::add_fetch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::TensorProto* _add = _internal_mutable_fetch()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.RunCallableResponse.fetch)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>& RunCallableResponse::fetch() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.RunCallableResponse.fetch)
  return _internal_fetch();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>&
RunCallableResponse::_internal_fetch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fetch_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TensorProto>*
RunCallableResponse::_internal_mutable_fetch() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fetch_;
}

// .tensorflow.RunMetadata metadata = 2;
inline bool RunCallableResponse::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::tensorflow::RunMetadata& RunCallableResponse::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::RunMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::RunMetadata&>(::tensorflow::_RunMetadata_default_instance_);
}
inline const ::tensorflow::RunMetadata& RunCallableResponse::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunCallableResponse.metadata)
  return _internal_metadata();
}
inline void RunCallableResponse::unsafe_arena_set_allocated_metadata(::tensorflow::RunMetadata* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::tensorflow::RunMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RunCallableResponse.metadata)
}
inline ::tensorflow::RunMetadata* RunCallableResponse::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::RunMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::RunMetadata* RunCallableResponse::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.RunCallableResponse.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::RunMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::tensorflow::RunMetadata* RunCallableResponse::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::RunMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::tensorflow::RunMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::tensorflow::RunMetadata* RunCallableResponse::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::RunMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:tensorflow.RunCallableResponse.metadata)
  return _msg;
}
inline void RunCallableResponse::set_allocated_metadata(::tensorflow::RunMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::tensorflow::RunMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunCallableResponse.metadata)
}

// -------------------------------------------------------------------

// ReleaseCallableRequest

// string session_handle = 1;
inline void ReleaseCallableRequest::clear_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.ClearToEmpty();
}
inline const std::string& ReleaseCallableRequest::session_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ReleaseCallableRequest.session_handle)
  return _internal_session_handle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReleaseCallableRequest::set_session_handle(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.ReleaseCallableRequest.session_handle)
}
inline std::string* ReleaseCallableRequest::mutable_session_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:tensorflow.ReleaseCallableRequest.session_handle)
  return _s;
}
inline const std::string& ReleaseCallableRequest::_internal_session_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_handle_.Get();
}
inline void ReleaseCallableRequest::_internal_set_session_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.Set(value, GetArena());
}
inline std::string* ReleaseCallableRequest::_internal_mutable_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_handle_.Mutable( GetArena());
}
inline std::string* ReleaseCallableRequest::release_session_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.ReleaseCallableRequest.session_handle)
  return _impl_.session_handle_.Release();
}
inline void ReleaseCallableRequest::set_allocated_session_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_handle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_handle_.IsDefault()) {
          _impl_.session_handle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReleaseCallableRequest.session_handle)
}

// int64 handle = 2;
inline void ReleaseCallableRequest::clear_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handle_ = ::int64_t{0};
}
inline ::int64_t ReleaseCallableRequest::handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReleaseCallableRequest.handle)
  return _internal_handle();
}
inline void ReleaseCallableRequest::set_handle(::int64_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:tensorflow.ReleaseCallableRequest.handle)
}
inline ::int64_t ReleaseCallableRequest::_internal_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.handle_;
}
inline void ReleaseCallableRequest::_internal_set_handle(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handle_ = value;
}

// -------------------------------------------------------------------

// ReleaseCallableResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tensorflow


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto_2epb_2eh
