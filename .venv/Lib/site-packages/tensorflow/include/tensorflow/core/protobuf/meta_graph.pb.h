// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: tensorflow/core/protobuf/meta_graph.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/framework/op_def.pb.h"
#include "tensorflow/core/framework/tensor.pb.h"
#include "tensorflow/core/framework/tensor_shape.pb.h"
#include "tensorflow/core/framework/types.pb.h"
#include "tensorflow/core/protobuf/saved_object_graph.pb.h"
#include "tensorflow/core/protobuf/saver.pb.h"
#include "tensorflow/core/protobuf/struct.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
namespace tensorflow {
class AssetFileDef;
struct AssetFileDefDefaultTypeInternal;
PROTOBUF_EXPORT extern AssetFileDefDefaultTypeInternal _AssetFileDef_default_instance_;
class CollectionDef;
struct CollectionDefDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectionDefDefaultTypeInternal _CollectionDef_default_instance_;
class CollectionDef_AnyList;
struct CollectionDef_AnyListDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectionDef_AnyListDefaultTypeInternal _CollectionDef_AnyList_default_instance_;
class CollectionDef_BytesList;
struct CollectionDef_BytesListDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectionDef_BytesListDefaultTypeInternal _CollectionDef_BytesList_default_instance_;
class CollectionDef_FloatList;
struct CollectionDef_FloatListDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectionDef_FloatListDefaultTypeInternal _CollectionDef_FloatList_default_instance_;
class CollectionDef_Int64List;
struct CollectionDef_Int64ListDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectionDef_Int64ListDefaultTypeInternal _CollectionDef_Int64List_default_instance_;
class CollectionDef_NodeList;
struct CollectionDef_NodeListDefaultTypeInternal;
PROTOBUF_EXPORT extern CollectionDef_NodeListDefaultTypeInternal _CollectionDef_NodeList_default_instance_;
class MetaGraphDef;
struct MetaGraphDefDefaultTypeInternal;
PROTOBUF_EXPORT extern MetaGraphDefDefaultTypeInternal _MetaGraphDef_default_instance_;
class MetaGraphDef_CollectionDefEntry_DoNotUse;
struct MetaGraphDef_CollectionDefEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern MetaGraphDef_CollectionDefEntry_DoNotUseDefaultTypeInternal _MetaGraphDef_CollectionDefEntry_DoNotUse_default_instance_;
class MetaGraphDef_MetaInfoDef;
struct MetaGraphDef_MetaInfoDefDefaultTypeInternal;
PROTOBUF_EXPORT extern MetaGraphDef_MetaInfoDefDefaultTypeInternal _MetaGraphDef_MetaInfoDef_default_instance_;
class MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse;
struct MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUseDefaultTypeInternal _MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse_default_instance_;
class MetaGraphDef_SignatureDefEntry_DoNotUse;
struct MetaGraphDef_SignatureDefEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern MetaGraphDef_SignatureDefEntry_DoNotUseDefaultTypeInternal _MetaGraphDef_SignatureDefEntry_DoNotUse_default_instance_;
class SignatureDef;
struct SignatureDefDefaultTypeInternal;
PROTOBUF_EXPORT extern SignatureDefDefaultTypeInternal _SignatureDef_default_instance_;
class SignatureDef_DefaultsEntry_DoNotUse;
struct SignatureDef_DefaultsEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern SignatureDef_DefaultsEntry_DoNotUseDefaultTypeInternal _SignatureDef_DefaultsEntry_DoNotUse_default_instance_;
class SignatureDef_InputsEntry_DoNotUse;
struct SignatureDef_InputsEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern SignatureDef_InputsEntry_DoNotUseDefaultTypeInternal _SignatureDef_InputsEntry_DoNotUse_default_instance_;
class SignatureDef_OutputsEntry_DoNotUse;
struct SignatureDef_OutputsEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern SignatureDef_OutputsEntry_DoNotUseDefaultTypeInternal _SignatureDef_OutputsEntry_DoNotUse_default_instance_;
class TensorInfo;
struct TensorInfoDefaultTypeInternal;
PROTOBUF_EXPORT extern TensorInfoDefaultTypeInternal _TensorInfo_default_instance_;
class TensorInfo_CompositeTensor;
struct TensorInfo_CompositeTensorDefaultTypeInternal;
PROTOBUF_EXPORT extern TensorInfo_CompositeTensorDefaultTypeInternal _TensorInfo_CompositeTensor_default_instance_;
class TensorInfo_CooSparse;
struct TensorInfo_CooSparseDefaultTypeInternal;
PROTOBUF_EXPORT extern TensorInfo_CooSparseDefaultTypeInternal _TensorInfo_CooSparse_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT TensorInfo_CooSparse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TensorInfo.CooSparse) */ {
 public:
  inline TensorInfo_CooSparse() : TensorInfo_CooSparse(nullptr) {}
  ~TensorInfo_CooSparse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TensorInfo_CooSparse(
      ::google::protobuf::internal::ConstantInitialized);

  inline TensorInfo_CooSparse(const TensorInfo_CooSparse& from) : TensorInfo_CooSparse(nullptr, from) {}
  inline TensorInfo_CooSparse(TensorInfo_CooSparse&& from) noexcept
      : TensorInfo_CooSparse(nullptr, std::move(from)) {}
  inline TensorInfo_CooSparse& operator=(const TensorInfo_CooSparse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorInfo_CooSparse& operator=(TensorInfo_CooSparse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorInfo_CooSparse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorInfo_CooSparse* internal_default_instance() {
    return reinterpret_cast<const TensorInfo_CooSparse*>(
        &_TensorInfo_CooSparse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(TensorInfo_CooSparse& a, TensorInfo_CooSparse& b) { a.Swap(&b); }
  inline void Swap(TensorInfo_CooSparse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorInfo_CooSparse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorInfo_CooSparse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TensorInfo_CooSparse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorInfo_CooSparse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TensorInfo_CooSparse& from) { TensorInfo_CooSparse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorInfo_CooSparse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TensorInfo.CooSparse"; }

 protected:
  explicit TensorInfo_CooSparse(::google::protobuf::Arena* arena);
  TensorInfo_CooSparse(::google::protobuf::Arena* arena, const TensorInfo_CooSparse& from);
  TensorInfo_CooSparse(::google::protobuf::Arena* arena, TensorInfo_CooSparse&& from) noexcept
      : TensorInfo_CooSparse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesTensorNameFieldNumber = 1,
    kIndicesTensorNameFieldNumber = 2,
    kDenseShapeTensorNameFieldNumber = 3,
  };
  // string values_tensor_name = 1;
  void clear_values_tensor_name() ;
  const std::string& values_tensor_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_values_tensor_name(Arg_&& arg, Args_... args);
  std::string* mutable_values_tensor_name();
  PROTOBUF_NODISCARD std::string* release_values_tensor_name();
  void set_allocated_values_tensor_name(std::string* value);

  private:
  const std::string& _internal_values_tensor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_values_tensor_name(
      const std::string& value);
  std::string* _internal_mutable_values_tensor_name();

  public:
  // string indices_tensor_name = 2;
  void clear_indices_tensor_name() ;
  const std::string& indices_tensor_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_indices_tensor_name(Arg_&& arg, Args_... args);
  std::string* mutable_indices_tensor_name();
  PROTOBUF_NODISCARD std::string* release_indices_tensor_name();
  void set_allocated_indices_tensor_name(std::string* value);

  private:
  const std::string& _internal_indices_tensor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_indices_tensor_name(
      const std::string& value);
  std::string* _internal_mutable_indices_tensor_name();

  public:
  // string dense_shape_tensor_name = 3;
  void clear_dense_shape_tensor_name() ;
  const std::string& dense_shape_tensor_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dense_shape_tensor_name(Arg_&& arg, Args_... args);
  std::string* mutable_dense_shape_tensor_name();
  PROTOBUF_NODISCARD std::string* release_dense_shape_tensor_name();
  void set_allocated_dense_shape_tensor_name(std::string* value);

  private:
  const std::string& _internal_dense_shape_tensor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dense_shape_tensor_name(
      const std::string& value);
  std::string* _internal_mutable_dense_shape_tensor_name();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.TensorInfo.CooSparse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      100, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TensorInfo_CooSparse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr values_tensor_name_;
    ::google::protobuf::internal::ArenaStringPtr indices_tensor_name_;
    ::google::protobuf::internal::ArenaStringPtr dense_shape_tensor_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse*>(
        &_MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectionDef_NodeList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.NodeList) */ {
 public:
  inline CollectionDef_NodeList() : CollectionDef_NodeList(nullptr) {}
  ~CollectionDef_NodeList() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionDef_NodeList(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectionDef_NodeList(const CollectionDef_NodeList& from) : CollectionDef_NodeList(nullptr, from) {}
  inline CollectionDef_NodeList(CollectionDef_NodeList&& from) noexcept
      : CollectionDef_NodeList(nullptr, std::move(from)) {}
  inline CollectionDef_NodeList& operator=(const CollectionDef_NodeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionDef_NodeList& operator=(CollectionDef_NodeList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionDef_NodeList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionDef_NodeList* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_NodeList*>(
        &_CollectionDef_NodeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CollectionDef_NodeList& a, CollectionDef_NodeList& b) { a.Swap(&b); }
  inline void Swap(CollectionDef_NodeList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionDef_NodeList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionDef_NodeList* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectionDef_NodeList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionDef_NodeList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionDef_NodeList& from) { CollectionDef_NodeList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectionDef_NodeList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CollectionDef.NodeList"; }

 protected:
  explicit CollectionDef_NodeList(::google::protobuf::Arena* arena);
  CollectionDef_NodeList(::google::protobuf::Arena* arena, const CollectionDef_NodeList& from);
  CollectionDef_NodeList(::google::protobuf::Arena* arena, CollectionDef_NodeList&& from) noexcept
      : CollectionDef_NodeList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated string value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(int index, Arg_&& value, Args_... args);
  std::string* add_value();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_value(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.NodeList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      47, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectionDef_NodeList& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectionDef_Int64List final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.Int64List) */ {
 public:
  inline CollectionDef_Int64List() : CollectionDef_Int64List(nullptr) {}
  ~CollectionDef_Int64List() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionDef_Int64List(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectionDef_Int64List(const CollectionDef_Int64List& from) : CollectionDef_Int64List(nullptr, from) {}
  inline CollectionDef_Int64List(CollectionDef_Int64List&& from) noexcept
      : CollectionDef_Int64List(nullptr, std::move(from)) {}
  inline CollectionDef_Int64List& operator=(const CollectionDef_Int64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionDef_Int64List& operator=(CollectionDef_Int64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionDef_Int64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionDef_Int64List* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_Int64List*>(
        &_CollectionDef_Int64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CollectionDef_Int64List& a, CollectionDef_Int64List& b) { a.Swap(&b); }
  inline void Swap(CollectionDef_Int64List* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionDef_Int64List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionDef_Int64List* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectionDef_Int64List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionDef_Int64List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionDef_Int64List& from) { CollectionDef_Int64List::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectionDef_Int64List* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CollectionDef.Int64List"; }

 protected:
  explicit CollectionDef_Int64List(::google::protobuf::Arena* arena);
  CollectionDef_Int64List(::google::protobuf::Arena* arena, const CollectionDef_Int64List& from);
  CollectionDef_Int64List(::google::protobuf::Arena* arena, CollectionDef_Int64List&& from) noexcept
      : CollectionDef_Int64List(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated int64 value = 1 [packed = true];
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  ::int64_t value(int index) const;
  void set_value(int index, ::int64_t value);
  void add_value(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& value() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_value();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_value() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.Int64List)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectionDef_Int64List& from_msg);
    ::google::protobuf::RepeatedField<::int64_t> value_;
    mutable ::google::protobuf::internal::CachedSize _value_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectionDef_FloatList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.FloatList) */ {
 public:
  inline CollectionDef_FloatList() : CollectionDef_FloatList(nullptr) {}
  ~CollectionDef_FloatList() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionDef_FloatList(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectionDef_FloatList(const CollectionDef_FloatList& from) : CollectionDef_FloatList(nullptr, from) {}
  inline CollectionDef_FloatList(CollectionDef_FloatList&& from) noexcept
      : CollectionDef_FloatList(nullptr, std::move(from)) {}
  inline CollectionDef_FloatList& operator=(const CollectionDef_FloatList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionDef_FloatList& operator=(CollectionDef_FloatList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionDef_FloatList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionDef_FloatList* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_FloatList*>(
        &_CollectionDef_FloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CollectionDef_FloatList& a, CollectionDef_FloatList& b) { a.Swap(&b); }
  inline void Swap(CollectionDef_FloatList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionDef_FloatList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionDef_FloatList* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectionDef_FloatList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionDef_FloatList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionDef_FloatList& from) { CollectionDef_FloatList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectionDef_FloatList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CollectionDef.FloatList"; }

 protected:
  explicit CollectionDef_FloatList(::google::protobuf::Arena* arena);
  CollectionDef_FloatList(::google::protobuf::Arena* arena, const CollectionDef_FloatList& from);
  CollectionDef_FloatList(::google::protobuf::Arena* arena, CollectionDef_FloatList&& from) noexcept
      : CollectionDef_FloatList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated float value = 1 [packed = true];
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField<float>& value() const;
  ::google::protobuf::RepeatedField<float>* mutable_value();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_value() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.FloatList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectionDef_FloatList& from_msg);
    ::google::protobuf::RepeatedField<float> value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectionDef_BytesList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.BytesList) */ {
 public:
  inline CollectionDef_BytesList() : CollectionDef_BytesList(nullptr) {}
  ~CollectionDef_BytesList() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionDef_BytesList(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectionDef_BytesList(const CollectionDef_BytesList& from) : CollectionDef_BytesList(nullptr, from) {}
  inline CollectionDef_BytesList(CollectionDef_BytesList&& from) noexcept
      : CollectionDef_BytesList(nullptr, std::move(from)) {}
  inline CollectionDef_BytesList& operator=(const CollectionDef_BytesList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionDef_BytesList& operator=(CollectionDef_BytesList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionDef_BytesList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionDef_BytesList* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_BytesList*>(
        &_CollectionDef_BytesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CollectionDef_BytesList& a, CollectionDef_BytesList& b) { a.Swap(&b); }
  inline void Swap(CollectionDef_BytesList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionDef_BytesList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionDef_BytesList* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectionDef_BytesList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionDef_BytesList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionDef_BytesList& from) { CollectionDef_BytesList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectionDef_BytesList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CollectionDef.BytesList"; }

 protected:
  explicit CollectionDef_BytesList(::google::protobuf::Arena* arena);
  CollectionDef_BytesList(::google::protobuf::Arena* arena, const CollectionDef_BytesList& from);
  CollectionDef_BytesList(::google::protobuf::Arena* arena, CollectionDef_BytesList&& from) noexcept
      : CollectionDef_BytesList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated bytes value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(int index, Arg_&& value, Args_... args);
  std::string* add_value();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_value(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.BytesList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectionDef_BytesList& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectionDef_AnyList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.AnyList) */ {
 public:
  inline CollectionDef_AnyList() : CollectionDef_AnyList(nullptr) {}
  ~CollectionDef_AnyList() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionDef_AnyList(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectionDef_AnyList(const CollectionDef_AnyList& from) : CollectionDef_AnyList(nullptr, from) {}
  inline CollectionDef_AnyList(CollectionDef_AnyList&& from) noexcept
      : CollectionDef_AnyList(nullptr, std::move(from)) {}
  inline CollectionDef_AnyList& operator=(const CollectionDef_AnyList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionDef_AnyList& operator=(CollectionDef_AnyList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionDef_AnyList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionDef_AnyList* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_AnyList*>(
        &_CollectionDef_AnyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CollectionDef_AnyList& a, CollectionDef_AnyList& b) { a.Swap(&b); }
  inline void Swap(CollectionDef_AnyList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionDef_AnyList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionDef_AnyList* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectionDef_AnyList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionDef_AnyList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionDef_AnyList& from) { CollectionDef_AnyList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectionDef_AnyList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CollectionDef.AnyList"; }

 protected:
  explicit CollectionDef_AnyList(::google::protobuf::Arena* arena);
  CollectionDef_AnyList(::google::protobuf::Arena* arena, const CollectionDef_AnyList& from);
  CollectionDef_AnyList(::google::protobuf::Arena* arena, CollectionDef_AnyList&& from) noexcept
      : CollectionDef_AnyList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .google.protobuf.Any value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  ::google::protobuf::Any* mutable_value(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_value();
  public:
  const ::google::protobuf::Any& value(int index) const;
  ::google::protobuf::Any* add_value();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& value() const;
  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.AnyList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectionDef_AnyList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CollectionDef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef) */ {
 public:
  inline CollectionDef() : CollectionDef(nullptr) {}
  ~CollectionDef() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionDef(
      ::google::protobuf::internal::ConstantInitialized);

  inline CollectionDef(const CollectionDef& from) : CollectionDef(nullptr, from) {}
  inline CollectionDef(CollectionDef&& from) noexcept
      : CollectionDef(nullptr, std::move(from)) {}
  inline CollectionDef& operator=(const CollectionDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionDef& operator=(CollectionDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionDef& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kNodeList = 1,
    kBytesList = 2,
    kInt64List = 3,
    kFloatList = 4,
    kAnyList = 5,
    KIND_NOT_SET = 0,
  };
  static inline const CollectionDef* internal_default_instance() {
    return reinterpret_cast<const CollectionDef*>(
        &_CollectionDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(CollectionDef& a, CollectionDef& b) { a.Swap(&b); }
  inline void Swap(CollectionDef* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionDef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionDef* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CollectionDef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionDef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CollectionDef& from) { CollectionDef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectionDef* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CollectionDef"; }

 protected:
  explicit CollectionDef(::google::protobuf::Arena* arena);
  CollectionDef(::google::protobuf::Arena* arena, const CollectionDef& from);
  CollectionDef(::google::protobuf::Arena* arena, CollectionDef&& from) noexcept
      : CollectionDef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NodeList = CollectionDef_NodeList;
  using BytesList = CollectionDef_BytesList;
  using Int64List = CollectionDef_Int64List;
  using FloatList = CollectionDef_FloatList;
  using AnyList = CollectionDef_AnyList;

  // accessors -------------------------------------------------------
  enum : int {
    kNodeListFieldNumber = 1,
    kBytesListFieldNumber = 2,
    kInt64ListFieldNumber = 3,
    kFloatListFieldNumber = 4,
    kAnyListFieldNumber = 5,
  };
  // .tensorflow.CollectionDef.NodeList node_list = 1;
  bool has_node_list() const;
  private:
  bool _internal_has_node_list() const;

  public:
  void clear_node_list() ;
  const ::tensorflow::CollectionDef_NodeList& node_list() const;
  PROTOBUF_NODISCARD ::tensorflow::CollectionDef_NodeList* release_node_list();
  ::tensorflow::CollectionDef_NodeList* mutable_node_list();
  void set_allocated_node_list(::tensorflow::CollectionDef_NodeList* value);
  void unsafe_arena_set_allocated_node_list(::tensorflow::CollectionDef_NodeList* value);
  ::tensorflow::CollectionDef_NodeList* unsafe_arena_release_node_list();

  private:
  const ::tensorflow::CollectionDef_NodeList& _internal_node_list() const;
  ::tensorflow::CollectionDef_NodeList* _internal_mutable_node_list();

  public:
  // .tensorflow.CollectionDef.BytesList bytes_list = 2;
  bool has_bytes_list() const;
  private:
  bool _internal_has_bytes_list() const;

  public:
  void clear_bytes_list() ;
  const ::tensorflow::CollectionDef_BytesList& bytes_list() const;
  PROTOBUF_NODISCARD ::tensorflow::CollectionDef_BytesList* release_bytes_list();
  ::tensorflow::CollectionDef_BytesList* mutable_bytes_list();
  void set_allocated_bytes_list(::tensorflow::CollectionDef_BytesList* value);
  void unsafe_arena_set_allocated_bytes_list(::tensorflow::CollectionDef_BytesList* value);
  ::tensorflow::CollectionDef_BytesList* unsafe_arena_release_bytes_list();

  private:
  const ::tensorflow::CollectionDef_BytesList& _internal_bytes_list() const;
  ::tensorflow::CollectionDef_BytesList* _internal_mutable_bytes_list();

  public:
  // .tensorflow.CollectionDef.Int64List int64_list = 3;
  bool has_int64_list() const;
  private:
  bool _internal_has_int64_list() const;

  public:
  void clear_int64_list() ;
  const ::tensorflow::CollectionDef_Int64List& int64_list() const;
  PROTOBUF_NODISCARD ::tensorflow::CollectionDef_Int64List* release_int64_list();
  ::tensorflow::CollectionDef_Int64List* mutable_int64_list();
  void set_allocated_int64_list(::tensorflow::CollectionDef_Int64List* value);
  void unsafe_arena_set_allocated_int64_list(::tensorflow::CollectionDef_Int64List* value);
  ::tensorflow::CollectionDef_Int64List* unsafe_arena_release_int64_list();

  private:
  const ::tensorflow::CollectionDef_Int64List& _internal_int64_list() const;
  ::tensorflow::CollectionDef_Int64List* _internal_mutable_int64_list();

  public:
  // .tensorflow.CollectionDef.FloatList float_list = 4;
  bool has_float_list() const;
  private:
  bool _internal_has_float_list() const;

  public:
  void clear_float_list() ;
  const ::tensorflow::CollectionDef_FloatList& float_list() const;
  PROTOBUF_NODISCARD ::tensorflow::CollectionDef_FloatList* release_float_list();
  ::tensorflow::CollectionDef_FloatList* mutable_float_list();
  void set_allocated_float_list(::tensorflow::CollectionDef_FloatList* value);
  void unsafe_arena_set_allocated_float_list(::tensorflow::CollectionDef_FloatList* value);
  ::tensorflow::CollectionDef_FloatList* unsafe_arena_release_float_list();

  private:
  const ::tensorflow::CollectionDef_FloatList& _internal_float_list() const;
  ::tensorflow::CollectionDef_FloatList* _internal_mutable_float_list();

  public:
  // .tensorflow.CollectionDef.AnyList any_list = 5;
  bool has_any_list() const;
  private:
  bool _internal_has_any_list() const;

  public:
  void clear_any_list() ;
  const ::tensorflow::CollectionDef_AnyList& any_list() const;
  PROTOBUF_NODISCARD ::tensorflow::CollectionDef_AnyList* release_any_list();
  ::tensorflow::CollectionDef_AnyList* mutable_any_list();
  void set_allocated_any_list(::tensorflow::CollectionDef_AnyList* value);
  void unsafe_arena_set_allocated_any_list(::tensorflow::CollectionDef_AnyList* value);
  ::tensorflow::CollectionDef_AnyList* unsafe_arena_release_any_list();

  private:
  const ::tensorflow::CollectionDef_AnyList& _internal_any_list() const;
  ::tensorflow::CollectionDef_AnyList* _internal_mutable_any_list();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef)
 private:
  class _Internal;
  void set_has_node_list();
  void set_has_bytes_list();
  void set_has_int64_list();
  void set_has_float_list();
  void set_has_any_list();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CollectionDef& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tensorflow::CollectionDef_NodeList* node_list_;
      ::tensorflow::CollectionDef_BytesList* bytes_list_;
      ::tensorflow::CollectionDef_Int64List* int64_list_;
      ::tensorflow::CollectionDef_FloatList* float_list_;
      ::tensorflow::CollectionDef_AnyList* any_list_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class MetaGraphDef_CollectionDefEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          MetaGraphDef_CollectionDefEntry_DoNotUse, std::string, ::tensorflow::CollectionDef,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      MetaGraphDef_CollectionDefEntry_DoNotUse, std::string, ::tensorflow::CollectionDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  MetaGraphDef_CollectionDefEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MetaGraphDef_CollectionDefEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MetaGraphDef_CollectionDefEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MetaGraphDef_CollectionDefEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MetaGraphDef_CollectionDefEntry_DoNotUse*>(
        &_MetaGraphDef_CollectionDefEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      54, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class SignatureDef_DefaultsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SignatureDef_DefaultsEntry_DoNotUse, std::string, ::tensorflow::TensorProto,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SignatureDef_DefaultsEntry_DoNotUse, std::string, ::tensorflow::TensorProto,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SignatureDef_DefaultsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignatureDef_DefaultsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SignatureDef_DefaultsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SignatureDef_DefaultsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SignatureDef_DefaultsEntry_DoNotUse*>(
        &_SignatureDef_DefaultsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      49, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TensorInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TensorInfo) */ {
 public:
  inline TensorInfo() : TensorInfo(nullptr) {}
  ~TensorInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TensorInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline TensorInfo(const TensorInfo& from) : TensorInfo(nullptr, from) {}
  inline TensorInfo(TensorInfo&& from) noexcept
      : TensorInfo(nullptr, std::move(from)) {}
  inline TensorInfo& operator=(const TensorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorInfo& operator=(TensorInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorInfo& default_instance() {
    return *internal_default_instance();
  }
  enum EncodingCase {
    kName = 1,
    kCooSparse = 4,
    kCompositeTensor = 5,
    ENCODING_NOT_SET = 0,
  };
  static inline const TensorInfo* internal_default_instance() {
    return reinterpret_cast<const TensorInfo*>(
        &_TensorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(TensorInfo& a, TensorInfo& b) { a.Swap(&b); }
  inline void Swap(TensorInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TensorInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TensorInfo& from) { TensorInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TensorInfo"; }

 protected:
  explicit TensorInfo(::google::protobuf::Arena* arena);
  TensorInfo(::google::protobuf::Arena* arena, const TensorInfo& from);
  TensorInfo(::google::protobuf::Arena* arena, TensorInfo&& from) noexcept
      : TensorInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using CooSparse = TensorInfo_CooSparse;
  using CompositeTensor = TensorInfo_CompositeTensor;

  // accessors -------------------------------------------------------
  enum : int {
    kTensorShapeFieldNumber = 3,
    kDtypeFieldNumber = 2,
    kNameFieldNumber = 1,
    kCooSparseFieldNumber = 4,
    kCompositeTensorFieldNumber = 5,
  };
  // .tensorflow.TensorShapeProto tensor_shape = 3;
  bool has_tensor_shape() const;
  void clear_tensor_shape() ;
  const ::tensorflow::TensorShapeProto& tensor_shape() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorShapeProto* release_tensor_shape();
  ::tensorflow::TensorShapeProto* mutable_tensor_shape();
  void set_allocated_tensor_shape(::tensorflow::TensorShapeProto* value);
  void unsafe_arena_set_allocated_tensor_shape(::tensorflow::TensorShapeProto* value);
  ::tensorflow::TensorShapeProto* unsafe_arena_release_tensor_shape();

  private:
  const ::tensorflow::TensorShapeProto& _internal_tensor_shape() const;
  ::tensorflow::TensorShapeProto* _internal_mutable_tensor_shape();

  public:
  // .tensorflow.DataType dtype = 2;
  void clear_dtype() ;
  ::tensorflow::DataType dtype() const;
  void set_dtype(::tensorflow::DataType value);

  private:
  ::tensorflow::DataType _internal_dtype() const;
  void _internal_set_dtype(::tensorflow::DataType value);

  public:
  // string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .tensorflow.TensorInfo.CooSparse coo_sparse = 4;
  bool has_coo_sparse() const;
  private:
  bool _internal_has_coo_sparse() const;

  public:
  void clear_coo_sparse() ;
  const ::tensorflow::TensorInfo_CooSparse& coo_sparse() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorInfo_CooSparse* release_coo_sparse();
  ::tensorflow::TensorInfo_CooSparse* mutable_coo_sparse();
  void set_allocated_coo_sparse(::tensorflow::TensorInfo_CooSparse* value);
  void unsafe_arena_set_allocated_coo_sparse(::tensorflow::TensorInfo_CooSparse* value);
  ::tensorflow::TensorInfo_CooSparse* unsafe_arena_release_coo_sparse();

  private:
  const ::tensorflow::TensorInfo_CooSparse& _internal_coo_sparse() const;
  ::tensorflow::TensorInfo_CooSparse* _internal_mutable_coo_sparse();

  public:
  // .tensorflow.TensorInfo.CompositeTensor composite_tensor = 5;
  bool has_composite_tensor() const;
  private:
  bool _internal_has_composite_tensor() const;

  public:
  void clear_composite_tensor() ;
  const ::tensorflow::TensorInfo_CompositeTensor& composite_tensor() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorInfo_CompositeTensor* release_composite_tensor();
  ::tensorflow::TensorInfo_CompositeTensor* mutable_composite_tensor();
  void set_allocated_composite_tensor(::tensorflow::TensorInfo_CompositeTensor* value);
  void unsafe_arena_set_allocated_composite_tensor(::tensorflow::TensorInfo_CompositeTensor* value);
  ::tensorflow::TensorInfo_CompositeTensor* unsafe_arena_release_composite_tensor();

  private:
  const ::tensorflow::TensorInfo_CompositeTensor& _internal_composite_tensor() const;
  ::tensorflow::TensorInfo_CompositeTensor* _internal_mutable_composite_tensor();

  public:
  void clear_encoding();
  EncodingCase encoding_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.TensorInfo)
 private:
  class _Internal;
  void set_has_name();
  void set_has_coo_sparse();
  void set_has_composite_tensor();
  inline bool has_encoding() const;
  inline void clear_has_encoding();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 5, 3,
      34, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TensorInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::TensorShapeProto* tensor_shape_;
    int dtype_;
    union EncodingUnion {
      constexpr EncodingUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr name_;
      ::tensorflow::TensorInfo_CooSparse* coo_sparse_;
      ::tensorflow::TensorInfo_CompositeTensor* composite_tensor_;
    } encoding_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TensorInfo_CompositeTensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TensorInfo.CompositeTensor) */ {
 public:
  inline TensorInfo_CompositeTensor() : TensorInfo_CompositeTensor(nullptr) {}
  ~TensorInfo_CompositeTensor() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TensorInfo_CompositeTensor(
      ::google::protobuf::internal::ConstantInitialized);

  inline TensorInfo_CompositeTensor(const TensorInfo_CompositeTensor& from) : TensorInfo_CompositeTensor(nullptr, from) {}
  inline TensorInfo_CompositeTensor(TensorInfo_CompositeTensor&& from) noexcept
      : TensorInfo_CompositeTensor(nullptr, std::move(from)) {}
  inline TensorInfo_CompositeTensor& operator=(const TensorInfo_CompositeTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorInfo_CompositeTensor& operator=(TensorInfo_CompositeTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorInfo_CompositeTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorInfo_CompositeTensor* internal_default_instance() {
    return reinterpret_cast<const TensorInfo_CompositeTensor*>(
        &_TensorInfo_CompositeTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(TensorInfo_CompositeTensor& a, TensorInfo_CompositeTensor& b) { a.Swap(&b); }
  inline void Swap(TensorInfo_CompositeTensor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorInfo_CompositeTensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorInfo_CompositeTensor* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TensorInfo_CompositeTensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorInfo_CompositeTensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TensorInfo_CompositeTensor& from) { TensorInfo_CompositeTensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorInfo_CompositeTensor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TensorInfo.CompositeTensor"; }

 protected:
  explicit TensorInfo_CompositeTensor(::google::protobuf::Arena* arena);
  TensorInfo_CompositeTensor(::google::protobuf::Arena* arena, const TensorInfo_CompositeTensor& from);
  TensorInfo_CompositeTensor(::google::protobuf::Arena* arena, TensorInfo_CompositeTensor&& from) noexcept
      : TensorInfo_CompositeTensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentsFieldNumber = 2,
    kTypeSpecFieldNumber = 1,
  };
  // repeated .tensorflow.TensorInfo components = 2;
  int components_size() const;
  private:
  int _internal_components_size() const;

  public:
  void clear_components() ;
  ::tensorflow::TensorInfo* mutable_components(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::TensorInfo>* mutable_components();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorInfo>& _internal_components() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::TensorInfo>* _internal_mutable_components();
  public:
  const ::tensorflow::TensorInfo& components(int index) const;
  ::tensorflow::TensorInfo* add_components();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorInfo>& components() const;
  // .tensorflow.TypeSpecProto type_spec = 1;
  bool has_type_spec() const;
  void clear_type_spec() ;
  const ::tensorflow::TypeSpecProto& type_spec() const;
  PROTOBUF_NODISCARD ::tensorflow::TypeSpecProto* release_type_spec();
  ::tensorflow::TypeSpecProto* mutable_type_spec();
  void set_allocated_type_spec(::tensorflow::TypeSpecProto* value);
  void unsafe_arena_set_allocated_type_spec(::tensorflow::TypeSpecProto* value);
  ::tensorflow::TypeSpecProto* unsafe_arena_release_type_spec();

  private:
  const ::tensorflow::TypeSpecProto& _internal_type_spec() const;
  ::tensorflow::TypeSpecProto* _internal_mutable_type_spec();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.TensorInfo.CompositeTensor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TensorInfo_CompositeTensor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorInfo > components_;
    ::tensorflow::TypeSpecProto* type_spec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class SignatureDef_OutputsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SignatureDef_OutputsEntry_DoNotUse, std::string, ::tensorflow::TensorInfo,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SignatureDef_OutputsEntry_DoNotUse, std::string, ::tensorflow::TensorInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SignatureDef_OutputsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignatureDef_OutputsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SignatureDef_OutputsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SignatureDef_OutputsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SignatureDef_OutputsEntry_DoNotUse*>(
        &_SignatureDef_OutputsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      48, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class SignatureDef_InputsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SignatureDef_InputsEntry_DoNotUse, std::string, ::tensorflow::TensorInfo,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SignatureDef_InputsEntry_DoNotUse, std::string, ::tensorflow::TensorInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SignatureDef_InputsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignatureDef_InputsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SignatureDef_InputsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SignatureDef_InputsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SignatureDef_InputsEntry_DoNotUse*>(
        &_SignatureDef_InputsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      47, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT AssetFileDef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.AssetFileDef) */ {
 public:
  inline AssetFileDef() : AssetFileDef(nullptr) {}
  ~AssetFileDef() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssetFileDef(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssetFileDef(const AssetFileDef& from) : AssetFileDef(nullptr, from) {}
  inline AssetFileDef(AssetFileDef&& from) noexcept
      : AssetFileDef(nullptr, std::move(from)) {}
  inline AssetFileDef& operator=(const AssetFileDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetFileDef& operator=(AssetFileDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetFileDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetFileDef* internal_default_instance() {
    return reinterpret_cast<const AssetFileDef*>(
        &_AssetFileDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(AssetFileDef& a, AssetFileDef& b) { a.Swap(&b); }
  inline void Swap(AssetFileDef* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetFileDef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetFileDef* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AssetFileDef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssetFileDef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssetFileDef& from) { AssetFileDef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssetFileDef* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.AssetFileDef"; }

 protected:
  explicit AssetFileDef(::google::protobuf::Arena* arena);
  AssetFileDef(::google::protobuf::Arena* arena, const AssetFileDef& from);
  AssetFileDef(::google::protobuf::Arena* arena, AssetFileDef&& from) noexcept
      : AssetFileDef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilenameFieldNumber = 2,
    kTensorInfoFieldNumber = 1,
  };
  // string filename = 2;
  void clear_filename() ;
  const std::string& filename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename(Arg_&& arg, Args_... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* value);

  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(
      const std::string& value);
  std::string* _internal_mutable_filename();

  public:
  // .tensorflow.TensorInfo tensor_info = 1;
  bool has_tensor_info() const;
  void clear_tensor_info() ;
  const ::tensorflow::TensorInfo& tensor_info() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorInfo* release_tensor_info();
  ::tensorflow::TensorInfo* mutable_tensor_info();
  void set_allocated_tensor_info(::tensorflow::TensorInfo* value);
  void unsafe_arena_set_allocated_tensor_info(::tensorflow::TensorInfo* value);
  ::tensorflow::TensorInfo* unsafe_arena_release_tensor_info();

  private:
  const ::tensorflow::TensorInfo& _internal_tensor_info() const;
  ::tensorflow::TensorInfo* _internal_mutable_tensor_info();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.AssetFileDef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      40, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssetFileDef& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filename_;
    ::tensorflow::TensorInfo* tensor_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SignatureDef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SignatureDef) */ {
 public:
  inline SignatureDef() : SignatureDef(nullptr) {}
  ~SignatureDef() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignatureDef(
      ::google::protobuf::internal::ConstantInitialized);

  inline SignatureDef(const SignatureDef& from) : SignatureDef(nullptr, from) {}
  inline SignatureDef(SignatureDef&& from) noexcept
      : SignatureDef(nullptr, std::move(from)) {}
  inline SignatureDef& operator=(const SignatureDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureDef& operator=(SignatureDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureDef* internal_default_instance() {
    return reinterpret_cast<const SignatureDef*>(
        &_SignatureDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(SignatureDef& a, SignatureDef& b) { a.Swap(&b); }
  inline void Swap(SignatureDef* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureDef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignatureDef* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SignatureDef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignatureDef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignatureDef& from) { SignatureDef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignatureDef* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SignatureDef"; }

 protected:
  explicit SignatureDef(::google::protobuf::Arena* arena);
  SignatureDef(::google::protobuf::Arena* arena, const SignatureDef& from);
  SignatureDef(::google::protobuf::Arena* arena, SignatureDef&& from) noexcept
      : SignatureDef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 1,
    kOutputsFieldNumber = 2,
    kDefaultsFieldNumber = 4,
    kMethodNameFieldNumber = 3,
  };
  // map<string, .tensorflow.TensorInfo> inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>& inputs() const;
  ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>* mutable_inputs();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>& _internal_inputs() const;
  ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>* _internal_mutable_inputs();

  public:
  // map<string, .tensorflow.TensorInfo> outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>& outputs() const;
  ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>* mutable_outputs();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>& _internal_outputs() const;
  ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>* _internal_mutable_outputs();

  public:
  // map<string, .tensorflow.TensorProto> defaults = 4;
  int defaults_size() const;
  private:
  int _internal_defaults_size() const;

  public:
  void clear_defaults() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::TensorProto>& defaults() const;
  ::google::protobuf::Map<std::string, ::tensorflow::TensorProto>* mutable_defaults();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::TensorProto>& _internal_defaults() const;
  ::google::protobuf::Map<std::string, ::tensorflow::TensorProto>* _internal_mutable_defaults();

  public:
  // string method_name = 3;
  void clear_method_name() ;
  const std::string& method_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_method_name(Arg_&& arg, Args_... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* value);

  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(
      const std::string& value);
  std::string* _internal_mutable_method_name();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SignatureDef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 6,
      64, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SignatureDef& from_msg);
    ::google::protobuf::internal::MapField<SignatureDef_InputsEntry_DoNotUse, std::string, ::tensorflow::TensorInfo,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        inputs_;
    ::google::protobuf::internal::MapField<SignatureDef_OutputsEntry_DoNotUse, std::string, ::tensorflow::TensorInfo,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        outputs_;
    ::google::protobuf::internal::MapField<SignatureDef_DefaultsEntry_DoNotUse, std::string, ::tensorflow::TensorProto,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        defaults_;
    ::google::protobuf::internal::ArenaStringPtr method_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MetaGraphDef_MetaInfoDef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.MetaGraphDef.MetaInfoDef) */ {
 public:
  inline MetaGraphDef_MetaInfoDef() : MetaGraphDef_MetaInfoDef(nullptr) {}
  ~MetaGraphDef_MetaInfoDef() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MetaGraphDef_MetaInfoDef(
      ::google::protobuf::internal::ConstantInitialized);

  inline MetaGraphDef_MetaInfoDef(const MetaGraphDef_MetaInfoDef& from) : MetaGraphDef_MetaInfoDef(nullptr, from) {}
  inline MetaGraphDef_MetaInfoDef(MetaGraphDef_MetaInfoDef&& from) noexcept
      : MetaGraphDef_MetaInfoDef(nullptr, std::move(from)) {}
  inline MetaGraphDef_MetaInfoDef& operator=(const MetaGraphDef_MetaInfoDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaGraphDef_MetaInfoDef& operator=(MetaGraphDef_MetaInfoDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaGraphDef_MetaInfoDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaGraphDef_MetaInfoDef* internal_default_instance() {
    return reinterpret_cast<const MetaGraphDef_MetaInfoDef*>(
        &_MetaGraphDef_MetaInfoDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(MetaGraphDef_MetaInfoDef& a, MetaGraphDef_MetaInfoDef& b) { a.Swap(&b); }
  inline void Swap(MetaGraphDef_MetaInfoDef* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaGraphDef_MetaInfoDef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetaGraphDef_MetaInfoDef* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MetaGraphDef_MetaInfoDef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MetaGraphDef_MetaInfoDef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MetaGraphDef_MetaInfoDef& from) { MetaGraphDef_MetaInfoDef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MetaGraphDef_MetaInfoDef* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.MetaGraphDef.MetaInfoDef"; }

 protected:
  explicit MetaGraphDef_MetaInfoDef(::google::protobuf::Arena* arena);
  MetaGraphDef_MetaInfoDef(::google::protobuf::Arena* arena, const MetaGraphDef_MetaInfoDef& from);
  MetaGraphDef_MetaInfoDef(::google::protobuf::Arena* arena, MetaGraphDef_MetaInfoDef&& from) noexcept
      : MetaGraphDef_MetaInfoDef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTagsFieldNumber = 4,
    kFunctionAliasesFieldNumber = 8,
    kMetaGraphVersionFieldNumber = 1,
    kTensorflowVersionFieldNumber = 5,
    kTensorflowGitVersionFieldNumber = 6,
    kStrippedOpListFieldNumber = 2,
    kAnyInfoFieldNumber = 3,
    kStrippedDefaultAttrsFieldNumber = 7,
  };
  // repeated string tags = 4;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tags(int index, Arg_&& value, Args_... args);
  std::string* add_tags();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_tags(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // map<string, string> function_aliases = 8;
  int function_aliases_size() const;
  private:
  int _internal_function_aliases_size() const;

  public:
  void clear_function_aliases() ;
  const ::google::protobuf::Map<std::string, std::string>& function_aliases() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_function_aliases();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_function_aliases() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_function_aliases();

  public:
  // string meta_graph_version = 1;
  void clear_meta_graph_version() ;
  const std::string& meta_graph_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_meta_graph_version(Arg_&& arg, Args_... args);
  std::string* mutable_meta_graph_version();
  PROTOBUF_NODISCARD std::string* release_meta_graph_version();
  void set_allocated_meta_graph_version(std::string* value);

  private:
  const std::string& _internal_meta_graph_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meta_graph_version(
      const std::string& value);
  std::string* _internal_mutable_meta_graph_version();

  public:
  // string tensorflow_version = 5;
  void clear_tensorflow_version() ;
  const std::string& tensorflow_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tensorflow_version(Arg_&& arg, Args_... args);
  std::string* mutable_tensorflow_version();
  PROTOBUF_NODISCARD std::string* release_tensorflow_version();
  void set_allocated_tensorflow_version(std::string* value);

  private:
  const std::string& _internal_tensorflow_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tensorflow_version(
      const std::string& value);
  std::string* _internal_mutable_tensorflow_version();

  public:
  // string tensorflow_git_version = 6;
  void clear_tensorflow_git_version() ;
  const std::string& tensorflow_git_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tensorflow_git_version(Arg_&& arg, Args_... args);
  std::string* mutable_tensorflow_git_version();
  PROTOBUF_NODISCARD std::string* release_tensorflow_git_version();
  void set_allocated_tensorflow_git_version(std::string* value);

  private:
  const std::string& _internal_tensorflow_git_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tensorflow_git_version(
      const std::string& value);
  std::string* _internal_mutable_tensorflow_git_version();

  public:
  // .tensorflow.OpList stripped_op_list = 2;
  bool has_stripped_op_list() const;
  void clear_stripped_op_list() ;
  const ::tensorflow::OpList& stripped_op_list() const;
  PROTOBUF_NODISCARD ::tensorflow::OpList* release_stripped_op_list();
  ::tensorflow::OpList* mutable_stripped_op_list();
  void set_allocated_stripped_op_list(::tensorflow::OpList* value);
  void unsafe_arena_set_allocated_stripped_op_list(::tensorflow::OpList* value);
  ::tensorflow::OpList* unsafe_arena_release_stripped_op_list();

  private:
  const ::tensorflow::OpList& _internal_stripped_op_list() const;
  ::tensorflow::OpList* _internal_mutable_stripped_op_list();

  public:
  // .google.protobuf.Any any_info = 3;
  bool has_any_info() const;
  void clear_any_info() ;
  const ::google::protobuf::Any& any_info() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_any_info();
  ::google::protobuf::Any* mutable_any_info();
  void set_allocated_any_info(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_any_info(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_any_info();

  private:
  const ::google::protobuf::Any& _internal_any_info() const;
  ::google::protobuf::Any* _internal_mutable_any_info();

  public:
  // bool stripped_default_attrs = 7;
  void clear_stripped_default_attrs() ;
  bool stripped_default_attrs() const;
  void set_stripped_default_attrs(bool value);

  private:
  bool _internal_stripped_default_attrs() const;
  void _internal_set_stripped_default_attrs(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.MetaGraphDef.MetaInfoDef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      130, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MetaGraphDef_MetaInfoDef& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::internal::MapField<MetaGraphDef_MetaInfoDef_FunctionAliasesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        function_aliases_;
    ::google::protobuf::internal::ArenaStringPtr meta_graph_version_;
    ::google::protobuf::internal::ArenaStringPtr tensorflow_version_;
    ::google::protobuf::internal::ArenaStringPtr tensorflow_git_version_;
    ::tensorflow::OpList* stripped_op_list_;
    ::google::protobuf::Any* any_info_;
    bool stripped_default_attrs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class MetaGraphDef_SignatureDefEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          MetaGraphDef_SignatureDefEntry_DoNotUse, std::string, ::tensorflow::SignatureDef,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      MetaGraphDef_SignatureDefEntry_DoNotUse, std::string, ::tensorflow::SignatureDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  MetaGraphDef_SignatureDefEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MetaGraphDef_SignatureDefEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MetaGraphDef_SignatureDefEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MetaGraphDef_SignatureDefEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MetaGraphDef_SignatureDefEntry_DoNotUse*>(
        &_MetaGraphDef_SignatureDefEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      53, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MetaGraphDef final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.MetaGraphDef) */ {
 public:
  inline MetaGraphDef() : MetaGraphDef(nullptr) {}
  ~MetaGraphDef() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MetaGraphDef(
      ::google::protobuf::internal::ConstantInitialized);

  inline MetaGraphDef(const MetaGraphDef& from) : MetaGraphDef(nullptr, from) {}
  inline MetaGraphDef(MetaGraphDef&& from) noexcept
      : MetaGraphDef(nullptr, std::move(from)) {}
  inline MetaGraphDef& operator=(const MetaGraphDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaGraphDef& operator=(MetaGraphDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaGraphDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaGraphDef* internal_default_instance() {
    return reinterpret_cast<const MetaGraphDef*>(
        &_MetaGraphDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(MetaGraphDef& a, MetaGraphDef& b) { a.Swap(&b); }
  inline void Swap(MetaGraphDef* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaGraphDef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetaGraphDef* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MetaGraphDef>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MetaGraphDef& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MetaGraphDef& from) { MetaGraphDef::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MetaGraphDef* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.MetaGraphDef"; }

 protected:
  explicit MetaGraphDef(::google::protobuf::Arena* arena);
  MetaGraphDef(::google::protobuf::Arena* arena, const MetaGraphDef& from);
  MetaGraphDef(::google::protobuf::Arena* arena, MetaGraphDef&& from) noexcept
      : MetaGraphDef(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MetaInfoDef = MetaGraphDef_MetaInfoDef;

  // accessors -------------------------------------------------------
  enum : int {
    kCollectionDefFieldNumber = 4,
    kSignatureDefFieldNumber = 5,
    kAssetFileDefFieldNumber = 6,
    kMetaInfoDefFieldNumber = 1,
    kGraphDefFieldNumber = 2,
    kSaverDefFieldNumber = 3,
    kObjectGraphDefFieldNumber = 7,
  };
  // map<string, .tensorflow.CollectionDef> collection_def = 4;
  int collection_def_size() const;
  private:
  int _internal_collection_def_size() const;

  public:
  void clear_collection_def() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::CollectionDef>& collection_def() const;
  ::google::protobuf::Map<std::string, ::tensorflow::CollectionDef>* mutable_collection_def();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::CollectionDef>& _internal_collection_def() const;
  ::google::protobuf::Map<std::string, ::tensorflow::CollectionDef>* _internal_mutable_collection_def();

  public:
  // map<string, .tensorflow.SignatureDef> signature_def = 5;
  int signature_def_size() const;
  private:
  int _internal_signature_def_size() const;

  public:
  void clear_signature_def() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::SignatureDef>& signature_def() const;
  ::google::protobuf::Map<std::string, ::tensorflow::SignatureDef>* mutable_signature_def();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::SignatureDef>& _internal_signature_def() const;
  ::google::protobuf::Map<std::string, ::tensorflow::SignatureDef>* _internal_mutable_signature_def();

  public:
  // repeated .tensorflow.AssetFileDef asset_file_def = 6;
  int asset_file_def_size() const;
  private:
  int _internal_asset_file_def_size() const;

  public:
  void clear_asset_file_def() ;
  ::tensorflow::AssetFileDef* mutable_asset_file_def(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::AssetFileDef>* mutable_asset_file_def();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::AssetFileDef>& _internal_asset_file_def() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::AssetFileDef>* _internal_mutable_asset_file_def();
  public:
  const ::tensorflow::AssetFileDef& asset_file_def(int index) const;
  ::tensorflow::AssetFileDef* add_asset_file_def();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::AssetFileDef>& asset_file_def() const;
  // .tensorflow.MetaGraphDef.MetaInfoDef meta_info_def = 1;
  bool has_meta_info_def() const;
  void clear_meta_info_def() ;
  const ::tensorflow::MetaGraphDef_MetaInfoDef& meta_info_def() const;
  PROTOBUF_NODISCARD ::tensorflow::MetaGraphDef_MetaInfoDef* release_meta_info_def();
  ::tensorflow::MetaGraphDef_MetaInfoDef* mutable_meta_info_def();
  void set_allocated_meta_info_def(::tensorflow::MetaGraphDef_MetaInfoDef* value);
  void unsafe_arena_set_allocated_meta_info_def(::tensorflow::MetaGraphDef_MetaInfoDef* value);
  ::tensorflow::MetaGraphDef_MetaInfoDef* unsafe_arena_release_meta_info_def();

  private:
  const ::tensorflow::MetaGraphDef_MetaInfoDef& _internal_meta_info_def() const;
  ::tensorflow::MetaGraphDef_MetaInfoDef* _internal_mutable_meta_info_def();

  public:
  // .tensorflow.GraphDef graph_def = 2;
  bool has_graph_def() const;
  void clear_graph_def() ;
  const ::tensorflow::GraphDef& graph_def() const;
  PROTOBUF_NODISCARD ::tensorflow::GraphDef* release_graph_def();
  ::tensorflow::GraphDef* mutable_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* value);
  void unsafe_arena_set_allocated_graph_def(::tensorflow::GraphDef* value);
  ::tensorflow::GraphDef* unsafe_arena_release_graph_def();

  private:
  const ::tensorflow::GraphDef& _internal_graph_def() const;
  ::tensorflow::GraphDef* _internal_mutable_graph_def();

  public:
  // .tensorflow.SaverDef saver_def = 3;
  bool has_saver_def() const;
  void clear_saver_def() ;
  const ::tensorflow::SaverDef& saver_def() const;
  PROTOBUF_NODISCARD ::tensorflow::SaverDef* release_saver_def();
  ::tensorflow::SaverDef* mutable_saver_def();
  void set_allocated_saver_def(::tensorflow::SaverDef* value);
  void unsafe_arena_set_allocated_saver_def(::tensorflow::SaverDef* value);
  ::tensorflow::SaverDef* unsafe_arena_release_saver_def();

  private:
  const ::tensorflow::SaverDef& _internal_saver_def() const;
  ::tensorflow::SaverDef* _internal_mutable_saver_def();

  public:
  // .tensorflow.SavedObjectGraph object_graph_def = 7;
  bool has_object_graph_def() const;
  void clear_object_graph_def() ;
  const ::tensorflow::SavedObjectGraph& object_graph_def() const;
  PROTOBUF_NODISCARD ::tensorflow::SavedObjectGraph* release_object_graph_def();
  ::tensorflow::SavedObjectGraph* mutable_object_graph_def();
  void set_allocated_object_graph_def(::tensorflow::SavedObjectGraph* value);
  void unsafe_arena_set_allocated_object_graph_def(::tensorflow::SavedObjectGraph* value);
  ::tensorflow::SavedObjectGraph* unsafe_arena_release_object_graph_def();

  private:
  const ::tensorflow::SavedObjectGraph& _internal_object_graph_def() const;
  ::tensorflow::SavedObjectGraph* _internal_mutable_object_graph_def();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.MetaGraphDef)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 9,
      59, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MetaGraphDef& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<MetaGraphDef_CollectionDefEntry_DoNotUse, std::string, ::tensorflow::CollectionDef,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        collection_def_;
    ::google::protobuf::internal::MapField<MetaGraphDef_SignatureDefEntry_DoNotUse, std::string, ::tensorflow::SignatureDef,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        signature_def_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::AssetFileDef > asset_file_def_;
    ::tensorflow::MetaGraphDef_MetaInfoDef* meta_info_def_;
    ::tensorflow::GraphDef* graph_def_;
    ::tensorflow::SaverDef* saver_def_;
    ::tensorflow::SavedObjectGraph* object_graph_def_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetaGraphDef_MetaInfoDef

// string meta_graph_version = 1;
inline void MetaGraphDef_MetaInfoDef::clear_meta_graph_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_graph_version_.ClearToEmpty();
}
inline const std::string& MetaGraphDef_MetaInfoDef::meta_graph_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  return _internal_meta_graph_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetaGraphDef_MetaInfoDef::set_meta_graph_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_graph_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
inline std::string* MetaGraphDef_MetaInfoDef::mutable_meta_graph_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_meta_graph_version();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  return _s;
}
inline const std::string& MetaGraphDef_MetaInfoDef::_internal_meta_graph_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.meta_graph_version_.Get();
}
inline void MetaGraphDef_MetaInfoDef::_internal_set_meta_graph_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_graph_version_.Set(value, GetArena());
}
inline std::string* MetaGraphDef_MetaInfoDef::_internal_mutable_meta_graph_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.meta_graph_version_.Mutable( GetArena());
}
inline std::string* MetaGraphDef_MetaInfoDef::release_meta_graph_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  return _impl_.meta_graph_version_.Release();
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_meta_graph_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meta_graph_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.meta_graph_version_.IsDefault()) {
          _impl_.meta_graph_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}

// .tensorflow.OpList stripped_op_list = 2;
inline bool MetaGraphDef_MetaInfoDef::has_stripped_op_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stripped_op_list_ != nullptr);
  return value;
}
inline const ::tensorflow::OpList& MetaGraphDef_MetaInfoDef::_internal_stripped_op_list() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::OpList* p = _impl_.stripped_op_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::OpList&>(::tensorflow::_OpList_default_instance_);
}
inline const ::tensorflow::OpList& MetaGraphDef_MetaInfoDef::stripped_op_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
  return _internal_stripped_op_list();
}
inline void MetaGraphDef_MetaInfoDef::unsafe_arena_set_allocated_stripped_op_list(::tensorflow::OpList* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stripped_op_list_);
  }
  _impl_.stripped_op_list_ = reinterpret_cast<::tensorflow::OpList*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
}
inline ::tensorflow::OpList* MetaGraphDef_MetaInfoDef::release_stripped_op_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::OpList* released = _impl_.stripped_op_list_;
  _impl_.stripped_op_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::OpList* MetaGraphDef_MetaInfoDef::unsafe_arena_release_stripped_op_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::OpList* temp = _impl_.stripped_op_list_;
  _impl_.stripped_op_list_ = nullptr;
  return temp;
}
inline ::tensorflow::OpList* MetaGraphDef_MetaInfoDef::_internal_mutable_stripped_op_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stripped_op_list_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::OpList>(GetArena());
    _impl_.stripped_op_list_ = reinterpret_cast<::tensorflow::OpList*>(p);
  }
  return _impl_.stripped_op_list_;
}
inline ::tensorflow::OpList* MetaGraphDef_MetaInfoDef::mutable_stripped_op_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::OpList* _msg = _internal_mutable_stripped_op_list();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
  return _msg;
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_stripped_op_list(::tensorflow::OpList* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stripped_op_list_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stripped_op_list_ = reinterpret_cast<::tensorflow::OpList*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
}

// .google.protobuf.Any any_info = 3;
inline bool MetaGraphDef_MetaInfoDef::has_any_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.any_info_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& MetaGraphDef_MetaInfoDef::_internal_any_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.any_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& MetaGraphDef_MetaInfoDef::any_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
  return _internal_any_info();
}
inline void MetaGraphDef_MetaInfoDef::unsafe_arena_set_allocated_any_info(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.any_info_);
  }
  _impl_.any_info_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
}
inline ::google::protobuf::Any* MetaGraphDef_MetaInfoDef::release_any_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* released = _impl_.any_info_;
  _impl_.any_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* MetaGraphDef_MetaInfoDef::unsafe_arena_release_any_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.any_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* temp = _impl_.any_info_;
  _impl_.any_info_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* MetaGraphDef_MetaInfoDef::_internal_mutable_any_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.any_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.any_info_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.any_info_;
}
inline ::google::protobuf::Any* MetaGraphDef_MetaInfoDef::mutable_any_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Any* _msg = _internal_mutable_any_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
  return _msg;
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_any_info(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.any_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.any_info_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
}

// repeated string tags = 4;
inline int MetaGraphDef_MetaInfoDef::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int MetaGraphDef_MetaInfoDef::tags_size() const {
  return _internal_tags_size();
}
inline void MetaGraphDef_MetaInfoDef::clear_tags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tags_.Clear();
}
inline std::string* MetaGraphDef_MetaInfoDef::add_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return _s;
}
inline const std::string& MetaGraphDef_MetaInfoDef::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return _internal_tags().Get(index);
}
inline std::string* MetaGraphDef_MetaInfoDef::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return _internal_mutable_tags()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void MetaGraphDef_MetaInfoDef::set_tags(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_tags()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.tags)
}
template <typename Arg_, typename... Args_>
inline void MetaGraphDef_MetaInfoDef::add_tags(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_tags(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.MetaGraphDef.MetaInfoDef.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MetaGraphDef_MetaInfoDef::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MetaGraphDef_MetaInfoDef::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MetaGraphDef_MetaInfoDef::_internal_tags() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MetaGraphDef_MetaInfoDef::_internal_mutable_tags() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tags_;
}

// string tensorflow_version = 5;
inline void MetaGraphDef_MetaInfoDef::clear_tensorflow_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_version_.ClearToEmpty();
}
inline const std::string& MetaGraphDef_MetaInfoDef::tensorflow_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
  return _internal_tensorflow_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetaGraphDef_MetaInfoDef::set_tensorflow_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
}
inline std::string* MetaGraphDef_MetaInfoDef::mutable_tensorflow_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tensorflow_version();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
  return _s;
}
inline const std::string& MetaGraphDef_MetaInfoDef::_internal_tensorflow_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tensorflow_version_.Get();
}
inline void MetaGraphDef_MetaInfoDef::_internal_set_tensorflow_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_version_.Set(value, GetArena());
}
inline std::string* MetaGraphDef_MetaInfoDef::_internal_mutable_tensorflow_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tensorflow_version_.Mutable( GetArena());
}
inline std::string* MetaGraphDef_MetaInfoDef::release_tensorflow_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
  return _impl_.tensorflow_version_.Release();
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_tensorflow_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tensorflow_version_.IsDefault()) {
          _impl_.tensorflow_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
}

// string tensorflow_git_version = 6;
inline void MetaGraphDef_MetaInfoDef::clear_tensorflow_git_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_git_version_.ClearToEmpty();
}
inline const std::string& MetaGraphDef_MetaInfoDef::tensorflow_git_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
  return _internal_tensorflow_git_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetaGraphDef_MetaInfoDef::set_tensorflow_git_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_git_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
}
inline std::string* MetaGraphDef_MetaInfoDef::mutable_tensorflow_git_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tensorflow_git_version();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
  return _s;
}
inline const std::string& MetaGraphDef_MetaInfoDef::_internal_tensorflow_git_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tensorflow_git_version_.Get();
}
inline void MetaGraphDef_MetaInfoDef::_internal_set_tensorflow_git_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_git_version_.Set(value, GetArena());
}
inline std::string* MetaGraphDef_MetaInfoDef::_internal_mutable_tensorflow_git_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tensorflow_git_version_.Mutable( GetArena());
}
inline std::string* MetaGraphDef_MetaInfoDef::release_tensorflow_git_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
  return _impl_.tensorflow_git_version_.Release();
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_tensorflow_git_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tensorflow_git_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tensorflow_git_version_.IsDefault()) {
          _impl_.tensorflow_git_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
}

// bool stripped_default_attrs = 7;
inline void MetaGraphDef_MetaInfoDef::clear_stripped_default_attrs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stripped_default_attrs_ = false;
}
inline bool MetaGraphDef_MetaInfoDef::stripped_default_attrs() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.stripped_default_attrs)
  return _internal_stripped_default_attrs();
}
inline void MetaGraphDef_MetaInfoDef::set_stripped_default_attrs(bool value) {
  _internal_set_stripped_default_attrs(value);
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.stripped_default_attrs)
}
inline bool MetaGraphDef_MetaInfoDef::_internal_stripped_default_attrs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stripped_default_attrs_;
}
inline void MetaGraphDef_MetaInfoDef::_internal_set_stripped_default_attrs(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stripped_default_attrs_ = value;
}

// map<string, string> function_aliases = 8;
inline int MetaGraphDef_MetaInfoDef::_internal_function_aliases_size() const {
  return _internal_function_aliases().size();
}
inline int MetaGraphDef_MetaInfoDef::function_aliases_size() const {
  return _internal_function_aliases_size();
}
inline void MetaGraphDef_MetaInfoDef::clear_function_aliases() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_aliases_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& MetaGraphDef_MetaInfoDef::_internal_function_aliases() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.function_aliases_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& MetaGraphDef_MetaInfoDef::function_aliases() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.MetaGraphDef.MetaInfoDef.function_aliases)
  return _internal_function_aliases();
}
inline ::google::protobuf::Map<std::string, std::string>* MetaGraphDef_MetaInfoDef::_internal_mutable_function_aliases() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.function_aliases_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* MetaGraphDef_MetaInfoDef::mutable_function_aliases() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.MetaGraphDef.MetaInfoDef.function_aliases)
  return _internal_mutable_function_aliases();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetaGraphDef

// .tensorflow.MetaGraphDef.MetaInfoDef meta_info_def = 1;
inline bool MetaGraphDef::has_meta_info_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_info_def_ != nullptr);
  return value;
}
inline void MetaGraphDef::clear_meta_info_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.meta_info_def_ != nullptr) _impl_.meta_info_def_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::MetaGraphDef_MetaInfoDef& MetaGraphDef::_internal_meta_info_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::MetaGraphDef_MetaInfoDef* p = _impl_.meta_info_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::MetaGraphDef_MetaInfoDef&>(::tensorflow::_MetaGraphDef_MetaInfoDef_default_instance_);
}
inline const ::tensorflow::MetaGraphDef_MetaInfoDef& MetaGraphDef::meta_info_def() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.meta_info_def)
  return _internal_meta_info_def();
}
inline void MetaGraphDef::unsafe_arena_set_allocated_meta_info_def(::tensorflow::MetaGraphDef_MetaInfoDef* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_info_def_);
  }
  _impl_.meta_info_def_ = reinterpret_cast<::tensorflow::MetaGraphDef_MetaInfoDef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.meta_info_def)
}
inline ::tensorflow::MetaGraphDef_MetaInfoDef* MetaGraphDef::release_meta_info_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::MetaGraphDef_MetaInfoDef* released = _impl_.meta_info_def_;
  _impl_.meta_info_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::MetaGraphDef_MetaInfoDef* MetaGraphDef::unsafe_arena_release_meta_info_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.meta_info_def)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::MetaGraphDef_MetaInfoDef* temp = _impl_.meta_info_def_;
  _impl_.meta_info_def_ = nullptr;
  return temp;
}
inline ::tensorflow::MetaGraphDef_MetaInfoDef* MetaGraphDef::_internal_mutable_meta_info_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.meta_info_def_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::MetaGraphDef_MetaInfoDef>(GetArena());
    _impl_.meta_info_def_ = reinterpret_cast<::tensorflow::MetaGraphDef_MetaInfoDef*>(p);
  }
  return _impl_.meta_info_def_;
}
inline ::tensorflow::MetaGraphDef_MetaInfoDef* MetaGraphDef::mutable_meta_info_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::MetaGraphDef_MetaInfoDef* _msg = _internal_mutable_meta_info_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.meta_info_def)
  return _msg;
}
inline void MetaGraphDef::set_allocated_meta_info_def(::tensorflow::MetaGraphDef_MetaInfoDef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.meta_info_def_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.meta_info_def_ = reinterpret_cast<::tensorflow::MetaGraphDef_MetaInfoDef*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.meta_info_def)
}

// .tensorflow.GraphDef graph_def = 2;
inline bool MetaGraphDef::has_graph_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.graph_def_ != nullptr);
  return value;
}
inline const ::tensorflow::GraphDef& MetaGraphDef::_internal_graph_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::GraphDef* p = _impl_.graph_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::GraphDef&>(::tensorflow::_GraphDef_default_instance_);
}
inline const ::tensorflow::GraphDef& MetaGraphDef::graph_def() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.graph_def)
  return _internal_graph_def();
}
inline void MetaGraphDef::unsafe_arena_set_allocated_graph_def(::tensorflow::GraphDef* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.graph_def_);
  }
  _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.graph_def)
}
inline ::tensorflow::GraphDef* MetaGraphDef::release_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::GraphDef* released = _impl_.graph_def_;
  _impl_.graph_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::GraphDef* MetaGraphDef::unsafe_arena_release_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.graph_def)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::GraphDef* temp = _impl_.graph_def_;
  _impl_.graph_def_ = nullptr;
  return temp;
}
inline ::tensorflow::GraphDef* MetaGraphDef::_internal_mutable_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.graph_def_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::GraphDef>(GetArena());
    _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(p);
  }
  return _impl_.graph_def_;
}
inline ::tensorflow::GraphDef* MetaGraphDef::mutable_graph_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::GraphDef* _msg = _internal_mutable_graph_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.graph_def)
  return _msg;
}
inline void MetaGraphDef::set_allocated_graph_def(::tensorflow::GraphDef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.graph_def_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.graph_def_ = reinterpret_cast<::tensorflow::GraphDef*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.graph_def)
}

// .tensorflow.SaverDef saver_def = 3;
inline bool MetaGraphDef::has_saver_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.saver_def_ != nullptr);
  return value;
}
inline const ::tensorflow::SaverDef& MetaGraphDef::_internal_saver_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::SaverDef* p = _impl_.saver_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::SaverDef&>(::tensorflow::_SaverDef_default_instance_);
}
inline const ::tensorflow::SaverDef& MetaGraphDef::saver_def() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.saver_def)
  return _internal_saver_def();
}
inline void MetaGraphDef::unsafe_arena_set_allocated_saver_def(::tensorflow::SaverDef* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.saver_def_);
  }
  _impl_.saver_def_ = reinterpret_cast<::tensorflow::SaverDef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.saver_def)
}
inline ::tensorflow::SaverDef* MetaGraphDef::release_saver_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::SaverDef* released = _impl_.saver_def_;
  _impl_.saver_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::SaverDef* MetaGraphDef::unsafe_arena_release_saver_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.saver_def)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::SaverDef* temp = _impl_.saver_def_;
  _impl_.saver_def_ = nullptr;
  return temp;
}
inline ::tensorflow::SaverDef* MetaGraphDef::_internal_mutable_saver_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.saver_def_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::SaverDef>(GetArena());
    _impl_.saver_def_ = reinterpret_cast<::tensorflow::SaverDef*>(p);
  }
  return _impl_.saver_def_;
}
inline ::tensorflow::SaverDef* MetaGraphDef::mutable_saver_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tensorflow::SaverDef* _msg = _internal_mutable_saver_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.saver_def)
  return _msg;
}
inline void MetaGraphDef::set_allocated_saver_def(::tensorflow::SaverDef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.saver_def_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.saver_def_ = reinterpret_cast<::tensorflow::SaverDef*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.saver_def)
}

// map<string, .tensorflow.CollectionDef> collection_def = 4;
inline int MetaGraphDef::_internal_collection_def_size() const {
  return _internal_collection_def().size();
}
inline int MetaGraphDef::collection_def_size() const {
  return _internal_collection_def_size();
}
inline void MetaGraphDef::clear_collection_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collection_def_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::CollectionDef>& MetaGraphDef::_internal_collection_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collection_def_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::CollectionDef>& MetaGraphDef::collection_def() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.MetaGraphDef.collection_def)
  return _internal_collection_def();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::CollectionDef>* MetaGraphDef::_internal_mutable_collection_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collection_def_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::CollectionDef>* MetaGraphDef::mutable_collection_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.MetaGraphDef.collection_def)
  return _internal_mutable_collection_def();
}

// map<string, .tensorflow.SignatureDef> signature_def = 5;
inline int MetaGraphDef::_internal_signature_def_size() const {
  return _internal_signature_def().size();
}
inline int MetaGraphDef::signature_def_size() const {
  return _internal_signature_def_size();
}
inline void MetaGraphDef::clear_signature_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_def_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::SignatureDef>& MetaGraphDef::_internal_signature_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_def_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::SignatureDef>& MetaGraphDef::signature_def() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.MetaGraphDef.signature_def)
  return _internal_signature_def();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::SignatureDef>* MetaGraphDef::_internal_mutable_signature_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signature_def_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::SignatureDef>* MetaGraphDef::mutable_signature_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.MetaGraphDef.signature_def)
  return _internal_mutable_signature_def();
}

// repeated .tensorflow.AssetFileDef asset_file_def = 6;
inline int MetaGraphDef::_internal_asset_file_def_size() const {
  return _internal_asset_file_def().size();
}
inline int MetaGraphDef::asset_file_def_size() const {
  return _internal_asset_file_def_size();
}
inline void MetaGraphDef::clear_asset_file_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_file_def_.Clear();
}
inline ::tensorflow::AssetFileDef* MetaGraphDef::mutable_asset_file_def(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.asset_file_def)
  return _internal_mutable_asset_file_def()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::AssetFileDef>* MetaGraphDef::mutable_asset_file_def()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.MetaGraphDef.asset_file_def)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_asset_file_def();
}
inline const ::tensorflow::AssetFileDef& MetaGraphDef::asset_file_def(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.asset_file_def)
  return _internal_asset_file_def().Get(index);
}
inline ::tensorflow::AssetFileDef* MetaGraphDef::add_asset_file_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::AssetFileDef* _add = _internal_mutable_asset_file_def()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.MetaGraphDef.asset_file_def)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::AssetFileDef>& MetaGraphDef::asset_file_def() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.MetaGraphDef.asset_file_def)
  return _internal_asset_file_def();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::AssetFileDef>&
MetaGraphDef::_internal_asset_file_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asset_file_def_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::AssetFileDef>*
MetaGraphDef::_internal_mutable_asset_file_def() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.asset_file_def_;
}

// .tensorflow.SavedObjectGraph object_graph_def = 7;
inline bool MetaGraphDef::has_object_graph_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_graph_def_ != nullptr);
  return value;
}
inline const ::tensorflow::SavedObjectGraph& MetaGraphDef::_internal_object_graph_def() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::SavedObjectGraph* p = _impl_.object_graph_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::SavedObjectGraph&>(::tensorflow::_SavedObjectGraph_default_instance_);
}
inline const ::tensorflow::SavedObjectGraph& MetaGraphDef::object_graph_def() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.object_graph_def)
  return _internal_object_graph_def();
}
inline void MetaGraphDef::unsafe_arena_set_allocated_object_graph_def(::tensorflow::SavedObjectGraph* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_graph_def_);
  }
  _impl_.object_graph_def_ = reinterpret_cast<::tensorflow::SavedObjectGraph*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.object_graph_def)
}
inline ::tensorflow::SavedObjectGraph* MetaGraphDef::release_object_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tensorflow::SavedObjectGraph* released = _impl_.object_graph_def_;
  _impl_.object_graph_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::SavedObjectGraph* MetaGraphDef::unsafe_arena_release_object_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.object_graph_def)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tensorflow::SavedObjectGraph* temp = _impl_.object_graph_def_;
  _impl_.object_graph_def_ = nullptr;
  return temp;
}
inline ::tensorflow::SavedObjectGraph* MetaGraphDef::_internal_mutable_object_graph_def() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_graph_def_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::SavedObjectGraph>(GetArena());
    _impl_.object_graph_def_ = reinterpret_cast<::tensorflow::SavedObjectGraph*>(p);
  }
  return _impl_.object_graph_def_;
}
inline ::tensorflow::SavedObjectGraph* MetaGraphDef::mutable_object_graph_def() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::tensorflow::SavedObjectGraph* _msg = _internal_mutable_object_graph_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.object_graph_def)
  return _msg;
}
inline void MetaGraphDef::set_allocated_object_graph_def(::tensorflow::SavedObjectGraph* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_graph_def_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.object_graph_def_ = reinterpret_cast<::tensorflow::SavedObjectGraph*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.object_graph_def)
}

// -------------------------------------------------------------------

// CollectionDef_NodeList

// repeated string value = 1;
inline int CollectionDef_NodeList::_internal_value_size() const {
  return _internal_value().size();
}
inline int CollectionDef_NodeList::value_size() const {
  return _internal_value_size();
}
inline void CollectionDef_NodeList::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline std::string* CollectionDef_NodeList::add_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.CollectionDef.NodeList.value)
  return _s;
}
inline const std::string& CollectionDef_NodeList::value(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.NodeList.value)
  return _internal_value().Get(index);
}
inline std::string* CollectionDef_NodeList::mutable_value(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.NodeList.value)
  return _internal_mutable_value()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CollectionDef_NodeList::set_value(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_value()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.NodeList.value)
}
template <typename Arg_, typename... Args_>
inline void CollectionDef_NodeList::add_value(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_value(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.NodeList.value)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollectionDef_NodeList::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.NodeList.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollectionDef_NodeList::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.NodeList.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollectionDef_NodeList::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollectionDef_NodeList::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// CollectionDef_BytesList

// repeated bytes value = 1;
inline int CollectionDef_BytesList::_internal_value_size() const {
  return _internal_value().size();
}
inline int CollectionDef_BytesList::value_size() const {
  return _internal_value_size();
}
inline void CollectionDef_BytesList::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline std::string* CollectionDef_BytesList::add_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.CollectionDef.BytesList.value)
  return _s;
}
inline const std::string& CollectionDef_BytesList::value(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.BytesList.value)
  return _internal_value().Get(index);
}
inline std::string* CollectionDef_BytesList::mutable_value(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.BytesList.value)
  return _internal_mutable_value()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CollectionDef_BytesList::set_value(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_value()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.BytesList.value)
}
template <typename Arg_, typename... Args_>
inline void CollectionDef_BytesList::add_value(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_value(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.BytesList.value)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollectionDef_BytesList::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.BytesList.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollectionDef_BytesList::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.BytesList.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CollectionDef_BytesList::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CollectionDef_BytesList::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// CollectionDef_Int64List

// repeated int64 value = 1 [packed = true];
inline int CollectionDef_Int64List::_internal_value_size() const {
  return _internal_value().size();
}
inline int CollectionDef_Int64List::value_size() const {
  return _internal_value_size();
}
inline void CollectionDef_Int64List::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline ::int64_t CollectionDef_Int64List::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.Int64List.value)
  return _internal_value().Get(index);
}
inline void CollectionDef_Int64List::set_value(int index, ::int64_t value) {
  _internal_mutable_value()->Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.Int64List.value)
}
inline void CollectionDef_Int64List::add_value(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.Int64List.value)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& CollectionDef_Int64List::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.Int64List.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedField<::int64_t>* CollectionDef_Int64List::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.Int64List.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
CollectionDef_Int64List::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* CollectionDef_Int64List::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// CollectionDef_FloatList

// repeated float value = 1 [packed = true];
inline int CollectionDef_FloatList::_internal_value_size() const {
  return _internal_value().size();
}
inline int CollectionDef_FloatList::value_size() const {
  return _internal_value_size();
}
inline void CollectionDef_FloatList::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline float CollectionDef_FloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.FloatList.value)
  return _internal_value().Get(index);
}
inline void CollectionDef_FloatList::set_value(int index, float value) {
  _internal_mutable_value()->Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.FloatList.value)
}
inline void CollectionDef_FloatList::add_value(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.FloatList.value)
}
inline const ::google::protobuf::RepeatedField<float>& CollectionDef_FloatList::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.FloatList.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedField<float>* CollectionDef_FloatList::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.FloatList.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedField<float>&
CollectionDef_FloatList::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedField<float>* CollectionDef_FloatList::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// CollectionDef_AnyList

// repeated .google.protobuf.Any value = 1;
inline int CollectionDef_AnyList::_internal_value_size() const {
  return _internal_value().size();
}
inline int CollectionDef_AnyList::value_size() const {
  return _internal_value_size();
}
inline ::google::protobuf::Any* CollectionDef_AnyList::mutable_value(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.AnyList.value)
  return _internal_mutable_value()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* CollectionDef_AnyList::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.AnyList.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::google::protobuf::Any& CollectionDef_AnyList::value(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.AnyList.value)
  return _internal_value().Get(index);
}
inline ::google::protobuf::Any* CollectionDef_AnyList::add_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.AnyList.value)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& CollectionDef_AnyList::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.AnyList.value)
  return _internal_value();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
CollectionDef_AnyList::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
CollectionDef_AnyList::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// CollectionDef

// .tensorflow.CollectionDef.NodeList node_list = 1;
inline bool CollectionDef::has_node_list() const {
  return kind_case() == kNodeList;
}
inline bool CollectionDef::_internal_has_node_list() const {
  return kind_case() == kNodeList;
}
inline void CollectionDef::set_has_node_list() {
  _impl_._oneof_case_[0] = kNodeList;
}
inline void CollectionDef::clear_node_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kNodeList) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.node_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.node_list_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::CollectionDef_NodeList* CollectionDef::release_node_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.node_list)
  if (kind_case() == kNodeList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.node_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.node_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::CollectionDef_NodeList& CollectionDef::_internal_node_list() const {
  return kind_case() == kNodeList ? *_impl_.kind_.node_list_ : reinterpret_cast<::tensorflow::CollectionDef_NodeList&>(::tensorflow::_CollectionDef_NodeList_default_instance_);
}
inline const ::tensorflow::CollectionDef_NodeList& CollectionDef::node_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.node_list)
  return _internal_node_list();
}
inline ::tensorflow::CollectionDef_NodeList* CollectionDef::unsafe_arena_release_node_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.node_list)
  if (kind_case() == kNodeList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.node_list_;
    _impl_.kind_.node_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectionDef::unsafe_arena_set_allocated_node_list(::tensorflow::CollectionDef_NodeList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_node_list();
    _impl_.kind_.node_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.node_list)
}
inline ::tensorflow::CollectionDef_NodeList* CollectionDef::_internal_mutable_node_list() {
  if (kind_case() != kNodeList) {
    clear_kind();
    set_has_node_list();
    _impl_.kind_.node_list_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::CollectionDef_NodeList>(GetArena());
  }
  return _impl_.kind_.node_list_;
}
inline ::tensorflow::CollectionDef_NodeList* CollectionDef::mutable_node_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::CollectionDef_NodeList* _msg = _internal_mutable_node_list();
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.node_list)
  return _msg;
}

// .tensorflow.CollectionDef.BytesList bytes_list = 2;
inline bool CollectionDef::has_bytes_list() const {
  return kind_case() == kBytesList;
}
inline bool CollectionDef::_internal_has_bytes_list() const {
  return kind_case() == kBytesList;
}
inline void CollectionDef::set_has_bytes_list() {
  _impl_._oneof_case_[0] = kBytesList;
}
inline void CollectionDef::clear_bytes_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBytesList) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.bytes_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.bytes_list_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::CollectionDef_BytesList* CollectionDef::release_bytes_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.bytes_list)
  if (kind_case() == kBytesList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.bytes_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.bytes_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::CollectionDef_BytesList& CollectionDef::_internal_bytes_list() const {
  return kind_case() == kBytesList ? *_impl_.kind_.bytes_list_ : reinterpret_cast<::tensorflow::CollectionDef_BytesList&>(::tensorflow::_CollectionDef_BytesList_default_instance_);
}
inline const ::tensorflow::CollectionDef_BytesList& CollectionDef::bytes_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.bytes_list)
  return _internal_bytes_list();
}
inline ::tensorflow::CollectionDef_BytesList* CollectionDef::unsafe_arena_release_bytes_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.bytes_list)
  if (kind_case() == kBytesList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.bytes_list_;
    _impl_.kind_.bytes_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectionDef::unsafe_arena_set_allocated_bytes_list(::tensorflow::CollectionDef_BytesList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_bytes_list();
    _impl_.kind_.bytes_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.bytes_list)
}
inline ::tensorflow::CollectionDef_BytesList* CollectionDef::_internal_mutable_bytes_list() {
  if (kind_case() != kBytesList) {
    clear_kind();
    set_has_bytes_list();
    _impl_.kind_.bytes_list_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::CollectionDef_BytesList>(GetArena());
  }
  return _impl_.kind_.bytes_list_;
}
inline ::tensorflow::CollectionDef_BytesList* CollectionDef::mutable_bytes_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::CollectionDef_BytesList* _msg = _internal_mutable_bytes_list();
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.bytes_list)
  return _msg;
}

// .tensorflow.CollectionDef.Int64List int64_list = 3;
inline bool CollectionDef::has_int64_list() const {
  return kind_case() == kInt64List;
}
inline bool CollectionDef::_internal_has_int64_list() const {
  return kind_case() == kInt64List;
}
inline void CollectionDef::set_has_int64_list() {
  _impl_._oneof_case_[0] = kInt64List;
}
inline void CollectionDef::clear_int64_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kInt64List) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.int64_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.int64_list_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::CollectionDef_Int64List* CollectionDef::release_int64_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.int64_list)
  if (kind_case() == kInt64List) {
    clear_has_kind();
    auto* temp = _impl_.kind_.int64_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.int64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::CollectionDef_Int64List& CollectionDef::_internal_int64_list() const {
  return kind_case() == kInt64List ? *_impl_.kind_.int64_list_ : reinterpret_cast<::tensorflow::CollectionDef_Int64List&>(::tensorflow::_CollectionDef_Int64List_default_instance_);
}
inline const ::tensorflow::CollectionDef_Int64List& CollectionDef::int64_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.int64_list)
  return _internal_int64_list();
}
inline ::tensorflow::CollectionDef_Int64List* CollectionDef::unsafe_arena_release_int64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.int64_list)
  if (kind_case() == kInt64List) {
    clear_has_kind();
    auto* temp = _impl_.kind_.int64_list_;
    _impl_.kind_.int64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectionDef::unsafe_arena_set_allocated_int64_list(::tensorflow::CollectionDef_Int64List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_int64_list();
    _impl_.kind_.int64_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.int64_list)
}
inline ::tensorflow::CollectionDef_Int64List* CollectionDef::_internal_mutable_int64_list() {
  if (kind_case() != kInt64List) {
    clear_kind();
    set_has_int64_list();
    _impl_.kind_.int64_list_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::CollectionDef_Int64List>(GetArena());
  }
  return _impl_.kind_.int64_list_;
}
inline ::tensorflow::CollectionDef_Int64List* CollectionDef::mutable_int64_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::CollectionDef_Int64List* _msg = _internal_mutable_int64_list();
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.int64_list)
  return _msg;
}

// .tensorflow.CollectionDef.FloatList float_list = 4;
inline bool CollectionDef::has_float_list() const {
  return kind_case() == kFloatList;
}
inline bool CollectionDef::_internal_has_float_list() const {
  return kind_case() == kFloatList;
}
inline void CollectionDef::set_has_float_list() {
  _impl_._oneof_case_[0] = kFloatList;
}
inline void CollectionDef::clear_float_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kFloatList) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.float_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.float_list_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::CollectionDef_FloatList* CollectionDef::release_float_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.float_list)
  if (kind_case() == kFloatList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.float_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::CollectionDef_FloatList& CollectionDef::_internal_float_list() const {
  return kind_case() == kFloatList ? *_impl_.kind_.float_list_ : reinterpret_cast<::tensorflow::CollectionDef_FloatList&>(::tensorflow::_CollectionDef_FloatList_default_instance_);
}
inline const ::tensorflow::CollectionDef_FloatList& CollectionDef::float_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.float_list)
  return _internal_float_list();
}
inline ::tensorflow::CollectionDef_FloatList* CollectionDef::unsafe_arena_release_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.float_list)
  if (kind_case() == kFloatList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.float_list_;
    _impl_.kind_.float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectionDef::unsafe_arena_set_allocated_float_list(::tensorflow::CollectionDef_FloatList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_float_list();
    _impl_.kind_.float_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.float_list)
}
inline ::tensorflow::CollectionDef_FloatList* CollectionDef::_internal_mutable_float_list() {
  if (kind_case() != kFloatList) {
    clear_kind();
    set_has_float_list();
    _impl_.kind_.float_list_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::CollectionDef_FloatList>(GetArena());
  }
  return _impl_.kind_.float_list_;
}
inline ::tensorflow::CollectionDef_FloatList* CollectionDef::mutable_float_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::CollectionDef_FloatList* _msg = _internal_mutable_float_list();
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.float_list)
  return _msg;
}

// .tensorflow.CollectionDef.AnyList any_list = 5;
inline bool CollectionDef::has_any_list() const {
  return kind_case() == kAnyList;
}
inline bool CollectionDef::_internal_has_any_list() const {
  return kind_case() == kAnyList;
}
inline void CollectionDef::set_has_any_list() {
  _impl_._oneof_case_[0] = kAnyList;
}
inline void CollectionDef::clear_any_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kAnyList) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.any_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.any_list_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::CollectionDef_AnyList* CollectionDef::release_any_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.any_list)
  if (kind_case() == kAnyList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.any_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.any_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::CollectionDef_AnyList& CollectionDef::_internal_any_list() const {
  return kind_case() == kAnyList ? *_impl_.kind_.any_list_ : reinterpret_cast<::tensorflow::CollectionDef_AnyList&>(::tensorflow::_CollectionDef_AnyList_default_instance_);
}
inline const ::tensorflow::CollectionDef_AnyList& CollectionDef::any_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.any_list)
  return _internal_any_list();
}
inline ::tensorflow::CollectionDef_AnyList* CollectionDef::unsafe_arena_release_any_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.any_list)
  if (kind_case() == kAnyList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.any_list_;
    _impl_.kind_.any_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CollectionDef::unsafe_arena_set_allocated_any_list(::tensorflow::CollectionDef_AnyList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_any_list();
    _impl_.kind_.any_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.any_list)
}
inline ::tensorflow::CollectionDef_AnyList* CollectionDef::_internal_mutable_any_list() {
  if (kind_case() != kAnyList) {
    clear_kind();
    set_has_any_list();
    _impl_.kind_.any_list_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::CollectionDef_AnyList>(GetArena());
  }
  return _impl_.kind_.any_list_;
}
inline ::tensorflow::CollectionDef_AnyList* CollectionDef::mutable_any_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::CollectionDef_AnyList* _msg = _internal_mutable_any_list();
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.any_list)
  return _msg;
}

inline bool CollectionDef::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void CollectionDef::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline CollectionDef::KindCase CollectionDef::kind_case() const {
  return CollectionDef::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TensorInfo_CooSparse

// string values_tensor_name = 1;
inline void TensorInfo_CooSparse::clear_values_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_tensor_name_.ClearToEmpty();
}
inline const std::string& TensorInfo_CooSparse::values_tensor_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.CooSparse.values_tensor_name)
  return _internal_values_tensor_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorInfo_CooSparse::set_values_tensor_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_tensor_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.CooSparse.values_tensor_name)
}
inline std::string* TensorInfo_CooSparse::mutable_values_tensor_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_values_tensor_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.CooSparse.values_tensor_name)
  return _s;
}
inline const std::string& TensorInfo_CooSparse::_internal_values_tensor_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_tensor_name_.Get();
}
inline void TensorInfo_CooSparse::_internal_set_values_tensor_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_tensor_name_.Set(value, GetArena());
}
inline std::string* TensorInfo_CooSparse::_internal_mutable_values_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.values_tensor_name_.Mutable( GetArena());
}
inline std::string* TensorInfo_CooSparse::release_values_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.CooSparse.values_tensor_name)
  return _impl_.values_tensor_name_.Release();
}
inline void TensorInfo_CooSparse::set_allocated_values_tensor_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_tensor_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.values_tensor_name_.IsDefault()) {
          _impl_.values_tensor_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.CooSparse.values_tensor_name)
}

// string indices_tensor_name = 2;
inline void TensorInfo_CooSparse::clear_indices_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indices_tensor_name_.ClearToEmpty();
}
inline const std::string& TensorInfo_CooSparse::indices_tensor_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
  return _internal_indices_tensor_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorInfo_CooSparse::set_indices_tensor_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indices_tensor_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
}
inline std::string* TensorInfo_CooSparse::mutable_indices_tensor_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_indices_tensor_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
  return _s;
}
inline const std::string& TensorInfo_CooSparse::_internal_indices_tensor_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.indices_tensor_name_.Get();
}
inline void TensorInfo_CooSparse::_internal_set_indices_tensor_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indices_tensor_name_.Set(value, GetArena());
}
inline std::string* TensorInfo_CooSparse::_internal_mutable_indices_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.indices_tensor_name_.Mutable( GetArena());
}
inline std::string* TensorInfo_CooSparse::release_indices_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
  return _impl_.indices_tensor_name_.Release();
}
inline void TensorInfo_CooSparse::set_allocated_indices_tensor_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indices_tensor_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.indices_tensor_name_.IsDefault()) {
          _impl_.indices_tensor_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
}

// string dense_shape_tensor_name = 3;
inline void TensorInfo_CooSparse::clear_dense_shape_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dense_shape_tensor_name_.ClearToEmpty();
}
inline const std::string& TensorInfo_CooSparse::dense_shape_tensor_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
  return _internal_dense_shape_tensor_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorInfo_CooSparse::set_dense_shape_tensor_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dense_shape_tensor_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
}
inline std::string* TensorInfo_CooSparse::mutable_dense_shape_tensor_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dense_shape_tensor_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
  return _s;
}
inline const std::string& TensorInfo_CooSparse::_internal_dense_shape_tensor_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dense_shape_tensor_name_.Get();
}
inline void TensorInfo_CooSparse::_internal_set_dense_shape_tensor_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dense_shape_tensor_name_.Set(value, GetArena());
}
inline std::string* TensorInfo_CooSparse::_internal_mutable_dense_shape_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dense_shape_tensor_name_.Mutable( GetArena());
}
inline std::string* TensorInfo_CooSparse::release_dense_shape_tensor_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
  return _impl_.dense_shape_tensor_name_.Release();
}
inline void TensorInfo_CooSparse::set_allocated_dense_shape_tensor_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dense_shape_tensor_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dense_shape_tensor_name_.IsDefault()) {
          _impl_.dense_shape_tensor_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
}

// -------------------------------------------------------------------

// TensorInfo_CompositeTensor

// .tensorflow.TypeSpecProto type_spec = 1;
inline bool TensorInfo_CompositeTensor::has_type_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_spec_ != nullptr);
  return value;
}
inline const ::tensorflow::TypeSpecProto& TensorInfo_CompositeTensor::_internal_type_spec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TypeSpecProto* p = _impl_.type_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TypeSpecProto&>(::tensorflow::_TypeSpecProto_default_instance_);
}
inline const ::tensorflow::TypeSpecProto& TensorInfo_CompositeTensor::type_spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.CompositeTensor.type_spec)
  return _internal_type_spec();
}
inline void TensorInfo_CompositeTensor::unsafe_arena_set_allocated_type_spec(::tensorflow::TypeSpecProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_spec_);
  }
  _impl_.type_spec_ = reinterpret_cast<::tensorflow::TypeSpecProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.CompositeTensor.type_spec)
}
inline ::tensorflow::TypeSpecProto* TensorInfo_CompositeTensor::release_type_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TypeSpecProto* released = _impl_.type_spec_;
  _impl_.type_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TypeSpecProto* TensorInfo_CompositeTensor::unsafe_arena_release_type_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.CompositeTensor.type_spec)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TypeSpecProto* temp = _impl_.type_spec_;
  _impl_.type_spec_ = nullptr;
  return temp;
}
inline ::tensorflow::TypeSpecProto* TensorInfo_CompositeTensor::_internal_mutable_type_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_spec_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TypeSpecProto>(GetArena());
    _impl_.type_spec_ = reinterpret_cast<::tensorflow::TypeSpecProto*>(p);
  }
  return _impl_.type_spec_;
}
inline ::tensorflow::TypeSpecProto* TensorInfo_CompositeTensor::mutable_type_spec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::TypeSpecProto* _msg = _internal_mutable_type_spec();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.CompositeTensor.type_spec)
  return _msg;
}
inline void TensorInfo_CompositeTensor::set_allocated_type_spec(::tensorflow::TypeSpecProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_spec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.type_spec_ = reinterpret_cast<::tensorflow::TypeSpecProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.CompositeTensor.type_spec)
}

// repeated .tensorflow.TensorInfo components = 2;
inline int TensorInfo_CompositeTensor::_internal_components_size() const {
  return _internal_components().size();
}
inline int TensorInfo_CompositeTensor::components_size() const {
  return _internal_components_size();
}
inline void TensorInfo_CompositeTensor::clear_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.components_.Clear();
}
inline ::tensorflow::TensorInfo* TensorInfo_CompositeTensor::mutable_components(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.CompositeTensor.components)
  return _internal_mutable_components()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TensorInfo>* TensorInfo_CompositeTensor::mutable_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorInfo.CompositeTensor.components)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_components();
}
inline const ::tensorflow::TensorInfo& TensorInfo_CompositeTensor::components(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.CompositeTensor.components)
  return _internal_components().Get(index);
}
inline ::tensorflow::TensorInfo* TensorInfo_CompositeTensor::add_components() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::TensorInfo* _add = _internal_mutable_components()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.TensorInfo.CompositeTensor.components)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorInfo>& TensorInfo_CompositeTensor::components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.TensorInfo.CompositeTensor.components)
  return _internal_components();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TensorInfo>&
TensorInfo_CompositeTensor::_internal_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.components_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TensorInfo>*
TensorInfo_CompositeTensor::_internal_mutable_components() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.components_;
}

// -------------------------------------------------------------------

// TensorInfo

// string name = 1;
inline bool TensorInfo::has_name() const {
  return encoding_case() == kName;
}
inline void TensorInfo::set_has_name() {
  _impl_._oneof_case_[0] = kName;
}
inline void TensorInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_case() == kName) {
    _impl_.encoding_.name_.Destroy();
    clear_has_encoding();
  }
}
inline const std::string& TensorInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_case() != kName) {
    clear_encoding();

    set_has_name();
    _impl_.encoding_.name_.InitDefault();
  }
  _impl_.encoding_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.name)
}
inline std::string* TensorInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.name)
  return _s;
}
inline const std::string& TensorInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (encoding_case() != kName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.encoding_.name_.Get();
}
inline void TensorInfo::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_case() != kName) {
    clear_encoding();

    set_has_name();
    _impl_.encoding_.name_.InitDefault();
  }
  _impl_.encoding_.name_.Set(value, GetArena());
}
inline std::string* TensorInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_case() != kName) {
    clear_encoding();

    set_has_name();
    _impl_.encoding_.name_.InitDefault();
  }
  return _impl_.encoding_.name_.Mutable( GetArena());
}
inline std::string* TensorInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.name)
  if (encoding_case() != kName) {
    return nullptr;
  }
  clear_has_encoding();
  return _impl_.encoding_.name_.Release();
}
inline void TensorInfo::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_encoding()) {
    clear_encoding();
  }
  if (value != nullptr) {
    set_has_name();
    _impl_.encoding_.name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.name)
}

// .tensorflow.TensorInfo.CooSparse coo_sparse = 4;
inline bool TensorInfo::has_coo_sparse() const {
  return encoding_case() == kCooSparse;
}
inline bool TensorInfo::_internal_has_coo_sparse() const {
  return encoding_case() == kCooSparse;
}
inline void TensorInfo::set_has_coo_sparse() {
  _impl_._oneof_case_[0] = kCooSparse;
}
inline void TensorInfo::clear_coo_sparse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_case() == kCooSparse) {
    if (GetArena() == nullptr) {
      delete _impl_.encoding_.coo_sparse_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.encoding_.coo_sparse_);
    }
    clear_has_encoding();
  }
}
inline ::tensorflow::TensorInfo_CooSparse* TensorInfo::release_coo_sparse() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.coo_sparse)
  if (encoding_case() == kCooSparse) {
    clear_has_encoding();
    auto* temp = _impl_.encoding_.coo_sparse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.encoding_.coo_sparse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TensorInfo_CooSparse& TensorInfo::_internal_coo_sparse() const {
  return encoding_case() == kCooSparse ? *_impl_.encoding_.coo_sparse_ : reinterpret_cast<::tensorflow::TensorInfo_CooSparse&>(::tensorflow::_TensorInfo_CooSparse_default_instance_);
}
inline const ::tensorflow::TensorInfo_CooSparse& TensorInfo::coo_sparse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.coo_sparse)
  return _internal_coo_sparse();
}
inline ::tensorflow::TensorInfo_CooSparse* TensorInfo::unsafe_arena_release_coo_sparse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorInfo.coo_sparse)
  if (encoding_case() == kCooSparse) {
    clear_has_encoding();
    auto* temp = _impl_.encoding_.coo_sparse_;
    _impl_.encoding_.coo_sparse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorInfo::unsafe_arena_set_allocated_coo_sparse(::tensorflow::TensorInfo_CooSparse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_encoding();
  if (value) {
    set_has_coo_sparse();
    _impl_.encoding_.coo_sparse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.coo_sparse)
}
inline ::tensorflow::TensorInfo_CooSparse* TensorInfo::_internal_mutable_coo_sparse() {
  if (encoding_case() != kCooSparse) {
    clear_encoding();
    set_has_coo_sparse();
    _impl_.encoding_.coo_sparse_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorInfo_CooSparse>(GetArena());
  }
  return _impl_.encoding_.coo_sparse_;
}
inline ::tensorflow::TensorInfo_CooSparse* TensorInfo::mutable_coo_sparse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::TensorInfo_CooSparse* _msg = _internal_mutable_coo_sparse();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.coo_sparse)
  return _msg;
}

// .tensorflow.TensorInfo.CompositeTensor composite_tensor = 5;
inline bool TensorInfo::has_composite_tensor() const {
  return encoding_case() == kCompositeTensor;
}
inline bool TensorInfo::_internal_has_composite_tensor() const {
  return encoding_case() == kCompositeTensor;
}
inline void TensorInfo::set_has_composite_tensor() {
  _impl_._oneof_case_[0] = kCompositeTensor;
}
inline void TensorInfo::clear_composite_tensor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_case() == kCompositeTensor) {
    if (GetArena() == nullptr) {
      delete _impl_.encoding_.composite_tensor_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.encoding_.composite_tensor_);
    }
    clear_has_encoding();
  }
}
inline ::tensorflow::TensorInfo_CompositeTensor* TensorInfo::release_composite_tensor() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.composite_tensor)
  if (encoding_case() == kCompositeTensor) {
    clear_has_encoding();
    auto* temp = _impl_.encoding_.composite_tensor_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.encoding_.composite_tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TensorInfo_CompositeTensor& TensorInfo::_internal_composite_tensor() const {
  return encoding_case() == kCompositeTensor ? *_impl_.encoding_.composite_tensor_ : reinterpret_cast<::tensorflow::TensorInfo_CompositeTensor&>(::tensorflow::_TensorInfo_CompositeTensor_default_instance_);
}
inline const ::tensorflow::TensorInfo_CompositeTensor& TensorInfo::composite_tensor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.composite_tensor)
  return _internal_composite_tensor();
}
inline ::tensorflow::TensorInfo_CompositeTensor* TensorInfo::unsafe_arena_release_composite_tensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorInfo.composite_tensor)
  if (encoding_case() == kCompositeTensor) {
    clear_has_encoding();
    auto* temp = _impl_.encoding_.composite_tensor_;
    _impl_.encoding_.composite_tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TensorInfo::unsafe_arena_set_allocated_composite_tensor(::tensorflow::TensorInfo_CompositeTensor* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_encoding();
  if (value) {
    set_has_composite_tensor();
    _impl_.encoding_.composite_tensor_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.composite_tensor)
}
inline ::tensorflow::TensorInfo_CompositeTensor* TensorInfo::_internal_mutable_composite_tensor() {
  if (encoding_case() != kCompositeTensor) {
    clear_encoding();
    set_has_composite_tensor();
    _impl_.encoding_.composite_tensor_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorInfo_CompositeTensor>(GetArena());
  }
  return _impl_.encoding_.composite_tensor_;
}
inline ::tensorflow::TensorInfo_CompositeTensor* TensorInfo::mutable_composite_tensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::TensorInfo_CompositeTensor* _msg = _internal_mutable_composite_tensor();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.composite_tensor)
  return _msg;
}

// .tensorflow.DataType dtype = 2;
inline void TensorInfo::clear_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_ = 0;
}
inline ::tensorflow::DataType TensorInfo::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.dtype)
  return _internal_dtype();
}
inline void TensorInfo::set_dtype(::tensorflow::DataType value) {
  _internal_set_dtype(value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.dtype)
}
inline ::tensorflow::DataType TensorInfo::_internal_dtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::DataType>(_impl_.dtype_);
}
inline void TensorInfo::_internal_set_dtype(::tensorflow::DataType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_ = value;
}

// .tensorflow.TensorShapeProto tensor_shape = 3;
inline bool TensorInfo::has_tensor_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tensor_shape_ != nullptr);
  return value;
}
inline const ::tensorflow::TensorShapeProto& TensorInfo::_internal_tensor_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TensorShapeProto* p = _impl_.tensor_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TensorShapeProto&>(::tensorflow::_TensorShapeProto_default_instance_);
}
inline const ::tensorflow::TensorShapeProto& TensorInfo::tensor_shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.tensor_shape)
  return _internal_tensor_shape();
}
inline void TensorInfo::unsafe_arena_set_allocated_tensor_shape(::tensorflow::TensorShapeProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tensor_shape_);
  }
  _impl_.tensor_shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.tensor_shape)
}
inline ::tensorflow::TensorShapeProto* TensorInfo::release_tensor_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorShapeProto* released = _impl_.tensor_shape_;
  _impl_.tensor_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TensorShapeProto* TensorInfo::unsafe_arena_release_tensor_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.tensor_shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorShapeProto* temp = _impl_.tensor_shape_;
  _impl_.tensor_shape_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorShapeProto* TensorInfo::_internal_mutable_tensor_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tensor_shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorShapeProto>(GetArena());
    _impl_.tensor_shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(p);
  }
  return _impl_.tensor_shape_;
}
inline ::tensorflow::TensorShapeProto* TensorInfo::mutable_tensor_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::TensorShapeProto* _msg = _internal_mutable_tensor_shape();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.tensor_shape)
  return _msg;
}
inline void TensorInfo::set_allocated_tensor_shape(::tensorflow::TensorShapeProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tensor_shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tensor_shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.tensor_shape)
}

inline bool TensorInfo::has_encoding() const {
  return encoding_case() != ENCODING_NOT_SET;
}
inline void TensorInfo::clear_has_encoding() {
  _impl_._oneof_case_[0] = ENCODING_NOT_SET;
}
inline TensorInfo::EncodingCase TensorInfo::encoding_case() const {
  return TensorInfo::EncodingCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SignatureDef

// map<string, .tensorflow.TensorInfo> inputs = 1;
inline int SignatureDef::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int SignatureDef::inputs_size() const {
  return _internal_inputs_size();
}
inline void SignatureDef::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>& SignatureDef::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>& SignatureDef::inputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.SignatureDef.inputs)
  return _internal_inputs();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>* SignatureDef::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.inputs_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>* SignatureDef::mutable_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.SignatureDef.inputs)
  return _internal_mutable_inputs();
}

// map<string, .tensorflow.TensorInfo> outputs = 2;
inline int SignatureDef::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int SignatureDef::outputs_size() const {
  return _internal_outputs_size();
}
inline void SignatureDef::clear_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outputs_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>& SignatureDef::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>& SignatureDef::outputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.SignatureDef.outputs)
  return _internal_outputs();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>* SignatureDef::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.outputs_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::TensorInfo>* SignatureDef::mutable_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.SignatureDef.outputs)
  return _internal_mutable_outputs();
}

// string method_name = 3;
inline void SignatureDef::clear_method_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_name_.ClearToEmpty();
}
inline const std::string& SignatureDef::method_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SignatureDef.method_name)
  return _internal_method_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureDef::set_method_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SignatureDef.method_name)
}
inline std::string* SignatureDef::mutable_method_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.SignatureDef.method_name)
  return _s;
}
inline const std::string& SignatureDef::_internal_method_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.method_name_.Get();
}
inline void SignatureDef::_internal_set_method_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_name_.Set(value, GetArena());
}
inline std::string* SignatureDef::_internal_mutable_method_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.method_name_.Mutable( GetArena());
}
inline std::string* SignatureDef::release_method_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SignatureDef.method_name)
  return _impl_.method_name_.Release();
}
inline void SignatureDef::set_allocated_method_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.method_name_.IsDefault()) {
          _impl_.method_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SignatureDef.method_name)
}

// map<string, .tensorflow.TensorProto> defaults = 4;
inline int SignatureDef::_internal_defaults_size() const {
  return _internal_defaults().size();
}
inline int SignatureDef::defaults_size() const {
  return _internal_defaults_size();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::TensorProto>& SignatureDef::_internal_defaults() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.defaults_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::TensorProto>& SignatureDef::defaults() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.SignatureDef.defaults)
  return _internal_defaults();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::TensorProto>* SignatureDef::_internal_mutable_defaults() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.defaults_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::TensorProto>* SignatureDef::mutable_defaults() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.SignatureDef.defaults)
  return _internal_mutable_defaults();
}

// -------------------------------------------------------------------

// AssetFileDef

// .tensorflow.TensorInfo tensor_info = 1;
inline bool AssetFileDef::has_tensor_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tensor_info_ != nullptr);
  return value;
}
inline void AssetFileDef::clear_tensor_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tensor_info_ != nullptr) _impl_.tensor_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::TensorInfo& AssetFileDef::_internal_tensor_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TensorInfo* p = _impl_.tensor_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TensorInfo&>(::tensorflow::_TensorInfo_default_instance_);
}
inline const ::tensorflow::TensorInfo& AssetFileDef::tensor_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.AssetFileDef.tensor_info)
  return _internal_tensor_info();
}
inline void AssetFileDef::unsafe_arena_set_allocated_tensor_info(::tensorflow::TensorInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tensor_info_);
  }
  _impl_.tensor_info_ = reinterpret_cast<::tensorflow::TensorInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.AssetFileDef.tensor_info)
}
inline ::tensorflow::TensorInfo* AssetFileDef::release_tensor_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorInfo* released = _impl_.tensor_info_;
  _impl_.tensor_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TensorInfo* AssetFileDef::unsafe_arena_release_tensor_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.AssetFileDef.tensor_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorInfo* temp = _impl_.tensor_info_;
  _impl_.tensor_info_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorInfo* AssetFileDef::_internal_mutable_tensor_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tensor_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorInfo>(GetArena());
    _impl_.tensor_info_ = reinterpret_cast<::tensorflow::TensorInfo*>(p);
  }
  return _impl_.tensor_info_;
}
inline ::tensorflow::TensorInfo* AssetFileDef::mutable_tensor_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::TensorInfo* _msg = _internal_mutable_tensor_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.AssetFileDef.tensor_info)
  return _msg;
}
inline void AssetFileDef::set_allocated_tensor_info(::tensorflow::TensorInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tensor_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tensor_info_ = reinterpret_cast<::tensorflow::TensorInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AssetFileDef.tensor_info)
}

// string filename = 2;
inline void AssetFileDef::clear_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& AssetFileDef::filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.AssetFileDef.filename)
  return _internal_filename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AssetFileDef::set_filename(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.AssetFileDef.filename)
}
inline std::string* AssetFileDef::mutable_filename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:tensorflow.AssetFileDef.filename)
  return _s;
}
inline const std::string& AssetFileDef::_internal_filename() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filename_.Get();
}
inline void AssetFileDef::_internal_set_filename(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.Set(value, GetArena());
}
inline std::string* AssetFileDef::_internal_mutable_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.filename_.Mutable( GetArena());
}
inline std::string* AssetFileDef::release_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.AssetFileDef.filename)
  return _impl_.filename_.Release();
}
inline void AssetFileDef::set_allocated_filename(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filename_.IsDefault()) {
          _impl_.filename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AssetFileDef.filename)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tensorflow


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto_2epb_2eh
