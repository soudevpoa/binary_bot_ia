// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: tensorflow/core/protobuf/saved_object_graph.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "tensorflow/core/framework/tensor_shape.pb.h"
#include "tensorflow/core/framework/types.pb.h"
#include "tensorflow/core/framework/variable.pb.h"
#include "tensorflow/core/framework/versions.pb.h"
#include "tensorflow/core/protobuf/struct.pb.h"
#include "tensorflow/core/protobuf/trackable_object_graph.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
namespace tensorflow {
class CapturedTensor;
struct CapturedTensorDefaultTypeInternal;
PROTOBUF_EXPORT extern CapturedTensorDefaultTypeInternal _CapturedTensor_default_instance_;
class FunctionSpec;
struct FunctionSpecDefaultTypeInternal;
PROTOBUF_EXPORT extern FunctionSpecDefaultTypeInternal _FunctionSpec_default_instance_;
class SaveableObject;
struct SaveableObjectDefaultTypeInternal;
PROTOBUF_EXPORT extern SaveableObjectDefaultTypeInternal _SaveableObject_default_instance_;
class SavedAsset;
struct SavedAssetDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedAssetDefaultTypeInternal _SavedAsset_default_instance_;
class SavedBareConcreteFunction;
struct SavedBareConcreteFunctionDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedBareConcreteFunctionDefaultTypeInternal _SavedBareConcreteFunction_default_instance_;
class SavedConcreteFunction;
struct SavedConcreteFunctionDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedConcreteFunctionDefaultTypeInternal _SavedConcreteFunction_default_instance_;
class SavedConstant;
struct SavedConstantDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedConstantDefaultTypeInternal _SavedConstant_default_instance_;
class SavedFunction;
struct SavedFunctionDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedFunctionDefaultTypeInternal _SavedFunction_default_instance_;
class SavedObject;
struct SavedObjectDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedObjectDefaultTypeInternal _SavedObject_default_instance_;
class SavedObjectGraph;
struct SavedObjectGraphDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedObjectGraphDefaultTypeInternal _SavedObjectGraph_default_instance_;
class SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse;
struct SavedObjectGraph_ConcreteFunctionsEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedObjectGraph_ConcreteFunctionsEntry_DoNotUseDefaultTypeInternal _SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse_default_instance_;
class SavedObject_SaveableObjectsEntry_DoNotUse;
struct SavedObject_SaveableObjectsEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedObject_SaveableObjectsEntry_DoNotUseDefaultTypeInternal _SavedObject_SaveableObjectsEntry_DoNotUse_default_instance_;
class SavedResource;
struct SavedResourceDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedResourceDefaultTypeInternal _SavedResource_default_instance_;
class SavedUserObject;
struct SavedUserObjectDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedUserObjectDefaultTypeInternal _SavedUserObject_default_instance_;
class SavedVariable;
struct SavedVariableDefaultTypeInternal;
PROTOBUF_EXPORT extern SavedVariableDefaultTypeInternal _SavedVariable_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {
enum FunctionSpec_JitCompile : int {
  FunctionSpec_JitCompile_DEFAULT = 0,
  FunctionSpec_JitCompile_ON = 1,
  FunctionSpec_JitCompile_OFF = 2,
  FunctionSpec_JitCompile_FunctionSpec_JitCompile_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FunctionSpec_JitCompile_FunctionSpec_JitCompile_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool FunctionSpec_JitCompile_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t FunctionSpec_JitCompile_internal_data_[];
constexpr FunctionSpec_JitCompile FunctionSpec_JitCompile_JitCompile_MIN = static_cast<FunctionSpec_JitCompile>(0);
constexpr FunctionSpec_JitCompile FunctionSpec_JitCompile_JitCompile_MAX = static_cast<FunctionSpec_JitCompile>(2);
constexpr int FunctionSpec_JitCompile_JitCompile_ARRAYSIZE = 2 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
FunctionSpec_JitCompile_descriptor();
template <typename T>
const std::string& FunctionSpec_JitCompile_Name(T value) {
  static_assert(std::is_same<T, FunctionSpec_JitCompile>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JitCompile_Name().");
  return FunctionSpec_JitCompile_Name(static_cast<FunctionSpec_JitCompile>(value));
}
template <>
inline const std::string& FunctionSpec_JitCompile_Name(FunctionSpec_JitCompile value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FunctionSpec_JitCompile_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool FunctionSpec_JitCompile_Parse(absl::string_view name, FunctionSpec_JitCompile* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionSpec_JitCompile>(
      FunctionSpec_JitCompile_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedResource final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedResource) */ {
 public:
  inline SavedResource() : SavedResource(nullptr) {}
  ~SavedResource() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedResource(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedResource(const SavedResource& from) : SavedResource(nullptr, from) {}
  inline SavedResource(SavedResource&& from) noexcept
      : SavedResource(nullptr, std::move(from)) {}
  inline SavedResource& operator=(const SavedResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedResource& operator=(SavedResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedResource* internal_default_instance() {
    return reinterpret_cast<const SavedResource*>(
        &_SavedResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SavedResource& a, SavedResource& b) { a.Swap(&b); }
  inline void Swap(SavedResource* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedResource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedResource* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedResource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedResource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedResource& from) { SavedResource::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedResource* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedResource"; }

 protected:
  explicit SavedResource(::google::protobuf::Arena* arena);
  SavedResource(::google::protobuf::Arena* arena, const SavedResource& from);
  SavedResource(::google::protobuf::Arena* arena, SavedResource&& from) noexcept
      : SavedResource(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 1,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedResource)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      39, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedResource& from_msg);
    ::google::protobuf::internal::ArenaStringPtr device_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedConstant final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedConstant) */ {
 public:
  inline SavedConstant() : SavedConstant(nullptr) {}
  ~SavedConstant() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedConstant(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedConstant(const SavedConstant& from) : SavedConstant(nullptr, from) {}
  inline SavedConstant(SavedConstant&& from) noexcept
      : SavedConstant(nullptr, std::move(from)) {}
  inline SavedConstant& operator=(const SavedConstant& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedConstant& operator=(SavedConstant&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedConstant& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedConstant* internal_default_instance() {
    return reinterpret_cast<const SavedConstant*>(
        &_SavedConstant_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(SavedConstant& a, SavedConstant& b) { a.Swap(&b); }
  inline void Swap(SavedConstant* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedConstant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedConstant* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedConstant>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedConstant& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedConstant& from) { SavedConstant::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedConstant* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedConstant"; }

 protected:
  explicit SavedConstant(::google::protobuf::Arena* arena);
  SavedConstant(::google::protobuf::Arena* arena, const SavedConstant& from);
  SavedConstant(::google::protobuf::Arena* arena, SavedConstant&& from) noexcept
      : SavedConstant(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOperationFieldNumber = 1,
  };
  // string operation = 1;
  void clear_operation() ;
  const std::string& operation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation(Arg_&& arg, Args_... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* value);

  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(
      const std::string& value);
  std::string* _internal_mutable_operation();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedConstant)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      42, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedConstant& from_msg);
    ::google::protobuf::internal::ArenaStringPtr operation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedAsset final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedAsset) */ {
 public:
  inline SavedAsset() : SavedAsset(nullptr) {}
  ~SavedAsset() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedAsset(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedAsset(const SavedAsset& from) : SavedAsset(nullptr, from) {}
  inline SavedAsset(SavedAsset&& from) noexcept
      : SavedAsset(nullptr, std::move(from)) {}
  inline SavedAsset& operator=(const SavedAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedAsset& operator=(SavedAsset&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedAsset& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedAsset* internal_default_instance() {
    return reinterpret_cast<const SavedAsset*>(
        &_SavedAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SavedAsset& a, SavedAsset& b) { a.Swap(&b); }
  inline void Swap(SavedAsset* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedAsset* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedAsset* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedAsset>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedAsset& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedAsset& from) { SavedAsset::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedAsset* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedAsset"; }

 protected:
  explicit SavedAsset(::google::protobuf::Arena* arena);
  SavedAsset(::google::protobuf::Arena* arena, const SavedAsset& from);
  SavedAsset(::google::protobuf::Arena* arena, SavedAsset&& from) noexcept
      : SavedAsset(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAssetFileDefIndexFieldNumber = 1,
  };
  // int32 asset_file_def_index = 1;
  void clear_asset_file_def_index() ;
  ::int32_t asset_file_def_index() const;
  void set_asset_file_def_index(::int32_t value);

  private:
  ::int32_t _internal_asset_file_def_index() const;
  void _internal_set_asset_file_def_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedAsset)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedAsset& from_msg);
    ::int32_t asset_file_def_index_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SaveableObject final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SaveableObject) */ {
 public:
  inline SaveableObject() : SaveableObject(nullptr) {}
  ~SaveableObject() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SaveableObject(
      ::google::protobuf::internal::ConstantInitialized);

  inline SaveableObject(const SaveableObject& from) : SaveableObject(nullptr, from) {}
  inline SaveableObject(SaveableObject&& from) noexcept
      : SaveableObject(nullptr, std::move(from)) {}
  inline SaveableObject& operator=(const SaveableObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveableObject& operator=(SaveableObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveableObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveableObject* internal_default_instance() {
    return reinterpret_cast<const SaveableObject*>(
        &_SaveableObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SaveableObject& a, SaveableObject& b) { a.Swap(&b); }
  inline void Swap(SaveableObject* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveableObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveableObject* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SaveableObject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SaveableObject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SaveableObject& from) { SaveableObject::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SaveableObject* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SaveableObject"; }

 protected:
  explicit SaveableObject(::google::protobuf::Arena* arena);
  SaveableObject(::google::protobuf::Arena* arena, const SaveableObject& from);
  SaveableObject(::google::protobuf::Arena* arena, SaveableObject&& from) noexcept
      : SaveableObject(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSaveFunctionFieldNumber = 2,
    kRestoreFunctionFieldNumber = 3,
  };
  // int32 save_function = 2;
  void clear_save_function() ;
  ::int32_t save_function() const;
  void set_save_function(::int32_t value);

  private:
  ::int32_t _internal_save_function() const;
  void _internal_set_save_function(::int32_t value);

  public:
  // int32 restore_function = 3;
  void clear_restore_function() ;
  ::int32_t restore_function() const;
  void set_restore_function(::int32_t value);

  private:
  ::int32_t _internal_restore_function() const;
  void _internal_set_restore_function(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SaveableObject)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SaveableObject& from_msg);
    ::int32_t save_function_;
    ::int32_t restore_function_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CapturedTensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CapturedTensor) */ {
 public:
  inline CapturedTensor() : CapturedTensor(nullptr) {}
  ~CapturedTensor() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapturedTensor(
      ::google::protobuf::internal::ConstantInitialized);

  inline CapturedTensor(const CapturedTensor& from) : CapturedTensor(nullptr, from) {}
  inline CapturedTensor(CapturedTensor&& from) noexcept
      : CapturedTensor(nullptr, std::move(from)) {}
  inline CapturedTensor& operator=(const CapturedTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapturedTensor& operator=(CapturedTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapturedTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapturedTensor* internal_default_instance() {
    return reinterpret_cast<const CapturedTensor*>(
        &_CapturedTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CapturedTensor& a, CapturedTensor& b) { a.Swap(&b); }
  inline void Swap(CapturedTensor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapturedTensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapturedTensor* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CapturedTensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapturedTensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapturedTensor& from) { CapturedTensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CapturedTensor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CapturedTensor"; }

 protected:
  explicit CapturedTensor(::google::protobuf::Arena* arena);
  CapturedTensor(::google::protobuf::Arena* arena, const CapturedTensor& from);
  CapturedTensor(::google::protobuf::Arena* arena, CapturedTensor&& from) noexcept
      : CapturedTensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kConcreteFunctionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string concrete_function = 2;
  void clear_concrete_function() ;
  const std::string& concrete_function() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_concrete_function(Arg_&& arg, Args_... args);
  std::string* mutable_concrete_function();
  PROTOBUF_NODISCARD std::string* release_concrete_function();
  void set_allocated_concrete_function(std::string* value);

  private:
  const std::string& _internal_concrete_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_concrete_function(
      const std::string& value);
  std::string* _internal_mutable_concrete_function();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CapturedTensor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CapturedTensor& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr concrete_function_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedUserObject final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedUserObject) */ {
 public:
  inline SavedUserObject() : SavedUserObject(nullptr) {}
  ~SavedUserObject() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedUserObject(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedUserObject(const SavedUserObject& from) : SavedUserObject(nullptr, from) {}
  inline SavedUserObject(SavedUserObject&& from) noexcept
      : SavedUserObject(nullptr, std::move(from)) {}
  inline SavedUserObject& operator=(const SavedUserObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedUserObject& operator=(SavedUserObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedUserObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedUserObject* internal_default_instance() {
    return reinterpret_cast<const SavedUserObject*>(
        &_SavedUserObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SavedUserObject& a, SavedUserObject& b) { a.Swap(&b); }
  inline void Swap(SavedUserObject* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedUserObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedUserObject* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedUserObject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedUserObject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedUserObject& from) { SavedUserObject::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedUserObject* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedUserObject"; }

 protected:
  explicit SavedUserObject(::google::protobuf::Arena* arena);
  SavedUserObject(::google::protobuf::Arena* arena, const SavedUserObject& from);
  SavedUserObject(::google::protobuf::Arena* arena, SavedUserObject&& from) noexcept
      : SavedUserObject(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdentifierFieldNumber = 1,
    kMetadataFieldNumber = 3,
    kVersionFieldNumber = 2,
  };
  // string identifier = 1;
  void clear_identifier() ;
  const std::string& identifier() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identifier(Arg_&& arg, Args_... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* value);

  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(
      const std::string& value);
  std::string* _internal_mutable_identifier();

  public:
  // string metadata = 3 [deprecated = true];
  [[deprecated]]  void clear_metadata() ;
  [[deprecated]] const std::string& metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_metadata(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_metadata();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_metadata();
  [[deprecated]] void set_allocated_metadata(std::string* value);

  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(
      const std::string& value);
  std::string* _internal_mutable_metadata();

  public:
  // .tensorflow.VersionDef version = 2;
  bool has_version() const;
  void clear_version() ;
  const ::tensorflow::VersionDef& version() const;
  PROTOBUF_NODISCARD ::tensorflow::VersionDef* release_version();
  ::tensorflow::VersionDef* mutable_version();
  void set_allocated_version(::tensorflow::VersionDef* value);
  void unsafe_arena_set_allocated_version(::tensorflow::VersionDef* value);
  ::tensorflow::VersionDef* unsafe_arena_release_version();

  private:
  const ::tensorflow::VersionDef& _internal_version() const;
  ::tensorflow::VersionDef* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedUserObject)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      53, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedUserObject& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr identifier_;
    ::google::protobuf::internal::ArenaStringPtr metadata_;
    ::tensorflow::VersionDef* version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class SavedObject_SaveableObjectsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SavedObject_SaveableObjectsEntry_DoNotUse, std::string, ::tensorflow::SaveableObject,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SavedObject_SaveableObjectsEntry_DoNotUse, std::string, ::tensorflow::SaveableObject,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SavedObject_SaveableObjectsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedObject_SaveableObjectsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SavedObject_SaveableObjectsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SavedObject_SaveableObjectsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SavedObject_SaveableObjectsEntry_DoNotUse*>(
        &_SavedObject_SaveableObjectsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      55, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedVariable final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedVariable) */ {
 public:
  inline SavedVariable() : SavedVariable(nullptr) {}
  ~SavedVariable() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedVariable(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedVariable(const SavedVariable& from) : SavedVariable(nullptr, from) {}
  inline SavedVariable(SavedVariable&& from) noexcept
      : SavedVariable(nullptr, std::move(from)) {}
  inline SavedVariable& operator=(const SavedVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedVariable& operator=(SavedVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedVariable* internal_default_instance() {
    return reinterpret_cast<const SavedVariable*>(
        &_SavedVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SavedVariable& a, SavedVariable& b) { a.Swap(&b); }
  inline void Swap(SavedVariable* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedVariable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedVariable* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedVariable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedVariable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedVariable& from) { SavedVariable::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedVariable* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedVariable"; }

 protected:
  explicit SavedVariable(::google::protobuf::Arena* arena);
  SavedVariable(::google::protobuf::Arena* arena, const SavedVariable& from);
  SavedVariable(::google::protobuf::Arena* arena, SavedVariable&& from) noexcept
      : SavedVariable(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExperimentalDistributedVariableComponentsFieldNumber = 8,
    kNameFieldNumber = 6,
    kDeviceFieldNumber = 7,
    kShapeFieldNumber = 2,
    kDtypeFieldNumber = 1,
    kTrainableFieldNumber = 3,
    kSynchronizationFieldNumber = 4,
    kAggregationFieldNumber = 5,
  };
  // repeated .tensorflow.SavedVariable experimental_distributed_variable_components = 8;
  int experimental_distributed_variable_components_size() const;
  private:
  int _internal_experimental_distributed_variable_components_size() const;

  public:
  void clear_experimental_distributed_variable_components() ;
  ::tensorflow::SavedVariable* mutable_experimental_distributed_variable_components(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::SavedVariable>* mutable_experimental_distributed_variable_components();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::SavedVariable>& _internal_experimental_distributed_variable_components() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::SavedVariable>* _internal_mutable_experimental_distributed_variable_components();
  public:
  const ::tensorflow::SavedVariable& experimental_distributed_variable_components(int index) const;
  ::tensorflow::SavedVariable* add_experimental_distributed_variable_components();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::SavedVariable>& experimental_distributed_variable_components() const;
  // string name = 6;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string device = 7;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // .tensorflow.TensorShapeProto shape = 2;
  bool has_shape() const;
  void clear_shape() ;
  const ::tensorflow::TensorShapeProto& shape() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorShapeProto* release_shape();
  ::tensorflow::TensorShapeProto* mutable_shape();
  void set_allocated_shape(::tensorflow::TensorShapeProto* value);
  void unsafe_arena_set_allocated_shape(::tensorflow::TensorShapeProto* value);
  ::tensorflow::TensorShapeProto* unsafe_arena_release_shape();

  private:
  const ::tensorflow::TensorShapeProto& _internal_shape() const;
  ::tensorflow::TensorShapeProto* _internal_mutable_shape();

  public:
  // .tensorflow.DataType dtype = 1;
  void clear_dtype() ;
  ::tensorflow::DataType dtype() const;
  void set_dtype(::tensorflow::DataType value);

  private:
  ::tensorflow::DataType _internal_dtype() const;
  void _internal_set_dtype(::tensorflow::DataType value);

  public:
  // bool trainable = 3;
  void clear_trainable() ;
  bool trainable() const;
  void set_trainable(bool value);

  private:
  bool _internal_trainable() const;
  void _internal_set_trainable(bool value);

  public:
  // .tensorflow.VariableSynchronization synchronization = 4;
  void clear_synchronization() ;
  ::tensorflow::VariableSynchronization synchronization() const;
  void set_synchronization(::tensorflow::VariableSynchronization value);

  private:
  ::tensorflow::VariableSynchronization _internal_synchronization() const;
  void _internal_set_synchronization(::tensorflow::VariableSynchronization value);

  public:
  // .tensorflow.VariableAggregation aggregation = 5;
  void clear_aggregation() ;
  ::tensorflow::VariableAggregation aggregation() const;
  void set_aggregation(::tensorflow::VariableAggregation value);

  private:
  ::tensorflow::VariableAggregation _internal_aggregation() const;
  void _internal_set_aggregation(::tensorflow::VariableAggregation value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedVariable)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 2,
      51, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedVariable& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::SavedVariable > experimental_distributed_variable_components_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::tensorflow::TensorShapeProto* shape_;
    int dtype_;
    bool trainable_;
    int synchronization_;
    int aggregation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedConcreteFunction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedConcreteFunction) */ {
 public:
  inline SavedConcreteFunction() : SavedConcreteFunction(nullptr) {}
  ~SavedConcreteFunction() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedConcreteFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedConcreteFunction(const SavedConcreteFunction& from) : SavedConcreteFunction(nullptr, from) {}
  inline SavedConcreteFunction(SavedConcreteFunction&& from) noexcept
      : SavedConcreteFunction(nullptr, std::move(from)) {}
  inline SavedConcreteFunction& operator=(const SavedConcreteFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedConcreteFunction& operator=(SavedConcreteFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedConcreteFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedConcreteFunction* internal_default_instance() {
    return reinterpret_cast<const SavedConcreteFunction*>(
        &_SavedConcreteFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SavedConcreteFunction& a, SavedConcreteFunction& b) { a.Swap(&b); }
  inline void Swap(SavedConcreteFunction* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedConcreteFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedConcreteFunction* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedConcreteFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedConcreteFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedConcreteFunction& from) { SavedConcreteFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedConcreteFunction* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedConcreteFunction"; }

 protected:
  explicit SavedConcreteFunction(::google::protobuf::Arena* arena);
  SavedConcreteFunction(::google::protobuf::Arena* arena, const SavedConcreteFunction& from);
  SavedConcreteFunction(::google::protobuf::Arena* arena, SavedConcreteFunction&& from) noexcept
      : SavedConcreteFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBoundInputsFieldNumber = 2,
    kCanonicalizedInputSignatureFieldNumber = 3,
    kOutputSignatureFieldNumber = 4,
  };
  // repeated int32 bound_inputs = 2;
  int bound_inputs_size() const;
  private:
  int _internal_bound_inputs_size() const;

  public:
  void clear_bound_inputs() ;
  ::int32_t bound_inputs(int index) const;
  void set_bound_inputs(int index, ::int32_t value);
  void add_bound_inputs(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& bound_inputs() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_bound_inputs();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_bound_inputs() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_bound_inputs();

  public:
  // .tensorflow.StructuredValue canonicalized_input_signature = 3;
  bool has_canonicalized_input_signature() const;
  void clear_canonicalized_input_signature() ;
  const ::tensorflow::StructuredValue& canonicalized_input_signature() const;
  PROTOBUF_NODISCARD ::tensorflow::StructuredValue* release_canonicalized_input_signature();
  ::tensorflow::StructuredValue* mutable_canonicalized_input_signature();
  void set_allocated_canonicalized_input_signature(::tensorflow::StructuredValue* value);
  void unsafe_arena_set_allocated_canonicalized_input_signature(::tensorflow::StructuredValue* value);
  ::tensorflow::StructuredValue* unsafe_arena_release_canonicalized_input_signature();

  private:
  const ::tensorflow::StructuredValue& _internal_canonicalized_input_signature() const;
  ::tensorflow::StructuredValue* _internal_mutable_canonicalized_input_signature();

  public:
  // .tensorflow.StructuredValue output_signature = 4;
  bool has_output_signature() const;
  void clear_output_signature() ;
  const ::tensorflow::StructuredValue& output_signature() const;
  PROTOBUF_NODISCARD ::tensorflow::StructuredValue* release_output_signature();
  ::tensorflow::StructuredValue* mutable_output_signature();
  void set_allocated_output_signature(::tensorflow::StructuredValue* value);
  void unsafe_arena_set_allocated_output_signature(::tensorflow::StructuredValue* value);
  ::tensorflow::StructuredValue* unsafe_arena_release_output_signature();

  private:
  const ::tensorflow::StructuredValue& _internal_output_signature() const;
  ::tensorflow::StructuredValue* _internal_mutable_output_signature();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedConcreteFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedConcreteFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> bound_inputs_;
    mutable ::google::protobuf::internal::CachedSize _bound_inputs_cached_byte_size_;
    ::tensorflow::StructuredValue* canonicalized_input_signature_;
    ::tensorflow::StructuredValue* output_signature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT FunctionSpec final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.FunctionSpec) */ {
 public:
  inline FunctionSpec() : FunctionSpec(nullptr) {}
  ~FunctionSpec() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FunctionSpec(
      ::google::protobuf::internal::ConstantInitialized);

  inline FunctionSpec(const FunctionSpec& from) : FunctionSpec(nullptr, from) {}
  inline FunctionSpec(FunctionSpec&& from) noexcept
      : FunctionSpec(nullptr, std::move(from)) {}
  inline FunctionSpec& operator=(const FunctionSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionSpec& operator=(FunctionSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionSpec* internal_default_instance() {
    return reinterpret_cast<const FunctionSpec*>(
        &_FunctionSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(FunctionSpec& a, FunctionSpec& b) { a.Swap(&b); }
  inline void Swap(FunctionSpec* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionSpec* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionSpec* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<FunctionSpec>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FunctionSpec& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FunctionSpec& from) { FunctionSpec::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FunctionSpec* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.FunctionSpec"; }

 protected:
  explicit FunctionSpec(::google::protobuf::Arena* arena);
  FunctionSpec(::google::protobuf::Arena* arena, const FunctionSpec& from);
  FunctionSpec(::google::protobuf::Arena* arena, FunctionSpec&& from) noexcept
      : FunctionSpec(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using JitCompile = FunctionSpec_JitCompile;
  static constexpr JitCompile DEFAULT = FunctionSpec_JitCompile_DEFAULT;
  static constexpr JitCompile ON = FunctionSpec_JitCompile_ON;
  static constexpr JitCompile OFF = FunctionSpec_JitCompile_OFF;
  static inline bool JitCompile_IsValid(int value) {
    return FunctionSpec_JitCompile_IsValid(value);
  }
  static constexpr JitCompile JitCompile_MIN = FunctionSpec_JitCompile_JitCompile_MIN;
  static constexpr JitCompile JitCompile_MAX = FunctionSpec_JitCompile_JitCompile_MAX;
  static constexpr int JitCompile_ARRAYSIZE = FunctionSpec_JitCompile_JitCompile_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JitCompile_descriptor() {
    return FunctionSpec_JitCompile_descriptor();
  }
  template <typename T>
  static inline const std::string& JitCompile_Name(T value) {
    return FunctionSpec_JitCompile_Name(value);
  }
  static inline bool JitCompile_Parse(absl::string_view name, JitCompile* value) {
    return FunctionSpec_JitCompile_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kFullargspecFieldNumber = 1,
    kInputSignatureFieldNumber = 5,
    kIsMethodFieldNumber = 2,
    kJitCompileFieldNumber = 6,
  };
  // .tensorflow.StructuredValue fullargspec = 1;
  bool has_fullargspec() const;
  void clear_fullargspec() ;
  const ::tensorflow::StructuredValue& fullargspec() const;
  PROTOBUF_NODISCARD ::tensorflow::StructuredValue* release_fullargspec();
  ::tensorflow::StructuredValue* mutable_fullargspec();
  void set_allocated_fullargspec(::tensorflow::StructuredValue* value);
  void unsafe_arena_set_allocated_fullargspec(::tensorflow::StructuredValue* value);
  ::tensorflow::StructuredValue* unsafe_arena_release_fullargspec();

  private:
  const ::tensorflow::StructuredValue& _internal_fullargspec() const;
  ::tensorflow::StructuredValue* _internal_mutable_fullargspec();

  public:
  // .tensorflow.StructuredValue input_signature = 5;
  bool has_input_signature() const;
  void clear_input_signature() ;
  const ::tensorflow::StructuredValue& input_signature() const;
  PROTOBUF_NODISCARD ::tensorflow::StructuredValue* release_input_signature();
  ::tensorflow::StructuredValue* mutable_input_signature();
  void set_allocated_input_signature(::tensorflow::StructuredValue* value);
  void unsafe_arena_set_allocated_input_signature(::tensorflow::StructuredValue* value);
  ::tensorflow::StructuredValue* unsafe_arena_release_input_signature();

  private:
  const ::tensorflow::StructuredValue& _internal_input_signature() const;
  ::tensorflow::StructuredValue* _internal_mutable_input_signature();

  public:
  // bool is_method = 2;
  void clear_is_method() ;
  bool is_method() const;
  void set_is_method(bool value);

  private:
  bool _internal_is_method() const;
  void _internal_set_is_method(bool value);

  public:
  // .tensorflow.FunctionSpec.JitCompile jit_compile = 6;
  void clear_jit_compile() ;
  ::tensorflow::FunctionSpec_JitCompile jit_compile() const;
  void set_jit_compile(::tensorflow::FunctionSpec_JitCompile value);

  private:
  ::tensorflow::FunctionSpec_JitCompile _internal_jit_compile() const;
  void _internal_set_jit_compile(::tensorflow::FunctionSpec_JitCompile value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.FunctionSpec)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 2,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FunctionSpec& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::StructuredValue* fullargspec_;
    ::tensorflow::StructuredValue* input_signature_;
    bool is_method_;
    int jit_compile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse, std::string, ::tensorflow::SavedConcreteFunction,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse, std::string, ::tensorflow::SavedConcreteFunction,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse*>(
        &_SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      62, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedFunction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedFunction) */ {
 public:
  inline SavedFunction() : SavedFunction(nullptr) {}
  ~SavedFunction() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedFunction(const SavedFunction& from) : SavedFunction(nullptr, from) {}
  inline SavedFunction(SavedFunction&& from) noexcept
      : SavedFunction(nullptr, std::move(from)) {}
  inline SavedFunction& operator=(const SavedFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedFunction& operator=(SavedFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedFunction* internal_default_instance() {
    return reinterpret_cast<const SavedFunction*>(
        &_SavedFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(SavedFunction& a, SavedFunction& b) { a.Swap(&b); }
  inline void Swap(SavedFunction* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedFunction* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedFunction& from) { SavedFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedFunction* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedFunction"; }

 protected:
  explicit SavedFunction(::google::protobuf::Arena* arena);
  SavedFunction(::google::protobuf::Arena* arena, const SavedFunction& from);
  SavedFunction(::google::protobuf::Arena* arena, SavedFunction&& from) noexcept
      : SavedFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConcreteFunctionsFieldNumber = 1,
    kFunctionSpecFieldNumber = 2,
  };
  // repeated string concrete_functions = 1;
  int concrete_functions_size() const;
  private:
  int _internal_concrete_functions_size() const;

  public:
  void clear_concrete_functions() ;
  const std::string& concrete_functions(int index) const;
  std::string* mutable_concrete_functions(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_concrete_functions(int index, Arg_&& value, Args_... args);
  std::string* add_concrete_functions();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_concrete_functions(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& concrete_functions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_concrete_functions();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_concrete_functions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_concrete_functions();

  public:
  // .tensorflow.FunctionSpec function_spec = 2;
  bool has_function_spec() const;
  void clear_function_spec() ;
  const ::tensorflow::FunctionSpec& function_spec() const;
  PROTOBUF_NODISCARD ::tensorflow::FunctionSpec* release_function_spec();
  ::tensorflow::FunctionSpec* mutable_function_spec();
  void set_allocated_function_spec(::tensorflow::FunctionSpec* value);
  void unsafe_arena_set_allocated_function_spec(::tensorflow::FunctionSpec* value);
  ::tensorflow::FunctionSpec* unsafe_arena_release_function_spec();

  private:
  const ::tensorflow::FunctionSpec& _internal_function_spec() const;
  ::tensorflow::FunctionSpec* _internal_mutable_function_spec();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      51, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> concrete_functions_;
    ::tensorflow::FunctionSpec* function_spec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedBareConcreteFunction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedBareConcreteFunction) */ {
 public:
  inline SavedBareConcreteFunction() : SavedBareConcreteFunction(nullptr) {}
  ~SavedBareConcreteFunction() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedBareConcreteFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedBareConcreteFunction(const SavedBareConcreteFunction& from) : SavedBareConcreteFunction(nullptr, from) {}
  inline SavedBareConcreteFunction(SavedBareConcreteFunction&& from) noexcept
      : SavedBareConcreteFunction(nullptr, std::move(from)) {}
  inline SavedBareConcreteFunction& operator=(const SavedBareConcreteFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedBareConcreteFunction& operator=(SavedBareConcreteFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedBareConcreteFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedBareConcreteFunction* internal_default_instance() {
    return reinterpret_cast<const SavedBareConcreteFunction*>(
        &_SavedBareConcreteFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(SavedBareConcreteFunction& a, SavedBareConcreteFunction& b) { a.Swap(&b); }
  inline void Swap(SavedBareConcreteFunction* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedBareConcreteFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedBareConcreteFunction* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedBareConcreteFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedBareConcreteFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedBareConcreteFunction& from) { SavedBareConcreteFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedBareConcreteFunction* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedBareConcreteFunction"; }

 protected:
  explicit SavedBareConcreteFunction(::google::protobuf::Arena* arena);
  SavedBareConcreteFunction(::google::protobuf::Arena* arena, const SavedBareConcreteFunction& from);
  SavedBareConcreteFunction(::google::protobuf::Arena* arena, SavedBareConcreteFunction&& from) noexcept
      : SavedBareConcreteFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArgumentKeywordsFieldNumber = 2,
    kConcreteFunctionNameFieldNumber = 1,
    kFunctionSpecFieldNumber = 4,
    kAllowedPositionalArgumentsFieldNumber = 3,
  };
  // repeated string argument_keywords = 2;
  int argument_keywords_size() const;
  private:
  int _internal_argument_keywords_size() const;

  public:
  void clear_argument_keywords() ;
  const std::string& argument_keywords(int index) const;
  std::string* mutable_argument_keywords(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_argument_keywords(int index, Arg_&& value, Args_... args);
  std::string* add_argument_keywords();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_argument_keywords(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& argument_keywords() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_argument_keywords();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_argument_keywords() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_argument_keywords();

  public:
  // string concrete_function_name = 1;
  void clear_concrete_function_name() ;
  const std::string& concrete_function_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_concrete_function_name(Arg_&& arg, Args_... args);
  std::string* mutable_concrete_function_name();
  PROTOBUF_NODISCARD std::string* release_concrete_function_name();
  void set_allocated_concrete_function_name(std::string* value);

  private:
  const std::string& _internal_concrete_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_concrete_function_name(
      const std::string& value);
  std::string* _internal_mutable_concrete_function_name();

  public:
  // .tensorflow.FunctionSpec function_spec = 4;
  bool has_function_spec() const;
  void clear_function_spec() ;
  const ::tensorflow::FunctionSpec& function_spec() const;
  PROTOBUF_NODISCARD ::tensorflow::FunctionSpec* release_function_spec();
  ::tensorflow::FunctionSpec* mutable_function_spec();
  void set_allocated_function_spec(::tensorflow::FunctionSpec* value);
  void unsafe_arena_set_allocated_function_spec(::tensorflow::FunctionSpec* value);
  ::tensorflow::FunctionSpec* unsafe_arena_release_function_spec();

  private:
  const ::tensorflow::FunctionSpec& _internal_function_spec() const;
  ::tensorflow::FunctionSpec* _internal_mutable_function_spec();

  public:
  // int64 allowed_positional_arguments = 3;
  void clear_allowed_positional_arguments() ;
  ::int64_t allowed_positional_arguments() const;
  void set_allowed_positional_arguments(::int64_t value);

  private:
  ::int64_t _internal_allowed_positional_arguments() const;
  void _internal_set_allowed_positional_arguments(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedBareConcreteFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      84, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedBareConcreteFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> argument_keywords_;
    ::google::protobuf::internal::ArenaStringPtr concrete_function_name_;
    ::tensorflow::FunctionSpec* function_spec_;
    ::int64_t allowed_positional_arguments_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedObject final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedObject) */ {
 public:
  inline SavedObject() : SavedObject(nullptr) {}
  ~SavedObject() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedObject(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedObject(const SavedObject& from) : SavedObject(nullptr, from) {}
  inline SavedObject(SavedObject&& from) noexcept
      : SavedObject(nullptr, std::move(from)) {}
  inline SavedObject& operator=(const SavedObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedObject& operator=(SavedObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedObject& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kUserObject = 4,
    kAsset = 5,
    kFunction = 6,
    kVariable = 7,
    kBareConcreteFunction = 8,
    kConstant = 9,
    kResource = 10,
    kCapturedTensor = 12,
    KIND_NOT_SET = 0,
  };
  static inline const SavedObject* internal_default_instance() {
    return reinterpret_cast<const SavedObject*>(
        &_SavedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SavedObject& a, SavedObject& b) { a.Swap(&b); }
  inline void Swap(SavedObject* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedObject* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedObject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedObject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedObject& from) { SavedObject::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedObject* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedObject"; }

 protected:
  explicit SavedObject(::google::protobuf::Arena* arena);
  SavedObject(::google::protobuf::Arena* arena, const SavedObject& from);
  SavedObject(::google::protobuf::Arena* arena, SavedObject&& from) noexcept
      : SavedObject(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChildrenFieldNumber = 1,
    kSlotVariablesFieldNumber = 3,
    kSaveableObjectsFieldNumber = 11,
    kDependenciesFieldNumber = 15,
    kRegisteredNameFieldNumber = 13,
    kRegisteredSaverFieldNumber = 16,
    kSerializedUserProtoFieldNumber = 14,
    kUserObjectFieldNumber = 4,
    kAssetFieldNumber = 5,
    kFunctionFieldNumber = 6,
    kVariableFieldNumber = 7,
    kBareConcreteFunctionFieldNumber = 8,
    kConstantFieldNumber = 9,
    kResourceFieldNumber = 10,
    kCapturedTensorFieldNumber = 12,
  };
  // repeated .tensorflow.TrackableObjectGraph.TrackableObject.ObjectReference children = 1;
  int children_size() const;
  private:
  int _internal_children_size() const;

  public:
  void clear_children() ;
  ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>* mutable_children();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>& _internal_children() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>* _internal_mutable_children();
  public:
  const ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference& children(int index) const;
  ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* add_children();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>& children() const;
  // repeated .tensorflow.TrackableObjectGraph.TrackableObject.SlotVariableReference slot_variables = 3;
  int slot_variables_size() const;
  private:
  int _internal_slot_variables_size() const;

  public:
  void clear_slot_variables() ;
  ::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference* mutable_slot_variables(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference>* mutable_slot_variables();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference>& _internal_slot_variables() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference>* _internal_mutable_slot_variables();
  public:
  const ::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference& slot_variables(int index) const;
  ::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference* add_slot_variables();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference>& slot_variables() const;
  // map<string, .tensorflow.SaveableObject> saveable_objects = 11;
  int saveable_objects_size() const;
  private:
  int _internal_saveable_objects_size() const;

  public:
  void clear_saveable_objects() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::SaveableObject>& saveable_objects() const;
  ::google::protobuf::Map<std::string, ::tensorflow::SaveableObject>* mutable_saveable_objects();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::SaveableObject>& _internal_saveable_objects() const;
  ::google::protobuf::Map<std::string, ::tensorflow::SaveableObject>* _internal_mutable_saveable_objects();

  public:
  // repeated .tensorflow.TrackableObjectGraph.TrackableObject.ObjectReference dependencies = 15;
  int dependencies_size() const;
  private:
  int _internal_dependencies_size() const;

  public:
  void clear_dependencies() ;
  ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* mutable_dependencies(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>* mutable_dependencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>& _internal_dependencies() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>* _internal_mutable_dependencies();
  public:
  const ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference& dependencies(int index) const;
  ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* add_dependencies();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>& dependencies() const;
  // string registered_name = 13;
  void clear_registered_name() ;
  const std::string& registered_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_registered_name(Arg_&& arg, Args_... args);
  std::string* mutable_registered_name();
  PROTOBUF_NODISCARD std::string* release_registered_name();
  void set_allocated_registered_name(std::string* value);

  private:
  const std::string& _internal_registered_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registered_name(
      const std::string& value);
  std::string* _internal_mutable_registered_name();

  public:
  // string registered_saver = 16;
  void clear_registered_saver() ;
  const std::string& registered_saver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_registered_saver(Arg_&& arg, Args_... args);
  std::string* mutable_registered_saver();
  PROTOBUF_NODISCARD std::string* release_registered_saver();
  void set_allocated_registered_saver(std::string* value);

  private:
  const std::string& _internal_registered_saver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registered_saver(
      const std::string& value);
  std::string* _internal_mutable_registered_saver();

  public:
  // .google.protobuf.Any serialized_user_proto = 14;
  bool has_serialized_user_proto() const;
  void clear_serialized_user_proto() ;
  const ::google::protobuf::Any& serialized_user_proto() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_serialized_user_proto();
  ::google::protobuf::Any* mutable_serialized_user_proto();
  void set_allocated_serialized_user_proto(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_serialized_user_proto(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_serialized_user_proto();

  private:
  const ::google::protobuf::Any& _internal_serialized_user_proto() const;
  ::google::protobuf::Any* _internal_mutable_serialized_user_proto();

  public:
  // .tensorflow.SavedUserObject user_object = 4;
  bool has_user_object() const;
  private:
  bool _internal_has_user_object() const;

  public:
  void clear_user_object() ;
  const ::tensorflow::SavedUserObject& user_object() const;
  PROTOBUF_NODISCARD ::tensorflow::SavedUserObject* release_user_object();
  ::tensorflow::SavedUserObject* mutable_user_object();
  void set_allocated_user_object(::tensorflow::SavedUserObject* value);
  void unsafe_arena_set_allocated_user_object(::tensorflow::SavedUserObject* value);
  ::tensorflow::SavedUserObject* unsafe_arena_release_user_object();

  private:
  const ::tensorflow::SavedUserObject& _internal_user_object() const;
  ::tensorflow::SavedUserObject* _internal_mutable_user_object();

  public:
  // .tensorflow.SavedAsset asset = 5;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;

  public:
  void clear_asset() ;
  const ::tensorflow::SavedAsset& asset() const;
  PROTOBUF_NODISCARD ::tensorflow::SavedAsset* release_asset();
  ::tensorflow::SavedAsset* mutable_asset();
  void set_allocated_asset(::tensorflow::SavedAsset* value);
  void unsafe_arena_set_allocated_asset(::tensorflow::SavedAsset* value);
  ::tensorflow::SavedAsset* unsafe_arena_release_asset();

  private:
  const ::tensorflow::SavedAsset& _internal_asset() const;
  ::tensorflow::SavedAsset* _internal_mutable_asset();

  public:
  // .tensorflow.SavedFunction function = 6;
  bool has_function() const;
  private:
  bool _internal_has_function() const;

  public:
  void clear_function() ;
  const ::tensorflow::SavedFunction& function() const;
  PROTOBUF_NODISCARD ::tensorflow::SavedFunction* release_function();
  ::tensorflow::SavedFunction* mutable_function();
  void set_allocated_function(::tensorflow::SavedFunction* value);
  void unsafe_arena_set_allocated_function(::tensorflow::SavedFunction* value);
  ::tensorflow::SavedFunction* unsafe_arena_release_function();

  private:
  const ::tensorflow::SavedFunction& _internal_function() const;
  ::tensorflow::SavedFunction* _internal_mutable_function();

  public:
  // .tensorflow.SavedVariable variable = 7;
  bool has_variable() const;
  private:
  bool _internal_has_variable() const;

  public:
  void clear_variable() ;
  const ::tensorflow::SavedVariable& variable() const;
  PROTOBUF_NODISCARD ::tensorflow::SavedVariable* release_variable();
  ::tensorflow::SavedVariable* mutable_variable();
  void set_allocated_variable(::tensorflow::SavedVariable* value);
  void unsafe_arena_set_allocated_variable(::tensorflow::SavedVariable* value);
  ::tensorflow::SavedVariable* unsafe_arena_release_variable();

  private:
  const ::tensorflow::SavedVariable& _internal_variable() const;
  ::tensorflow::SavedVariable* _internal_mutable_variable();

  public:
  // .tensorflow.SavedBareConcreteFunction bare_concrete_function = 8;
  bool has_bare_concrete_function() const;
  private:
  bool _internal_has_bare_concrete_function() const;

  public:
  void clear_bare_concrete_function() ;
  const ::tensorflow::SavedBareConcreteFunction& bare_concrete_function() const;
  PROTOBUF_NODISCARD ::tensorflow::SavedBareConcreteFunction* release_bare_concrete_function();
  ::tensorflow::SavedBareConcreteFunction* mutable_bare_concrete_function();
  void set_allocated_bare_concrete_function(::tensorflow::SavedBareConcreteFunction* value);
  void unsafe_arena_set_allocated_bare_concrete_function(::tensorflow::SavedBareConcreteFunction* value);
  ::tensorflow::SavedBareConcreteFunction* unsafe_arena_release_bare_concrete_function();

  private:
  const ::tensorflow::SavedBareConcreteFunction& _internal_bare_concrete_function() const;
  ::tensorflow::SavedBareConcreteFunction* _internal_mutable_bare_concrete_function();

  public:
  // .tensorflow.SavedConstant constant = 9;
  bool has_constant() const;
  private:
  bool _internal_has_constant() const;

  public:
  void clear_constant() ;
  const ::tensorflow::SavedConstant& constant() const;
  PROTOBUF_NODISCARD ::tensorflow::SavedConstant* release_constant();
  ::tensorflow::SavedConstant* mutable_constant();
  void set_allocated_constant(::tensorflow::SavedConstant* value);
  void unsafe_arena_set_allocated_constant(::tensorflow::SavedConstant* value);
  ::tensorflow::SavedConstant* unsafe_arena_release_constant();

  private:
  const ::tensorflow::SavedConstant& _internal_constant() const;
  ::tensorflow::SavedConstant* _internal_mutable_constant();

  public:
  // .tensorflow.SavedResource resource = 10;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;

  public:
  void clear_resource() ;
  const ::tensorflow::SavedResource& resource() const;
  PROTOBUF_NODISCARD ::tensorflow::SavedResource* release_resource();
  ::tensorflow::SavedResource* mutable_resource();
  void set_allocated_resource(::tensorflow::SavedResource* value);
  void unsafe_arena_set_allocated_resource(::tensorflow::SavedResource* value);
  ::tensorflow::SavedResource* unsafe_arena_release_resource();

  private:
  const ::tensorflow::SavedResource& _internal_resource() const;
  ::tensorflow::SavedResource* _internal_mutable_resource();

  public:
  // .tensorflow.CapturedTensor captured_tensor = 12;
  bool has_captured_tensor() const;
  private:
  bool _internal_has_captured_tensor() const;

  public:
  void clear_captured_tensor() ;
  const ::tensorflow::CapturedTensor& captured_tensor() const;
  PROTOBUF_NODISCARD ::tensorflow::CapturedTensor* release_captured_tensor();
  ::tensorflow::CapturedTensor* mutable_captured_tensor();
  void set_allocated_captured_tensor(::tensorflow::CapturedTensor* value);
  void unsafe_arena_set_allocated_captured_tensor(::tensorflow::CapturedTensor* value);
  ::tensorflow::CapturedTensor* unsafe_arena_release_captured_tensor();

  private:
  const ::tensorflow::CapturedTensor& _internal_captured_tensor() const;
  ::tensorflow::CapturedTensor* _internal_mutable_captured_tensor();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.SavedObject)
 private:
  class _Internal;
  void set_has_user_object();
  void set_has_asset();
  void set_has_function();
  void set_has_variable();
  void set_has_bare_concrete_function();
  void set_has_constant();
  void set_has_resource();
  void set_has_captured_tensor();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 15, 14,
      86, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedObject& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference > children_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference > slot_variables_;
    ::google::protobuf::internal::MapField<SavedObject_SaveableObjectsEntry_DoNotUse, std::string, ::tensorflow::SaveableObject,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        saveable_objects_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference > dependencies_;
    ::google::protobuf::internal::ArenaStringPtr registered_name_;
    ::google::protobuf::internal::ArenaStringPtr registered_saver_;
    ::google::protobuf::Any* serialized_user_proto_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tensorflow::SavedUserObject* user_object_;
      ::tensorflow::SavedAsset* asset_;
      ::tensorflow::SavedFunction* function_;
      ::tensorflow::SavedVariable* variable_;
      ::tensorflow::SavedBareConcreteFunction* bare_concrete_function_;
      ::tensorflow::SavedConstant* constant_;
      ::tensorflow::SavedResource* resource_;
      ::tensorflow::CapturedTensor* captured_tensor_;
    } kind_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT SavedObjectGraph final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.SavedObjectGraph) */ {
 public:
  inline SavedObjectGraph() : SavedObjectGraph(nullptr) {}
  ~SavedObjectGraph() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SavedObjectGraph(
      ::google::protobuf::internal::ConstantInitialized);

  inline SavedObjectGraph(const SavedObjectGraph& from) : SavedObjectGraph(nullptr, from) {}
  inline SavedObjectGraph(SavedObjectGraph&& from) noexcept
      : SavedObjectGraph(nullptr, std::move(from)) {}
  inline SavedObjectGraph& operator=(const SavedObjectGraph& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavedObjectGraph& operator=(SavedObjectGraph&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavedObjectGraph& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavedObjectGraph* internal_default_instance() {
    return reinterpret_cast<const SavedObjectGraph*>(
        &_SavedObjectGraph_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SavedObjectGraph& a, SavedObjectGraph& b) { a.Swap(&b); }
  inline void Swap(SavedObjectGraph* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavedObjectGraph* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavedObjectGraph* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SavedObjectGraph>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SavedObjectGraph& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SavedObjectGraph& from) { SavedObjectGraph::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SavedObjectGraph* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.SavedObjectGraph"; }

 protected:
  explicit SavedObjectGraph(::google::protobuf::Arena* arena);
  SavedObjectGraph(::google::protobuf::Arena* arena, const SavedObjectGraph& from);
  SavedObjectGraph(::google::protobuf::Arena* arena, SavedObjectGraph&& from) noexcept
      : SavedObjectGraph(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodesFieldNumber = 1,
    kConcreteFunctionsFieldNumber = 2,
  };
  // repeated .tensorflow.SavedObject nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  ::tensorflow::SavedObject* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::SavedObject>* mutable_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::SavedObject>& _internal_nodes() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::SavedObject>* _internal_mutable_nodes();
  public:
  const ::tensorflow::SavedObject& nodes(int index) const;
  ::tensorflow::SavedObject* add_nodes();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::SavedObject>& nodes() const;
  // map<string, .tensorflow.SavedConcreteFunction> concrete_functions = 2;
  int concrete_functions_size() const;
  private:
  int _internal_concrete_functions_size() const;

  public:
  void clear_concrete_functions() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::SavedConcreteFunction>& concrete_functions() const;
  ::google::protobuf::Map<std::string, ::tensorflow::SavedConcreteFunction>* mutable_concrete_functions();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::SavedConcreteFunction>& _internal_concrete_functions() const;
  ::google::protobuf::Map<std::string, ::tensorflow::SavedConcreteFunction>* _internal_mutable_concrete_functions();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.SavedObjectGraph)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 3,
      54, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SavedObjectGraph& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::SavedObject > nodes_;
    ::google::protobuf::internal::MapField<SavedObjectGraph_ConcreteFunctionsEntry_DoNotUse, std::string, ::tensorflow::SavedConcreteFunction,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        concrete_functions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SavedObjectGraph

// repeated .tensorflow.SavedObject nodes = 1;
inline int SavedObjectGraph::_internal_nodes_size() const {
  return _internal_nodes().size();
}
inline int SavedObjectGraph::nodes_size() const {
  return _internal_nodes_size();
}
inline void SavedObjectGraph::clear_nodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nodes_.Clear();
}
inline ::tensorflow::SavedObject* SavedObjectGraph::mutable_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObjectGraph.nodes)
  return _internal_mutable_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::SavedObject>* SavedObjectGraph::mutable_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SavedObjectGraph.nodes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_nodes();
}
inline const ::tensorflow::SavedObject& SavedObjectGraph::nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObjectGraph.nodes)
  return _internal_nodes().Get(index);
}
inline ::tensorflow::SavedObject* SavedObjectGraph::add_nodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::SavedObject* _add = _internal_mutable_nodes()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.SavedObjectGraph.nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::SavedObject>& SavedObjectGraph::nodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SavedObjectGraph.nodes)
  return _internal_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::SavedObject>&
SavedObjectGraph::_internal_nodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::SavedObject>*
SavedObjectGraph::_internal_mutable_nodes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.nodes_;
}

// map<string, .tensorflow.SavedConcreteFunction> concrete_functions = 2;
inline int SavedObjectGraph::_internal_concrete_functions_size() const {
  return _internal_concrete_functions().size();
}
inline int SavedObjectGraph::concrete_functions_size() const {
  return _internal_concrete_functions_size();
}
inline void SavedObjectGraph::clear_concrete_functions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_functions_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::SavedConcreteFunction>& SavedObjectGraph::_internal_concrete_functions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.concrete_functions_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::SavedConcreteFunction>& SavedObjectGraph::concrete_functions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.SavedObjectGraph.concrete_functions)
  return _internal_concrete_functions();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::SavedConcreteFunction>* SavedObjectGraph::_internal_mutable_concrete_functions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.concrete_functions_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::SavedConcreteFunction>* SavedObjectGraph::mutable_concrete_functions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.SavedObjectGraph.concrete_functions)
  return _internal_mutable_concrete_functions();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SavedObject

// repeated .tensorflow.TrackableObjectGraph.TrackableObject.ObjectReference children = 1;
inline int SavedObject::_internal_children_size() const {
  return _internal_children().size();
}
inline int SavedObject::children_size() const {
  return _internal_children_size();
}
inline ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* SavedObject::mutable_children(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.children)
  return _internal_mutable_children()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>* SavedObject::mutable_children()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SavedObject.children)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_children();
}
inline const ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference& SavedObject::children(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.children)
  return _internal_children().Get(index);
}
inline ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* SavedObject::add_children() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* _add = _internal_mutable_children()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.SavedObject.children)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>& SavedObject::children() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SavedObject.children)
  return _internal_children();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>&
SavedObject::_internal_children() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.children_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>*
SavedObject::_internal_mutable_children() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.children_;
}

// repeated .tensorflow.TrackableObjectGraph.TrackableObject.ObjectReference dependencies = 15;
inline int SavedObject::_internal_dependencies_size() const {
  return _internal_dependencies().size();
}
inline int SavedObject::dependencies_size() const {
  return _internal_dependencies_size();
}
inline ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* SavedObject::mutable_dependencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.dependencies)
  return _internal_mutable_dependencies()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>* SavedObject::mutable_dependencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SavedObject.dependencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dependencies();
}
inline const ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference& SavedObject::dependencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.dependencies)
  return _internal_dependencies().Get(index);
}
inline ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* SavedObject::add_dependencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference* _add = _internal_mutable_dependencies()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.SavedObject.dependencies)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>& SavedObject::dependencies() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SavedObject.dependencies)
  return _internal_dependencies();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>&
SavedObject::_internal_dependencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dependencies_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_ObjectReference>*
SavedObject::_internal_mutable_dependencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dependencies_;
}

// repeated .tensorflow.TrackableObjectGraph.TrackableObject.SlotVariableReference slot_variables = 3;
inline int SavedObject::_internal_slot_variables_size() const {
  return _internal_slot_variables().size();
}
inline int SavedObject::slot_variables_size() const {
  return _internal_slot_variables_size();
}
inline ::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference* SavedObject::mutable_slot_variables(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.slot_variables)
  return _internal_mutable_slot_variables()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference>* SavedObject::mutable_slot_variables()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SavedObject.slot_variables)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_slot_variables();
}
inline const ::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference& SavedObject::slot_variables(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.slot_variables)
  return _internal_slot_variables().Get(index);
}
inline ::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference* SavedObject::add_slot_variables() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference* _add = _internal_mutable_slot_variables()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.SavedObject.slot_variables)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference>& SavedObject::slot_variables() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SavedObject.slot_variables)
  return _internal_slot_variables();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference>&
SavedObject::_internal_slot_variables() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_variables_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::TrackableObjectGraph_TrackableObject_SlotVariableReference>*
SavedObject::_internal_mutable_slot_variables() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.slot_variables_;
}

// .tensorflow.SavedUserObject user_object = 4;
inline bool SavedObject::has_user_object() const {
  return kind_case() == kUserObject;
}
inline bool SavedObject::_internal_has_user_object() const {
  return kind_case() == kUserObject;
}
inline void SavedObject::set_has_user_object() {
  _impl_._oneof_case_[0] = kUserObject;
}
inline void SavedObject::clear_user_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kUserObject) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.user_object_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.user_object_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::SavedUserObject* SavedObject::release_user_object() {
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.user_object)
  if (kind_case() == kUserObject) {
    clear_has_kind();
    auto* temp = _impl_.kind_.user_object_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.user_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::SavedUserObject& SavedObject::_internal_user_object() const {
  return kind_case() == kUserObject ? *_impl_.kind_.user_object_ : reinterpret_cast<::tensorflow::SavedUserObject&>(::tensorflow::_SavedUserObject_default_instance_);
}
inline const ::tensorflow::SavedUserObject& SavedObject::user_object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.user_object)
  return _internal_user_object();
}
inline ::tensorflow::SavedUserObject* SavedObject::unsafe_arena_release_user_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SavedObject.user_object)
  if (kind_case() == kUserObject) {
    clear_has_kind();
    auto* temp = _impl_.kind_.user_object_;
    _impl_.kind_.user_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SavedObject::unsafe_arena_set_allocated_user_object(::tensorflow::SavedUserObject* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_user_object();
    _impl_.kind_.user_object_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.user_object)
}
inline ::tensorflow::SavedUserObject* SavedObject::_internal_mutable_user_object() {
  if (kind_case() != kUserObject) {
    clear_kind();
    set_has_user_object();
    _impl_.kind_.user_object_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::SavedUserObject>(GetArena());
  }
  return _impl_.kind_.user_object_;
}
inline ::tensorflow::SavedUserObject* SavedObject::mutable_user_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::SavedUserObject* _msg = _internal_mutable_user_object();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.user_object)
  return _msg;
}

// .tensorflow.SavedAsset asset = 5;
inline bool SavedObject::has_asset() const {
  return kind_case() == kAsset;
}
inline bool SavedObject::_internal_has_asset() const {
  return kind_case() == kAsset;
}
inline void SavedObject::set_has_asset() {
  _impl_._oneof_case_[0] = kAsset;
}
inline void SavedObject::clear_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kAsset) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.asset_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.asset_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::SavedAsset* SavedObject::release_asset() {
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.asset)
  if (kind_case() == kAsset) {
    clear_has_kind();
    auto* temp = _impl_.kind_.asset_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::SavedAsset& SavedObject::_internal_asset() const {
  return kind_case() == kAsset ? *_impl_.kind_.asset_ : reinterpret_cast<::tensorflow::SavedAsset&>(::tensorflow::_SavedAsset_default_instance_);
}
inline const ::tensorflow::SavedAsset& SavedObject::asset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.asset)
  return _internal_asset();
}
inline ::tensorflow::SavedAsset* SavedObject::unsafe_arena_release_asset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SavedObject.asset)
  if (kind_case() == kAsset) {
    clear_has_kind();
    auto* temp = _impl_.kind_.asset_;
    _impl_.kind_.asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SavedObject::unsafe_arena_set_allocated_asset(::tensorflow::SavedAsset* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_asset();
    _impl_.kind_.asset_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.asset)
}
inline ::tensorflow::SavedAsset* SavedObject::_internal_mutable_asset() {
  if (kind_case() != kAsset) {
    clear_kind();
    set_has_asset();
    _impl_.kind_.asset_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::SavedAsset>(GetArena());
  }
  return _impl_.kind_.asset_;
}
inline ::tensorflow::SavedAsset* SavedObject::mutable_asset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::SavedAsset* _msg = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.asset)
  return _msg;
}

// .tensorflow.SavedFunction function = 6;
inline bool SavedObject::has_function() const {
  return kind_case() == kFunction;
}
inline bool SavedObject::_internal_has_function() const {
  return kind_case() == kFunction;
}
inline void SavedObject::set_has_function() {
  _impl_._oneof_case_[0] = kFunction;
}
inline void SavedObject::clear_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kFunction) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.function_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.function_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::SavedFunction* SavedObject::release_function() {
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.function)
  if (kind_case() == kFunction) {
    clear_has_kind();
    auto* temp = _impl_.kind_.function_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::SavedFunction& SavedObject::_internal_function() const {
  return kind_case() == kFunction ? *_impl_.kind_.function_ : reinterpret_cast<::tensorflow::SavedFunction&>(::tensorflow::_SavedFunction_default_instance_);
}
inline const ::tensorflow::SavedFunction& SavedObject::function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.function)
  return _internal_function();
}
inline ::tensorflow::SavedFunction* SavedObject::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SavedObject.function)
  if (kind_case() == kFunction) {
    clear_has_kind();
    auto* temp = _impl_.kind_.function_;
    _impl_.kind_.function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SavedObject::unsafe_arena_set_allocated_function(::tensorflow::SavedFunction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_function();
    _impl_.kind_.function_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.function)
}
inline ::tensorflow::SavedFunction* SavedObject::_internal_mutable_function() {
  if (kind_case() != kFunction) {
    clear_kind();
    set_has_function();
    _impl_.kind_.function_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::SavedFunction>(GetArena());
  }
  return _impl_.kind_.function_;
}
inline ::tensorflow::SavedFunction* SavedObject::mutable_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::SavedFunction* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.function)
  return _msg;
}

// .tensorflow.SavedVariable variable = 7;
inline bool SavedObject::has_variable() const {
  return kind_case() == kVariable;
}
inline bool SavedObject::_internal_has_variable() const {
  return kind_case() == kVariable;
}
inline void SavedObject::set_has_variable() {
  _impl_._oneof_case_[0] = kVariable;
}
inline void SavedObject::clear_variable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kVariable) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.variable_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.variable_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::SavedVariable* SavedObject::release_variable() {
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.variable)
  if (kind_case() == kVariable) {
    clear_has_kind();
    auto* temp = _impl_.kind_.variable_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.variable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::SavedVariable& SavedObject::_internal_variable() const {
  return kind_case() == kVariable ? *_impl_.kind_.variable_ : reinterpret_cast<::tensorflow::SavedVariable&>(::tensorflow::_SavedVariable_default_instance_);
}
inline const ::tensorflow::SavedVariable& SavedObject::variable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.variable)
  return _internal_variable();
}
inline ::tensorflow::SavedVariable* SavedObject::unsafe_arena_release_variable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SavedObject.variable)
  if (kind_case() == kVariable) {
    clear_has_kind();
    auto* temp = _impl_.kind_.variable_;
    _impl_.kind_.variable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SavedObject::unsafe_arena_set_allocated_variable(::tensorflow::SavedVariable* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_variable();
    _impl_.kind_.variable_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.variable)
}
inline ::tensorflow::SavedVariable* SavedObject::_internal_mutable_variable() {
  if (kind_case() != kVariable) {
    clear_kind();
    set_has_variable();
    _impl_.kind_.variable_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::SavedVariable>(GetArena());
  }
  return _impl_.kind_.variable_;
}
inline ::tensorflow::SavedVariable* SavedObject::mutable_variable() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::SavedVariable* _msg = _internal_mutable_variable();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.variable)
  return _msg;
}

// .tensorflow.SavedBareConcreteFunction bare_concrete_function = 8;
inline bool SavedObject::has_bare_concrete_function() const {
  return kind_case() == kBareConcreteFunction;
}
inline bool SavedObject::_internal_has_bare_concrete_function() const {
  return kind_case() == kBareConcreteFunction;
}
inline void SavedObject::set_has_bare_concrete_function() {
  _impl_._oneof_case_[0] = kBareConcreteFunction;
}
inline void SavedObject::clear_bare_concrete_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBareConcreteFunction) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.bare_concrete_function_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.bare_concrete_function_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::SavedBareConcreteFunction* SavedObject::release_bare_concrete_function() {
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.bare_concrete_function)
  if (kind_case() == kBareConcreteFunction) {
    clear_has_kind();
    auto* temp = _impl_.kind_.bare_concrete_function_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.bare_concrete_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::SavedBareConcreteFunction& SavedObject::_internal_bare_concrete_function() const {
  return kind_case() == kBareConcreteFunction ? *_impl_.kind_.bare_concrete_function_ : reinterpret_cast<::tensorflow::SavedBareConcreteFunction&>(::tensorflow::_SavedBareConcreteFunction_default_instance_);
}
inline const ::tensorflow::SavedBareConcreteFunction& SavedObject::bare_concrete_function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.bare_concrete_function)
  return _internal_bare_concrete_function();
}
inline ::tensorflow::SavedBareConcreteFunction* SavedObject::unsafe_arena_release_bare_concrete_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SavedObject.bare_concrete_function)
  if (kind_case() == kBareConcreteFunction) {
    clear_has_kind();
    auto* temp = _impl_.kind_.bare_concrete_function_;
    _impl_.kind_.bare_concrete_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SavedObject::unsafe_arena_set_allocated_bare_concrete_function(::tensorflow::SavedBareConcreteFunction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_bare_concrete_function();
    _impl_.kind_.bare_concrete_function_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.bare_concrete_function)
}
inline ::tensorflow::SavedBareConcreteFunction* SavedObject::_internal_mutable_bare_concrete_function() {
  if (kind_case() != kBareConcreteFunction) {
    clear_kind();
    set_has_bare_concrete_function();
    _impl_.kind_.bare_concrete_function_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::SavedBareConcreteFunction>(GetArena());
  }
  return _impl_.kind_.bare_concrete_function_;
}
inline ::tensorflow::SavedBareConcreteFunction* SavedObject::mutable_bare_concrete_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::SavedBareConcreteFunction* _msg = _internal_mutable_bare_concrete_function();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.bare_concrete_function)
  return _msg;
}

// .tensorflow.SavedConstant constant = 9;
inline bool SavedObject::has_constant() const {
  return kind_case() == kConstant;
}
inline bool SavedObject::_internal_has_constant() const {
  return kind_case() == kConstant;
}
inline void SavedObject::set_has_constant() {
  _impl_._oneof_case_[0] = kConstant;
}
inline void SavedObject::clear_constant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kConstant) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.constant_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.constant_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::SavedConstant* SavedObject::release_constant() {
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.constant)
  if (kind_case() == kConstant) {
    clear_has_kind();
    auto* temp = _impl_.kind_.constant_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::SavedConstant& SavedObject::_internal_constant() const {
  return kind_case() == kConstant ? *_impl_.kind_.constant_ : reinterpret_cast<::tensorflow::SavedConstant&>(::tensorflow::_SavedConstant_default_instance_);
}
inline const ::tensorflow::SavedConstant& SavedObject::constant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.constant)
  return _internal_constant();
}
inline ::tensorflow::SavedConstant* SavedObject::unsafe_arena_release_constant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SavedObject.constant)
  if (kind_case() == kConstant) {
    clear_has_kind();
    auto* temp = _impl_.kind_.constant_;
    _impl_.kind_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SavedObject::unsafe_arena_set_allocated_constant(::tensorflow::SavedConstant* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_constant();
    _impl_.kind_.constant_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.constant)
}
inline ::tensorflow::SavedConstant* SavedObject::_internal_mutable_constant() {
  if (kind_case() != kConstant) {
    clear_kind();
    set_has_constant();
    _impl_.kind_.constant_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::SavedConstant>(GetArena());
  }
  return _impl_.kind_.constant_;
}
inline ::tensorflow::SavedConstant* SavedObject::mutable_constant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::SavedConstant* _msg = _internal_mutable_constant();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.constant)
  return _msg;
}

// .tensorflow.SavedResource resource = 10;
inline bool SavedObject::has_resource() const {
  return kind_case() == kResource;
}
inline bool SavedObject::_internal_has_resource() const {
  return kind_case() == kResource;
}
inline void SavedObject::set_has_resource() {
  _impl_._oneof_case_[0] = kResource;
}
inline void SavedObject::clear_resource() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kResource) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.resource_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.resource_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::SavedResource* SavedObject::release_resource() {
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.resource)
  if (kind_case() == kResource) {
    clear_has_kind();
    auto* temp = _impl_.kind_.resource_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.resource_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::SavedResource& SavedObject::_internal_resource() const {
  return kind_case() == kResource ? *_impl_.kind_.resource_ : reinterpret_cast<::tensorflow::SavedResource&>(::tensorflow::_SavedResource_default_instance_);
}
inline const ::tensorflow::SavedResource& SavedObject::resource() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.resource)
  return _internal_resource();
}
inline ::tensorflow::SavedResource* SavedObject::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SavedObject.resource)
  if (kind_case() == kResource) {
    clear_has_kind();
    auto* temp = _impl_.kind_.resource_;
    _impl_.kind_.resource_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SavedObject::unsafe_arena_set_allocated_resource(::tensorflow::SavedResource* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_resource();
    _impl_.kind_.resource_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.resource)
}
inline ::tensorflow::SavedResource* SavedObject::_internal_mutable_resource() {
  if (kind_case() != kResource) {
    clear_kind();
    set_has_resource();
    _impl_.kind_.resource_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::SavedResource>(GetArena());
  }
  return _impl_.kind_.resource_;
}
inline ::tensorflow::SavedResource* SavedObject::mutable_resource() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::SavedResource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.resource)
  return _msg;
}

// .tensorflow.CapturedTensor captured_tensor = 12;
inline bool SavedObject::has_captured_tensor() const {
  return kind_case() == kCapturedTensor;
}
inline bool SavedObject::_internal_has_captured_tensor() const {
  return kind_case() == kCapturedTensor;
}
inline void SavedObject::set_has_captured_tensor() {
  _impl_._oneof_case_[0] = kCapturedTensor;
}
inline void SavedObject::clear_captured_tensor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kCapturedTensor) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.captured_tensor_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.captured_tensor_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::CapturedTensor* SavedObject::release_captured_tensor() {
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.captured_tensor)
  if (kind_case() == kCapturedTensor) {
    clear_has_kind();
    auto* temp = _impl_.kind_.captured_tensor_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.captured_tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::CapturedTensor& SavedObject::_internal_captured_tensor() const {
  return kind_case() == kCapturedTensor ? *_impl_.kind_.captured_tensor_ : reinterpret_cast<::tensorflow::CapturedTensor&>(::tensorflow::_CapturedTensor_default_instance_);
}
inline const ::tensorflow::CapturedTensor& SavedObject::captured_tensor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.captured_tensor)
  return _internal_captured_tensor();
}
inline ::tensorflow::CapturedTensor* SavedObject::unsafe_arena_release_captured_tensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SavedObject.captured_tensor)
  if (kind_case() == kCapturedTensor) {
    clear_has_kind();
    auto* temp = _impl_.kind_.captured_tensor_;
    _impl_.kind_.captured_tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SavedObject::unsafe_arena_set_allocated_captured_tensor(::tensorflow::CapturedTensor* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_captured_tensor();
    _impl_.kind_.captured_tensor_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.captured_tensor)
}
inline ::tensorflow::CapturedTensor* SavedObject::_internal_mutable_captured_tensor() {
  if (kind_case() != kCapturedTensor) {
    clear_kind();
    set_has_captured_tensor();
    _impl_.kind_.captured_tensor_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::CapturedTensor>(GetArena());
  }
  return _impl_.kind_.captured_tensor_;
}
inline ::tensorflow::CapturedTensor* SavedObject::mutable_captured_tensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::CapturedTensor* _msg = _internal_mutable_captured_tensor();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.captured_tensor)
  return _msg;
}

// map<string, .tensorflow.SaveableObject> saveable_objects = 11;
inline int SavedObject::_internal_saveable_objects_size() const {
  return _internal_saveable_objects().size();
}
inline int SavedObject::saveable_objects_size() const {
  return _internal_saveable_objects_size();
}
inline void SavedObject::clear_saveable_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saveable_objects_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::SaveableObject>& SavedObject::_internal_saveable_objects() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.saveable_objects_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::SaveableObject>& SavedObject::saveable_objects() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.SavedObject.saveable_objects)
  return _internal_saveable_objects();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::SaveableObject>* SavedObject::_internal_mutable_saveable_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.saveable_objects_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::SaveableObject>* SavedObject::mutable_saveable_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.SavedObject.saveable_objects)
  return _internal_mutable_saveable_objects();
}

// string registered_name = 13;
inline void SavedObject::clear_registered_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.registered_name_.ClearToEmpty();
}
inline const std::string& SavedObject::registered_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.registered_name)
  return _internal_registered_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedObject::set_registered_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.registered_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedObject.registered_name)
}
inline std::string* SavedObject::mutable_registered_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_registered_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.registered_name)
  return _s;
}
inline const std::string& SavedObject::_internal_registered_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.registered_name_.Get();
}
inline void SavedObject::_internal_set_registered_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.registered_name_.Set(value, GetArena());
}
inline std::string* SavedObject::_internal_mutable_registered_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.registered_name_.Mutable( GetArena());
}
inline std::string* SavedObject::release_registered_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.registered_name)
  return _impl_.registered_name_.Release();
}
inline void SavedObject::set_allocated_registered_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.registered_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.registered_name_.IsDefault()) {
          _impl_.registered_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedObject.registered_name)
}

// .google.protobuf.Any serialized_user_proto = 14;
inline bool SavedObject::has_serialized_user_proto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.serialized_user_proto_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& SavedObject::_internal_serialized_user_proto() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.serialized_user_proto_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& SavedObject::serialized_user_proto() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.serialized_user_proto)
  return _internal_serialized_user_proto();
}
inline void SavedObject::unsafe_arena_set_allocated_serialized_user_proto(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.serialized_user_proto_);
  }
  _impl_.serialized_user_proto_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedObject.serialized_user_proto)
}
inline ::google::protobuf::Any* SavedObject::release_serialized_user_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.serialized_user_proto_;
  _impl_.serialized_user_proto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* SavedObject::unsafe_arena_release_serialized_user_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.serialized_user_proto)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.serialized_user_proto_;
  _impl_.serialized_user_proto_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* SavedObject::_internal_mutable_serialized_user_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.serialized_user_proto_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.serialized_user_proto_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.serialized_user_proto_;
}
inline ::google::protobuf::Any* SavedObject::mutable_serialized_user_proto() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_serialized_user_proto();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.serialized_user_proto)
  return _msg;
}
inline void SavedObject::set_allocated_serialized_user_proto(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.serialized_user_proto_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.serialized_user_proto_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedObject.serialized_user_proto)
}

// string registered_saver = 16;
inline void SavedObject::clear_registered_saver() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.registered_saver_.ClearToEmpty();
}
inline const std::string& SavedObject::registered_saver() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedObject.registered_saver)
  return _internal_registered_saver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedObject::set_registered_saver(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.registered_saver_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedObject.registered_saver)
}
inline std::string* SavedObject::mutable_registered_saver() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_registered_saver();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedObject.registered_saver)
  return _s;
}
inline const std::string& SavedObject::_internal_registered_saver() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.registered_saver_.Get();
}
inline void SavedObject::_internal_set_registered_saver(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.registered_saver_.Set(value, GetArena());
}
inline std::string* SavedObject::_internal_mutable_registered_saver() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.registered_saver_.Mutable( GetArena());
}
inline std::string* SavedObject::release_registered_saver() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedObject.registered_saver)
  return _impl_.registered_saver_.Release();
}
inline void SavedObject::set_allocated_registered_saver(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.registered_saver_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.registered_saver_.IsDefault()) {
          _impl_.registered_saver_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedObject.registered_saver)
}

inline bool SavedObject::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void SavedObject::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline SavedObject::KindCase SavedObject::kind_case() const {
  return SavedObject::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SavedUserObject

// string identifier = 1;
inline void SavedUserObject::clear_identifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identifier_.ClearToEmpty();
}
inline const std::string& SavedUserObject::identifier() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedUserObject.identifier)
  return _internal_identifier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedUserObject::set_identifier(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identifier_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedUserObject.identifier)
}
inline std::string* SavedUserObject::mutable_identifier() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedUserObject.identifier)
  return _s;
}
inline const std::string& SavedUserObject::_internal_identifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.identifier_.Get();
}
inline void SavedUserObject::_internal_set_identifier(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identifier_.Set(value, GetArena());
}
inline std::string* SavedUserObject::_internal_mutable_identifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.identifier_.Mutable( GetArena());
}
inline std::string* SavedUserObject::release_identifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedUserObject.identifier)
  return _impl_.identifier_.Release();
}
inline void SavedUserObject::set_allocated_identifier(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identifier_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.identifier_.IsDefault()) {
          _impl_.identifier_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedUserObject.identifier)
}

// .tensorflow.VersionDef version = 2;
inline bool SavedUserObject::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.version_ != nullptr);
  return value;
}
inline const ::tensorflow::VersionDef& SavedUserObject::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::VersionDef* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::VersionDef&>(::tensorflow::_VersionDef_default_instance_);
}
inline const ::tensorflow::VersionDef& SavedUserObject::version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedUserObject.version)
  return _internal_version();
}
inline void SavedUserObject::unsafe_arena_set_allocated_version(::tensorflow::VersionDef* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = reinterpret_cast<::tensorflow::VersionDef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedUserObject.version)
}
inline ::tensorflow::VersionDef* SavedUserObject::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::VersionDef* released = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::VersionDef* SavedUserObject::unsafe_arena_release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedUserObject.version)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::VersionDef* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::tensorflow::VersionDef* SavedUserObject::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::VersionDef>(GetArena());
    _impl_.version_ = reinterpret_cast<::tensorflow::VersionDef*>(p);
  }
  return _impl_.version_;
}
inline ::tensorflow::VersionDef* SavedUserObject::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::VersionDef* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedUserObject.version)
  return _msg;
}
inline void SavedUserObject::set_allocated_version(::tensorflow::VersionDef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.version_ = reinterpret_cast<::tensorflow::VersionDef*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedUserObject.version)
}

// string metadata = 3 [deprecated = true];
inline void SavedUserObject::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& SavedUserObject::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedUserObject.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedUserObject::set_metadata(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedUserObject.metadata)
}
inline std::string* SavedUserObject::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedUserObject.metadata)
  return _s;
}
inline const std::string& SavedUserObject::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.Get();
}
inline void SavedUserObject::_internal_set_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Set(value, GetArena());
}
inline std::string* SavedUserObject::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.Mutable( GetArena());
}
inline std::string* SavedUserObject::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedUserObject.metadata)
  return _impl_.metadata_.Release();
}
inline void SavedUserObject::set_allocated_metadata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_.IsDefault()) {
          _impl_.metadata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedUserObject.metadata)
}

// -------------------------------------------------------------------

// SavedAsset

// int32 asset_file_def_index = 1;
inline void SavedAsset::clear_asset_file_def_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_file_def_index_ = 0;
}
inline ::int32_t SavedAsset::asset_file_def_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.SavedAsset.asset_file_def_index)
  return _internal_asset_file_def_index();
}
inline void SavedAsset::set_asset_file_def_index(::int32_t value) {
  _internal_set_asset_file_def_index(value);
  // @@protoc_insertion_point(field_set:tensorflow.SavedAsset.asset_file_def_index)
}
inline ::int32_t SavedAsset::_internal_asset_file_def_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asset_file_def_index_;
}
inline void SavedAsset::_internal_set_asset_file_def_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_file_def_index_ = value;
}

// -------------------------------------------------------------------

// SavedFunction

// repeated string concrete_functions = 1;
inline int SavedFunction::_internal_concrete_functions_size() const {
  return _internal_concrete_functions().size();
}
inline int SavedFunction::concrete_functions_size() const {
  return _internal_concrete_functions_size();
}
inline void SavedFunction::clear_concrete_functions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_functions_.Clear();
}
inline std::string* SavedFunction::add_concrete_functions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_concrete_functions()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.SavedFunction.concrete_functions)
  return _s;
}
inline const std::string& SavedFunction::concrete_functions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedFunction.concrete_functions)
  return _internal_concrete_functions().Get(index);
}
inline std::string* SavedFunction::mutable_concrete_functions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedFunction.concrete_functions)
  return _internal_mutable_concrete_functions()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SavedFunction::set_concrete_functions(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_concrete_functions()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.SavedFunction.concrete_functions)
}
template <typename Arg_, typename... Args_>
inline void SavedFunction::add_concrete_functions(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_concrete_functions(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.SavedFunction.concrete_functions)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SavedFunction::concrete_functions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SavedFunction.concrete_functions)
  return _internal_concrete_functions();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SavedFunction::mutable_concrete_functions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SavedFunction.concrete_functions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_concrete_functions();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SavedFunction::_internal_concrete_functions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.concrete_functions_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SavedFunction::_internal_mutable_concrete_functions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.concrete_functions_;
}

// .tensorflow.FunctionSpec function_spec = 2;
inline bool SavedFunction::has_function_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.function_spec_ != nullptr);
  return value;
}
inline void SavedFunction::clear_function_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.function_spec_ != nullptr) _impl_.function_spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::FunctionSpec& SavedFunction::_internal_function_spec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::FunctionSpec* p = _impl_.function_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::FunctionSpec&>(::tensorflow::_FunctionSpec_default_instance_);
}
inline const ::tensorflow::FunctionSpec& SavedFunction::function_spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedFunction.function_spec)
  return _internal_function_spec();
}
inline void SavedFunction::unsafe_arena_set_allocated_function_spec(::tensorflow::FunctionSpec* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.function_spec_);
  }
  _impl_.function_spec_ = reinterpret_cast<::tensorflow::FunctionSpec*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedFunction.function_spec)
}
inline ::tensorflow::FunctionSpec* SavedFunction::release_function_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::FunctionSpec* released = _impl_.function_spec_;
  _impl_.function_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::FunctionSpec* SavedFunction::unsafe_arena_release_function_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedFunction.function_spec)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::FunctionSpec* temp = _impl_.function_spec_;
  _impl_.function_spec_ = nullptr;
  return temp;
}
inline ::tensorflow::FunctionSpec* SavedFunction::_internal_mutable_function_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.function_spec_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::FunctionSpec>(GetArena());
    _impl_.function_spec_ = reinterpret_cast<::tensorflow::FunctionSpec*>(p);
  }
  return _impl_.function_spec_;
}
inline ::tensorflow::FunctionSpec* SavedFunction::mutable_function_spec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::FunctionSpec* _msg = _internal_mutable_function_spec();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedFunction.function_spec)
  return _msg;
}
inline void SavedFunction::set_allocated_function_spec(::tensorflow::FunctionSpec* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.function_spec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.function_spec_ = reinterpret_cast<::tensorflow::FunctionSpec*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedFunction.function_spec)
}

// -------------------------------------------------------------------

// CapturedTensor

// string name = 1;
inline void CapturedTensor::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CapturedTensor::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CapturedTensor.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapturedTensor::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CapturedTensor.name)
}
inline std::string* CapturedTensor::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.CapturedTensor.name)
  return _s;
}
inline const std::string& CapturedTensor::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CapturedTensor::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CapturedTensor::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CapturedTensor::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CapturedTensor.name)
  return _impl_.name_.Release();
}
inline void CapturedTensor::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CapturedTensor.name)
}

// string concrete_function = 2;
inline void CapturedTensor::clear_concrete_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_function_.ClearToEmpty();
}
inline const std::string& CapturedTensor::concrete_function() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CapturedTensor.concrete_function)
  return _internal_concrete_function();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapturedTensor::set_concrete_function(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_function_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CapturedTensor.concrete_function)
}
inline std::string* CapturedTensor::mutable_concrete_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_concrete_function();
  // @@protoc_insertion_point(field_mutable:tensorflow.CapturedTensor.concrete_function)
  return _s;
}
inline const std::string& CapturedTensor::_internal_concrete_function() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.concrete_function_.Get();
}
inline void CapturedTensor::_internal_set_concrete_function(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_function_.Set(value, GetArena());
}
inline std::string* CapturedTensor::_internal_mutable_concrete_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.concrete_function_.Mutable( GetArena());
}
inline std::string* CapturedTensor::release_concrete_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CapturedTensor.concrete_function)
  return _impl_.concrete_function_.Release();
}
inline void CapturedTensor::set_allocated_concrete_function(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_function_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.concrete_function_.IsDefault()) {
          _impl_.concrete_function_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CapturedTensor.concrete_function)
}

// -------------------------------------------------------------------

// SavedConcreteFunction

// repeated int32 bound_inputs = 2;
inline int SavedConcreteFunction::_internal_bound_inputs_size() const {
  return _internal_bound_inputs().size();
}
inline int SavedConcreteFunction::bound_inputs_size() const {
  return _internal_bound_inputs_size();
}
inline void SavedConcreteFunction::clear_bound_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bound_inputs_.Clear();
}
inline ::int32_t SavedConcreteFunction::bound_inputs(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.SavedConcreteFunction.bound_inputs)
  return _internal_bound_inputs().Get(index);
}
inline void SavedConcreteFunction::set_bound_inputs(int index, ::int32_t value) {
  _internal_mutable_bound_inputs()->Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.SavedConcreteFunction.bound_inputs)
}
inline void SavedConcreteFunction::add_bound_inputs(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_bound_inputs()->Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.SavedConcreteFunction.bound_inputs)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SavedConcreteFunction::bound_inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SavedConcreteFunction.bound_inputs)
  return _internal_bound_inputs();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SavedConcreteFunction::mutable_bound_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SavedConcreteFunction.bound_inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bound_inputs();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SavedConcreteFunction::_internal_bound_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bound_inputs_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SavedConcreteFunction::_internal_mutable_bound_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bound_inputs_;
}

// .tensorflow.StructuredValue canonicalized_input_signature = 3;
inline bool SavedConcreteFunction::has_canonicalized_input_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.canonicalized_input_signature_ != nullptr);
  return value;
}
inline const ::tensorflow::StructuredValue& SavedConcreteFunction::_internal_canonicalized_input_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::StructuredValue* p = _impl_.canonicalized_input_signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::StructuredValue&>(::tensorflow::_StructuredValue_default_instance_);
}
inline const ::tensorflow::StructuredValue& SavedConcreteFunction::canonicalized_input_signature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedConcreteFunction.canonicalized_input_signature)
  return _internal_canonicalized_input_signature();
}
inline void SavedConcreteFunction::unsafe_arena_set_allocated_canonicalized_input_signature(::tensorflow::StructuredValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.canonicalized_input_signature_);
  }
  _impl_.canonicalized_input_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedConcreteFunction.canonicalized_input_signature)
}
inline ::tensorflow::StructuredValue* SavedConcreteFunction::release_canonicalized_input_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::StructuredValue* released = _impl_.canonicalized_input_signature_;
  _impl_.canonicalized_input_signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::StructuredValue* SavedConcreteFunction::unsafe_arena_release_canonicalized_input_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedConcreteFunction.canonicalized_input_signature)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::StructuredValue* temp = _impl_.canonicalized_input_signature_;
  _impl_.canonicalized_input_signature_ = nullptr;
  return temp;
}
inline ::tensorflow::StructuredValue* SavedConcreteFunction::_internal_mutable_canonicalized_input_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.canonicalized_input_signature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::StructuredValue>(GetArena());
    _impl_.canonicalized_input_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(p);
  }
  return _impl_.canonicalized_input_signature_;
}
inline ::tensorflow::StructuredValue* SavedConcreteFunction::mutable_canonicalized_input_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::StructuredValue* _msg = _internal_mutable_canonicalized_input_signature();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedConcreteFunction.canonicalized_input_signature)
  return _msg;
}
inline void SavedConcreteFunction::set_allocated_canonicalized_input_signature(::tensorflow::StructuredValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.canonicalized_input_signature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.canonicalized_input_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedConcreteFunction.canonicalized_input_signature)
}

// .tensorflow.StructuredValue output_signature = 4;
inline bool SavedConcreteFunction::has_output_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_signature_ != nullptr);
  return value;
}
inline const ::tensorflow::StructuredValue& SavedConcreteFunction::_internal_output_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::StructuredValue* p = _impl_.output_signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::StructuredValue&>(::tensorflow::_StructuredValue_default_instance_);
}
inline const ::tensorflow::StructuredValue& SavedConcreteFunction::output_signature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedConcreteFunction.output_signature)
  return _internal_output_signature();
}
inline void SavedConcreteFunction::unsafe_arena_set_allocated_output_signature(::tensorflow::StructuredValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_signature_);
  }
  _impl_.output_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedConcreteFunction.output_signature)
}
inline ::tensorflow::StructuredValue* SavedConcreteFunction::release_output_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::StructuredValue* released = _impl_.output_signature_;
  _impl_.output_signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::StructuredValue* SavedConcreteFunction::unsafe_arena_release_output_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedConcreteFunction.output_signature)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::StructuredValue* temp = _impl_.output_signature_;
  _impl_.output_signature_ = nullptr;
  return temp;
}
inline ::tensorflow::StructuredValue* SavedConcreteFunction::_internal_mutable_output_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_signature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::StructuredValue>(GetArena());
    _impl_.output_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(p);
  }
  return _impl_.output_signature_;
}
inline ::tensorflow::StructuredValue* SavedConcreteFunction::mutable_output_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::StructuredValue* _msg = _internal_mutable_output_signature();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedConcreteFunction.output_signature)
  return _msg;
}
inline void SavedConcreteFunction::set_allocated_output_signature(::tensorflow::StructuredValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_signature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.output_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedConcreteFunction.output_signature)
}

// -------------------------------------------------------------------

// SavedBareConcreteFunction

// string concrete_function_name = 1;
inline void SavedBareConcreteFunction::clear_concrete_function_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_function_name_.ClearToEmpty();
}
inline const std::string& SavedBareConcreteFunction::concrete_function_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedBareConcreteFunction.concrete_function_name)
  return _internal_concrete_function_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedBareConcreteFunction::set_concrete_function_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_function_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedBareConcreteFunction.concrete_function_name)
}
inline std::string* SavedBareConcreteFunction::mutable_concrete_function_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_concrete_function_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedBareConcreteFunction.concrete_function_name)
  return _s;
}
inline const std::string& SavedBareConcreteFunction::_internal_concrete_function_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.concrete_function_name_.Get();
}
inline void SavedBareConcreteFunction::_internal_set_concrete_function_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_function_name_.Set(value, GetArena());
}
inline std::string* SavedBareConcreteFunction::_internal_mutable_concrete_function_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.concrete_function_name_.Mutable( GetArena());
}
inline std::string* SavedBareConcreteFunction::release_concrete_function_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedBareConcreteFunction.concrete_function_name)
  return _impl_.concrete_function_name_.Release();
}
inline void SavedBareConcreteFunction::set_allocated_concrete_function_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concrete_function_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.concrete_function_name_.IsDefault()) {
          _impl_.concrete_function_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedBareConcreteFunction.concrete_function_name)
}

// repeated string argument_keywords = 2;
inline int SavedBareConcreteFunction::_internal_argument_keywords_size() const {
  return _internal_argument_keywords().size();
}
inline int SavedBareConcreteFunction::argument_keywords_size() const {
  return _internal_argument_keywords_size();
}
inline void SavedBareConcreteFunction::clear_argument_keywords() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.argument_keywords_.Clear();
}
inline std::string* SavedBareConcreteFunction::add_argument_keywords() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_argument_keywords()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.SavedBareConcreteFunction.argument_keywords)
  return _s;
}
inline const std::string& SavedBareConcreteFunction::argument_keywords(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedBareConcreteFunction.argument_keywords)
  return _internal_argument_keywords().Get(index);
}
inline std::string* SavedBareConcreteFunction::mutable_argument_keywords(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedBareConcreteFunction.argument_keywords)
  return _internal_mutable_argument_keywords()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SavedBareConcreteFunction::set_argument_keywords(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_argument_keywords()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.SavedBareConcreteFunction.argument_keywords)
}
template <typename Arg_, typename... Args_>
inline void SavedBareConcreteFunction::add_argument_keywords(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_argument_keywords(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.SavedBareConcreteFunction.argument_keywords)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SavedBareConcreteFunction::argument_keywords() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SavedBareConcreteFunction.argument_keywords)
  return _internal_argument_keywords();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SavedBareConcreteFunction::mutable_argument_keywords() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SavedBareConcreteFunction.argument_keywords)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_argument_keywords();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SavedBareConcreteFunction::_internal_argument_keywords() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.argument_keywords_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SavedBareConcreteFunction::_internal_mutable_argument_keywords() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.argument_keywords_;
}

// int64 allowed_positional_arguments = 3;
inline void SavedBareConcreteFunction::clear_allowed_positional_arguments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allowed_positional_arguments_ = ::int64_t{0};
}
inline ::int64_t SavedBareConcreteFunction::allowed_positional_arguments() const {
  // @@protoc_insertion_point(field_get:tensorflow.SavedBareConcreteFunction.allowed_positional_arguments)
  return _internal_allowed_positional_arguments();
}
inline void SavedBareConcreteFunction::set_allowed_positional_arguments(::int64_t value) {
  _internal_set_allowed_positional_arguments(value);
  // @@protoc_insertion_point(field_set:tensorflow.SavedBareConcreteFunction.allowed_positional_arguments)
}
inline ::int64_t SavedBareConcreteFunction::_internal_allowed_positional_arguments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.allowed_positional_arguments_;
}
inline void SavedBareConcreteFunction::_internal_set_allowed_positional_arguments(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allowed_positional_arguments_ = value;
}

// .tensorflow.FunctionSpec function_spec = 4;
inline bool SavedBareConcreteFunction::has_function_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.function_spec_ != nullptr);
  return value;
}
inline void SavedBareConcreteFunction::clear_function_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.function_spec_ != nullptr) _impl_.function_spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::FunctionSpec& SavedBareConcreteFunction::_internal_function_spec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::FunctionSpec* p = _impl_.function_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::FunctionSpec&>(::tensorflow::_FunctionSpec_default_instance_);
}
inline const ::tensorflow::FunctionSpec& SavedBareConcreteFunction::function_spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedBareConcreteFunction.function_spec)
  return _internal_function_spec();
}
inline void SavedBareConcreteFunction::unsafe_arena_set_allocated_function_spec(::tensorflow::FunctionSpec* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.function_spec_);
  }
  _impl_.function_spec_ = reinterpret_cast<::tensorflow::FunctionSpec*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedBareConcreteFunction.function_spec)
}
inline ::tensorflow::FunctionSpec* SavedBareConcreteFunction::release_function_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::FunctionSpec* released = _impl_.function_spec_;
  _impl_.function_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::FunctionSpec* SavedBareConcreteFunction::unsafe_arena_release_function_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedBareConcreteFunction.function_spec)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::FunctionSpec* temp = _impl_.function_spec_;
  _impl_.function_spec_ = nullptr;
  return temp;
}
inline ::tensorflow::FunctionSpec* SavedBareConcreteFunction::_internal_mutable_function_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.function_spec_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::FunctionSpec>(GetArena());
    _impl_.function_spec_ = reinterpret_cast<::tensorflow::FunctionSpec*>(p);
  }
  return _impl_.function_spec_;
}
inline ::tensorflow::FunctionSpec* SavedBareConcreteFunction::mutable_function_spec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::FunctionSpec* _msg = _internal_mutable_function_spec();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedBareConcreteFunction.function_spec)
  return _msg;
}
inline void SavedBareConcreteFunction::set_allocated_function_spec(::tensorflow::FunctionSpec* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.function_spec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.function_spec_ = reinterpret_cast<::tensorflow::FunctionSpec*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedBareConcreteFunction.function_spec)
}

// -------------------------------------------------------------------

// SavedConstant

// string operation = 1;
inline void SavedConstant::clear_operation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_.ClearToEmpty();
}
inline const std::string& SavedConstant::operation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedConstant.operation)
  return _internal_operation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedConstant::set_operation(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedConstant.operation)
}
inline std::string* SavedConstant::mutable_operation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedConstant.operation)
  return _s;
}
inline const std::string& SavedConstant::_internal_operation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_.Get();
}
inline void SavedConstant::_internal_set_operation(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_.Set(value, GetArena());
}
inline std::string* SavedConstant::_internal_mutable_operation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operation_.Mutable( GetArena());
}
inline std::string* SavedConstant::release_operation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedConstant.operation)
  return _impl_.operation_.Release();
}
inline void SavedConstant::set_allocated_operation(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_.IsDefault()) {
          _impl_.operation_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedConstant.operation)
}

// -------------------------------------------------------------------

// SavedVariable

// .tensorflow.DataType dtype = 1;
inline void SavedVariable::clear_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_ = 0;
}
inline ::tensorflow::DataType SavedVariable::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.SavedVariable.dtype)
  return _internal_dtype();
}
inline void SavedVariable::set_dtype(::tensorflow::DataType value) {
  _internal_set_dtype(value);
  // @@protoc_insertion_point(field_set:tensorflow.SavedVariable.dtype)
}
inline ::tensorflow::DataType SavedVariable::_internal_dtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::DataType>(_impl_.dtype_);
}
inline void SavedVariable::_internal_set_dtype(::tensorflow::DataType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_ = value;
}

// .tensorflow.TensorShapeProto shape = 2;
inline bool SavedVariable::has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline const ::tensorflow::TensorShapeProto& SavedVariable::_internal_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TensorShapeProto* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TensorShapeProto&>(::tensorflow::_TensorShapeProto_default_instance_);
}
inline const ::tensorflow::TensorShapeProto& SavedVariable::shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedVariable.shape)
  return _internal_shape();
}
inline void SavedVariable::unsafe_arena_set_allocated_shape(::tensorflow::TensorShapeProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SavedVariable.shape)
}
inline ::tensorflow::TensorShapeProto* SavedVariable::release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorShapeProto* released = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TensorShapeProto* SavedVariable::unsafe_arena_release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedVariable.shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorShapeProto* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorShapeProto* SavedVariable::_internal_mutable_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorShapeProto>(GetArena());
    _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(p);
  }
  return _impl_.shape_;
}
inline ::tensorflow::TensorShapeProto* SavedVariable::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::TensorShapeProto* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedVariable.shape)
  return _msg;
}
inline void SavedVariable::set_allocated_shape(::tensorflow::TensorShapeProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedVariable.shape)
}

// bool trainable = 3;
inline void SavedVariable::clear_trainable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trainable_ = false;
}
inline bool SavedVariable::trainable() const {
  // @@protoc_insertion_point(field_get:tensorflow.SavedVariable.trainable)
  return _internal_trainable();
}
inline void SavedVariable::set_trainable(bool value) {
  _internal_set_trainable(value);
  // @@protoc_insertion_point(field_set:tensorflow.SavedVariable.trainable)
}
inline bool SavedVariable::_internal_trainable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trainable_;
}
inline void SavedVariable::_internal_set_trainable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trainable_ = value;
}

// .tensorflow.VariableSynchronization synchronization = 4;
inline void SavedVariable::clear_synchronization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.synchronization_ = 0;
}
inline ::tensorflow::VariableSynchronization SavedVariable::synchronization() const {
  // @@protoc_insertion_point(field_get:tensorflow.SavedVariable.synchronization)
  return _internal_synchronization();
}
inline void SavedVariable::set_synchronization(::tensorflow::VariableSynchronization value) {
  _internal_set_synchronization(value);
  // @@protoc_insertion_point(field_set:tensorflow.SavedVariable.synchronization)
}
inline ::tensorflow::VariableSynchronization SavedVariable::_internal_synchronization() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::VariableSynchronization>(_impl_.synchronization_);
}
inline void SavedVariable::_internal_set_synchronization(::tensorflow::VariableSynchronization value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.synchronization_ = value;
}

// .tensorflow.VariableAggregation aggregation = 5;
inline void SavedVariable::clear_aggregation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregation_ = 0;
}
inline ::tensorflow::VariableAggregation SavedVariable::aggregation() const {
  // @@protoc_insertion_point(field_get:tensorflow.SavedVariable.aggregation)
  return _internal_aggregation();
}
inline void SavedVariable::set_aggregation(::tensorflow::VariableAggregation value) {
  _internal_set_aggregation(value);
  // @@protoc_insertion_point(field_set:tensorflow.SavedVariable.aggregation)
}
inline ::tensorflow::VariableAggregation SavedVariable::_internal_aggregation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::VariableAggregation>(_impl_.aggregation_);
}
inline void SavedVariable::_internal_set_aggregation(::tensorflow::VariableAggregation value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregation_ = value;
}

// string name = 6;
inline void SavedVariable::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SavedVariable::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedVariable.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedVariable::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedVariable.name)
}
inline std::string* SavedVariable::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedVariable.name)
  return _s;
}
inline const std::string& SavedVariable::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void SavedVariable::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SavedVariable::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SavedVariable::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedVariable.name)
  return _impl_.name_.Release();
}
inline void SavedVariable::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedVariable.name)
}

// string device = 7;
inline void SavedVariable::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& SavedVariable::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedVariable.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedVariable::set_device(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedVariable.device)
}
inline std::string* SavedVariable::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedVariable.device)
  return _s;
}
inline const std::string& SavedVariable::_internal_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_.Get();
}
inline void SavedVariable::_internal_set_device(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.Set(value, GetArena());
}
inline std::string* SavedVariable::_internal_mutable_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* SavedVariable::release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedVariable.device)
  return _impl_.device_.Release();
}
inline void SavedVariable::set_allocated_device(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedVariable.device)
}

// repeated .tensorflow.SavedVariable experimental_distributed_variable_components = 8;
inline int SavedVariable::_internal_experimental_distributed_variable_components_size() const {
  return _internal_experimental_distributed_variable_components().size();
}
inline int SavedVariable::experimental_distributed_variable_components_size() const {
  return _internal_experimental_distributed_variable_components_size();
}
inline void SavedVariable::clear_experimental_distributed_variable_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.experimental_distributed_variable_components_.Clear();
}
inline ::tensorflow::SavedVariable* SavedVariable::mutable_experimental_distributed_variable_components(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedVariable.experimental_distributed_variable_components)
  return _internal_mutable_experimental_distributed_variable_components()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::SavedVariable>* SavedVariable::mutable_experimental_distributed_variable_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.SavedVariable.experimental_distributed_variable_components)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_experimental_distributed_variable_components();
}
inline const ::tensorflow::SavedVariable& SavedVariable::experimental_distributed_variable_components(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedVariable.experimental_distributed_variable_components)
  return _internal_experimental_distributed_variable_components().Get(index);
}
inline ::tensorflow::SavedVariable* SavedVariable::add_experimental_distributed_variable_components() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::SavedVariable* _add = _internal_mutable_experimental_distributed_variable_components()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.SavedVariable.experimental_distributed_variable_components)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::SavedVariable>& SavedVariable::experimental_distributed_variable_components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.SavedVariable.experimental_distributed_variable_components)
  return _internal_experimental_distributed_variable_components();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::SavedVariable>&
SavedVariable::_internal_experimental_distributed_variable_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.experimental_distributed_variable_components_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::SavedVariable>*
SavedVariable::_internal_mutable_experimental_distributed_variable_components() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.experimental_distributed_variable_components_;
}

// -------------------------------------------------------------------

// FunctionSpec

// .tensorflow.StructuredValue fullargspec = 1;
inline bool FunctionSpec::has_fullargspec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fullargspec_ != nullptr);
  return value;
}
inline const ::tensorflow::StructuredValue& FunctionSpec::_internal_fullargspec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::StructuredValue* p = _impl_.fullargspec_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::StructuredValue&>(::tensorflow::_StructuredValue_default_instance_);
}
inline const ::tensorflow::StructuredValue& FunctionSpec::fullargspec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.FunctionSpec.fullargspec)
  return _internal_fullargspec();
}
inline void FunctionSpec::unsafe_arena_set_allocated_fullargspec(::tensorflow::StructuredValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fullargspec_);
  }
  _impl_.fullargspec_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.FunctionSpec.fullargspec)
}
inline ::tensorflow::StructuredValue* FunctionSpec::release_fullargspec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::StructuredValue* released = _impl_.fullargspec_;
  _impl_.fullargspec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::StructuredValue* FunctionSpec::unsafe_arena_release_fullargspec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.FunctionSpec.fullargspec)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::StructuredValue* temp = _impl_.fullargspec_;
  _impl_.fullargspec_ = nullptr;
  return temp;
}
inline ::tensorflow::StructuredValue* FunctionSpec::_internal_mutable_fullargspec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fullargspec_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::StructuredValue>(GetArena());
    _impl_.fullargspec_ = reinterpret_cast<::tensorflow::StructuredValue*>(p);
  }
  return _impl_.fullargspec_;
}
inline ::tensorflow::StructuredValue* FunctionSpec::mutable_fullargspec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::StructuredValue* _msg = _internal_mutable_fullargspec();
  // @@protoc_insertion_point(field_mutable:tensorflow.FunctionSpec.fullargspec)
  return _msg;
}
inline void FunctionSpec::set_allocated_fullargspec(::tensorflow::StructuredValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fullargspec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fullargspec_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.FunctionSpec.fullargspec)
}

// bool is_method = 2;
inline void FunctionSpec::clear_is_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_method_ = false;
}
inline bool FunctionSpec::is_method() const {
  // @@protoc_insertion_point(field_get:tensorflow.FunctionSpec.is_method)
  return _internal_is_method();
}
inline void FunctionSpec::set_is_method(bool value) {
  _internal_set_is_method(value);
  // @@protoc_insertion_point(field_set:tensorflow.FunctionSpec.is_method)
}
inline bool FunctionSpec::_internal_is_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_method_;
}
inline void FunctionSpec::_internal_set_is_method(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_method_ = value;
}

// .tensorflow.StructuredValue input_signature = 5;
inline bool FunctionSpec::has_input_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_signature_ != nullptr);
  return value;
}
inline const ::tensorflow::StructuredValue& FunctionSpec::_internal_input_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::StructuredValue* p = _impl_.input_signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::StructuredValue&>(::tensorflow::_StructuredValue_default_instance_);
}
inline const ::tensorflow::StructuredValue& FunctionSpec::input_signature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.FunctionSpec.input_signature)
  return _internal_input_signature();
}
inline void FunctionSpec::unsafe_arena_set_allocated_input_signature(::tensorflow::StructuredValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_signature_);
  }
  _impl_.input_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.FunctionSpec.input_signature)
}
inline ::tensorflow::StructuredValue* FunctionSpec::release_input_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::StructuredValue* released = _impl_.input_signature_;
  _impl_.input_signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::StructuredValue* FunctionSpec::unsafe_arena_release_input_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.FunctionSpec.input_signature)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::StructuredValue* temp = _impl_.input_signature_;
  _impl_.input_signature_ = nullptr;
  return temp;
}
inline ::tensorflow::StructuredValue* FunctionSpec::_internal_mutable_input_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_signature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::StructuredValue>(GetArena());
    _impl_.input_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(p);
  }
  return _impl_.input_signature_;
}
inline ::tensorflow::StructuredValue* FunctionSpec::mutable_input_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::StructuredValue* _msg = _internal_mutable_input_signature();
  // @@protoc_insertion_point(field_mutable:tensorflow.FunctionSpec.input_signature)
  return _msg;
}
inline void FunctionSpec::set_allocated_input_signature(::tensorflow::StructuredValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_signature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_signature_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.FunctionSpec.input_signature)
}

// .tensorflow.FunctionSpec.JitCompile jit_compile = 6;
inline void FunctionSpec::clear_jit_compile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jit_compile_ = 0;
}
inline ::tensorflow::FunctionSpec_JitCompile FunctionSpec::jit_compile() const {
  // @@protoc_insertion_point(field_get:tensorflow.FunctionSpec.jit_compile)
  return _internal_jit_compile();
}
inline void FunctionSpec::set_jit_compile(::tensorflow::FunctionSpec_JitCompile value) {
  _internal_set_jit_compile(value);
  // @@protoc_insertion_point(field_set:tensorflow.FunctionSpec.jit_compile)
}
inline ::tensorflow::FunctionSpec_JitCompile FunctionSpec::_internal_jit_compile() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::FunctionSpec_JitCompile>(_impl_.jit_compile_);
}
inline void FunctionSpec::_internal_set_jit_compile(::tensorflow::FunctionSpec_JitCompile value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jit_compile_ = value;
}

// -------------------------------------------------------------------

// SavedResource

// string device = 1;
inline void SavedResource::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& SavedResource::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.SavedResource.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SavedResource::set_device(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.SavedResource.device)
}
inline std::string* SavedResource::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:tensorflow.SavedResource.device)
  return _s;
}
inline const std::string& SavedResource::_internal_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_.Get();
}
inline void SavedResource::_internal_set_device(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.Set(value, GetArena());
}
inline std::string* SavedResource::_internal_mutable_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* SavedResource::release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.SavedResource.device)
  return _impl_.device_.Release();
}
inline void SavedResource::set_allocated_device(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SavedResource.device)
}

// -------------------------------------------------------------------

// SaveableObject

// int32 save_function = 2;
inline void SaveableObject::clear_save_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.save_function_ = 0;
}
inline ::int32_t SaveableObject::save_function() const {
  // @@protoc_insertion_point(field_get:tensorflow.SaveableObject.save_function)
  return _internal_save_function();
}
inline void SaveableObject::set_save_function(::int32_t value) {
  _internal_set_save_function(value);
  // @@protoc_insertion_point(field_set:tensorflow.SaveableObject.save_function)
}
inline ::int32_t SaveableObject::_internal_save_function() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.save_function_;
}
inline void SaveableObject::_internal_set_save_function(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.save_function_ = value;
}

// int32 restore_function = 3;
inline void SaveableObject::clear_restore_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.restore_function_ = 0;
}
inline ::int32_t SaveableObject::restore_function() const {
  // @@protoc_insertion_point(field_get:tensorflow.SaveableObject.restore_function)
  return _internal_restore_function();
}
inline void SaveableObject::set_restore_function(::int32_t value) {
  _internal_set_restore_function(value);
  // @@protoc_insertion_point(field_set:tensorflow.SaveableObject.restore_function)
}
inline ::int32_t SaveableObject::_internal_restore_function() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.restore_function_;
}
inline void SaveableObject::_internal_set_restore_function(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.restore_function_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tensorflow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tensorflow::FunctionSpec_JitCompile> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::FunctionSpec_JitCompile>() {
  return ::tensorflow::FunctionSpec_JitCompile_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fsaved_5fobject_5fgraph_2eproto_2epb_2eh
