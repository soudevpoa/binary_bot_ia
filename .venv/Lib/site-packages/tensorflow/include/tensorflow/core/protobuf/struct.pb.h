// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: tensorflow/core/protobuf/struct.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "tensorflow/core/framework/tensor.pb.h"
#include "tensorflow/core/framework/tensor_shape.pb.h"
#include "tensorflow/core/framework/types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
namespace tensorflow {
class BoundedTensorSpecProto;
struct BoundedTensorSpecProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern BoundedTensorSpecProtoDefaultTypeInternal _BoundedTensorSpecProto_default_instance_;
class DictValue;
struct DictValueDefaultTypeInternal;
PROTOBUF_EXPORT extern DictValueDefaultTypeInternal _DictValue_default_instance_;
class DictValue_FieldsEntry_DoNotUse;
struct DictValue_FieldsEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern DictValue_FieldsEntry_DoNotUseDefaultTypeInternal _DictValue_FieldsEntry_DoNotUse_default_instance_;
class ListValue;
struct ListValueDefaultTypeInternal;
PROTOBUF_EXPORT extern ListValueDefaultTypeInternal _ListValue_default_instance_;
class NamedTupleValue;
struct NamedTupleValueDefaultTypeInternal;
PROTOBUF_EXPORT extern NamedTupleValueDefaultTypeInternal _NamedTupleValue_default_instance_;
class NoneValue;
struct NoneValueDefaultTypeInternal;
PROTOBUF_EXPORT extern NoneValueDefaultTypeInternal _NoneValue_default_instance_;
class PairValue;
struct PairValueDefaultTypeInternal;
PROTOBUF_EXPORT extern PairValueDefaultTypeInternal _PairValue_default_instance_;
class StructuredValue;
struct StructuredValueDefaultTypeInternal;
PROTOBUF_EXPORT extern StructuredValueDefaultTypeInternal _StructuredValue_default_instance_;
class TensorSpecProto;
struct TensorSpecProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern TensorSpecProtoDefaultTypeInternal _TensorSpecProto_default_instance_;
class TupleValue;
struct TupleValueDefaultTypeInternal;
PROTOBUF_EXPORT extern TupleValueDefaultTypeInternal _TupleValue_default_instance_;
class TypeSpecProto;
struct TypeSpecProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern TypeSpecProtoDefaultTypeInternal _TypeSpecProto_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {
enum TypeSpecProto_TypeSpecClass : int {
  TypeSpecProto_TypeSpecClass_UNKNOWN = 0,
  TypeSpecProto_TypeSpecClass_SPARSE_TENSOR_SPEC = 1,
  TypeSpecProto_TypeSpecClass_INDEXED_SLICES_SPEC = 2,
  TypeSpecProto_TypeSpecClass_RAGGED_TENSOR_SPEC = 3,
  TypeSpecProto_TypeSpecClass_TENSOR_ARRAY_SPEC = 4,
  TypeSpecProto_TypeSpecClass_DATA_DATASET_SPEC = 5,
  TypeSpecProto_TypeSpecClass_DATA_ITERATOR_SPEC = 6,
  TypeSpecProto_TypeSpecClass_OPTIONAL_SPEC = 7,
  TypeSpecProto_TypeSpecClass_PER_REPLICA_SPEC = 8,
  TypeSpecProto_TypeSpecClass_VARIABLE_SPEC = 9,
  TypeSpecProto_TypeSpecClass_ROW_PARTITION_SPEC = 10,
  TypeSpecProto_TypeSpecClass_REGISTERED_TYPE_SPEC = 12,
  TypeSpecProto_TypeSpecClass_EXTENSION_TYPE_SPEC = 13,
  TypeSpecProto_TypeSpecClass_TypeSpecProto_TypeSpecClass_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TypeSpecProto_TypeSpecClass_TypeSpecProto_TypeSpecClass_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool TypeSpecProto_TypeSpecClass_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t TypeSpecProto_TypeSpecClass_internal_data_[];
constexpr TypeSpecProto_TypeSpecClass TypeSpecProto_TypeSpecClass_TypeSpecClass_MIN = static_cast<TypeSpecProto_TypeSpecClass>(0);
constexpr TypeSpecProto_TypeSpecClass TypeSpecProto_TypeSpecClass_TypeSpecClass_MAX = static_cast<TypeSpecProto_TypeSpecClass>(13);
constexpr int TypeSpecProto_TypeSpecClass_TypeSpecClass_ARRAYSIZE = 13 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
TypeSpecProto_TypeSpecClass_descriptor();
template <typename T>
const std::string& TypeSpecProto_TypeSpecClass_Name(T value) {
  static_assert(std::is_same<T, TypeSpecProto_TypeSpecClass>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TypeSpecClass_Name().");
  return TypeSpecProto_TypeSpecClass_Name(static_cast<TypeSpecProto_TypeSpecClass>(value));
}
template <>
inline const std::string& TypeSpecProto_TypeSpecClass_Name(TypeSpecProto_TypeSpecClass value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TypeSpecProto_TypeSpecClass_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool TypeSpecProto_TypeSpecClass_Parse(absl::string_view name, TypeSpecProto_TypeSpecClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TypeSpecProto_TypeSpecClass>(
      TypeSpecProto_TypeSpecClass_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT NoneValue final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tensorflow.NoneValue) */ {
 public:
  inline NoneValue() : NoneValue(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NoneValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline NoneValue(const NoneValue& from) : NoneValue(nullptr, from) {}
  inline NoneValue(NoneValue&& from) noexcept
      : NoneValue(nullptr, std::move(from)) {}
  inline NoneValue& operator=(const NoneValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoneValue& operator=(NoneValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoneValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoneValue* internal_default_instance() {
    return reinterpret_cast<const NoneValue*>(
        &_NoneValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(NoneValue& a, NoneValue& b) { a.Swap(&b); }
  inline void Swap(NoneValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoneValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoneValue* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<NoneValue>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NoneValue& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NoneValue& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.NoneValue"; }

 protected:
  explicit NoneValue(::google::protobuf::Arena* arena);
  NoneValue(::google::protobuf::Arena* arena, const NoneValue& from);
  NoneValue(::google::protobuf::Arena* arena, NoneValue&& from) noexcept
      : NoneValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tensorflow.NoneValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NoneValue& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TensorSpecProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TensorSpecProto) */ {
 public:
  inline TensorSpecProto() : TensorSpecProto(nullptr) {}
  ~TensorSpecProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TensorSpecProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline TensorSpecProto(const TensorSpecProto& from) : TensorSpecProto(nullptr, from) {}
  inline TensorSpecProto(TensorSpecProto&& from) noexcept
      : TensorSpecProto(nullptr, std::move(from)) {}
  inline TensorSpecProto& operator=(const TensorSpecProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorSpecProto& operator=(TensorSpecProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorSpecProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorSpecProto* internal_default_instance() {
    return reinterpret_cast<const TensorSpecProto*>(
        &_TensorSpecProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(TensorSpecProto& a, TensorSpecProto& b) { a.Swap(&b); }
  inline void Swap(TensorSpecProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorSpecProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorSpecProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TensorSpecProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorSpecProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TensorSpecProto& from) { TensorSpecProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorSpecProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TensorSpecProto"; }

 protected:
  explicit TensorSpecProto(::google::protobuf::Arena* arena);
  TensorSpecProto(::google::protobuf::Arena* arena, const TensorSpecProto& from);
  TensorSpecProto(::google::protobuf::Arena* arena, TensorSpecProto&& from) noexcept
      : TensorSpecProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kShapeFieldNumber = 2,
    kDtypeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .tensorflow.TensorShapeProto shape = 2;
  bool has_shape() const;
  void clear_shape() ;
  const ::tensorflow::TensorShapeProto& shape() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorShapeProto* release_shape();
  ::tensorflow::TensorShapeProto* mutable_shape();
  void set_allocated_shape(::tensorflow::TensorShapeProto* value);
  void unsafe_arena_set_allocated_shape(::tensorflow::TensorShapeProto* value);
  ::tensorflow::TensorShapeProto* unsafe_arena_release_shape();

  private:
  const ::tensorflow::TensorShapeProto& _internal_shape() const;
  ::tensorflow::TensorShapeProto* _internal_mutable_shape();

  public:
  // .tensorflow.DataType dtype = 3;
  void clear_dtype() ;
  ::tensorflow::DataType dtype() const;
  void set_dtype(::tensorflow::DataType value);

  private:
  ::tensorflow::DataType _internal_dtype() const;
  void _internal_set_dtype(::tensorflow::DataType value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.TensorSpecProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      39, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TensorSpecProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::tensorflow::TensorShapeProto* shape_;
    int dtype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BoundedTensorSpecProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.BoundedTensorSpecProto) */ {
 public:
  inline BoundedTensorSpecProto() : BoundedTensorSpecProto(nullptr) {}
  ~BoundedTensorSpecProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BoundedTensorSpecProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline BoundedTensorSpecProto(const BoundedTensorSpecProto& from) : BoundedTensorSpecProto(nullptr, from) {}
  inline BoundedTensorSpecProto(BoundedTensorSpecProto&& from) noexcept
      : BoundedTensorSpecProto(nullptr, std::move(from)) {}
  inline BoundedTensorSpecProto& operator=(const BoundedTensorSpecProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundedTensorSpecProto& operator=(BoundedTensorSpecProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoundedTensorSpecProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoundedTensorSpecProto* internal_default_instance() {
    return reinterpret_cast<const BoundedTensorSpecProto*>(
        &_BoundedTensorSpecProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(BoundedTensorSpecProto& a, BoundedTensorSpecProto& b) { a.Swap(&b); }
  inline void Swap(BoundedTensorSpecProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundedTensorSpecProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoundedTensorSpecProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BoundedTensorSpecProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoundedTensorSpecProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BoundedTensorSpecProto& from) { BoundedTensorSpecProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoundedTensorSpecProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.BoundedTensorSpecProto"; }

 protected:
  explicit BoundedTensorSpecProto(::google::protobuf::Arena* arena);
  BoundedTensorSpecProto(::google::protobuf::Arena* arena, const BoundedTensorSpecProto& from);
  BoundedTensorSpecProto(::google::protobuf::Arena* arena, BoundedTensorSpecProto&& from) noexcept
      : BoundedTensorSpecProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kShapeFieldNumber = 2,
    kMinimumFieldNumber = 4,
    kMaximumFieldNumber = 5,
    kDtypeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .tensorflow.TensorShapeProto shape = 2;
  bool has_shape() const;
  void clear_shape() ;
  const ::tensorflow::TensorShapeProto& shape() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorShapeProto* release_shape();
  ::tensorflow::TensorShapeProto* mutable_shape();
  void set_allocated_shape(::tensorflow::TensorShapeProto* value);
  void unsafe_arena_set_allocated_shape(::tensorflow::TensorShapeProto* value);
  ::tensorflow::TensorShapeProto* unsafe_arena_release_shape();

  private:
  const ::tensorflow::TensorShapeProto& _internal_shape() const;
  ::tensorflow::TensorShapeProto* _internal_mutable_shape();

  public:
  // .tensorflow.TensorProto minimum = 4;
  bool has_minimum() const;
  void clear_minimum() ;
  const ::tensorflow::TensorProto& minimum() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorProto* release_minimum();
  ::tensorflow::TensorProto* mutable_minimum();
  void set_allocated_minimum(::tensorflow::TensorProto* value);
  void unsafe_arena_set_allocated_minimum(::tensorflow::TensorProto* value);
  ::tensorflow::TensorProto* unsafe_arena_release_minimum();

  private:
  const ::tensorflow::TensorProto& _internal_minimum() const;
  ::tensorflow::TensorProto* _internal_mutable_minimum();

  public:
  // .tensorflow.TensorProto maximum = 5;
  bool has_maximum() const;
  void clear_maximum() ;
  const ::tensorflow::TensorProto& maximum() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorProto* release_maximum();
  ::tensorflow::TensorProto* mutable_maximum();
  void set_allocated_maximum(::tensorflow::TensorProto* value);
  void unsafe_arena_set_allocated_maximum(::tensorflow::TensorProto* value);
  ::tensorflow::TensorProto* unsafe_arena_release_maximum();

  private:
  const ::tensorflow::TensorProto& _internal_maximum() const;
  ::tensorflow::TensorProto* _internal_mutable_maximum();

  public:
  // .tensorflow.DataType dtype = 3;
  void clear_dtype() ;
  ::tensorflow::DataType dtype() const;
  void set_dtype(::tensorflow::DataType value);

  private:
  ::tensorflow::DataType _internal_dtype() const;
  void _internal_set_dtype(::tensorflow::DataType value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.BoundedTensorSpecProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      46, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BoundedTensorSpecProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::tensorflow::TensorShapeProto* shape_;
    ::tensorflow::TensorProto* minimum_;
    ::tensorflow::TensorProto* maximum_;
    int dtype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT DictValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.DictValue) */ {
 public:
  inline DictValue() : DictValue(nullptr) {}
  ~DictValue() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DictValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline DictValue(const DictValue& from) : DictValue(nullptr, from) {}
  inline DictValue(DictValue&& from) noexcept
      : DictValue(nullptr, std::move(from)) {}
  inline DictValue& operator=(const DictValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictValue& operator=(DictValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DictValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const DictValue* internal_default_instance() {
    return reinterpret_cast<const DictValue*>(
        &_DictValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(DictValue& a, DictValue& b) { a.Swap(&b); }
  inline void Swap(DictValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DictValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DictValue* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<DictValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DictValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DictValue& from) { DictValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DictValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.DictValue"; }

 protected:
  explicit DictValue(::google::protobuf::Arena* arena);
  DictValue(::google::protobuf::Arena* arena, const DictValue& from);
  DictValue(::google::protobuf::Arena* arena, DictValue&& from) noexcept
      : DictValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 1,
  };
  // map<string, .tensorflow.StructuredValue> fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::StructuredValue>& fields() const;
  ::google::protobuf::Map<std::string, ::tensorflow::StructuredValue>* mutable_fields();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::StructuredValue>& _internal_fields() const;
  ::google::protobuf::Map<std::string, ::tensorflow::StructuredValue>* _internal_mutable_fields();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.DictValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 2,
      35, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DictValue& from_msg);
    ::google::protobuf::internal::MapField<DictValue_FieldsEntry_DoNotUse, std::string, ::tensorflow::StructuredValue,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        fields_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class DictValue_FieldsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          DictValue_FieldsEntry_DoNotUse, std::string, ::tensorflow::StructuredValue,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      DictValue_FieldsEntry_DoNotUse, std::string, ::tensorflow::StructuredValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  DictValue_FieldsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DictValue_FieldsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit DictValue_FieldsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const DictValue_FieldsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const DictValue_FieldsEntry_DoNotUse*>(
        &_DictValue_FieldsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      44, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT ListValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.ListValue) */ {
 public:
  inline ListValue() : ListValue(nullptr) {}
  ~ListValue() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListValue(const ListValue& from) : ListValue(nullptr, from) {}
  inline ListValue(ListValue&& from) noexcept
      : ListValue(nullptr, std::move(from)) {}
  inline ListValue& operator=(const ListValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListValue& operator=(ListValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListValue* internal_default_instance() {
    return reinterpret_cast<const ListValue*>(
        &_ListValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ListValue& a, ListValue& b) { a.Swap(&b); }
  inline void Swap(ListValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListValue* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ListValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListValue& from) { ListValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.ListValue"; }

 protected:
  explicit ListValue(::google::protobuf::Arena* arena);
  ListValue(::google::protobuf::Arena* arena, const ListValue& from);
  ListValue(::google::protobuf::Arena* arena, ListValue&& from) noexcept
      : ListValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .tensorflow.StructuredValue values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::tensorflow::StructuredValue* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>* _internal_mutable_values();
  public:
  const ::tensorflow::StructuredValue& values(int index) const;
  ::tensorflow::StructuredValue* add_values();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>& values() const;
  // @@protoc_insertion_point(class_scope:tensorflow.ListValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListValue& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::StructuredValue > values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT NamedTupleValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.NamedTupleValue) */ {
 public:
  inline NamedTupleValue() : NamedTupleValue(nullptr) {}
  ~NamedTupleValue() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NamedTupleValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline NamedTupleValue(const NamedTupleValue& from) : NamedTupleValue(nullptr, from) {}
  inline NamedTupleValue(NamedTupleValue&& from) noexcept
      : NamedTupleValue(nullptr, std::move(from)) {}
  inline NamedTupleValue& operator=(const NamedTupleValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedTupleValue& operator=(NamedTupleValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedTupleValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedTupleValue* internal_default_instance() {
    return reinterpret_cast<const NamedTupleValue*>(
        &_NamedTupleValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(NamedTupleValue& a, NamedTupleValue& b) { a.Swap(&b); }
  inline void Swap(NamedTupleValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedTupleValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedTupleValue* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<NamedTupleValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NamedTupleValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NamedTupleValue& from) { NamedTupleValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NamedTupleValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.NamedTupleValue"; }

 protected:
  explicit NamedTupleValue(::google::protobuf::Arena* arena);
  NamedTupleValue(::google::protobuf::Arena* arena, const NamedTupleValue& from);
  NamedTupleValue(::google::protobuf::Arena* arena, NamedTupleValue&& from) noexcept
      : NamedTupleValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .tensorflow.PairValue values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::tensorflow::PairValue* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::PairValue>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::PairValue>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::PairValue>* _internal_mutable_values();
  public:
  const ::tensorflow::PairValue& values(int index) const;
  ::tensorflow::PairValue* add_values();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::PairValue>& values() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.NamedTupleValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      39, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NamedTupleValue& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::PairValue > values_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PairValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.PairValue) */ {
 public:
  inline PairValue() : PairValue(nullptr) {}
  ~PairValue() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PairValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline PairValue(const PairValue& from) : PairValue(nullptr, from) {}
  inline PairValue(PairValue&& from) noexcept
      : PairValue(nullptr, std::move(from)) {}
  inline PairValue& operator=(const PairValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairValue& operator=(PairValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PairValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const PairValue* internal_default_instance() {
    return reinterpret_cast<const PairValue*>(
        &_PairValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PairValue& a, PairValue& b) { a.Swap(&b); }
  inline void Swap(PairValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PairValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PairValue* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PairValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PairValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PairValue& from) { PairValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PairValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.PairValue"; }

 protected:
  explicit PairValue(::google::protobuf::Arena* arena);
  PairValue(::google::protobuf::Arena* arena, const PairValue& from);
  PairValue(::google::protobuf::Arena* arena, PairValue&& from) noexcept
      : PairValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .tensorflow.StructuredValue value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::tensorflow::StructuredValue& value() const;
  PROTOBUF_NODISCARD ::tensorflow::StructuredValue* release_value();
  ::tensorflow::StructuredValue* mutable_value();
  void set_allocated_value(::tensorflow::StructuredValue* value);
  void unsafe_arena_set_allocated_value(::tensorflow::StructuredValue* value);
  ::tensorflow::StructuredValue* unsafe_arena_release_value();

  private:
  const ::tensorflow::StructuredValue& _internal_value() const;
  ::tensorflow::StructuredValue* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.PairValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      32, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PairValue& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::tensorflow::StructuredValue* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT StructuredValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.StructuredValue) */ {
 public:
  inline StructuredValue() : StructuredValue(nullptr) {}
  ~StructuredValue() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StructuredValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline StructuredValue(const StructuredValue& from) : StructuredValue(nullptr, from) {}
  inline StructuredValue(StructuredValue&& from) noexcept
      : StructuredValue(nullptr, std::move(from)) {}
  inline StructuredValue& operator=(const StructuredValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructuredValue& operator=(StructuredValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructuredValue& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kNoneValue = 1,
    kFloat64Value = 11,
    kInt64Value = 12,
    kStringValue = 13,
    kBoolValue = 14,
    kTensorShapeValue = 31,
    kTensorDtypeValue = 32,
    kTensorSpecValue = 33,
    kTypeSpecValue = 34,
    kBoundedTensorSpecValue = 35,
    kListValue = 51,
    kTupleValue = 52,
    kDictValue = 53,
    kNamedTupleValue = 54,
    kTensorValue = 55,
    kNumpyValue = 56,
    KIND_NOT_SET = 0,
  };
  static inline const StructuredValue* internal_default_instance() {
    return reinterpret_cast<const StructuredValue*>(
        &_StructuredValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(StructuredValue& a, StructuredValue& b) { a.Swap(&b); }
  inline void Swap(StructuredValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructuredValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StructuredValue* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<StructuredValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StructuredValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StructuredValue& from) { StructuredValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StructuredValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.StructuredValue"; }

 protected:
  explicit StructuredValue(::google::protobuf::Arena* arena);
  StructuredValue(::google::protobuf::Arena* arena, const StructuredValue& from);
  StructuredValue(::google::protobuf::Arena* arena, StructuredValue&& from) noexcept
      : StructuredValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNoneValueFieldNumber = 1,
    kFloat64ValueFieldNumber = 11,
    kInt64ValueFieldNumber = 12,
    kStringValueFieldNumber = 13,
    kBoolValueFieldNumber = 14,
    kTensorShapeValueFieldNumber = 31,
    kTensorDtypeValueFieldNumber = 32,
    kTensorSpecValueFieldNumber = 33,
    kTypeSpecValueFieldNumber = 34,
    kBoundedTensorSpecValueFieldNumber = 35,
    kListValueFieldNumber = 51,
    kTupleValueFieldNumber = 52,
    kDictValueFieldNumber = 53,
    kNamedTupleValueFieldNumber = 54,
    kTensorValueFieldNumber = 55,
    kNumpyValueFieldNumber = 56,
  };
  // .tensorflow.NoneValue none_value = 1;
  bool has_none_value() const;
  private:
  bool _internal_has_none_value() const;

  public:
  void clear_none_value() ;
  const ::tensorflow::NoneValue& none_value() const;
  PROTOBUF_NODISCARD ::tensorflow::NoneValue* release_none_value();
  ::tensorflow::NoneValue* mutable_none_value();
  void set_allocated_none_value(::tensorflow::NoneValue* value);
  void unsafe_arena_set_allocated_none_value(::tensorflow::NoneValue* value);
  ::tensorflow::NoneValue* unsafe_arena_release_none_value();

  private:
  const ::tensorflow::NoneValue& _internal_none_value() const;
  ::tensorflow::NoneValue* _internal_mutable_none_value();

  public:
  // double float64_value = 11;
  bool has_float64_value() const;
  void clear_float64_value() ;
  double float64_value() const;
  void set_float64_value(double value);

  private:
  double _internal_float64_value() const;
  void _internal_set_float64_value(double value);

  public:
  // sint64 int64_value = 12;
  bool has_int64_value() const;
  void clear_int64_value() ;
  ::int64_t int64_value() const;
  void set_int64_value(::int64_t value);

  private:
  ::int64_t _internal_int64_value() const;
  void _internal_set_int64_value(::int64_t value);

  public:
  // string string_value = 13;
  bool has_string_value() const;
  void clear_string_value() ;
  const std::string& string_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_value(Arg_&& arg, Args_... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* value);

  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
      const std::string& value);
  std::string* _internal_mutable_string_value();

  public:
  // bool bool_value = 14;
  bool has_bool_value() const;
  void clear_bool_value() ;
  bool bool_value() const;
  void set_bool_value(bool value);

  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);

  public:
  // .tensorflow.TensorShapeProto tensor_shape_value = 31;
  bool has_tensor_shape_value() const;
  private:
  bool _internal_has_tensor_shape_value() const;

  public:
  void clear_tensor_shape_value() ;
  const ::tensorflow::TensorShapeProto& tensor_shape_value() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorShapeProto* release_tensor_shape_value();
  ::tensorflow::TensorShapeProto* mutable_tensor_shape_value();
  void set_allocated_tensor_shape_value(::tensorflow::TensorShapeProto* value);
  void unsafe_arena_set_allocated_tensor_shape_value(::tensorflow::TensorShapeProto* value);
  ::tensorflow::TensorShapeProto* unsafe_arena_release_tensor_shape_value();

  private:
  const ::tensorflow::TensorShapeProto& _internal_tensor_shape_value() const;
  ::tensorflow::TensorShapeProto* _internal_mutable_tensor_shape_value();

  public:
  // .tensorflow.DataType tensor_dtype_value = 32;
  bool has_tensor_dtype_value() const;
  void clear_tensor_dtype_value() ;
  ::tensorflow::DataType tensor_dtype_value() const;
  void set_tensor_dtype_value(::tensorflow::DataType value);

  private:
  ::tensorflow::DataType _internal_tensor_dtype_value() const;
  void _internal_set_tensor_dtype_value(::tensorflow::DataType value);

  public:
  // .tensorflow.TensorSpecProto tensor_spec_value = 33;
  bool has_tensor_spec_value() const;
  private:
  bool _internal_has_tensor_spec_value() const;

  public:
  void clear_tensor_spec_value() ;
  const ::tensorflow::TensorSpecProto& tensor_spec_value() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorSpecProto* release_tensor_spec_value();
  ::tensorflow::TensorSpecProto* mutable_tensor_spec_value();
  void set_allocated_tensor_spec_value(::tensorflow::TensorSpecProto* value);
  void unsafe_arena_set_allocated_tensor_spec_value(::tensorflow::TensorSpecProto* value);
  ::tensorflow::TensorSpecProto* unsafe_arena_release_tensor_spec_value();

  private:
  const ::tensorflow::TensorSpecProto& _internal_tensor_spec_value() const;
  ::tensorflow::TensorSpecProto* _internal_mutable_tensor_spec_value();

  public:
  // .tensorflow.TypeSpecProto type_spec_value = 34;
  bool has_type_spec_value() const;
  private:
  bool _internal_has_type_spec_value() const;

  public:
  void clear_type_spec_value() ;
  const ::tensorflow::TypeSpecProto& type_spec_value() const;
  PROTOBUF_NODISCARD ::tensorflow::TypeSpecProto* release_type_spec_value();
  ::tensorflow::TypeSpecProto* mutable_type_spec_value();
  void set_allocated_type_spec_value(::tensorflow::TypeSpecProto* value);
  void unsafe_arena_set_allocated_type_spec_value(::tensorflow::TypeSpecProto* value);
  ::tensorflow::TypeSpecProto* unsafe_arena_release_type_spec_value();

  private:
  const ::tensorflow::TypeSpecProto& _internal_type_spec_value() const;
  ::tensorflow::TypeSpecProto* _internal_mutable_type_spec_value();

  public:
  // .tensorflow.BoundedTensorSpecProto bounded_tensor_spec_value = 35;
  bool has_bounded_tensor_spec_value() const;
  private:
  bool _internal_has_bounded_tensor_spec_value() const;

  public:
  void clear_bounded_tensor_spec_value() ;
  const ::tensorflow::BoundedTensorSpecProto& bounded_tensor_spec_value() const;
  PROTOBUF_NODISCARD ::tensorflow::BoundedTensorSpecProto* release_bounded_tensor_spec_value();
  ::tensorflow::BoundedTensorSpecProto* mutable_bounded_tensor_spec_value();
  void set_allocated_bounded_tensor_spec_value(::tensorflow::BoundedTensorSpecProto* value);
  void unsafe_arena_set_allocated_bounded_tensor_spec_value(::tensorflow::BoundedTensorSpecProto* value);
  ::tensorflow::BoundedTensorSpecProto* unsafe_arena_release_bounded_tensor_spec_value();

  private:
  const ::tensorflow::BoundedTensorSpecProto& _internal_bounded_tensor_spec_value() const;
  ::tensorflow::BoundedTensorSpecProto* _internal_mutable_bounded_tensor_spec_value();

  public:
  // .tensorflow.ListValue list_value = 51;
  bool has_list_value() const;
  private:
  bool _internal_has_list_value() const;

  public:
  void clear_list_value() ;
  const ::tensorflow::ListValue& list_value() const;
  PROTOBUF_NODISCARD ::tensorflow::ListValue* release_list_value();
  ::tensorflow::ListValue* mutable_list_value();
  void set_allocated_list_value(::tensorflow::ListValue* value);
  void unsafe_arena_set_allocated_list_value(::tensorflow::ListValue* value);
  ::tensorflow::ListValue* unsafe_arena_release_list_value();

  private:
  const ::tensorflow::ListValue& _internal_list_value() const;
  ::tensorflow::ListValue* _internal_mutable_list_value();

  public:
  // .tensorflow.TupleValue tuple_value = 52;
  bool has_tuple_value() const;
  private:
  bool _internal_has_tuple_value() const;

  public:
  void clear_tuple_value() ;
  const ::tensorflow::TupleValue& tuple_value() const;
  PROTOBUF_NODISCARD ::tensorflow::TupleValue* release_tuple_value();
  ::tensorflow::TupleValue* mutable_tuple_value();
  void set_allocated_tuple_value(::tensorflow::TupleValue* value);
  void unsafe_arena_set_allocated_tuple_value(::tensorflow::TupleValue* value);
  ::tensorflow::TupleValue* unsafe_arena_release_tuple_value();

  private:
  const ::tensorflow::TupleValue& _internal_tuple_value() const;
  ::tensorflow::TupleValue* _internal_mutable_tuple_value();

  public:
  // .tensorflow.DictValue dict_value = 53;
  bool has_dict_value() const;
  private:
  bool _internal_has_dict_value() const;

  public:
  void clear_dict_value() ;
  const ::tensorflow::DictValue& dict_value() const;
  PROTOBUF_NODISCARD ::tensorflow::DictValue* release_dict_value();
  ::tensorflow::DictValue* mutable_dict_value();
  void set_allocated_dict_value(::tensorflow::DictValue* value);
  void unsafe_arena_set_allocated_dict_value(::tensorflow::DictValue* value);
  ::tensorflow::DictValue* unsafe_arena_release_dict_value();

  private:
  const ::tensorflow::DictValue& _internal_dict_value() const;
  ::tensorflow::DictValue* _internal_mutable_dict_value();

  public:
  // .tensorflow.NamedTupleValue named_tuple_value = 54;
  bool has_named_tuple_value() const;
  private:
  bool _internal_has_named_tuple_value() const;

  public:
  void clear_named_tuple_value() ;
  const ::tensorflow::NamedTupleValue& named_tuple_value() const;
  PROTOBUF_NODISCARD ::tensorflow::NamedTupleValue* release_named_tuple_value();
  ::tensorflow::NamedTupleValue* mutable_named_tuple_value();
  void set_allocated_named_tuple_value(::tensorflow::NamedTupleValue* value);
  void unsafe_arena_set_allocated_named_tuple_value(::tensorflow::NamedTupleValue* value);
  ::tensorflow::NamedTupleValue* unsafe_arena_release_named_tuple_value();

  private:
  const ::tensorflow::NamedTupleValue& _internal_named_tuple_value() const;
  ::tensorflow::NamedTupleValue* _internal_mutable_named_tuple_value();

  public:
  // .tensorflow.TensorProto tensor_value = 55;
  bool has_tensor_value() const;
  private:
  bool _internal_has_tensor_value() const;

  public:
  void clear_tensor_value() ;
  const ::tensorflow::TensorProto& tensor_value() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorProto* release_tensor_value();
  ::tensorflow::TensorProto* mutable_tensor_value();
  void set_allocated_tensor_value(::tensorflow::TensorProto* value);
  void unsafe_arena_set_allocated_tensor_value(::tensorflow::TensorProto* value);
  ::tensorflow::TensorProto* unsafe_arena_release_tensor_value();

  private:
  const ::tensorflow::TensorProto& _internal_tensor_value() const;
  ::tensorflow::TensorProto* _internal_mutable_tensor_value();

  public:
  // .tensorflow.TensorProto numpy_value = 56;
  bool has_numpy_value() const;
  private:
  bool _internal_has_numpy_value() const;

  public:
  void clear_numpy_value() ;
  const ::tensorflow::TensorProto& numpy_value() const;
  PROTOBUF_NODISCARD ::tensorflow::TensorProto* release_numpy_value();
  ::tensorflow::TensorProto* mutable_numpy_value();
  void set_allocated_numpy_value(::tensorflow::TensorProto* value);
  void unsafe_arena_set_allocated_numpy_value(::tensorflow::TensorProto* value);
  ::tensorflow::TensorProto* unsafe_arena_release_numpy_value();

  private:
  const ::tensorflow::TensorProto& _internal_numpy_value() const;
  ::tensorflow::TensorProto* _internal_mutable_numpy_value();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.StructuredValue)
 private:
  class _Internal;
  void set_has_none_value();
  void set_has_float64_value();
  void set_has_int64_value();
  void set_has_string_value();
  void set_has_bool_value();
  void set_has_tensor_shape_value();
  void set_has_tensor_dtype_value();
  void set_has_tensor_spec_value();
  void set_has_type_spec_value();
  void set_has_bounded_tensor_spec_value();
  void set_has_list_value();
  void set_has_tuple_value();
  void set_has_dict_value();
  void set_has_named_tuple_value();
  void set_has_tensor_value();
  void set_has_numpy_value();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 16, 11,
      63, 9>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StructuredValue& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tensorflow::NoneValue* none_value_;
      double float64_value_;
      ::int64_t int64_value_;
      ::google::protobuf::internal::ArenaStringPtr string_value_;
      bool bool_value_;
      ::tensorflow::TensorShapeProto* tensor_shape_value_;
      int tensor_dtype_value_;
      ::tensorflow::TensorSpecProto* tensor_spec_value_;
      ::tensorflow::TypeSpecProto* type_spec_value_;
      ::tensorflow::BoundedTensorSpecProto* bounded_tensor_spec_value_;
      ::tensorflow::ListValue* list_value_;
      ::tensorflow::TupleValue* tuple_value_;
      ::tensorflow::DictValue* dict_value_;
      ::tensorflow::NamedTupleValue* named_tuple_value_;
      ::tensorflow::TensorProto* tensor_value_;
      ::tensorflow::TensorProto* numpy_value_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TupleValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TupleValue) */ {
 public:
  inline TupleValue() : TupleValue(nullptr) {}
  ~TupleValue() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TupleValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline TupleValue(const TupleValue& from) : TupleValue(nullptr, from) {}
  inline TupleValue(TupleValue&& from) noexcept
      : TupleValue(nullptr, std::move(from)) {}
  inline TupleValue& operator=(const TupleValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleValue& operator=(TupleValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleValue* internal_default_instance() {
    return reinterpret_cast<const TupleValue*>(
        &_TupleValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TupleValue& a, TupleValue& b) { a.Swap(&b); }
  inline void Swap(TupleValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleValue* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TupleValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TupleValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TupleValue& from) { TupleValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TupleValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TupleValue"; }

 protected:
  explicit TupleValue(::google::protobuf::Arena* arena);
  TupleValue(::google::protobuf::Arena* arena, const TupleValue& from);
  TupleValue(::google::protobuf::Arena* arena, TupleValue&& from) noexcept
      : TupleValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .tensorflow.StructuredValue values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::tensorflow::StructuredValue* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>* _internal_mutable_values();
  public:
  const ::tensorflow::StructuredValue& values(int index) const;
  ::tensorflow::StructuredValue* add_values();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>& values() const;
  // @@protoc_insertion_point(class_scope:tensorflow.TupleValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TupleValue& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::StructuredValue > values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TypeSpecProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TypeSpecProto) */ {
 public:
  inline TypeSpecProto() : TypeSpecProto(nullptr) {}
  ~TypeSpecProto() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeSpecProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline TypeSpecProto(const TypeSpecProto& from) : TypeSpecProto(nullptr, from) {}
  inline TypeSpecProto(TypeSpecProto&& from) noexcept
      : TypeSpecProto(nullptr, std::move(from)) {}
  inline TypeSpecProto& operator=(const TypeSpecProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeSpecProto& operator=(TypeSpecProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeSpecProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeSpecProto* internal_default_instance() {
    return reinterpret_cast<const TypeSpecProto*>(
        &_TypeSpecProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(TypeSpecProto& a, TypeSpecProto& b) { a.Swap(&b); }
  inline void Swap(TypeSpecProto* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeSpecProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeSpecProto* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TypeSpecProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeSpecProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeSpecProto& from) { TypeSpecProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TypeSpecProto* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TypeSpecProto"; }

 protected:
  explicit TypeSpecProto(::google::protobuf::Arena* arena);
  TypeSpecProto(::google::protobuf::Arena* arena, const TypeSpecProto& from);
  TypeSpecProto(::google::protobuf::Arena* arena, TypeSpecProto&& from) noexcept
      : TypeSpecProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeSpecClass = TypeSpecProto_TypeSpecClass;
  static constexpr TypeSpecClass UNKNOWN = TypeSpecProto_TypeSpecClass_UNKNOWN;
  static constexpr TypeSpecClass SPARSE_TENSOR_SPEC = TypeSpecProto_TypeSpecClass_SPARSE_TENSOR_SPEC;
  static constexpr TypeSpecClass INDEXED_SLICES_SPEC = TypeSpecProto_TypeSpecClass_INDEXED_SLICES_SPEC;
  static constexpr TypeSpecClass RAGGED_TENSOR_SPEC = TypeSpecProto_TypeSpecClass_RAGGED_TENSOR_SPEC;
  static constexpr TypeSpecClass TENSOR_ARRAY_SPEC = TypeSpecProto_TypeSpecClass_TENSOR_ARRAY_SPEC;
  static constexpr TypeSpecClass DATA_DATASET_SPEC = TypeSpecProto_TypeSpecClass_DATA_DATASET_SPEC;
  static constexpr TypeSpecClass DATA_ITERATOR_SPEC = TypeSpecProto_TypeSpecClass_DATA_ITERATOR_SPEC;
  static constexpr TypeSpecClass OPTIONAL_SPEC = TypeSpecProto_TypeSpecClass_OPTIONAL_SPEC;
  static constexpr TypeSpecClass PER_REPLICA_SPEC = TypeSpecProto_TypeSpecClass_PER_REPLICA_SPEC;
  static constexpr TypeSpecClass VARIABLE_SPEC = TypeSpecProto_TypeSpecClass_VARIABLE_SPEC;
  static constexpr TypeSpecClass ROW_PARTITION_SPEC = TypeSpecProto_TypeSpecClass_ROW_PARTITION_SPEC;
  static constexpr TypeSpecClass REGISTERED_TYPE_SPEC = TypeSpecProto_TypeSpecClass_REGISTERED_TYPE_SPEC;
  static constexpr TypeSpecClass EXTENSION_TYPE_SPEC = TypeSpecProto_TypeSpecClass_EXTENSION_TYPE_SPEC;
  static inline bool TypeSpecClass_IsValid(int value) {
    return TypeSpecProto_TypeSpecClass_IsValid(value);
  }
  static constexpr TypeSpecClass TypeSpecClass_MIN = TypeSpecProto_TypeSpecClass_TypeSpecClass_MIN;
  static constexpr TypeSpecClass TypeSpecClass_MAX = TypeSpecProto_TypeSpecClass_TypeSpecClass_MAX;
  static constexpr int TypeSpecClass_ARRAYSIZE = TypeSpecProto_TypeSpecClass_TypeSpecClass_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TypeSpecClass_descriptor() {
    return TypeSpecProto_TypeSpecClass_descriptor();
  }
  template <typename T>
  static inline const std::string& TypeSpecClass_Name(T value) {
    return TypeSpecProto_TypeSpecClass_Name(value);
  }
  static inline bool TypeSpecClass_Parse(absl::string_view name, TypeSpecClass* value) {
    return TypeSpecProto_TypeSpecClass_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeSpecClassNameFieldNumber = 3,
    kTypeStateFieldNumber = 2,
    kTypeSpecClassFieldNumber = 1,
    kNumFlatComponentsFieldNumber = 4,
  };
  // string type_spec_class_name = 3;
  void clear_type_spec_class_name() ;
  const std::string& type_spec_class_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type_spec_class_name(Arg_&& arg, Args_... args);
  std::string* mutable_type_spec_class_name();
  PROTOBUF_NODISCARD std::string* release_type_spec_class_name();
  void set_allocated_type_spec_class_name(std::string* value);

  private:
  const std::string& _internal_type_spec_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_spec_class_name(
      const std::string& value);
  std::string* _internal_mutable_type_spec_class_name();

  public:
  // .tensorflow.StructuredValue type_state = 2;
  bool has_type_state() const;
  void clear_type_state() ;
  const ::tensorflow::StructuredValue& type_state() const;
  PROTOBUF_NODISCARD ::tensorflow::StructuredValue* release_type_state();
  ::tensorflow::StructuredValue* mutable_type_state();
  void set_allocated_type_state(::tensorflow::StructuredValue* value);
  void unsafe_arena_set_allocated_type_state(::tensorflow::StructuredValue* value);
  ::tensorflow::StructuredValue* unsafe_arena_release_type_state();

  private:
  const ::tensorflow::StructuredValue& _internal_type_state() const;
  ::tensorflow::StructuredValue* _internal_mutable_type_state();

  public:
  // .tensorflow.TypeSpecProto.TypeSpecClass type_spec_class = 1;
  void clear_type_spec_class() ;
  ::tensorflow::TypeSpecProto_TypeSpecClass type_spec_class() const;
  void set_type_spec_class(::tensorflow::TypeSpecProto_TypeSpecClass value);

  private:
  ::tensorflow::TypeSpecProto_TypeSpecClass _internal_type_spec_class() const;
  void _internal_set_type_spec_class(::tensorflow::TypeSpecProto_TypeSpecClass value);

  public:
  // int32 num_flat_components = 4;
  void clear_num_flat_components() ;
  ::int32_t num_flat_components() const;
  void set_num_flat_components(::int32_t value);

  private:
  ::int32_t _internal_num_flat_components() const;
  void _internal_set_num_flat_components(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.TypeSpecProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      53, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TypeSpecProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_spec_class_name_;
    ::tensorflow::StructuredValue* type_state_;
    int type_spec_class_;
    ::int32_t num_flat_components_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// StructuredValue

// .tensorflow.NoneValue none_value = 1;
inline bool StructuredValue::has_none_value() const {
  return kind_case() == kNoneValue;
}
inline bool StructuredValue::_internal_has_none_value() const {
  return kind_case() == kNoneValue;
}
inline void StructuredValue::set_has_none_value() {
  _impl_._oneof_case_[0] = kNoneValue;
}
inline void StructuredValue::clear_none_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kNoneValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.none_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.none_value_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::NoneValue* StructuredValue::release_none_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.none_value)
  if (kind_case() == kNoneValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.none_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.none_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::NoneValue& StructuredValue::_internal_none_value() const {
  return kind_case() == kNoneValue ? *_impl_.kind_.none_value_ : reinterpret_cast<::tensorflow::NoneValue&>(::tensorflow::_NoneValue_default_instance_);
}
inline const ::tensorflow::NoneValue& StructuredValue::none_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.none_value)
  return _internal_none_value();
}
inline ::tensorflow::NoneValue* StructuredValue::unsafe_arena_release_none_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.none_value)
  if (kind_case() == kNoneValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.none_value_;
    _impl_.kind_.none_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_none_value(::tensorflow::NoneValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_none_value();
    _impl_.kind_.none_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.none_value)
}
inline ::tensorflow::NoneValue* StructuredValue::_internal_mutable_none_value() {
  if (kind_case() != kNoneValue) {
    clear_kind();
    set_has_none_value();
    _impl_.kind_.none_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::NoneValue>(GetArena());
  }
  return _impl_.kind_.none_value_;
}
inline ::tensorflow::NoneValue* StructuredValue::mutable_none_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::NoneValue* _msg = _internal_mutable_none_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.none_value)
  return _msg;
}

// double float64_value = 11;
inline bool StructuredValue::has_float64_value() const {
  return kind_case() == kFloat64Value;
}
inline void StructuredValue::set_has_float64_value() {
  _impl_._oneof_case_[0] = kFloat64Value;
}
inline void StructuredValue::clear_float64_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kFloat64Value) {
    _impl_.kind_.float64_value_ = 0;
    clear_has_kind();
  }
}
inline double StructuredValue::float64_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.float64_value)
  return _internal_float64_value();
}
inline void StructuredValue::set_float64_value(double value) {
  if (kind_case() != kFloat64Value) {
    clear_kind();
    set_has_float64_value();
  }
  _impl_.kind_.float64_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.float64_value)
}
inline double StructuredValue::_internal_float64_value() const {
  if (kind_case() == kFloat64Value) {
    return _impl_.kind_.float64_value_;
  }
  return 0;
}

// sint64 int64_value = 12;
inline bool StructuredValue::has_int64_value() const {
  return kind_case() == kInt64Value;
}
inline void StructuredValue::set_has_int64_value() {
  _impl_._oneof_case_[0] = kInt64Value;
}
inline void StructuredValue::clear_int64_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kInt64Value) {
    _impl_.kind_.int64_value_ = ::int64_t{0};
    clear_has_kind();
  }
}
inline ::int64_t StructuredValue::int64_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.int64_value)
  return _internal_int64_value();
}
inline void StructuredValue::set_int64_value(::int64_t value) {
  if (kind_case() != kInt64Value) {
    clear_kind();
    set_has_int64_value();
  }
  _impl_.kind_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.int64_value)
}
inline ::int64_t StructuredValue::_internal_int64_value() const {
  if (kind_case() == kInt64Value) {
    return _impl_.kind_.int64_value_;
  }
  return ::int64_t{0};
}

// string string_value = 13;
inline bool StructuredValue::has_string_value() const {
  return kind_case() == kStringValue;
}
inline void StructuredValue::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void StructuredValue::clear_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStringValue) {
    _impl_.kind_.string_value_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& StructuredValue::string_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.string_value)
  return _internal_string_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StructuredValue::set_string_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStringValue) {
    clear_kind();

    set_has_string_value();
    _impl_.kind_.string_value_.InitDefault();
  }
  _impl_.kind_.string_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.string_value)
}
inline std::string* StructuredValue::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.string_value)
  return _s;
}
inline const std::string& StructuredValue::_internal_string_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (kind_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.kind_.string_value_.Get();
}
inline void StructuredValue::_internal_set_string_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStringValue) {
    clear_kind();

    set_has_string_value();
    _impl_.kind_.string_value_.InitDefault();
  }
  _impl_.kind_.string_value_.Set(value, GetArena());
}
inline std::string* StructuredValue::_internal_mutable_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStringValue) {
    clear_kind();

    set_has_string_value();
    _impl_.kind_.string_value_.InitDefault();
  }
  return _impl_.kind_.string_value_.Mutable( GetArena());
}
inline std::string* StructuredValue::release_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.string_value)
  if (kind_case() != kStringValue) {
    return nullptr;
  }
  clear_has_kind();
  return _impl_.kind_.string_value_.Release();
}
inline void StructuredValue::set_allocated_string_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_kind()) {
    clear_kind();
  }
  if (value != nullptr) {
    set_has_string_value();
    _impl_.kind_.string_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.string_value)
}

// bool bool_value = 14;
inline bool StructuredValue::has_bool_value() const {
  return kind_case() == kBoolValue;
}
inline void StructuredValue::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void StructuredValue::clear_bool_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBoolValue) {
    _impl_.kind_.bool_value_ = false;
    clear_has_kind();
  }
}
inline bool StructuredValue::bool_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.bool_value)
  return _internal_bool_value();
}
inline void StructuredValue::set_bool_value(bool value) {
  if (kind_case() != kBoolValue) {
    clear_kind();
    set_has_bool_value();
  }
  _impl_.kind_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.bool_value)
}
inline bool StructuredValue::_internal_bool_value() const {
  if (kind_case() == kBoolValue) {
    return _impl_.kind_.bool_value_;
  }
  return false;
}

// .tensorflow.TensorShapeProto tensor_shape_value = 31;
inline bool StructuredValue::has_tensor_shape_value() const {
  return kind_case() == kTensorShapeValue;
}
inline bool StructuredValue::_internal_has_tensor_shape_value() const {
  return kind_case() == kTensorShapeValue;
}
inline void StructuredValue::set_has_tensor_shape_value() {
  _impl_._oneof_case_[0] = kTensorShapeValue;
}
inline ::tensorflow::TensorShapeProto* StructuredValue::release_tensor_shape_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.tensor_shape_value)
  if (kind_case() == kTensorShapeValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tensor_shape_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tensor_shape_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TensorShapeProto& StructuredValue::_internal_tensor_shape_value() const {
  return kind_case() == kTensorShapeValue ? *_impl_.kind_.tensor_shape_value_ : reinterpret_cast<::tensorflow::TensorShapeProto&>(::tensorflow::_TensorShapeProto_default_instance_);
}
inline const ::tensorflow::TensorShapeProto& StructuredValue::tensor_shape_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tensor_shape_value)
  return _internal_tensor_shape_value();
}
inline ::tensorflow::TensorShapeProto* StructuredValue::unsafe_arena_release_tensor_shape_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.tensor_shape_value)
  if (kind_case() == kTensorShapeValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tensor_shape_value_;
    _impl_.kind_.tensor_shape_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_tensor_shape_value(::tensorflow::TensorShapeProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tensor_shape_value();
    _impl_.kind_.tensor_shape_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.tensor_shape_value)
}
inline ::tensorflow::TensorShapeProto* StructuredValue::_internal_mutable_tensor_shape_value() {
  if (kind_case() != kTensorShapeValue) {
    clear_kind();
    set_has_tensor_shape_value();
    _impl_.kind_.tensor_shape_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorShapeProto>(GetArena());
  }
  return _impl_.kind_.tensor_shape_value_;
}
inline ::tensorflow::TensorShapeProto* StructuredValue::mutable_tensor_shape_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::TensorShapeProto* _msg = _internal_mutable_tensor_shape_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.tensor_shape_value)
  return _msg;
}

// .tensorflow.DataType tensor_dtype_value = 32;
inline bool StructuredValue::has_tensor_dtype_value() const {
  return kind_case() == kTensorDtypeValue;
}
inline void StructuredValue::set_has_tensor_dtype_value() {
  _impl_._oneof_case_[0] = kTensorDtypeValue;
}
inline void StructuredValue::clear_tensor_dtype_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTensorDtypeValue) {
    _impl_.kind_.tensor_dtype_value_ = 0;
    clear_has_kind();
  }
}
inline ::tensorflow::DataType StructuredValue::tensor_dtype_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tensor_dtype_value)
  return _internal_tensor_dtype_value();
}
inline void StructuredValue::set_tensor_dtype_value(::tensorflow::DataType value) {
  if (kind_case() != kTensorDtypeValue) {
    clear_kind();
    set_has_tensor_dtype_value();
  }
  _impl_.kind_.tensor_dtype_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.tensor_dtype_value)
}
inline ::tensorflow::DataType StructuredValue::_internal_tensor_dtype_value() const {
  if (kind_case() == kTensorDtypeValue) {
    return static_cast<::tensorflow::DataType>(_impl_.kind_.tensor_dtype_value_);
  }
  return static_cast<::tensorflow::DataType>(0);
}

// .tensorflow.TensorSpecProto tensor_spec_value = 33;
inline bool StructuredValue::has_tensor_spec_value() const {
  return kind_case() == kTensorSpecValue;
}
inline bool StructuredValue::_internal_has_tensor_spec_value() const {
  return kind_case() == kTensorSpecValue;
}
inline void StructuredValue::set_has_tensor_spec_value() {
  _impl_._oneof_case_[0] = kTensorSpecValue;
}
inline void StructuredValue::clear_tensor_spec_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTensorSpecValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.tensor_spec_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.tensor_spec_value_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::TensorSpecProto* StructuredValue::release_tensor_spec_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.tensor_spec_value)
  if (kind_case() == kTensorSpecValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tensor_spec_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tensor_spec_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TensorSpecProto& StructuredValue::_internal_tensor_spec_value() const {
  return kind_case() == kTensorSpecValue ? *_impl_.kind_.tensor_spec_value_ : reinterpret_cast<::tensorflow::TensorSpecProto&>(::tensorflow::_TensorSpecProto_default_instance_);
}
inline const ::tensorflow::TensorSpecProto& StructuredValue::tensor_spec_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tensor_spec_value)
  return _internal_tensor_spec_value();
}
inline ::tensorflow::TensorSpecProto* StructuredValue::unsafe_arena_release_tensor_spec_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.tensor_spec_value)
  if (kind_case() == kTensorSpecValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tensor_spec_value_;
    _impl_.kind_.tensor_spec_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_tensor_spec_value(::tensorflow::TensorSpecProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tensor_spec_value();
    _impl_.kind_.tensor_spec_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.tensor_spec_value)
}
inline ::tensorflow::TensorSpecProto* StructuredValue::_internal_mutable_tensor_spec_value() {
  if (kind_case() != kTensorSpecValue) {
    clear_kind();
    set_has_tensor_spec_value();
    _impl_.kind_.tensor_spec_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorSpecProto>(GetArena());
  }
  return _impl_.kind_.tensor_spec_value_;
}
inline ::tensorflow::TensorSpecProto* StructuredValue::mutable_tensor_spec_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::TensorSpecProto* _msg = _internal_mutable_tensor_spec_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.tensor_spec_value)
  return _msg;
}

// .tensorflow.TypeSpecProto type_spec_value = 34;
inline bool StructuredValue::has_type_spec_value() const {
  return kind_case() == kTypeSpecValue;
}
inline bool StructuredValue::_internal_has_type_spec_value() const {
  return kind_case() == kTypeSpecValue;
}
inline void StructuredValue::set_has_type_spec_value() {
  _impl_._oneof_case_[0] = kTypeSpecValue;
}
inline void StructuredValue::clear_type_spec_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTypeSpecValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.type_spec_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.type_spec_value_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::TypeSpecProto* StructuredValue::release_type_spec_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.type_spec_value)
  if (kind_case() == kTypeSpecValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.type_spec_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.type_spec_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TypeSpecProto& StructuredValue::_internal_type_spec_value() const {
  return kind_case() == kTypeSpecValue ? *_impl_.kind_.type_spec_value_ : reinterpret_cast<::tensorflow::TypeSpecProto&>(::tensorflow::_TypeSpecProto_default_instance_);
}
inline const ::tensorflow::TypeSpecProto& StructuredValue::type_spec_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.type_spec_value)
  return _internal_type_spec_value();
}
inline ::tensorflow::TypeSpecProto* StructuredValue::unsafe_arena_release_type_spec_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.type_spec_value)
  if (kind_case() == kTypeSpecValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.type_spec_value_;
    _impl_.kind_.type_spec_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_type_spec_value(::tensorflow::TypeSpecProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_type_spec_value();
    _impl_.kind_.type_spec_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.type_spec_value)
}
inline ::tensorflow::TypeSpecProto* StructuredValue::_internal_mutable_type_spec_value() {
  if (kind_case() != kTypeSpecValue) {
    clear_kind();
    set_has_type_spec_value();
    _impl_.kind_.type_spec_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::TypeSpecProto>(GetArena());
  }
  return _impl_.kind_.type_spec_value_;
}
inline ::tensorflow::TypeSpecProto* StructuredValue::mutable_type_spec_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::TypeSpecProto* _msg = _internal_mutable_type_spec_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.type_spec_value)
  return _msg;
}

// .tensorflow.BoundedTensorSpecProto bounded_tensor_spec_value = 35;
inline bool StructuredValue::has_bounded_tensor_spec_value() const {
  return kind_case() == kBoundedTensorSpecValue;
}
inline bool StructuredValue::_internal_has_bounded_tensor_spec_value() const {
  return kind_case() == kBoundedTensorSpecValue;
}
inline void StructuredValue::set_has_bounded_tensor_spec_value() {
  _impl_._oneof_case_[0] = kBoundedTensorSpecValue;
}
inline void StructuredValue::clear_bounded_tensor_spec_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBoundedTensorSpecValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.bounded_tensor_spec_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.bounded_tensor_spec_value_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::BoundedTensorSpecProto* StructuredValue::release_bounded_tensor_spec_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.bounded_tensor_spec_value)
  if (kind_case() == kBoundedTensorSpecValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.bounded_tensor_spec_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.bounded_tensor_spec_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::BoundedTensorSpecProto& StructuredValue::_internal_bounded_tensor_spec_value() const {
  return kind_case() == kBoundedTensorSpecValue ? *_impl_.kind_.bounded_tensor_spec_value_ : reinterpret_cast<::tensorflow::BoundedTensorSpecProto&>(::tensorflow::_BoundedTensorSpecProto_default_instance_);
}
inline const ::tensorflow::BoundedTensorSpecProto& StructuredValue::bounded_tensor_spec_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.bounded_tensor_spec_value)
  return _internal_bounded_tensor_spec_value();
}
inline ::tensorflow::BoundedTensorSpecProto* StructuredValue::unsafe_arena_release_bounded_tensor_spec_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.bounded_tensor_spec_value)
  if (kind_case() == kBoundedTensorSpecValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.bounded_tensor_spec_value_;
    _impl_.kind_.bounded_tensor_spec_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_bounded_tensor_spec_value(::tensorflow::BoundedTensorSpecProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_bounded_tensor_spec_value();
    _impl_.kind_.bounded_tensor_spec_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.bounded_tensor_spec_value)
}
inline ::tensorflow::BoundedTensorSpecProto* StructuredValue::_internal_mutable_bounded_tensor_spec_value() {
  if (kind_case() != kBoundedTensorSpecValue) {
    clear_kind();
    set_has_bounded_tensor_spec_value();
    _impl_.kind_.bounded_tensor_spec_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::BoundedTensorSpecProto>(GetArena());
  }
  return _impl_.kind_.bounded_tensor_spec_value_;
}
inline ::tensorflow::BoundedTensorSpecProto* StructuredValue::mutable_bounded_tensor_spec_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::BoundedTensorSpecProto* _msg = _internal_mutable_bounded_tensor_spec_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.bounded_tensor_spec_value)
  return _msg;
}

// .tensorflow.ListValue list_value = 51;
inline bool StructuredValue::has_list_value() const {
  return kind_case() == kListValue;
}
inline bool StructuredValue::_internal_has_list_value() const {
  return kind_case() == kListValue;
}
inline void StructuredValue::set_has_list_value() {
  _impl_._oneof_case_[0] = kListValue;
}
inline void StructuredValue::clear_list_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kListValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.list_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.list_value_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::ListValue* StructuredValue::release_list_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.list_value)
  if (kind_case() == kListValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.list_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.list_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::ListValue& StructuredValue::_internal_list_value() const {
  return kind_case() == kListValue ? *_impl_.kind_.list_value_ : reinterpret_cast<::tensorflow::ListValue&>(::tensorflow::_ListValue_default_instance_);
}
inline const ::tensorflow::ListValue& StructuredValue::list_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.list_value)
  return _internal_list_value();
}
inline ::tensorflow::ListValue* StructuredValue::unsafe_arena_release_list_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.list_value)
  if (kind_case() == kListValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.list_value_;
    _impl_.kind_.list_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_list_value(::tensorflow::ListValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_list_value();
    _impl_.kind_.list_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.list_value)
}
inline ::tensorflow::ListValue* StructuredValue::_internal_mutable_list_value() {
  if (kind_case() != kListValue) {
    clear_kind();
    set_has_list_value();
    _impl_.kind_.list_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::ListValue>(GetArena());
  }
  return _impl_.kind_.list_value_;
}
inline ::tensorflow::ListValue* StructuredValue::mutable_list_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::ListValue* _msg = _internal_mutable_list_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.list_value)
  return _msg;
}

// .tensorflow.TupleValue tuple_value = 52;
inline bool StructuredValue::has_tuple_value() const {
  return kind_case() == kTupleValue;
}
inline bool StructuredValue::_internal_has_tuple_value() const {
  return kind_case() == kTupleValue;
}
inline void StructuredValue::set_has_tuple_value() {
  _impl_._oneof_case_[0] = kTupleValue;
}
inline void StructuredValue::clear_tuple_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTupleValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.tuple_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.tuple_value_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::TupleValue* StructuredValue::release_tuple_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.tuple_value)
  if (kind_case() == kTupleValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tuple_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tuple_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TupleValue& StructuredValue::_internal_tuple_value() const {
  return kind_case() == kTupleValue ? *_impl_.kind_.tuple_value_ : reinterpret_cast<::tensorflow::TupleValue&>(::tensorflow::_TupleValue_default_instance_);
}
inline const ::tensorflow::TupleValue& StructuredValue::tuple_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tuple_value)
  return _internal_tuple_value();
}
inline ::tensorflow::TupleValue* StructuredValue::unsafe_arena_release_tuple_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.tuple_value)
  if (kind_case() == kTupleValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tuple_value_;
    _impl_.kind_.tuple_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_tuple_value(::tensorflow::TupleValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tuple_value();
    _impl_.kind_.tuple_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.tuple_value)
}
inline ::tensorflow::TupleValue* StructuredValue::_internal_mutable_tuple_value() {
  if (kind_case() != kTupleValue) {
    clear_kind();
    set_has_tuple_value();
    _impl_.kind_.tuple_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::TupleValue>(GetArena());
  }
  return _impl_.kind_.tuple_value_;
}
inline ::tensorflow::TupleValue* StructuredValue::mutable_tuple_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::TupleValue* _msg = _internal_mutable_tuple_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.tuple_value)
  return _msg;
}

// .tensorflow.DictValue dict_value = 53;
inline bool StructuredValue::has_dict_value() const {
  return kind_case() == kDictValue;
}
inline bool StructuredValue::_internal_has_dict_value() const {
  return kind_case() == kDictValue;
}
inline void StructuredValue::set_has_dict_value() {
  _impl_._oneof_case_[0] = kDictValue;
}
inline void StructuredValue::clear_dict_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kDictValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.dict_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.dict_value_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::DictValue* StructuredValue::release_dict_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.dict_value)
  if (kind_case() == kDictValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.dict_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.dict_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::DictValue& StructuredValue::_internal_dict_value() const {
  return kind_case() == kDictValue ? *_impl_.kind_.dict_value_ : reinterpret_cast<::tensorflow::DictValue&>(::tensorflow::_DictValue_default_instance_);
}
inline const ::tensorflow::DictValue& StructuredValue::dict_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.dict_value)
  return _internal_dict_value();
}
inline ::tensorflow::DictValue* StructuredValue::unsafe_arena_release_dict_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.dict_value)
  if (kind_case() == kDictValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.dict_value_;
    _impl_.kind_.dict_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_dict_value(::tensorflow::DictValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_dict_value();
    _impl_.kind_.dict_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.dict_value)
}
inline ::tensorflow::DictValue* StructuredValue::_internal_mutable_dict_value() {
  if (kind_case() != kDictValue) {
    clear_kind();
    set_has_dict_value();
    _impl_.kind_.dict_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::DictValue>(GetArena());
  }
  return _impl_.kind_.dict_value_;
}
inline ::tensorflow::DictValue* StructuredValue::mutable_dict_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::DictValue* _msg = _internal_mutable_dict_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.dict_value)
  return _msg;
}

// .tensorflow.NamedTupleValue named_tuple_value = 54;
inline bool StructuredValue::has_named_tuple_value() const {
  return kind_case() == kNamedTupleValue;
}
inline bool StructuredValue::_internal_has_named_tuple_value() const {
  return kind_case() == kNamedTupleValue;
}
inline void StructuredValue::set_has_named_tuple_value() {
  _impl_._oneof_case_[0] = kNamedTupleValue;
}
inline void StructuredValue::clear_named_tuple_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kNamedTupleValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.named_tuple_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.named_tuple_value_);
    }
    clear_has_kind();
  }
}
inline ::tensorflow::NamedTupleValue* StructuredValue::release_named_tuple_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.named_tuple_value)
  if (kind_case() == kNamedTupleValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.named_tuple_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.named_tuple_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::NamedTupleValue& StructuredValue::_internal_named_tuple_value() const {
  return kind_case() == kNamedTupleValue ? *_impl_.kind_.named_tuple_value_ : reinterpret_cast<::tensorflow::NamedTupleValue&>(::tensorflow::_NamedTupleValue_default_instance_);
}
inline const ::tensorflow::NamedTupleValue& StructuredValue::named_tuple_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.named_tuple_value)
  return _internal_named_tuple_value();
}
inline ::tensorflow::NamedTupleValue* StructuredValue::unsafe_arena_release_named_tuple_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.named_tuple_value)
  if (kind_case() == kNamedTupleValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.named_tuple_value_;
    _impl_.kind_.named_tuple_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_named_tuple_value(::tensorflow::NamedTupleValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_named_tuple_value();
    _impl_.kind_.named_tuple_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.named_tuple_value)
}
inline ::tensorflow::NamedTupleValue* StructuredValue::_internal_mutable_named_tuple_value() {
  if (kind_case() != kNamedTupleValue) {
    clear_kind();
    set_has_named_tuple_value();
    _impl_.kind_.named_tuple_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::NamedTupleValue>(GetArena());
  }
  return _impl_.kind_.named_tuple_value_;
}
inline ::tensorflow::NamedTupleValue* StructuredValue::mutable_named_tuple_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::NamedTupleValue* _msg = _internal_mutable_named_tuple_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.named_tuple_value)
  return _msg;
}

// .tensorflow.TensorProto tensor_value = 55;
inline bool StructuredValue::has_tensor_value() const {
  return kind_case() == kTensorValue;
}
inline bool StructuredValue::_internal_has_tensor_value() const {
  return kind_case() == kTensorValue;
}
inline void StructuredValue::set_has_tensor_value() {
  _impl_._oneof_case_[0] = kTensorValue;
}
inline ::tensorflow::TensorProto* StructuredValue::release_tensor_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.tensor_value)
  if (kind_case() == kTensorValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tensor_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tensor_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TensorProto& StructuredValue::_internal_tensor_value() const {
  return kind_case() == kTensorValue ? *_impl_.kind_.tensor_value_ : reinterpret_cast<::tensorflow::TensorProto&>(::tensorflow::_TensorProto_default_instance_);
}
inline const ::tensorflow::TensorProto& StructuredValue::tensor_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tensor_value)
  return _internal_tensor_value();
}
inline ::tensorflow::TensorProto* StructuredValue::unsafe_arena_release_tensor_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.tensor_value)
  if (kind_case() == kTensorValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tensor_value_;
    _impl_.kind_.tensor_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_tensor_value(::tensorflow::TensorProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tensor_value();
    _impl_.kind_.tensor_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.tensor_value)
}
inline ::tensorflow::TensorProto* StructuredValue::_internal_mutable_tensor_value() {
  if (kind_case() != kTensorValue) {
    clear_kind();
    set_has_tensor_value();
    _impl_.kind_.tensor_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorProto>(GetArena());
  }
  return _impl_.kind_.tensor_value_;
}
inline ::tensorflow::TensorProto* StructuredValue::mutable_tensor_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::TensorProto* _msg = _internal_mutable_tensor_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.tensor_value)
  return _msg;
}

// .tensorflow.TensorProto numpy_value = 56;
inline bool StructuredValue::has_numpy_value() const {
  return kind_case() == kNumpyValue;
}
inline bool StructuredValue::_internal_has_numpy_value() const {
  return kind_case() == kNumpyValue;
}
inline void StructuredValue::set_has_numpy_value() {
  _impl_._oneof_case_[0] = kNumpyValue;
}
inline ::tensorflow::TensorProto* StructuredValue::release_numpy_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.numpy_value)
  if (kind_case() == kNumpyValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.numpy_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.numpy_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TensorProto& StructuredValue::_internal_numpy_value() const {
  return kind_case() == kNumpyValue ? *_impl_.kind_.numpy_value_ : reinterpret_cast<::tensorflow::TensorProto&>(::tensorflow::_TensorProto_default_instance_);
}
inline const ::tensorflow::TensorProto& StructuredValue::numpy_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.numpy_value)
  return _internal_numpy_value();
}
inline ::tensorflow::TensorProto* StructuredValue::unsafe_arena_release_numpy_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.StructuredValue.numpy_value)
  if (kind_case() == kNumpyValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.numpy_value_;
    _impl_.kind_.numpy_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StructuredValue::unsafe_arena_set_allocated_numpy_value(::tensorflow::TensorProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_numpy_value();
    _impl_.kind_.numpy_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.StructuredValue.numpy_value)
}
inline ::tensorflow::TensorProto* StructuredValue::_internal_mutable_numpy_value() {
  if (kind_case() != kNumpyValue) {
    clear_kind();
    set_has_numpy_value();
    _impl_.kind_.numpy_value_ =
        ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorProto>(GetArena());
  }
  return _impl_.kind_.numpy_value_;
}
inline ::tensorflow::TensorProto* StructuredValue::mutable_numpy_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tensorflow::TensorProto* _msg = _internal_mutable_numpy_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.numpy_value)
  return _msg;
}

inline bool StructuredValue::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void StructuredValue::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline StructuredValue::KindCase StructuredValue::kind_case() const {
  return StructuredValue::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NoneValue

// -------------------------------------------------------------------

// ListValue

// repeated .tensorflow.StructuredValue values = 1;
inline int ListValue::_internal_values_size() const {
  return _internal_values().size();
}
inline int ListValue::values_size() const {
  return _internal_values_size();
}
inline void ListValue::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::tensorflow::StructuredValue* ListValue::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.ListValue.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>* ListValue::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ListValue.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::tensorflow::StructuredValue& ListValue::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.ListValue.values)
  return _internal_values().Get(index);
}
inline ::tensorflow::StructuredValue* ListValue::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::StructuredValue* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.ListValue.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>& ListValue::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.ListValue.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>&
ListValue::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>*
ListValue::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// TupleValue

// repeated .tensorflow.StructuredValue values = 1;
inline int TupleValue::_internal_values_size() const {
  return _internal_values().size();
}
inline int TupleValue::values_size() const {
  return _internal_values_size();
}
inline void TupleValue::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::tensorflow::StructuredValue* TupleValue::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.TupleValue.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>* TupleValue::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TupleValue.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::tensorflow::StructuredValue& TupleValue::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TupleValue.values)
  return _internal_values().Get(index);
}
inline ::tensorflow::StructuredValue* TupleValue::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::StructuredValue* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.TupleValue.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>& TupleValue::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.TupleValue.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>&
TupleValue::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::StructuredValue>*
TupleValue::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DictValue

// map<string, .tensorflow.StructuredValue> fields = 1;
inline int DictValue::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int DictValue::fields_size() const {
  return _internal_fields_size();
}
inline void DictValue::clear_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fields_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::StructuredValue>& DictValue::_internal_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fields_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::StructuredValue>& DictValue::fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.DictValue.fields)
  return _internal_fields();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::StructuredValue>* DictValue::_internal_mutable_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.fields_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::StructuredValue>* DictValue::mutable_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.DictValue.fields)
  return _internal_mutable_fields();
}

// -------------------------------------------------------------------

// PairValue

// string key = 1;
inline void PairValue::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& PairValue::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PairValue.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PairValue::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PairValue.key)
}
inline std::string* PairValue::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tensorflow.PairValue.key)
  return _s;
}
inline const std::string& PairValue::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void PairValue::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* PairValue::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* PairValue::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PairValue.key)
  return _impl_.key_.Release();
}
inline void PairValue::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PairValue.key)
}

// .tensorflow.StructuredValue value = 2;
inline bool PairValue::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void PairValue::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::StructuredValue& PairValue::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::StructuredValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::StructuredValue&>(::tensorflow::_StructuredValue_default_instance_);
}
inline const ::tensorflow::StructuredValue& PairValue::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PairValue.value)
  return _internal_value();
}
inline void PairValue::unsafe_arena_set_allocated_value(::tensorflow::StructuredValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.PairValue.value)
}
inline ::tensorflow::StructuredValue* PairValue::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::StructuredValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::StructuredValue* PairValue::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PairValue.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::StructuredValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::tensorflow::StructuredValue* PairValue::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::StructuredValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::tensorflow::StructuredValue*>(p);
  }
  return _impl_.value_;
}
inline ::tensorflow::StructuredValue* PairValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::StructuredValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.PairValue.value)
  return _msg;
}
inline void PairValue::set_allocated_value(::tensorflow::StructuredValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PairValue.value)
}

// -------------------------------------------------------------------

// NamedTupleValue

// string name = 1;
inline void NamedTupleValue::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NamedTupleValue::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.NamedTupleValue.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NamedTupleValue::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.NamedTupleValue.name)
}
inline std::string* NamedTupleValue::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.NamedTupleValue.name)
  return _s;
}
inline const std::string& NamedTupleValue::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NamedTupleValue::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NamedTupleValue::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NamedTupleValue::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.NamedTupleValue.name)
  return _impl_.name_.Release();
}
inline void NamedTupleValue::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.NamedTupleValue.name)
}

// repeated .tensorflow.PairValue values = 2;
inline int NamedTupleValue::_internal_values_size() const {
  return _internal_values().size();
}
inline int NamedTupleValue::values_size() const {
  return _internal_values_size();
}
inline void NamedTupleValue::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::tensorflow::PairValue* NamedTupleValue::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.NamedTupleValue.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::PairValue>* NamedTupleValue::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.NamedTupleValue.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::tensorflow::PairValue& NamedTupleValue::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.NamedTupleValue.values)
  return _internal_values().Get(index);
}
inline ::tensorflow::PairValue* NamedTupleValue::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::PairValue* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.NamedTupleValue.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::PairValue>& NamedTupleValue::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.NamedTupleValue.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::PairValue>&
NamedTupleValue::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::PairValue>*
NamedTupleValue::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// TensorSpecProto

// string name = 1;
inline void TensorSpecProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TensorSpecProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorSpecProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorSpecProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TensorSpecProto.name)
}
inline std::string* TensorSpecProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorSpecProto.name)
  return _s;
}
inline const std::string& TensorSpecProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void TensorSpecProto::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TensorSpecProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TensorSpecProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TensorSpecProto.name)
  return _impl_.name_.Release();
}
inline void TensorSpecProto::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorSpecProto.name)
}

// .tensorflow.TensorShapeProto shape = 2;
inline bool TensorSpecProto::has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline const ::tensorflow::TensorShapeProto& TensorSpecProto::_internal_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TensorShapeProto* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TensorShapeProto&>(::tensorflow::_TensorShapeProto_default_instance_);
}
inline const ::tensorflow::TensorShapeProto& TensorSpecProto::shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TensorSpecProto.shape)
  return _internal_shape();
}
inline void TensorSpecProto::unsafe_arena_set_allocated_shape(::tensorflow::TensorShapeProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorSpecProto.shape)
}
inline ::tensorflow::TensorShapeProto* TensorSpecProto::release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorShapeProto* released = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TensorShapeProto* TensorSpecProto::unsafe_arena_release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TensorSpecProto.shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorShapeProto* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorShapeProto* TensorSpecProto::_internal_mutable_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorShapeProto>(GetArena());
    _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(p);
  }
  return _impl_.shape_;
}
inline ::tensorflow::TensorShapeProto* TensorSpecProto::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::TensorShapeProto* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorSpecProto.shape)
  return _msg;
}
inline void TensorSpecProto::set_allocated_shape(::tensorflow::TensorShapeProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorSpecProto.shape)
}

// .tensorflow.DataType dtype = 3;
inline void TensorSpecProto::clear_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_ = 0;
}
inline ::tensorflow::DataType TensorSpecProto::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorSpecProto.dtype)
  return _internal_dtype();
}
inline void TensorSpecProto::set_dtype(::tensorflow::DataType value) {
  _internal_set_dtype(value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorSpecProto.dtype)
}
inline ::tensorflow::DataType TensorSpecProto::_internal_dtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::DataType>(_impl_.dtype_);
}
inline void TensorSpecProto::_internal_set_dtype(::tensorflow::DataType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_ = value;
}

// -------------------------------------------------------------------

// BoundedTensorSpecProto

// string name = 1;
inline void BoundedTensorSpecProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& BoundedTensorSpecProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BoundedTensorSpecProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.BoundedTensorSpecProto.name)
}
inline std::string* BoundedTensorSpecProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.BoundedTensorSpecProto.name)
  return _s;
}
inline const std::string& BoundedTensorSpecProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void BoundedTensorSpecProto::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* BoundedTensorSpecProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* BoundedTensorSpecProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BoundedTensorSpecProto.name)
  return _impl_.name_.Release();
}
inline void BoundedTensorSpecProto::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BoundedTensorSpecProto.name)
}

// .tensorflow.TensorShapeProto shape = 2;
inline bool BoundedTensorSpecProto::has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline const ::tensorflow::TensorShapeProto& BoundedTensorSpecProto::_internal_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TensorShapeProto* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TensorShapeProto&>(::tensorflow::_TensorShapeProto_default_instance_);
}
inline const ::tensorflow::TensorShapeProto& BoundedTensorSpecProto::shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.shape)
  return _internal_shape();
}
inline void BoundedTensorSpecProto::unsafe_arena_set_allocated_shape(::tensorflow::TensorShapeProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.BoundedTensorSpecProto.shape)
}
inline ::tensorflow::TensorShapeProto* BoundedTensorSpecProto::release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorShapeProto* released = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TensorShapeProto* BoundedTensorSpecProto::unsafe_arena_release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BoundedTensorSpecProto.shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::TensorShapeProto* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorShapeProto* BoundedTensorSpecProto::_internal_mutable_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorShapeProto>(GetArena());
    _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(p);
  }
  return _impl_.shape_;
}
inline ::tensorflow::TensorShapeProto* BoundedTensorSpecProto::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::TensorShapeProto* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:tensorflow.BoundedTensorSpecProto.shape)
  return _msg;
}
inline void BoundedTensorSpecProto::set_allocated_shape(::tensorflow::TensorShapeProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shape_ = reinterpret_cast<::tensorflow::TensorShapeProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BoundedTensorSpecProto.shape)
}

// .tensorflow.DataType dtype = 3;
inline void BoundedTensorSpecProto::clear_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_ = 0;
}
inline ::tensorflow::DataType BoundedTensorSpecProto::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.dtype)
  return _internal_dtype();
}
inline void BoundedTensorSpecProto::set_dtype(::tensorflow::DataType value) {
  _internal_set_dtype(value);
  // @@protoc_insertion_point(field_set:tensorflow.BoundedTensorSpecProto.dtype)
}
inline ::tensorflow::DataType BoundedTensorSpecProto::_internal_dtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::DataType>(_impl_.dtype_);
}
inline void BoundedTensorSpecProto::_internal_set_dtype(::tensorflow::DataType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_ = value;
}

// .tensorflow.TensorProto minimum = 4;
inline bool BoundedTensorSpecProto::has_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimum_ != nullptr);
  return value;
}
inline const ::tensorflow::TensorProto& BoundedTensorSpecProto::_internal_minimum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TensorProto* p = _impl_.minimum_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TensorProto&>(::tensorflow::_TensorProto_default_instance_);
}
inline const ::tensorflow::TensorProto& BoundedTensorSpecProto::minimum() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.minimum)
  return _internal_minimum();
}
inline void BoundedTensorSpecProto::unsafe_arena_set_allocated_minimum(::tensorflow::TensorProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimum_);
  }
  _impl_.minimum_ = reinterpret_cast<::tensorflow::TensorProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.BoundedTensorSpecProto.minimum)
}
inline ::tensorflow::TensorProto* BoundedTensorSpecProto::release_minimum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::TensorProto* released = _impl_.minimum_;
  _impl_.minimum_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TensorProto* BoundedTensorSpecProto::unsafe_arena_release_minimum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BoundedTensorSpecProto.minimum)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::TensorProto* temp = _impl_.minimum_;
  _impl_.minimum_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorProto* BoundedTensorSpecProto::_internal_mutable_minimum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.minimum_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorProto>(GetArena());
    _impl_.minimum_ = reinterpret_cast<::tensorflow::TensorProto*>(p);
  }
  return _impl_.minimum_;
}
inline ::tensorflow::TensorProto* BoundedTensorSpecProto::mutable_minimum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::TensorProto* _msg = _internal_mutable_minimum();
  // @@protoc_insertion_point(field_mutable:tensorflow.BoundedTensorSpecProto.minimum)
  return _msg;
}
inline void BoundedTensorSpecProto::set_allocated_minimum(::tensorflow::TensorProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimum_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.minimum_ = reinterpret_cast<::tensorflow::TensorProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BoundedTensorSpecProto.minimum)
}

// .tensorflow.TensorProto maximum = 5;
inline bool BoundedTensorSpecProto::has_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximum_ != nullptr);
  return value;
}
inline const ::tensorflow::TensorProto& BoundedTensorSpecProto::_internal_maximum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::TensorProto* p = _impl_.maximum_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::TensorProto&>(::tensorflow::_TensorProto_default_instance_);
}
inline const ::tensorflow::TensorProto& BoundedTensorSpecProto::maximum() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.maximum)
  return _internal_maximum();
}
inline void BoundedTensorSpecProto::unsafe_arena_set_allocated_maximum(::tensorflow::TensorProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maximum_);
  }
  _impl_.maximum_ = reinterpret_cast<::tensorflow::TensorProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.BoundedTensorSpecProto.maximum)
}
inline ::tensorflow::TensorProto* BoundedTensorSpecProto::release_maximum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::TensorProto* released = _impl_.maximum_;
  _impl_.maximum_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::TensorProto* BoundedTensorSpecProto::unsafe_arena_release_maximum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BoundedTensorSpecProto.maximum)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::TensorProto* temp = _impl_.maximum_;
  _impl_.maximum_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorProto* BoundedTensorSpecProto::_internal_mutable_maximum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.maximum_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::TensorProto>(GetArena());
    _impl_.maximum_ = reinterpret_cast<::tensorflow::TensorProto*>(p);
  }
  return _impl_.maximum_;
}
inline ::tensorflow::TensorProto* BoundedTensorSpecProto::mutable_maximum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tensorflow::TensorProto* _msg = _internal_mutable_maximum();
  // @@protoc_insertion_point(field_mutable:tensorflow.BoundedTensorSpecProto.maximum)
  return _msg;
}
inline void BoundedTensorSpecProto::set_allocated_maximum(::tensorflow::TensorProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maximum_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.maximum_ = reinterpret_cast<::tensorflow::TensorProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BoundedTensorSpecProto.maximum)
}

// -------------------------------------------------------------------

// TypeSpecProto

// .tensorflow.TypeSpecProto.TypeSpecClass type_spec_class = 1;
inline void TypeSpecProto::clear_type_spec_class() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_spec_class_ = 0;
}
inline ::tensorflow::TypeSpecProto_TypeSpecClass TypeSpecProto::type_spec_class() const {
  // @@protoc_insertion_point(field_get:tensorflow.TypeSpecProto.type_spec_class)
  return _internal_type_spec_class();
}
inline void TypeSpecProto::set_type_spec_class(::tensorflow::TypeSpecProto_TypeSpecClass value) {
  _internal_set_type_spec_class(value);
  // @@protoc_insertion_point(field_set:tensorflow.TypeSpecProto.type_spec_class)
}
inline ::tensorflow::TypeSpecProto_TypeSpecClass TypeSpecProto::_internal_type_spec_class() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::TypeSpecProto_TypeSpecClass>(_impl_.type_spec_class_);
}
inline void TypeSpecProto::_internal_set_type_spec_class(::tensorflow::TypeSpecProto_TypeSpecClass value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_spec_class_ = value;
}

// .tensorflow.StructuredValue type_state = 2;
inline bool TypeSpecProto::has_type_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_state_ != nullptr);
  return value;
}
inline void TypeSpecProto::clear_type_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_state_ != nullptr) _impl_.type_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::StructuredValue& TypeSpecProto::_internal_type_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::StructuredValue* p = _impl_.type_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::StructuredValue&>(::tensorflow::_StructuredValue_default_instance_);
}
inline const ::tensorflow::StructuredValue& TypeSpecProto::type_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TypeSpecProto.type_state)
  return _internal_type_state();
}
inline void TypeSpecProto::unsafe_arena_set_allocated_type_state(::tensorflow::StructuredValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_state_);
  }
  _impl_.type_state_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TypeSpecProto.type_state)
}
inline ::tensorflow::StructuredValue* TypeSpecProto::release_type_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::StructuredValue* released = _impl_.type_state_;
  _impl_.type_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::StructuredValue* TypeSpecProto::unsafe_arena_release_type_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TypeSpecProto.type_state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::StructuredValue* temp = _impl_.type_state_;
  _impl_.type_state_ = nullptr;
  return temp;
}
inline ::tensorflow::StructuredValue* TypeSpecProto::_internal_mutable_type_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::StructuredValue>(GetArena());
    _impl_.type_state_ = reinterpret_cast<::tensorflow::StructuredValue*>(p);
  }
  return _impl_.type_state_;
}
inline ::tensorflow::StructuredValue* TypeSpecProto::mutable_type_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::StructuredValue* _msg = _internal_mutable_type_state();
  // @@protoc_insertion_point(field_mutable:tensorflow.TypeSpecProto.type_state)
  return _msg;
}
inline void TypeSpecProto::set_allocated_type_state(::tensorflow::StructuredValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.type_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.type_state_ = reinterpret_cast<::tensorflow::StructuredValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TypeSpecProto.type_state)
}

// string type_spec_class_name = 3;
inline void TypeSpecProto::clear_type_spec_class_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_spec_class_name_.ClearToEmpty();
}
inline const std::string& TypeSpecProto::type_spec_class_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TypeSpecProto.type_spec_class_name)
  return _internal_type_spec_class_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TypeSpecProto::set_type_spec_class_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_spec_class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TypeSpecProto.type_spec_class_name)
}
inline std::string* TypeSpecProto::mutable_type_spec_class_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type_spec_class_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.TypeSpecProto.type_spec_class_name)
  return _s;
}
inline const std::string& TypeSpecProto::_internal_type_spec_class_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_spec_class_name_.Get();
}
inline void TypeSpecProto::_internal_set_type_spec_class_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_spec_class_name_.Set(value, GetArena());
}
inline std::string* TypeSpecProto::_internal_mutable_type_spec_class_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_spec_class_name_.Mutable( GetArena());
}
inline std::string* TypeSpecProto::release_type_spec_class_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TypeSpecProto.type_spec_class_name)
  return _impl_.type_spec_class_name_.Release();
}
inline void TypeSpecProto::set_allocated_type_spec_class_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_spec_class_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_spec_class_name_.IsDefault()) {
          _impl_.type_spec_class_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TypeSpecProto.type_spec_class_name)
}

// int32 num_flat_components = 4;
inline void TypeSpecProto::clear_num_flat_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_flat_components_ = 0;
}
inline ::int32_t TypeSpecProto::num_flat_components() const {
  // @@protoc_insertion_point(field_get:tensorflow.TypeSpecProto.num_flat_components)
  return _internal_num_flat_components();
}
inline void TypeSpecProto::set_num_flat_components(::int32_t value) {
  _internal_set_num_flat_components(value);
  // @@protoc_insertion_point(field_set:tensorflow.TypeSpecProto.num_flat_components)
}
inline ::int32_t TypeSpecProto::_internal_num_flat_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_flat_components_;
}
inline void TypeSpecProto::_internal_set_num_flat_components(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_flat_components_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tensorflow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tensorflow::TypeSpecProto_TypeSpecClass> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::TypeSpecProto_TypeSpecClass>() {
  return ::tensorflow::TypeSpecProto_TypeSpecClass_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto_2epb_2eh
