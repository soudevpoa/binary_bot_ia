// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: xla/tsl/protobuf/test_log.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
namespace tensorflow {
class AvailableDeviceInfo;
struct AvailableDeviceInfoDefaultTypeInternal;
PROTOBUF_EXPORT extern AvailableDeviceInfoDefaultTypeInternal _AvailableDeviceInfo_default_instance_;
class BenchmarkEntries;
struct BenchmarkEntriesDefaultTypeInternal;
PROTOBUF_EXPORT extern BenchmarkEntriesDefaultTypeInternal _BenchmarkEntries_default_instance_;
class BenchmarkEntry;
struct BenchmarkEntryDefaultTypeInternal;
PROTOBUF_EXPORT extern BenchmarkEntryDefaultTypeInternal _BenchmarkEntry_default_instance_;
class BenchmarkEntry_ExtrasEntry_DoNotUse;
struct BenchmarkEntry_ExtrasEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern BenchmarkEntry_ExtrasEntry_DoNotUseDefaultTypeInternal _BenchmarkEntry_ExtrasEntry_DoNotUse_default_instance_;
class BuildConfiguration;
struct BuildConfigurationDefaultTypeInternal;
PROTOBUF_EXPORT extern BuildConfigurationDefaultTypeInternal _BuildConfiguration_default_instance_;
class CPUInfo;
struct CPUInfoDefaultTypeInternal;
PROTOBUF_EXPORT extern CPUInfoDefaultTypeInternal _CPUInfo_default_instance_;
class CPUInfo_CacheSizeEntry_DoNotUse;
struct CPUInfo_CacheSizeEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern CPUInfo_CacheSizeEntry_DoNotUseDefaultTypeInternal _CPUInfo_CacheSizeEntry_DoNotUse_default_instance_;
class CommitId;
struct CommitIdDefaultTypeInternal;
PROTOBUF_EXPORT extern CommitIdDefaultTypeInternal _CommitId_default_instance_;
class EntryValue;
struct EntryValueDefaultTypeInternal;
PROTOBUF_EXPORT extern EntryValueDefaultTypeInternal _EntryValue_default_instance_;
class GPUInfo;
struct GPUInfoDefaultTypeInternal;
PROTOBUF_EXPORT extern GPUInfoDefaultTypeInternal _GPUInfo_default_instance_;
class MachineConfiguration;
struct MachineConfigurationDefaultTypeInternal;
PROTOBUF_EXPORT extern MachineConfigurationDefaultTypeInternal _MachineConfiguration_default_instance_;
class MemoryInfo;
struct MemoryInfoDefaultTypeInternal;
PROTOBUF_EXPORT extern MemoryInfoDefaultTypeInternal _MemoryInfo_default_instance_;
class MetricEntry;
struct MetricEntryDefaultTypeInternal;
PROTOBUF_EXPORT extern MetricEntryDefaultTypeInternal _MetricEntry_default_instance_;
class PlatformInfo;
struct PlatformInfoDefaultTypeInternal;
PROTOBUF_EXPORT extern PlatformInfoDefaultTypeInternal _PlatformInfo_default_instance_;
class RunConfiguration;
struct RunConfigurationDefaultTypeInternal;
PROTOBUF_EXPORT extern RunConfigurationDefaultTypeInternal _RunConfiguration_default_instance_;
class RunConfiguration_EnvVarsEntry_DoNotUse;
struct RunConfiguration_EnvVarsEntry_DoNotUseDefaultTypeInternal;
PROTOBUF_EXPORT extern RunConfiguration_EnvVarsEntry_DoNotUseDefaultTypeInternal _RunConfiguration_EnvVarsEntry_DoNotUse_default_instance_;
class TestResults;
struct TestResultsDefaultTypeInternal;
PROTOBUF_EXPORT extern TestResultsDefaultTypeInternal _TestResults_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {
enum TestResults_BenchmarkType : int {
  TestResults_BenchmarkType_UNKNOWN = 0,
  TestResults_BenchmarkType_CPP_MICROBENCHMARK = 1,
  TestResults_BenchmarkType_PYTHON_BENCHMARK = 2,
  TestResults_BenchmarkType_ANDROID_BENCHMARK = 3,
  TestResults_BenchmarkType_EDGE_BENCHMARK = 4,
  TestResults_BenchmarkType_IOS_BENCHMARK = 5,
  TestResults_BenchmarkType_TestResults_BenchmarkType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestResults_BenchmarkType_TestResults_BenchmarkType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

PROTOBUF_EXPORT bool TestResults_BenchmarkType_IsValid(int value);
PROTOBUF_EXPORT extern const uint32_t TestResults_BenchmarkType_internal_data_[];
constexpr TestResults_BenchmarkType TestResults_BenchmarkType_BenchmarkType_MIN = static_cast<TestResults_BenchmarkType>(0);
constexpr TestResults_BenchmarkType TestResults_BenchmarkType_BenchmarkType_MAX = static_cast<TestResults_BenchmarkType>(5);
constexpr int TestResults_BenchmarkType_BenchmarkType_ARRAYSIZE = 5 + 1;
PROTOBUF_EXPORT const ::google::protobuf::EnumDescriptor*
TestResults_BenchmarkType_descriptor();
template <typename T>
const std::string& TestResults_BenchmarkType_Name(T value) {
  static_assert(std::is_same<T, TestResults_BenchmarkType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BenchmarkType_Name().");
  return TestResults_BenchmarkType_Name(static_cast<TestResults_BenchmarkType>(value));
}
template <>
inline const std::string& TestResults_BenchmarkType_Name(TestResults_BenchmarkType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestResults_BenchmarkType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TestResults_BenchmarkType_Parse(absl::string_view name, TestResults_BenchmarkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestResults_BenchmarkType>(
      TestResults_BenchmarkType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RunConfiguration_EnvVarsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          RunConfiguration_EnvVarsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      RunConfiguration_EnvVarsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RunConfiguration_EnvVarsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunConfiguration_EnvVarsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RunConfiguration_EnvVarsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RunConfiguration_EnvVarsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RunConfiguration_EnvVarsEntry_DoNotUse*>(
        &_RunConfiguration_EnvVarsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      57, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT PlatformInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.PlatformInfo) */ {
 public:
  inline PlatformInfo() : PlatformInfo(nullptr) {}
  ~PlatformInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlatformInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlatformInfo(const PlatformInfo& from) : PlatformInfo(nullptr, from) {}
  inline PlatformInfo(PlatformInfo&& from) noexcept
      : PlatformInfo(nullptr, std::move(from)) {}
  inline PlatformInfo& operator=(const PlatformInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlatformInfo& operator=(PlatformInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlatformInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlatformInfo* internal_default_instance() {
    return reinterpret_cast<const PlatformInfo*>(
        &_PlatformInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PlatformInfo& a, PlatformInfo& b) { a.Swap(&b); }
  inline void Swap(PlatformInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlatformInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlatformInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PlatformInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlatformInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlatformInfo& from) { PlatformInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlatformInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.PlatformInfo"; }

 protected:
  explicit PlatformInfo(::google::protobuf::Arena* arena);
  PlatformInfo(::google::protobuf::Arena* arena, const PlatformInfo& from);
  PlatformInfo(::google::protobuf::Arena* arena, PlatformInfo&& from) noexcept
      : PlatformInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBitsFieldNumber = 1,
    kLinkageFieldNumber = 2,
    kMachineFieldNumber = 3,
    kReleaseFieldNumber = 4,
    kSystemFieldNumber = 5,
    kVersionFieldNumber = 6,
  };
  // string bits = 1;
  void clear_bits() ;
  const std::string& bits() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bits(Arg_&& arg, Args_... args);
  std::string* mutable_bits();
  PROTOBUF_NODISCARD std::string* release_bits();
  void set_allocated_bits(std::string* value);

  private:
  const std::string& _internal_bits() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bits(
      const std::string& value);
  std::string* _internal_mutable_bits();

  public:
  // string linkage = 2;
  void clear_linkage() ;
  const std::string& linkage() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_linkage(Arg_&& arg, Args_... args);
  std::string* mutable_linkage();
  PROTOBUF_NODISCARD std::string* release_linkage();
  void set_allocated_linkage(std::string* value);

  private:
  const std::string& _internal_linkage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkage(
      const std::string& value);
  std::string* _internal_mutable_linkage();

  public:
  // string machine = 3;
  void clear_machine() ;
  const std::string& machine() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_machine(Arg_&& arg, Args_... args);
  std::string* mutable_machine();
  PROTOBUF_NODISCARD std::string* release_machine();
  void set_allocated_machine(std::string* value);

  private:
  const std::string& _internal_machine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine(
      const std::string& value);
  std::string* _internal_mutable_machine();

  public:
  // string release = 4;
  void clear_release() ;
  const std::string& release() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_release(Arg_&& arg, Args_... args);
  std::string* mutable_release();
  PROTOBUF_NODISCARD std::string* release_release();
  void set_allocated_release(std::string* value);

  private:
  const std::string& _internal_release() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_release(
      const std::string& value);
  std::string* _internal_mutable_release();

  public:
  // string system = 5;
  void clear_system() ;
  const std::string& system() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_system(Arg_&& arg, Args_... args);
  std::string* mutable_system();
  PROTOBUF_NODISCARD std::string* release_system();
  void set_allocated_system(std::string* value);

  private:
  const std::string& _internal_system() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system(
      const std::string& value);
  std::string* _internal_mutable_system();

  public:
  // string version = 6;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.PlatformInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      70, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlatformInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr bits_;
    ::google::protobuf::internal::ArenaStringPtr linkage_;
    ::google::protobuf::internal::ArenaStringPtr machine_;
    ::google::protobuf::internal::ArenaStringPtr release_;
    ::google::protobuf::internal::ArenaStringPtr system_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MemoryInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.MemoryInfo) */ {
 public:
  inline MemoryInfo() : MemoryInfo(nullptr) {}
  ~MemoryInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MemoryInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline MemoryInfo(const MemoryInfo& from) : MemoryInfo(nullptr, from) {}
  inline MemoryInfo(MemoryInfo&& from) noexcept
      : MemoryInfo(nullptr, std::move(from)) {}
  inline MemoryInfo& operator=(const MemoryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryInfo& operator=(MemoryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoryInfo* internal_default_instance() {
    return reinterpret_cast<const MemoryInfo*>(
        &_MemoryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(MemoryInfo& a, MemoryInfo& b) { a.Swap(&b); }
  inline void Swap(MemoryInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoryInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoryInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MemoryInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MemoryInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MemoryInfo& from) { MemoryInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MemoryInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.MemoryInfo"; }

 protected:
  explicit MemoryInfo(::google::protobuf::Arena* arena);
  MemoryInfo(::google::protobuf::Arena* arena, const MemoryInfo& from);
  MemoryInfo(::google::protobuf::Arena* arena, MemoryInfo&& from) noexcept
      : MemoryInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTotalFieldNumber = 1,
    kAvailableFieldNumber = 2,
  };
  // int64 total = 1;
  void clear_total() ;
  ::int64_t total() const;
  void set_total(::int64_t value);

  private:
  ::int64_t _internal_total() const;
  void _internal_set_total(::int64_t value);

  public:
  // int64 available = 2;
  void clear_available() ;
  ::int64_t available() const;
  void set_available(::int64_t value);

  private:
  ::int64_t _internal_available() const;
  void _internal_set_available(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.MemoryInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MemoryInfo& from_msg);
    ::int64_t total_;
    ::int64_t available_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT GPUInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.GPUInfo) */ {
 public:
  inline GPUInfo() : GPUInfo(nullptr) {}
  ~GPUInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GPUInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline GPUInfo(const GPUInfo& from) : GPUInfo(nullptr, from) {}
  inline GPUInfo(GPUInfo&& from) noexcept
      : GPUInfo(nullptr, std::move(from)) {}
  inline GPUInfo& operator=(const GPUInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPUInfo& operator=(GPUInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GPUInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GPUInfo* internal_default_instance() {
    return reinterpret_cast<const GPUInfo*>(
        &_GPUInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GPUInfo& a, GPUInfo& b) { a.Swap(&b); }
  inline void Swap(GPUInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPUInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GPUInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GPUInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GPUInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GPUInfo& from) { GPUInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GPUInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.GPUInfo"; }

 protected:
  explicit GPUInfo(::google::protobuf::Arena* arena);
  GPUInfo(::google::protobuf::Arena* arena, const GPUInfo& from);
  GPUInfo(::google::protobuf::Arena* arena, GPUInfo&& from) noexcept
      : GPUInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModelFieldNumber = 1,
    kUuidFieldNumber = 2,
    kBusIdFieldNumber = 3,
  };
  // string model = 1;
  void clear_model() ;
  const std::string& model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model(Arg_&& arg, Args_... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* value);

  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(
      const std::string& value);
  std::string* _internal_mutable_model();

  public:
  // string uuid = 2;
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // string bus_id = 3;
  void clear_bus_id() ;
  const std::string& bus_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bus_id(Arg_&& arg, Args_... args);
  std::string* mutable_bus_id();
  PROTOBUF_NODISCARD std::string* release_bus_id();
  void set_allocated_bus_id(std::string* value);

  private:
  const std::string& _internal_bus_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bus_id(
      const std::string& value);
  std::string* _internal_mutable_bus_id();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.GPUInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      42, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GPUInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr model_;
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    ::google::protobuf::internal::ArenaStringPtr bus_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT EntryValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.EntryValue) */ {
 public:
  inline EntryValue() : EntryValue(nullptr) {}
  ~EntryValue() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntryValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntryValue(const EntryValue& from) : EntryValue(nullptr, from) {}
  inline EntryValue(EntryValue&& from) noexcept
      : EntryValue(nullptr, std::move(from)) {}
  inline EntryValue& operator=(const EntryValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntryValue& operator=(EntryValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntryValue& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kDoubleValue = 1,
    kStringValue = 2,
    KIND_NOT_SET = 0,
  };
  static inline const EntryValue* internal_default_instance() {
    return reinterpret_cast<const EntryValue*>(
        &_EntryValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(EntryValue& a, EntryValue& b) { a.Swap(&b); }
  inline void Swap(EntryValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntryValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntryValue* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EntryValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntryValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntryValue& from) { EntryValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntryValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.EntryValue"; }

 protected:
  explicit EntryValue(::google::protobuf::Arena* arena);
  EntryValue(::google::protobuf::Arena* arena, const EntryValue& from);
  EntryValue(::google::protobuf::Arena* arena, EntryValue&& from) noexcept
      : EntryValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDoubleValueFieldNumber = 1,
    kStringValueFieldNumber = 2,
  };
  // double double_value = 1;
  bool has_double_value() const;
  void clear_double_value() ;
  double double_value() const;
  void set_double_value(double value);

  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);

  public:
  // string string_value = 2;
  bool has_string_value() const;
  void clear_string_value() ;
  const std::string& string_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_value(Arg_&& arg, Args_... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* value);

  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
      const std::string& value);
  std::string* _internal_mutable_string_value();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.EntryValue)
 private:
  class _Internal;
  void set_has_double_value();
  void set_has_string_value();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      42, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EntryValue& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      double double_value_;
      ::google::protobuf::internal::ArenaStringPtr string_value_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CommitId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CommitId) */ {
 public:
  inline CommitId() : CommitId(nullptr) {}
  ~CommitId() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommitId(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommitId(const CommitId& from) : CommitId(nullptr, from) {}
  inline CommitId(CommitId&& from) noexcept
      : CommitId(nullptr, std::move(from)) {}
  inline CommitId& operator=(const CommitId& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitId& operator=(CommitId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitId& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kChangelist = 1,
    kHash = 2,
    KIND_NOT_SET = 0,
  };
  static inline const CommitId* internal_default_instance() {
    return reinterpret_cast<const CommitId*>(
        &_CommitId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CommitId& a, CommitId& b) { a.Swap(&b); }
  inline void Swap(CommitId* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitId* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CommitId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommitId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommitId& from) { CommitId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommitId* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CommitId"; }

 protected:
  explicit CommitId(::google::protobuf::Arena* arena);
  CommitId(::google::protobuf::Arena* arena, const CommitId& from);
  CommitId(::google::protobuf::Arena* arena, CommitId&& from) noexcept
      : CommitId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSnapshotFieldNumber = 3,
    kPendingChangelistFieldNumber = 4,
    kChangelistFieldNumber = 1,
    kHashFieldNumber = 2,
  };
  // string snapshot = 3;
  void clear_snapshot() ;
  const std::string& snapshot() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_snapshot(Arg_&& arg, Args_... args);
  std::string* mutable_snapshot();
  PROTOBUF_NODISCARD std::string* release_snapshot();
  void set_allocated_snapshot(std::string* value);

  private:
  const std::string& _internal_snapshot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshot(
      const std::string& value);
  std::string* _internal_mutable_snapshot();

  public:
  // int64 pending_changelist = 4;
  void clear_pending_changelist() ;
  ::int64_t pending_changelist() const;
  void set_pending_changelist(::int64_t value);

  private:
  ::int64_t _internal_pending_changelist() const;
  void _internal_set_pending_changelist(::int64_t value);

  public:
  // int64 changelist = 1;
  bool has_changelist() const;
  void clear_changelist() ;
  ::int64_t changelist() const;
  void set_changelist(::int64_t value);

  private:
  ::int64_t _internal_changelist() const;
  void _internal_set_changelist(::int64_t value);

  public:
  // string hash = 2;
  bool has_hash() const;
  void clear_hash() ;
  const std::string& hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* value);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.CommitId)
 private:
  class _Internal;
  void set_has_changelist();
  void set_has_hash();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 0,
      40, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommitId& from_msg);
    ::google::protobuf::internal::ArenaStringPtr snapshot_;
    ::int64_t pending_changelist_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t changelist_;
      ::google::protobuf::internal::ArenaStringPtr hash_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class CPUInfo_CacheSizeEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CPUInfo_CacheSizeEntry_DoNotUse, std::string, ::int64_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT64> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CPUInfo_CacheSizeEntry_DoNotUse, std::string, ::int64_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>;
  CPUInfo_CacheSizeEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CPUInfo_CacheSizeEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CPUInfo_CacheSizeEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CPUInfo_CacheSizeEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CPUInfo_CacheSizeEntry_DoNotUse*>(
        &_CPUInfo_CacheSizeEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BuildConfiguration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.BuildConfiguration) */ {
 public:
  inline BuildConfiguration() : BuildConfiguration(nullptr) {}
  ~BuildConfiguration() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuildConfiguration(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuildConfiguration(const BuildConfiguration& from) : BuildConfiguration(nullptr, from) {}
  inline BuildConfiguration(BuildConfiguration&& from) noexcept
      : BuildConfiguration(nullptr, std::move(from)) {}
  inline BuildConfiguration& operator=(const BuildConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildConfiguration& operator=(BuildConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuildConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildConfiguration* internal_default_instance() {
    return reinterpret_cast<const BuildConfiguration*>(
        &_BuildConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(BuildConfiguration& a, BuildConfiguration& b) { a.Swap(&b); }
  inline void Swap(BuildConfiguration* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuildConfiguration* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BuildConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BuildConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BuildConfiguration& from) { BuildConfiguration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuildConfiguration* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.BuildConfiguration"; }

 protected:
  explicit BuildConfiguration(::google::protobuf::Arena* arena);
  BuildConfiguration(::google::protobuf::Arena* arena, const BuildConfiguration& from);
  BuildConfiguration(::google::protobuf::Arena* arena, BuildConfiguration&& from) noexcept
      : BuildConfiguration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCcFlagsFieldNumber = 2,
    kOptsFieldNumber = 3,
    kModeFieldNumber = 1,
  };
  // repeated string cc_flags = 2;
  int cc_flags_size() const;
  private:
  int _internal_cc_flags_size() const;

  public:
  void clear_cc_flags() ;
  const std::string& cc_flags(int index) const;
  std::string* mutable_cc_flags(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cc_flags(int index, Arg_&& value, Args_... args);
  std::string* add_cc_flags();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_cc_flags(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& cc_flags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cc_flags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cc_flags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cc_flags();

  public:
  // repeated string opts = 3;
  int opts_size() const;
  private:
  int _internal_opts_size() const;

  public:
  void clear_opts() ;
  const std::string& opts(int index) const;
  std::string* mutable_opts(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_opts(int index, Arg_&& value, Args_... args);
  std::string* add_opts();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_opts(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& opts() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_opts();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_opts() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_opts();

  public:
  // string mode = 1;
  void clear_mode() ;
  const std::string& mode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mode(Arg_&& arg, Args_... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* value);

  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(
      const std::string& value);
  std::string* _internal_mutable_mode();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.BuildConfiguration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      54, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BuildConfiguration& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> cc_flags_;
    ::google::protobuf::RepeatedPtrField<std::string> opts_;
    ::google::protobuf::internal::ArenaStringPtr mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT AvailableDeviceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.AvailableDeviceInfo) */ {
 public:
  inline AvailableDeviceInfo() : AvailableDeviceInfo(nullptr) {}
  ~AvailableDeviceInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvailableDeviceInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvailableDeviceInfo(const AvailableDeviceInfo& from) : AvailableDeviceInfo(nullptr, from) {}
  inline AvailableDeviceInfo(AvailableDeviceInfo&& from) noexcept
      : AvailableDeviceInfo(nullptr, std::move(from)) {}
  inline AvailableDeviceInfo& operator=(const AvailableDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailableDeviceInfo& operator=(AvailableDeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailableDeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailableDeviceInfo* internal_default_instance() {
    return reinterpret_cast<const AvailableDeviceInfo*>(
        &_AvailableDeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(AvailableDeviceInfo& a, AvailableDeviceInfo& b) { a.Swap(&b); }
  inline void Swap(AvailableDeviceInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailableDeviceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailableDeviceInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvailableDeviceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvailableDeviceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvailableDeviceInfo& from) { AvailableDeviceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvailableDeviceInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.AvailableDeviceInfo"; }

 protected:
  explicit AvailableDeviceInfo(::google::protobuf::Arena* arena);
  AvailableDeviceInfo(::google::protobuf::Arena* arena, const AvailableDeviceInfo& from);
  AvailableDeviceInfo(::google::protobuf::Arena* arena, AvailableDeviceInfo&& from) noexcept
      : AvailableDeviceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kPhysicalDescriptionFieldNumber = 4,
    kMemoryLimitFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string type = 2;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string physical_description = 4;
  void clear_physical_description() ;
  const std::string& physical_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_physical_description(Arg_&& arg, Args_... args);
  std::string* mutable_physical_description();
  PROTOBUF_NODISCARD std::string* release_physical_description();
  void set_allocated_physical_description(std::string* value);

  private:
  const std::string& _internal_physical_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_description(
      const std::string& value);
  std::string* _internal_mutable_physical_description();

  public:
  // int64 memory_limit = 3;
  void clear_memory_limit() ;
  ::int64_t memory_limit() const;
  void set_memory_limit(::int64_t value);

  private:
  ::int64_t _internal_memory_limit() const;
  void _internal_set_memory_limit(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.AvailableDeviceInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      67, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvailableDeviceInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr physical_description_;
    ::int64_t memory_limit_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT RunConfiguration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.RunConfiguration) */ {
 public:
  inline RunConfiguration() : RunConfiguration(nullptr) {}
  ~RunConfiguration() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunConfiguration(
      ::google::protobuf::internal::ConstantInitialized);

  inline RunConfiguration(const RunConfiguration& from) : RunConfiguration(nullptr, from) {}
  inline RunConfiguration(RunConfiguration&& from) noexcept
      : RunConfiguration(nullptr, std::move(from)) {}
  inline RunConfiguration& operator=(const RunConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunConfiguration& operator=(RunConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunConfiguration* internal_default_instance() {
    return reinterpret_cast<const RunConfiguration*>(
        &_RunConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(RunConfiguration& a, RunConfiguration& b) { a.Swap(&b); }
  inline void Swap(RunConfiguration* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunConfiguration* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<RunConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RunConfiguration& from) { RunConfiguration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunConfiguration* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.RunConfiguration"; }

 protected:
  explicit RunConfiguration(::google::protobuf::Arena* arena);
  RunConfiguration(::google::protobuf::Arena* arena, const RunConfiguration& from);
  RunConfiguration(::google::protobuf::Arena* arena, RunConfiguration&& from) noexcept
      : RunConfiguration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArgumentFieldNumber = 1,
    kEnvVarsFieldNumber = 2,
  };
  // repeated string argument = 1;
  int argument_size() const;
  private:
  int _internal_argument_size() const;

  public:
  void clear_argument() ;
  const std::string& argument(int index) const;
  std::string* mutable_argument(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_argument(int index, Arg_&& value, Args_... args);
  std::string* add_argument();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_argument(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& argument() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_argument();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_argument() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_argument();

  public:
  // map<string, string> env_vars = 2;
  int env_vars_size() const;
  private:
  int _internal_env_vars_size() const;

  public:
  void clear_env_vars() ;
  const ::google::protobuf::Map<std::string, std::string>& env_vars() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_env_vars();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_env_vars() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_env_vars();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.RunConfiguration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      52, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RunConfiguration& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> argument_;
    ::google::protobuf::internal::MapField<RunConfiguration_EnvVarsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        env_vars_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MetricEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.MetricEntry) */ {
 public:
  inline MetricEntry() : MetricEntry(nullptr) {}
  ~MetricEntry() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MetricEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline MetricEntry(const MetricEntry& from) : MetricEntry(nullptr, from) {}
  inline MetricEntry(MetricEntry&& from) noexcept
      : MetricEntry(nullptr, std::move(from)) {}
  inline MetricEntry& operator=(const MetricEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricEntry& operator=(MetricEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricEntry* internal_default_instance() {
    return reinterpret_cast<const MetricEntry*>(
        &_MetricEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(MetricEntry& a, MetricEntry& b) { a.Swap(&b); }
  inline void Swap(MetricEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricEntry* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MetricEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MetricEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MetricEntry& from) { MetricEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MetricEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.MetricEntry"; }

 protected:
  explicit MetricEntry(::google::protobuf::Arena* arena);
  MetricEntry(::google::protobuf::Arena* arena, const MetricEntry& from);
  MetricEntry(::google::protobuf::Arena* arena, MetricEntry&& from) noexcept
      : MetricEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kMinValueFieldNumber = 3,
    kMaxValueFieldNumber = 4,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .google.protobuf.DoubleValue min_value = 3;
  bool has_min_value() const;
  void clear_min_value() ;
  const ::google::protobuf::DoubleValue& min_value() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_min_value();
  ::google::protobuf::DoubleValue* mutable_min_value();
  void set_allocated_min_value(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_min_value(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_min_value();

  private:
  const ::google::protobuf::DoubleValue& _internal_min_value() const;
  ::google::protobuf::DoubleValue* _internal_mutable_min_value();

  public:
  // .google.protobuf.DoubleValue max_value = 4;
  bool has_max_value() const;
  void clear_max_value() ;
  const ::google::protobuf::DoubleValue& max_value() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_max_value();
  ::google::protobuf::DoubleValue* mutable_max_value();
  void set_allocated_max_value(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_max_value(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_max_value();

  private:
  const ::google::protobuf::DoubleValue& _internal_max_value() const;
  ::google::protobuf::DoubleValue* _internal_mutable_max_value();

  public:
  // double value = 2;
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.MetricEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      35, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MetricEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::DoubleValue* min_value_;
    ::google::protobuf::DoubleValue* max_value_;
    double value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CPUInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.CPUInfo) */ {
 public:
  inline CPUInfo() : CPUInfo(nullptr) {}
  ~CPUInfo() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CPUInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CPUInfo(const CPUInfo& from) : CPUInfo(nullptr, from) {}
  inline CPUInfo(CPUInfo&& from) noexcept
      : CPUInfo(nullptr, std::move(from)) {}
  inline CPUInfo& operator=(const CPUInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPUInfo& operator=(CPUInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPUInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPUInfo* internal_default_instance() {
    return reinterpret_cast<const CPUInfo*>(
        &_CPUInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CPUInfo& a, CPUInfo& b) { a.Swap(&b); }
  inline void Swap(CPUInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPUInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPUInfo* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CPUInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CPUInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CPUInfo& from) { CPUInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CPUInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.CPUInfo"; }

 protected:
  explicit CPUInfo(::google::protobuf::Arena* arena);
  CPUInfo(::google::protobuf::Arena* arena, const CPUInfo& from);
  CPUInfo(::google::protobuf::Arena* arena, CPUInfo&& from) noexcept
      : CPUInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCacheSizeFieldNumber = 6,
    kCpuInfoFieldNumber = 4,
    kCpuGovernorFieldNumber = 5,
    kNumCoresFieldNumber = 1,
    kNumCoresAllowedFieldNumber = 2,
    kMhzPerCpuFieldNumber = 3,
  };
  // map<string, int64> cache_size = 6;
  int cache_size_size() const;
  private:
  int _internal_cache_size_size() const;

  public:
  void clear_cache_size() ;
  const ::google::protobuf::Map<std::string, ::int64_t>& cache_size() const;
  ::google::protobuf::Map<std::string, ::int64_t>* mutable_cache_size();

  private:
  const ::google::protobuf::Map<std::string, ::int64_t>& _internal_cache_size() const;
  ::google::protobuf::Map<std::string, ::int64_t>* _internal_mutable_cache_size();

  public:
  // string cpu_info = 4;
  void clear_cpu_info() ;
  const std::string& cpu_info() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cpu_info(Arg_&& arg, Args_... args);
  std::string* mutable_cpu_info();
  PROTOBUF_NODISCARD std::string* release_cpu_info();
  void set_allocated_cpu_info(std::string* value);

  private:
  const std::string& _internal_cpu_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpu_info(
      const std::string& value);
  std::string* _internal_mutable_cpu_info();

  public:
  // string cpu_governor = 5;
  void clear_cpu_governor() ;
  const std::string& cpu_governor() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cpu_governor(Arg_&& arg, Args_... args);
  std::string* mutable_cpu_governor();
  PROTOBUF_NODISCARD std::string* release_cpu_governor();
  void set_allocated_cpu_governor(std::string* value);

  private:
  const std::string& _internal_cpu_governor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpu_governor(
      const std::string& value);
  std::string* _internal_mutable_cpu_governor();

  public:
  // int64 num_cores = 1;
  void clear_num_cores() ;
  ::int64_t num_cores() const;
  void set_num_cores(::int64_t value);

  private:
  ::int64_t _internal_num_cores() const;
  void _internal_set_num_cores(::int64_t value);

  public:
  // int64 num_cores_allowed = 2;
  void clear_num_cores_allowed() ;
  ::int64_t num_cores_allowed() const;
  void set_num_cores_allowed(::int64_t value);

  private:
  ::int64_t _internal_num_cores_allowed() const;
  void _internal_set_num_cores_allowed(::int64_t value);

  public:
  // double mhz_per_cpu = 3;
  void clear_mhz_per_cpu() ;
  double mhz_per_cpu() const;
  void set_mhz_per_cpu(double value);

  private:
  double _internal_mhz_per_cpu() const;
  void _internal_set_mhz_per_cpu(double value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.CPUInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      57, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CPUInfo& from_msg);
    ::google::protobuf::internal::MapField<CPUInfo_CacheSizeEntry_DoNotUse, std::string, ::int64_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>
        cache_size_;
    ::google::protobuf::internal::ArenaStringPtr cpu_info_;
    ::google::protobuf::internal::ArenaStringPtr cpu_governor_;
    ::int64_t num_cores_;
    ::int64_t num_cores_allowed_;
    double mhz_per_cpu_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class BenchmarkEntry_ExtrasEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          BenchmarkEntry_ExtrasEntry_DoNotUse, std::string, ::tensorflow::EntryValue,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      BenchmarkEntry_ExtrasEntry_DoNotUse, std::string, ::tensorflow::EntryValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  BenchmarkEntry_ExtrasEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BenchmarkEntry_ExtrasEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit BenchmarkEntry_ExtrasEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const BenchmarkEntry_ExtrasEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const BenchmarkEntry_ExtrasEntry_DoNotUse*>(
        &_BenchmarkEntry_ExtrasEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      49, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT MachineConfiguration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.MachineConfiguration) */ {
 public:
  inline MachineConfiguration() : MachineConfiguration(nullptr) {}
  ~MachineConfiguration() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MachineConfiguration(
      ::google::protobuf::internal::ConstantInitialized);

  inline MachineConfiguration(const MachineConfiguration& from) : MachineConfiguration(nullptr, from) {}
  inline MachineConfiguration(MachineConfiguration&& from) noexcept
      : MachineConfiguration(nullptr, std::move(from)) {}
  inline MachineConfiguration& operator=(const MachineConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline MachineConfiguration& operator=(MachineConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MachineConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const MachineConfiguration* internal_default_instance() {
    return reinterpret_cast<const MachineConfiguration*>(
        &_MachineConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(MachineConfiguration& a, MachineConfiguration& b) { a.Swap(&b); }
  inline void Swap(MachineConfiguration* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MachineConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MachineConfiguration* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MachineConfiguration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MachineConfiguration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MachineConfiguration& from) { MachineConfiguration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MachineConfiguration* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.MachineConfiguration"; }

 protected:
  explicit MachineConfiguration(::google::protobuf::Arena* arena);
  MachineConfiguration(::google::protobuf::Arena* arena, const MachineConfiguration& from);
  MachineConfiguration(::google::protobuf::Arena* arena, MachineConfiguration&& from) noexcept
      : MachineConfiguration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceInfoFieldNumber = 4,
    kAvailableDeviceInfoFieldNumber = 5,
    kHostnameFieldNumber = 1,
    kSerialIdentifierFieldNumber = 7,
    kPlatformInfoFieldNumber = 2,
    kCpuInfoFieldNumber = 3,
    kMemoryInfoFieldNumber = 6,
  };
  // repeated .google.protobuf.Any device_info = 4;
  int device_info_size() const;
  private:
  int _internal_device_info_size() const;

  public:
  void clear_device_info() ;
  ::google::protobuf::Any* mutable_device_info(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* mutable_device_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_device_info() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_device_info();
  public:
  const ::google::protobuf::Any& device_info(int index) const;
  ::google::protobuf::Any* add_device_info();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& device_info() const;
  // repeated .tensorflow.AvailableDeviceInfo available_device_info = 5;
  int available_device_info_size() const;
  private:
  int _internal_available_device_info_size() const;

  public:
  void clear_available_device_info() ;
  ::tensorflow::AvailableDeviceInfo* mutable_available_device_info(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::AvailableDeviceInfo>* mutable_available_device_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::AvailableDeviceInfo>& _internal_available_device_info() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::AvailableDeviceInfo>* _internal_mutable_available_device_info();
  public:
  const ::tensorflow::AvailableDeviceInfo& available_device_info(int index) const;
  ::tensorflow::AvailableDeviceInfo* add_available_device_info();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::AvailableDeviceInfo>& available_device_info() const;
  // string hostname = 1;
  void clear_hostname() ;
  const std::string& hostname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hostname(Arg_&& arg, Args_... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* value);

  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(
      const std::string& value);
  std::string* _internal_mutable_hostname();

  public:
  // string serial_identifier = 7;
  void clear_serial_identifier() ;
  const std::string& serial_identifier() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serial_identifier(Arg_&& arg, Args_... args);
  std::string* mutable_serial_identifier();
  PROTOBUF_NODISCARD std::string* release_serial_identifier();
  void set_allocated_serial_identifier(std::string* value);

  private:
  const std::string& _internal_serial_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_identifier(
      const std::string& value);
  std::string* _internal_mutable_serial_identifier();

  public:
  // .tensorflow.PlatformInfo platform_info = 2;
  bool has_platform_info() const;
  void clear_platform_info() ;
  const ::tensorflow::PlatformInfo& platform_info() const;
  PROTOBUF_NODISCARD ::tensorflow::PlatformInfo* release_platform_info();
  ::tensorflow::PlatformInfo* mutable_platform_info();
  void set_allocated_platform_info(::tensorflow::PlatformInfo* value);
  void unsafe_arena_set_allocated_platform_info(::tensorflow::PlatformInfo* value);
  ::tensorflow::PlatformInfo* unsafe_arena_release_platform_info();

  private:
  const ::tensorflow::PlatformInfo& _internal_platform_info() const;
  ::tensorflow::PlatformInfo* _internal_mutable_platform_info();

  public:
  // .tensorflow.CPUInfo cpu_info = 3;
  bool has_cpu_info() const;
  void clear_cpu_info() ;
  const ::tensorflow::CPUInfo& cpu_info() const;
  PROTOBUF_NODISCARD ::tensorflow::CPUInfo* release_cpu_info();
  ::tensorflow::CPUInfo* mutable_cpu_info();
  void set_allocated_cpu_info(::tensorflow::CPUInfo* value);
  void unsafe_arena_set_allocated_cpu_info(::tensorflow::CPUInfo* value);
  ::tensorflow::CPUInfo* unsafe_arena_release_cpu_info();

  private:
  const ::tensorflow::CPUInfo& _internal_cpu_info() const;
  ::tensorflow::CPUInfo* _internal_mutable_cpu_info();

  public:
  // .tensorflow.MemoryInfo memory_info = 6;
  bool has_memory_info() const;
  void clear_memory_info() ;
  const ::tensorflow::MemoryInfo& memory_info() const;
  PROTOBUF_NODISCARD ::tensorflow::MemoryInfo* release_memory_info();
  ::tensorflow::MemoryInfo* mutable_memory_info();
  void set_allocated_memory_info(::tensorflow::MemoryInfo* value);
  void unsafe_arena_set_allocated_memory_info(::tensorflow::MemoryInfo* value);
  ::tensorflow::MemoryInfo* unsafe_arena_release_memory_info();

  private:
  const ::tensorflow::MemoryInfo& _internal_memory_info() const;
  ::tensorflow::MemoryInfo* _internal_mutable_memory_info();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.MachineConfiguration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      65, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MachineConfiguration& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > device_info_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::AvailableDeviceInfo > available_device_info_;
    ::google::protobuf::internal::ArenaStringPtr hostname_;
    ::google::protobuf::internal::ArenaStringPtr serial_identifier_;
    ::tensorflow::PlatformInfo* platform_info_;
    ::tensorflow::CPUInfo* cpu_info_;
    ::tensorflow::MemoryInfo* memory_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BenchmarkEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.BenchmarkEntry) */ {
 public:
  inline BenchmarkEntry() : BenchmarkEntry(nullptr) {}
  ~BenchmarkEntry() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BenchmarkEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline BenchmarkEntry(const BenchmarkEntry& from) : BenchmarkEntry(nullptr, from) {}
  inline BenchmarkEntry(BenchmarkEntry&& from) noexcept
      : BenchmarkEntry(nullptr, std::move(from)) {}
  inline BenchmarkEntry& operator=(const BenchmarkEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline BenchmarkEntry& operator=(BenchmarkEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BenchmarkEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const BenchmarkEntry* internal_default_instance() {
    return reinterpret_cast<const BenchmarkEntry*>(
        &_BenchmarkEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BenchmarkEntry& a, BenchmarkEntry& b) { a.Swap(&b); }
  inline void Swap(BenchmarkEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BenchmarkEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BenchmarkEntry* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BenchmarkEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BenchmarkEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BenchmarkEntry& from) { BenchmarkEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BenchmarkEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.BenchmarkEntry"; }

 protected:
  explicit BenchmarkEntry(::google::protobuf::Arena* arena);
  BenchmarkEntry(::google::protobuf::Arena* arena, const BenchmarkEntry& from);
  BenchmarkEntry(::google::protobuf::Arena* arena, BenchmarkEntry&& from) noexcept
      : BenchmarkEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtrasFieldNumber = 6,
    kMetricsFieldNumber = 7,
    kNameFieldNumber = 1,
    kItersFieldNumber = 2,
    kCpuTimeFieldNumber = 3,
    kWallTimeFieldNumber = 4,
    kThroughputFieldNumber = 5,
  };
  // map<string, .tensorflow.EntryValue> extras = 6;
  int extras_size() const;
  private:
  int _internal_extras_size() const;

  public:
  void clear_extras() ;
  const ::google::protobuf::Map<std::string, ::tensorflow::EntryValue>& extras() const;
  ::google::protobuf::Map<std::string, ::tensorflow::EntryValue>* mutable_extras();

  private:
  const ::google::protobuf::Map<std::string, ::tensorflow::EntryValue>& _internal_extras() const;
  ::google::protobuf::Map<std::string, ::tensorflow::EntryValue>* _internal_mutable_extras();

  public:
  // repeated .tensorflow.MetricEntry metrics = 7;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;

  public:
  void clear_metrics() ;
  ::tensorflow::MetricEntry* mutable_metrics(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::MetricEntry>* mutable_metrics();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::MetricEntry>& _internal_metrics() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::MetricEntry>* _internal_mutable_metrics();
  public:
  const ::tensorflow::MetricEntry& metrics(int index) const;
  ::tensorflow::MetricEntry* add_metrics();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::MetricEntry>& metrics() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int64 iters = 2;
  void clear_iters() ;
  ::int64_t iters() const;
  void set_iters(::int64_t value);

  private:
  ::int64_t _internal_iters() const;
  void _internal_set_iters(::int64_t value);

  public:
  // double cpu_time = 3;
  void clear_cpu_time() ;
  double cpu_time() const;
  void set_cpu_time(double value);

  private:
  double _internal_cpu_time() const;
  void _internal_set_cpu_time(double value);

  public:
  // double wall_time = 4;
  void clear_wall_time() ;
  double wall_time() const;
  void set_wall_time(double value);

  private:
  double _internal_wall_time() const;
  void _internal_set_wall_time(double value);

  public:
  // double throughput = 5;
  void clear_throughput() ;
  double throughput() const;
  void set_throughput(double value);

  private:
  double _internal_throughput() const;
  void _internal_set_throughput(double value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.BenchmarkEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      44, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BenchmarkEntry& from_msg);
    ::google::protobuf::internal::MapField<BenchmarkEntry_ExtrasEntry_DoNotUse, std::string, ::tensorflow::EntryValue,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        extras_;
    ::google::protobuf::RepeatedPtrField< ::tensorflow::MetricEntry > metrics_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int64_t iters_;
    double cpu_time_;
    double wall_time_;
    double throughput_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BenchmarkEntries final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.BenchmarkEntries) */ {
 public:
  inline BenchmarkEntries() : BenchmarkEntries(nullptr) {}
  ~BenchmarkEntries() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BenchmarkEntries(
      ::google::protobuf::internal::ConstantInitialized);

  inline BenchmarkEntries(const BenchmarkEntries& from) : BenchmarkEntries(nullptr, from) {}
  inline BenchmarkEntries(BenchmarkEntries&& from) noexcept
      : BenchmarkEntries(nullptr, std::move(from)) {}
  inline BenchmarkEntries& operator=(const BenchmarkEntries& from) {
    CopyFrom(from);
    return *this;
  }
  inline BenchmarkEntries& operator=(BenchmarkEntries&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BenchmarkEntries& default_instance() {
    return *internal_default_instance();
  }
  static inline const BenchmarkEntries* internal_default_instance() {
    return reinterpret_cast<const BenchmarkEntries*>(
        &_BenchmarkEntries_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(BenchmarkEntries& a, BenchmarkEntries& b) { a.Swap(&b); }
  inline void Swap(BenchmarkEntries* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BenchmarkEntries* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BenchmarkEntries* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<BenchmarkEntries>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BenchmarkEntries& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BenchmarkEntries& from) { BenchmarkEntries::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BenchmarkEntries* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.BenchmarkEntries"; }

 protected:
  explicit BenchmarkEntries(::google::protobuf::Arena* arena);
  BenchmarkEntries(::google::protobuf::Arena* arena, const BenchmarkEntries& from);
  BenchmarkEntries(::google::protobuf::Arena* arena, BenchmarkEntries&& from) noexcept
      : BenchmarkEntries(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .tensorflow.BenchmarkEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;

  public:
  void clear_entry() ;
  ::tensorflow::BenchmarkEntry* mutable_entry(int index);
  ::google::protobuf::RepeatedPtrField<::tensorflow::BenchmarkEntry>* mutable_entry();

  private:
  const ::google::protobuf::RepeatedPtrField<::tensorflow::BenchmarkEntry>& _internal_entry() const;
  ::google::protobuf::RepeatedPtrField<::tensorflow::BenchmarkEntry>* _internal_mutable_entry();
  public:
  const ::tensorflow::BenchmarkEntry& entry(int index) const;
  ::tensorflow::BenchmarkEntry* add_entry();
  const ::google::protobuf::RepeatedPtrField<::tensorflow::BenchmarkEntry>& entry() const;
  // @@protoc_insertion_point(class_scope:tensorflow.BenchmarkEntries)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BenchmarkEntries& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tensorflow::BenchmarkEntry > entry_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};
// -------------------------------------------------------------------

class PROTOBUF_EXPORT TestResults final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.TestResults) */ {
 public:
  inline TestResults() : TestResults(nullptr) {}
  ~TestResults() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestResults(
      ::google::protobuf::internal::ConstantInitialized);

  inline TestResults(const TestResults& from) : TestResults(nullptr, from) {}
  inline TestResults(TestResults&& from) noexcept
      : TestResults(nullptr, std::move(from)) {}
  inline TestResults& operator=(const TestResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestResults& operator=(TestResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestResults* internal_default_instance() {
    return reinterpret_cast<const TestResults*>(
        &_TestResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(TestResults& a, TestResults& b) { a.Swap(&b); }
  inline void Swap(TestResults* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestResults* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestResults* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TestResults>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestResults& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TestResults& from) { TestResults::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TestResults* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tensorflow.TestResults"; }

 protected:
  explicit TestResults(::google::protobuf::Arena* arena);
  TestResults(::google::protobuf::Arena* arena, const TestResults& from);
  TestResults(::google::protobuf::Arena* arena, TestResults&& from) noexcept
      : TestResults(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using BenchmarkType = TestResults_BenchmarkType;
  static constexpr BenchmarkType UNKNOWN = TestResults_BenchmarkType_UNKNOWN;
  static constexpr BenchmarkType CPP_MICROBENCHMARK = TestResults_BenchmarkType_CPP_MICROBENCHMARK;
  static constexpr BenchmarkType PYTHON_BENCHMARK = TestResults_BenchmarkType_PYTHON_BENCHMARK;
  static constexpr BenchmarkType ANDROID_BENCHMARK = TestResults_BenchmarkType_ANDROID_BENCHMARK;
  static constexpr BenchmarkType EDGE_BENCHMARK = TestResults_BenchmarkType_EDGE_BENCHMARK;
  static constexpr BenchmarkType IOS_BENCHMARK = TestResults_BenchmarkType_IOS_BENCHMARK;
  static inline bool BenchmarkType_IsValid(int value) {
    return TestResults_BenchmarkType_IsValid(value);
  }
  static constexpr BenchmarkType BenchmarkType_MIN = TestResults_BenchmarkType_BenchmarkType_MIN;
  static constexpr BenchmarkType BenchmarkType_MAX = TestResults_BenchmarkType_BenchmarkType_MAX;
  static constexpr int BenchmarkType_ARRAYSIZE = TestResults_BenchmarkType_BenchmarkType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BenchmarkType_descriptor() {
    return TestResults_BenchmarkType_descriptor();
  }
  template <typename T>
  static inline const std::string& BenchmarkType_Name(T value) {
    return TestResults_BenchmarkType_Name(value);
  }
  static inline bool BenchmarkType_Parse(absl::string_view name, BenchmarkType* value) {
    return TestResults_BenchmarkType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kNameFieldNumber = 9,
    kRunModeFieldNumber = 11,
    kTfVersionFieldNumber = 12,
    kEntriesFieldNumber = 2,
    kBuildConfigurationFieldNumber = 3,
    kCommitIdFieldNumber = 4,
    kMachineConfigurationFieldNumber = 7,
    kRunConfigurationFieldNumber = 8,
    kStartTimeFieldNumber = 5,
    kRunTimeFieldNumber = 6,
    kBenchmarkTypeFieldNumber = 10,
  };
  // string target = 1;
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // string name = 9;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string run_mode = 11;
  void clear_run_mode() ;
  const std::string& run_mode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_run_mode(Arg_&& arg, Args_... args);
  std::string* mutable_run_mode();
  PROTOBUF_NODISCARD std::string* release_run_mode();
  void set_allocated_run_mode(std::string* value);

  private:
  const std::string& _internal_run_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_run_mode(
      const std::string& value);
  std::string* _internal_mutable_run_mode();

  public:
  // string tf_version = 12;
  void clear_tf_version() ;
  const std::string& tf_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tf_version(Arg_&& arg, Args_... args);
  std::string* mutable_tf_version();
  PROTOBUF_NODISCARD std::string* release_tf_version();
  void set_allocated_tf_version(std::string* value);

  private:
  const std::string& _internal_tf_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tf_version(
      const std::string& value);
  std::string* _internal_mutable_tf_version();

  public:
  // .tensorflow.BenchmarkEntries entries = 2;
  bool has_entries() const;
  void clear_entries() ;
  const ::tensorflow::BenchmarkEntries& entries() const;
  PROTOBUF_NODISCARD ::tensorflow::BenchmarkEntries* release_entries();
  ::tensorflow::BenchmarkEntries* mutable_entries();
  void set_allocated_entries(::tensorflow::BenchmarkEntries* value);
  void unsafe_arena_set_allocated_entries(::tensorflow::BenchmarkEntries* value);
  ::tensorflow::BenchmarkEntries* unsafe_arena_release_entries();

  private:
  const ::tensorflow::BenchmarkEntries& _internal_entries() const;
  ::tensorflow::BenchmarkEntries* _internal_mutable_entries();

  public:
  // .tensorflow.BuildConfiguration build_configuration = 3;
  bool has_build_configuration() const;
  void clear_build_configuration() ;
  const ::tensorflow::BuildConfiguration& build_configuration() const;
  PROTOBUF_NODISCARD ::tensorflow::BuildConfiguration* release_build_configuration();
  ::tensorflow::BuildConfiguration* mutable_build_configuration();
  void set_allocated_build_configuration(::tensorflow::BuildConfiguration* value);
  void unsafe_arena_set_allocated_build_configuration(::tensorflow::BuildConfiguration* value);
  ::tensorflow::BuildConfiguration* unsafe_arena_release_build_configuration();

  private:
  const ::tensorflow::BuildConfiguration& _internal_build_configuration() const;
  ::tensorflow::BuildConfiguration* _internal_mutable_build_configuration();

  public:
  // .tensorflow.CommitId commit_id = 4;
  bool has_commit_id() const;
  void clear_commit_id() ;
  const ::tensorflow::CommitId& commit_id() const;
  PROTOBUF_NODISCARD ::tensorflow::CommitId* release_commit_id();
  ::tensorflow::CommitId* mutable_commit_id();
  void set_allocated_commit_id(::tensorflow::CommitId* value);
  void unsafe_arena_set_allocated_commit_id(::tensorflow::CommitId* value);
  ::tensorflow::CommitId* unsafe_arena_release_commit_id();

  private:
  const ::tensorflow::CommitId& _internal_commit_id() const;
  ::tensorflow::CommitId* _internal_mutable_commit_id();

  public:
  // .tensorflow.MachineConfiguration machine_configuration = 7;
  bool has_machine_configuration() const;
  void clear_machine_configuration() ;
  const ::tensorflow::MachineConfiguration& machine_configuration() const;
  PROTOBUF_NODISCARD ::tensorflow::MachineConfiguration* release_machine_configuration();
  ::tensorflow::MachineConfiguration* mutable_machine_configuration();
  void set_allocated_machine_configuration(::tensorflow::MachineConfiguration* value);
  void unsafe_arena_set_allocated_machine_configuration(::tensorflow::MachineConfiguration* value);
  ::tensorflow::MachineConfiguration* unsafe_arena_release_machine_configuration();

  private:
  const ::tensorflow::MachineConfiguration& _internal_machine_configuration() const;
  ::tensorflow::MachineConfiguration* _internal_mutable_machine_configuration();

  public:
  // .tensorflow.RunConfiguration run_configuration = 8;
  bool has_run_configuration() const;
  void clear_run_configuration() ;
  const ::tensorflow::RunConfiguration& run_configuration() const;
  PROTOBUF_NODISCARD ::tensorflow::RunConfiguration* release_run_configuration();
  ::tensorflow::RunConfiguration* mutable_run_configuration();
  void set_allocated_run_configuration(::tensorflow::RunConfiguration* value);
  void unsafe_arena_set_allocated_run_configuration(::tensorflow::RunConfiguration* value);
  ::tensorflow::RunConfiguration* unsafe_arena_release_run_configuration();

  private:
  const ::tensorflow::RunConfiguration& _internal_run_configuration() const;
  ::tensorflow::RunConfiguration* _internal_mutable_run_configuration();

  public:
  // int64 start_time = 5;
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // double run_time = 6;
  void clear_run_time() ;
  double run_time() const;
  void set_run_time(double value);

  private:
  double _internal_run_time() const;
  void _internal_set_run_time(double value);

  public:
  // .tensorflow.TestResults.BenchmarkType benchmark_type = 10;
  void clear_benchmark_type() ;
  ::tensorflow::TestResults_BenchmarkType benchmark_type() const;
  void set_benchmark_type(::tensorflow::TestResults_BenchmarkType value);

  private:
  ::tensorflow::TestResults_BenchmarkType _internal_benchmark_type() const;
  void _internal_set_benchmark_type(::tensorflow::TestResults_BenchmarkType value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.TestResults)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 5,
      67, 2>
      _table_;


  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TestResults& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr run_mode_;
    ::google::protobuf::internal::ArenaStringPtr tf_version_;
    ::tensorflow::BenchmarkEntries* entries_;
    ::tensorflow::BuildConfiguration* build_configuration_;
    ::tensorflow::CommitId* commit_id_;
    ::tensorflow::MachineConfiguration* machine_configuration_;
    ::tensorflow::RunConfiguration* run_configuration_;
    ::int64_t start_time_;
    double run_time_;
    int benchmark_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EntryValue

// double double_value = 1;
inline bool EntryValue::has_double_value() const {
  return kind_case() == kDoubleValue;
}
inline void EntryValue::set_has_double_value() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void EntryValue::clear_double_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kDoubleValue) {
    _impl_.kind_.double_value_ = 0;
    clear_has_kind();
  }
}
inline double EntryValue::double_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.EntryValue.double_value)
  return _internal_double_value();
}
inline void EntryValue::set_double_value(double value) {
  if (kind_case() != kDoubleValue) {
    clear_kind();
    set_has_double_value();
  }
  _impl_.kind_.double_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.EntryValue.double_value)
}
inline double EntryValue::_internal_double_value() const {
  if (kind_case() == kDoubleValue) {
    return _impl_.kind_.double_value_;
  }
  return 0;
}

// string string_value = 2;
inline bool EntryValue::has_string_value() const {
  return kind_case() == kStringValue;
}
inline void EntryValue::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void EntryValue::clear_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStringValue) {
    _impl_.kind_.string_value_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& EntryValue::string_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.EntryValue.string_value)
  return _internal_string_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntryValue::set_string_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStringValue) {
    clear_kind();

    set_has_string_value();
    _impl_.kind_.string_value_.InitDefault();
  }
  _impl_.kind_.string_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.EntryValue.string_value)
}
inline std::string* EntryValue::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.EntryValue.string_value)
  return _s;
}
inline const std::string& EntryValue::_internal_string_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (kind_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.kind_.string_value_.Get();
}
inline void EntryValue::_internal_set_string_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStringValue) {
    clear_kind();

    set_has_string_value();
    _impl_.kind_.string_value_.InitDefault();
  }
  _impl_.kind_.string_value_.Set(value, GetArena());
}
inline std::string* EntryValue::_internal_mutable_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStringValue) {
    clear_kind();

    set_has_string_value();
    _impl_.kind_.string_value_.InitDefault();
  }
  return _impl_.kind_.string_value_.Mutable( GetArena());
}
inline std::string* EntryValue::release_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.EntryValue.string_value)
  if (kind_case() != kStringValue) {
    return nullptr;
  }
  clear_has_kind();
  return _impl_.kind_.string_value_.Release();
}
inline void EntryValue::set_allocated_string_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_kind()) {
    clear_kind();
  }
  if (value != nullptr) {
    set_has_string_value();
    _impl_.kind_.string_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.EntryValue.string_value)
}

inline bool EntryValue::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void EntryValue::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline EntryValue::KindCase EntryValue::kind_case() const {
  return EntryValue::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MetricEntry

// string name = 1;
inline void MetricEntry::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MetricEntry::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetricEntry.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetricEntry::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.MetricEntry.name)
}
inline std::string* MetricEntry::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetricEntry.name)
  return _s;
}
inline const std::string& MetricEntry::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void MetricEntry::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MetricEntry::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MetricEntry::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetricEntry.name)
  return _impl_.name_.Release();
}
inline void MetricEntry::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetricEntry.name)
}

// double value = 2;
inline void MetricEntry::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline double MetricEntry::value() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetricEntry.value)
  return _internal_value();
}
inline void MetricEntry::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:tensorflow.MetricEntry.value)
}
inline double MetricEntry::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void MetricEntry::_internal_set_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// .google.protobuf.DoubleValue min_value = 3;
inline bool MetricEntry::has_min_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_value_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& MetricEntry::_internal_min_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.min_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& MetricEntry::min_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetricEntry.min_value)
  return _internal_min_value();
}
inline void MetricEntry::unsafe_arena_set_allocated_min_value(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_value_);
  }
  _impl_.min_value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetricEntry.min_value)
}
inline ::google::protobuf::DoubleValue* MetricEntry::release_min_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.min_value_;
  _impl_.min_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* MetricEntry::unsafe_arena_release_min_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetricEntry.min_value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.min_value_;
  _impl_.min_value_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* MetricEntry::_internal_mutable_min_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.min_value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.min_value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.min_value_;
}
inline ::google::protobuf::DoubleValue* MetricEntry::mutable_min_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_min_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetricEntry.min_value)
  return _msg;
}
inline void MetricEntry::set_allocated_min_value(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.min_value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetricEntry.min_value)
}

// .google.protobuf.DoubleValue max_value = 4;
inline bool MetricEntry::has_max_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_value_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& MetricEntry::_internal_max_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::DoubleValue* p = _impl_.max_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& MetricEntry::max_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MetricEntry.max_value)
  return _internal_max_value();
}
inline void MetricEntry::unsafe_arena_set_allocated_max_value(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_value_);
  }
  _impl_.max_value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetricEntry.max_value)
}
inline ::google::protobuf::DoubleValue* MetricEntry::release_max_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* released = _impl_.max_value_;
  _impl_.max_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* MetricEntry::unsafe_arena_release_max_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MetricEntry.max_value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::DoubleValue* temp = _impl_.max_value_;
  _impl_.max_value_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* MetricEntry::_internal_mutable_max_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.max_value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::DoubleValue>(GetArena());
    _impl_.max_value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.max_value_;
}
inline ::google::protobuf::DoubleValue* MetricEntry::mutable_max_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_max_value();
  // @@protoc_insertion_point(field_mutable:tensorflow.MetricEntry.max_value)
  return _msg;
}
inline void MetricEntry::set_allocated_max_value(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.max_value_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetricEntry.max_value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BenchmarkEntry

// string name = 1;
inline void BenchmarkEntry::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& BenchmarkEntry::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BenchmarkEntry::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.name)
}
inline std::string* BenchmarkEntry::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.BenchmarkEntry.name)
  return _s;
}
inline const std::string& BenchmarkEntry::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void BenchmarkEntry::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* BenchmarkEntry::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* BenchmarkEntry::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BenchmarkEntry.name)
  return _impl_.name_.Release();
}
inline void BenchmarkEntry::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BenchmarkEntry.name)
}

// int64 iters = 2;
inline void BenchmarkEntry::clear_iters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iters_ = ::int64_t{0};
}
inline ::int64_t BenchmarkEntry::iters() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.iters)
  return _internal_iters();
}
inline void BenchmarkEntry::set_iters(::int64_t value) {
  _internal_set_iters(value);
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.iters)
}
inline ::int64_t BenchmarkEntry::_internal_iters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.iters_;
}
inline void BenchmarkEntry::_internal_set_iters(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iters_ = value;
}

// double cpu_time = 3;
inline void BenchmarkEntry::clear_cpu_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_time_ = 0;
}
inline double BenchmarkEntry::cpu_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.cpu_time)
  return _internal_cpu_time();
}
inline void BenchmarkEntry::set_cpu_time(double value) {
  _internal_set_cpu_time(value);
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.cpu_time)
}
inline double BenchmarkEntry::_internal_cpu_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cpu_time_;
}
inline void BenchmarkEntry::_internal_set_cpu_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_time_ = value;
}

// double wall_time = 4;
inline void BenchmarkEntry::clear_wall_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wall_time_ = 0;
}
inline double BenchmarkEntry::wall_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.wall_time)
  return _internal_wall_time();
}
inline void BenchmarkEntry::set_wall_time(double value) {
  _internal_set_wall_time(value);
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.wall_time)
}
inline double BenchmarkEntry::_internal_wall_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wall_time_;
}
inline void BenchmarkEntry::_internal_set_wall_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wall_time_ = value;
}

// double throughput = 5;
inline void BenchmarkEntry::clear_throughput() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.throughput_ = 0;
}
inline double BenchmarkEntry::throughput() const {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.throughput)
  return _internal_throughput();
}
inline void BenchmarkEntry::set_throughput(double value) {
  _internal_set_throughput(value);
  // @@protoc_insertion_point(field_set:tensorflow.BenchmarkEntry.throughput)
}
inline double BenchmarkEntry::_internal_throughput() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.throughput_;
}
inline void BenchmarkEntry::_internal_set_throughput(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.throughput_ = value;
}

// map<string, .tensorflow.EntryValue> extras = 6;
inline int BenchmarkEntry::_internal_extras_size() const {
  return _internal_extras().size();
}
inline int BenchmarkEntry::extras_size() const {
  return _internal_extras_size();
}
inline void BenchmarkEntry::clear_extras() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extras_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::EntryValue>& BenchmarkEntry::_internal_extras() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extras_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::tensorflow::EntryValue>& BenchmarkEntry::extras() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.BenchmarkEntry.extras)
  return _internal_extras();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::EntryValue>* BenchmarkEntry::_internal_mutable_extras() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.extras_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::tensorflow::EntryValue>* BenchmarkEntry::mutable_extras() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.BenchmarkEntry.extras)
  return _internal_mutable_extras();
}

// repeated .tensorflow.MetricEntry metrics = 7;
inline int BenchmarkEntry::_internal_metrics_size() const {
  return _internal_metrics().size();
}
inline int BenchmarkEntry::metrics_size() const {
  return _internal_metrics_size();
}
inline void BenchmarkEntry::clear_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metrics_.Clear();
}
inline ::tensorflow::MetricEntry* BenchmarkEntry::mutable_metrics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.BenchmarkEntry.metrics)
  return _internal_mutable_metrics()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::MetricEntry>* BenchmarkEntry::mutable_metrics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BenchmarkEntry.metrics)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_metrics();
}
inline const ::tensorflow::MetricEntry& BenchmarkEntry::metrics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntry.metrics)
  return _internal_metrics().Get(index);
}
inline ::tensorflow::MetricEntry* BenchmarkEntry::add_metrics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::MetricEntry* _add = _internal_mutable_metrics()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.BenchmarkEntry.metrics)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::MetricEntry>& BenchmarkEntry::metrics() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.BenchmarkEntry.metrics)
  return _internal_metrics();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::MetricEntry>&
BenchmarkEntry::_internal_metrics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metrics_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::MetricEntry>*
BenchmarkEntry::_internal_mutable_metrics() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.metrics_;
}

// -------------------------------------------------------------------

// BenchmarkEntries

// repeated .tensorflow.BenchmarkEntry entry = 1;
inline int BenchmarkEntries::_internal_entry_size() const {
  return _internal_entry().size();
}
inline int BenchmarkEntries::entry_size() const {
  return _internal_entry_size();
}
inline void BenchmarkEntries::clear_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entry_.Clear();
}
inline ::tensorflow::BenchmarkEntry* BenchmarkEntries::mutable_entry(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.BenchmarkEntries.entry)
  return _internal_mutable_entry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::BenchmarkEntry>* BenchmarkEntries::mutable_entry()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BenchmarkEntries.entry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entry();
}
inline const ::tensorflow::BenchmarkEntry& BenchmarkEntries::entry(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BenchmarkEntries.entry)
  return _internal_entry().Get(index);
}
inline ::tensorflow::BenchmarkEntry* BenchmarkEntries::add_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::BenchmarkEntry* _add = _internal_mutable_entry()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.BenchmarkEntries.entry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::BenchmarkEntry>& BenchmarkEntries::entry() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.BenchmarkEntries.entry)
  return _internal_entry();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::BenchmarkEntry>&
BenchmarkEntries::_internal_entry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entry_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::BenchmarkEntry>*
BenchmarkEntries::_internal_mutable_entry() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entry_;
}

// -------------------------------------------------------------------

// BuildConfiguration

// string mode = 1;
inline void BuildConfiguration::clear_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& BuildConfiguration::mode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BuildConfiguration.mode)
  return _internal_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BuildConfiguration::set_mode(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.BuildConfiguration.mode)
}
inline std::string* BuildConfiguration::mutable_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:tensorflow.BuildConfiguration.mode)
  return _s;
}
inline const std::string& BuildConfiguration::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mode_.Get();
}
inline void BuildConfiguration::_internal_set_mode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_.Set(value, GetArena());
}
inline std::string* BuildConfiguration::_internal_mutable_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.mode_.Mutable( GetArena());
}
inline std::string* BuildConfiguration::release_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.BuildConfiguration.mode)
  return _impl_.mode_.Release();
}
inline void BuildConfiguration::set_allocated_mode(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mode_.IsDefault()) {
          _impl_.mode_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BuildConfiguration.mode)
}

// repeated string cc_flags = 2;
inline int BuildConfiguration::_internal_cc_flags_size() const {
  return _internal_cc_flags().size();
}
inline int BuildConfiguration::cc_flags_size() const {
  return _internal_cc_flags_size();
}
inline void BuildConfiguration::clear_cc_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cc_flags_.Clear();
}
inline std::string* BuildConfiguration::add_cc_flags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_cc_flags()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.BuildConfiguration.cc_flags)
  return _s;
}
inline const std::string& BuildConfiguration::cc_flags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BuildConfiguration.cc_flags)
  return _internal_cc_flags().Get(index);
}
inline std::string* BuildConfiguration::mutable_cc_flags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.BuildConfiguration.cc_flags)
  return _internal_mutable_cc_flags()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BuildConfiguration::set_cc_flags(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_cc_flags()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.BuildConfiguration.cc_flags)
}
template <typename Arg_, typename... Args_>
inline void BuildConfiguration::add_cc_flags(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_cc_flags(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.BuildConfiguration.cc_flags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BuildConfiguration::cc_flags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.BuildConfiguration.cc_flags)
  return _internal_cc_flags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BuildConfiguration::mutable_cc_flags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BuildConfiguration.cc_flags)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cc_flags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BuildConfiguration::_internal_cc_flags() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cc_flags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BuildConfiguration::_internal_mutable_cc_flags() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cc_flags_;
}

// repeated string opts = 3;
inline int BuildConfiguration::_internal_opts_size() const {
  return _internal_opts().size();
}
inline int BuildConfiguration::opts_size() const {
  return _internal_opts_size();
}
inline void BuildConfiguration::clear_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opts_.Clear();
}
inline std::string* BuildConfiguration::add_opts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_opts()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.BuildConfiguration.opts)
  return _s;
}
inline const std::string& BuildConfiguration::opts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.BuildConfiguration.opts)
  return _internal_opts().Get(index);
}
inline std::string* BuildConfiguration::mutable_opts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.BuildConfiguration.opts)
  return _internal_mutable_opts()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BuildConfiguration::set_opts(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_opts()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.BuildConfiguration.opts)
}
template <typename Arg_, typename... Args_>
inline void BuildConfiguration::add_opts(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_opts(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.BuildConfiguration.opts)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BuildConfiguration::opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.BuildConfiguration.opts)
  return _internal_opts();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BuildConfiguration::mutable_opts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BuildConfiguration.opts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_opts();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BuildConfiguration::_internal_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.opts_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BuildConfiguration::_internal_mutable_opts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.opts_;
}

// -------------------------------------------------------------------

// CommitId

// int64 changelist = 1;
inline bool CommitId::has_changelist() const {
  return kind_case() == kChangelist;
}
inline void CommitId::set_has_changelist() {
  _impl_._oneof_case_[0] = kChangelist;
}
inline void CommitId::clear_changelist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kChangelist) {
    _impl_.kind_.changelist_ = ::int64_t{0};
    clear_has_kind();
  }
}
inline ::int64_t CommitId::changelist() const {
  // @@protoc_insertion_point(field_get:tensorflow.CommitId.changelist)
  return _internal_changelist();
}
inline void CommitId::set_changelist(::int64_t value) {
  if (kind_case() != kChangelist) {
    clear_kind();
    set_has_changelist();
  }
  _impl_.kind_.changelist_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CommitId.changelist)
}
inline ::int64_t CommitId::_internal_changelist() const {
  if (kind_case() == kChangelist) {
    return _impl_.kind_.changelist_;
  }
  return ::int64_t{0};
}

// string hash = 2;
inline bool CommitId::has_hash() const {
  return kind_case() == kHash;
}
inline void CommitId::set_has_hash() {
  _impl_._oneof_case_[0] = kHash;
}
inline void CommitId::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kHash) {
    _impl_.kind_.hash_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& CommitId::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CommitId.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommitId::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kHash) {
    clear_kind();

    set_has_hash();
    _impl_.kind_.hash_.InitDefault();
  }
  _impl_.kind_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CommitId.hash)
}
inline std::string* CommitId::mutable_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:tensorflow.CommitId.hash)
  return _s;
}
inline const std::string& CommitId::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (kind_case() != kHash) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.kind_.hash_.Get();
}
inline void CommitId::_internal_set_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kHash) {
    clear_kind();

    set_has_hash();
    _impl_.kind_.hash_.InitDefault();
  }
  _impl_.kind_.hash_.Set(value, GetArena());
}
inline std::string* CommitId::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kHash) {
    clear_kind();

    set_has_hash();
    _impl_.kind_.hash_.InitDefault();
  }
  return _impl_.kind_.hash_.Mutable( GetArena());
}
inline std::string* CommitId::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CommitId.hash)
  if (kind_case() != kHash) {
    return nullptr;
  }
  clear_has_kind();
  return _impl_.kind_.hash_.Release();
}
inline void CommitId::set_allocated_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_kind()) {
    clear_kind();
  }
  if (value != nullptr) {
    set_has_hash();
    _impl_.kind_.hash_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CommitId.hash)
}

// string snapshot = 3;
inline void CommitId::clear_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_.ClearToEmpty();
}
inline const std::string& CommitId::snapshot() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CommitId.snapshot)
  return _internal_snapshot();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommitId::set_snapshot(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CommitId.snapshot)
}
inline std::string* CommitId::mutable_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:tensorflow.CommitId.snapshot)
  return _s;
}
inline const std::string& CommitId::_internal_snapshot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snapshot_.Get();
}
inline void CommitId::_internal_set_snapshot(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_.Set(value, GetArena());
}
inline std::string* CommitId::_internal_mutable_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.snapshot_.Mutable( GetArena());
}
inline std::string* CommitId::release_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CommitId.snapshot)
  return _impl_.snapshot_.Release();
}
inline void CommitId::set_allocated_snapshot(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.snapshot_.IsDefault()) {
          _impl_.snapshot_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CommitId.snapshot)
}

// int64 pending_changelist = 4;
inline void CommitId::clear_pending_changelist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pending_changelist_ = ::int64_t{0};
}
inline ::int64_t CommitId::pending_changelist() const {
  // @@protoc_insertion_point(field_get:tensorflow.CommitId.pending_changelist)
  return _internal_pending_changelist();
}
inline void CommitId::set_pending_changelist(::int64_t value) {
  _internal_set_pending_changelist(value);
  // @@protoc_insertion_point(field_set:tensorflow.CommitId.pending_changelist)
}
inline ::int64_t CommitId::_internal_pending_changelist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pending_changelist_;
}
inline void CommitId::_internal_set_pending_changelist(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pending_changelist_ = value;
}

inline bool CommitId::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void CommitId::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline CommitId::KindCase CommitId::kind_case() const {
  return CommitId::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CPUInfo

// int64 num_cores = 1;
inline void CPUInfo::clear_num_cores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_cores_ = ::int64_t{0};
}
inline ::int64_t CPUInfo::num_cores() const {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.num_cores)
  return _internal_num_cores();
}
inline void CPUInfo::set_num_cores(::int64_t value) {
  _internal_set_num_cores(value);
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.num_cores)
}
inline ::int64_t CPUInfo::_internal_num_cores() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_cores_;
}
inline void CPUInfo::_internal_set_num_cores(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_cores_ = value;
}

// int64 num_cores_allowed = 2;
inline void CPUInfo::clear_num_cores_allowed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_cores_allowed_ = ::int64_t{0};
}
inline ::int64_t CPUInfo::num_cores_allowed() const {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.num_cores_allowed)
  return _internal_num_cores_allowed();
}
inline void CPUInfo::set_num_cores_allowed(::int64_t value) {
  _internal_set_num_cores_allowed(value);
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.num_cores_allowed)
}
inline ::int64_t CPUInfo::_internal_num_cores_allowed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_cores_allowed_;
}
inline void CPUInfo::_internal_set_num_cores_allowed(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_cores_allowed_ = value;
}

// double mhz_per_cpu = 3;
inline void CPUInfo::clear_mhz_per_cpu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mhz_per_cpu_ = 0;
}
inline double CPUInfo::mhz_per_cpu() const {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.mhz_per_cpu)
  return _internal_mhz_per_cpu();
}
inline void CPUInfo::set_mhz_per_cpu(double value) {
  _internal_set_mhz_per_cpu(value);
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.mhz_per_cpu)
}
inline double CPUInfo::_internal_mhz_per_cpu() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mhz_per_cpu_;
}
inline void CPUInfo::_internal_set_mhz_per_cpu(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mhz_per_cpu_ = value;
}

// string cpu_info = 4;
inline void CPUInfo::clear_cpu_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_info_.ClearToEmpty();
}
inline const std::string& CPUInfo::cpu_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.cpu_info)
  return _internal_cpu_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CPUInfo::set_cpu_info(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_info_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.cpu_info)
}
inline std::string* CPUInfo::mutable_cpu_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cpu_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.CPUInfo.cpu_info)
  return _s;
}
inline const std::string& CPUInfo::_internal_cpu_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cpu_info_.Get();
}
inline void CPUInfo::_internal_set_cpu_info(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_info_.Set(value, GetArena());
}
inline std::string* CPUInfo::_internal_mutable_cpu_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cpu_info_.Mutable( GetArena());
}
inline std::string* CPUInfo::release_cpu_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CPUInfo.cpu_info)
  return _impl_.cpu_info_.Release();
}
inline void CPUInfo::set_allocated_cpu_info(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_info_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cpu_info_.IsDefault()) {
          _impl_.cpu_info_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CPUInfo.cpu_info)
}

// string cpu_governor = 5;
inline void CPUInfo::clear_cpu_governor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_governor_.ClearToEmpty();
}
inline const std::string& CPUInfo::cpu_governor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.CPUInfo.cpu_governor)
  return _internal_cpu_governor();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CPUInfo::set_cpu_governor(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_governor_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.CPUInfo.cpu_governor)
}
inline std::string* CPUInfo::mutable_cpu_governor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cpu_governor();
  // @@protoc_insertion_point(field_mutable:tensorflow.CPUInfo.cpu_governor)
  return _s;
}
inline const std::string& CPUInfo::_internal_cpu_governor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cpu_governor_.Get();
}
inline void CPUInfo::_internal_set_cpu_governor(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_governor_.Set(value, GetArena());
}
inline std::string* CPUInfo::_internal_mutable_cpu_governor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cpu_governor_.Mutable( GetArena());
}
inline std::string* CPUInfo::release_cpu_governor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.CPUInfo.cpu_governor)
  return _impl_.cpu_governor_.Release();
}
inline void CPUInfo::set_allocated_cpu_governor(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_governor_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cpu_governor_.IsDefault()) {
          _impl_.cpu_governor_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CPUInfo.cpu_governor)
}

// map<string, int64> cache_size = 6;
inline int CPUInfo::_internal_cache_size_size() const {
  return _internal_cache_size().size();
}
inline int CPUInfo::cache_size_size() const {
  return _internal_cache_size_size();
}
inline void CPUInfo::clear_cache_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cache_size_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& CPUInfo::_internal_cache_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cache_size_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& CPUInfo::cache_size() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.CPUInfo.cache_size)
  return _internal_cache_size();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* CPUInfo::_internal_mutable_cache_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cache_size_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* CPUInfo::mutable_cache_size() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.CPUInfo.cache_size)
  return _internal_mutable_cache_size();
}

// -------------------------------------------------------------------

// MemoryInfo

// int64 total = 1;
inline void MemoryInfo::clear_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = ::int64_t{0};
}
inline ::int64_t MemoryInfo::total() const {
  // @@protoc_insertion_point(field_get:tensorflow.MemoryInfo.total)
  return _internal_total();
}
inline void MemoryInfo::set_total(::int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:tensorflow.MemoryInfo.total)
}
inline ::int64_t MemoryInfo::_internal_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_;
}
inline void MemoryInfo::_internal_set_total(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = value;
}

// int64 available = 2;
inline void MemoryInfo::clear_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_ = ::int64_t{0};
}
inline ::int64_t MemoryInfo::available() const {
  // @@protoc_insertion_point(field_get:tensorflow.MemoryInfo.available)
  return _internal_available();
}
inline void MemoryInfo::set_available(::int64_t value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:tensorflow.MemoryInfo.available)
}
inline ::int64_t MemoryInfo::_internal_available() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_;
}
inline void MemoryInfo::_internal_set_available(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_ = value;
}

// -------------------------------------------------------------------

// GPUInfo

// string model = 1;
inline void GPUInfo::clear_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.ClearToEmpty();
}
inline const std::string& GPUInfo::model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GPUInfo.model)
  return _internal_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GPUInfo::set_model(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GPUInfo.model)
}
inline std::string* GPUInfo::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:tensorflow.GPUInfo.model)
  return _s;
}
inline const std::string& GPUInfo::_internal_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_.Get();
}
inline void GPUInfo::_internal_set_model(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.Set(value, GetArena());
}
inline std::string* GPUInfo::_internal_mutable_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_.Mutable( GetArena());
}
inline std::string* GPUInfo::release_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GPUInfo.model)
  return _impl_.model_.Release();
}
inline void GPUInfo::set_allocated_model(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_.IsDefault()) {
          _impl_.model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GPUInfo.model)
}

// string uuid = 2;
inline void GPUInfo::clear_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& GPUInfo::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GPUInfo.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GPUInfo::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GPUInfo.uuid)
}
inline std::string* GPUInfo::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:tensorflow.GPUInfo.uuid)
  return _s;
}
inline const std::string& GPUInfo::_internal_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uuid_.Get();
}
inline void GPUInfo::_internal_set_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* GPUInfo::_internal_mutable_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* GPUInfo::release_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GPUInfo.uuid)
  return _impl_.uuid_.Release();
}
inline void GPUInfo::set_allocated_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uuid_.IsDefault()) {
          _impl_.uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GPUInfo.uuid)
}

// string bus_id = 3;
inline void GPUInfo::clear_bus_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bus_id_.ClearToEmpty();
}
inline const std::string& GPUInfo::bus_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.GPUInfo.bus_id)
  return _internal_bus_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GPUInfo::set_bus_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bus_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.GPUInfo.bus_id)
}
inline std::string* GPUInfo::mutable_bus_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bus_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.GPUInfo.bus_id)
  return _s;
}
inline const std::string& GPUInfo::_internal_bus_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bus_id_.Get();
}
inline void GPUInfo::_internal_set_bus_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bus_id_.Set(value, GetArena());
}
inline std::string* GPUInfo::_internal_mutable_bus_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.bus_id_.Mutable( GetArena());
}
inline std::string* GPUInfo::release_bus_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.GPUInfo.bus_id)
  return _impl_.bus_id_.Release();
}
inline void GPUInfo::set_allocated_bus_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bus_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bus_id_.IsDefault()) {
          _impl_.bus_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GPUInfo.bus_id)
}

// -------------------------------------------------------------------

// PlatformInfo

// string bits = 1;
inline void PlatformInfo::clear_bits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bits_.ClearToEmpty();
}
inline const std::string& PlatformInfo::bits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.bits)
  return _internal_bits();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformInfo::set_bits(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bits_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.bits)
}
inline std::string* PlatformInfo::mutable_bits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bits();
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.bits)
  return _s;
}
inline const std::string& PlatformInfo::_internal_bits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bits_.Get();
}
inline void PlatformInfo::_internal_set_bits(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bits_.Set(value, GetArena());
}
inline std::string* PlatformInfo::_internal_mutable_bits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.bits_.Mutable( GetArena());
}
inline std::string* PlatformInfo::release_bits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.bits)
  return _impl_.bits_.Release();
}
inline void PlatformInfo::set_allocated_bits(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bits_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bits_.IsDefault()) {
          _impl_.bits_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.bits)
}

// string linkage = 2;
inline void PlatformInfo::clear_linkage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.linkage_.ClearToEmpty();
}
inline const std::string& PlatformInfo::linkage() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.linkage)
  return _internal_linkage();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformInfo::set_linkage(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.linkage_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.linkage)
}
inline std::string* PlatformInfo::mutable_linkage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_linkage();
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.linkage)
  return _s;
}
inline const std::string& PlatformInfo::_internal_linkage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.linkage_.Get();
}
inline void PlatformInfo::_internal_set_linkage(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.linkage_.Set(value, GetArena());
}
inline std::string* PlatformInfo::_internal_mutable_linkage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.linkage_.Mutable( GetArena());
}
inline std::string* PlatformInfo::release_linkage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.linkage)
  return _impl_.linkage_.Release();
}
inline void PlatformInfo::set_allocated_linkage(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.linkage_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.linkage_.IsDefault()) {
          _impl_.linkage_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.linkage)
}

// string machine = 3;
inline void PlatformInfo::clear_machine() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.machine_.ClearToEmpty();
}
inline const std::string& PlatformInfo::machine() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.machine)
  return _internal_machine();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformInfo::set_machine(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.machine_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.machine)
}
inline std::string* PlatformInfo::mutable_machine() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_machine();
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.machine)
  return _s;
}
inline const std::string& PlatformInfo::_internal_machine() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.machine_.Get();
}
inline void PlatformInfo::_internal_set_machine(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.machine_.Set(value, GetArena());
}
inline std::string* PlatformInfo::_internal_mutable_machine() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.machine_.Mutable( GetArena());
}
inline std::string* PlatformInfo::release_machine() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.machine)
  return _impl_.machine_.Release();
}
inline void PlatformInfo::set_allocated_machine(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.machine_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.machine_.IsDefault()) {
          _impl_.machine_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.machine)
}

// string release = 4;
inline void PlatformInfo::clear_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_.ClearToEmpty();
}
inline const std::string& PlatformInfo::release() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.release)
  return _internal_release();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformInfo::set_release(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.release)
}
inline std::string* PlatformInfo::mutable_release() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_release();
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.release)
  return _s;
}
inline const std::string& PlatformInfo::_internal_release() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.release_.Get();
}
inline void PlatformInfo::_internal_set_release(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_.Set(value, GetArena());
}
inline std::string* PlatformInfo::_internal_mutable_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.release_.Mutable( GetArena());
}
inline std::string* PlatformInfo::release_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.release)
  return _impl_.release_.Release();
}
inline void PlatformInfo::set_allocated_release(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.release_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.release_.IsDefault()) {
          _impl_.release_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.release)
}

// string system = 5;
inline void PlatformInfo::clear_system() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.system_.ClearToEmpty();
}
inline const std::string& PlatformInfo::system() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.system)
  return _internal_system();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformInfo::set_system(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.system_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.system)
}
inline std::string* PlatformInfo::mutable_system() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_system();
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.system)
  return _s;
}
inline const std::string& PlatformInfo::_internal_system() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.system_.Get();
}
inline void PlatformInfo::_internal_set_system(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.system_.Set(value, GetArena());
}
inline std::string* PlatformInfo::_internal_mutable_system() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.system_.Mutable( GetArena());
}
inline std::string* PlatformInfo::release_system() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.system)
  return _impl_.system_.Release();
}
inline void PlatformInfo::set_allocated_system(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.system_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.system_.IsDefault()) {
          _impl_.system_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.system)
}

// string version = 6;
inline void PlatformInfo::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& PlatformInfo::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.PlatformInfo.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformInfo::set_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.PlatformInfo.version)
}
inline std::string* PlatformInfo::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:tensorflow.PlatformInfo.version)
  return _s;
}
inline const std::string& PlatformInfo::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void PlatformInfo::_internal_set_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(value, GetArena());
}
inline std::string* PlatformInfo::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* PlatformInfo::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.PlatformInfo.version)
  return _impl_.version_.Release();
}
inline void PlatformInfo::set_allocated_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PlatformInfo.version)
}

// -------------------------------------------------------------------

// AvailableDeviceInfo

// string name = 1;
inline void AvailableDeviceInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AvailableDeviceInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.AvailableDeviceInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AvailableDeviceInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.AvailableDeviceInfo.name)
}
inline std::string* AvailableDeviceInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.AvailableDeviceInfo.name)
  return _s;
}
inline const std::string& AvailableDeviceInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void AvailableDeviceInfo::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* AvailableDeviceInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* AvailableDeviceInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.AvailableDeviceInfo.name)
  return _impl_.name_.Release();
}
inline void AvailableDeviceInfo::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AvailableDeviceInfo.name)
}

// string type = 2;
inline void AvailableDeviceInfo::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& AvailableDeviceInfo::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.AvailableDeviceInfo.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AvailableDeviceInfo::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.AvailableDeviceInfo.type)
}
inline std::string* AvailableDeviceInfo::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:tensorflow.AvailableDeviceInfo.type)
  return _s;
}
inline const std::string& AvailableDeviceInfo::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void AvailableDeviceInfo::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* AvailableDeviceInfo::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* AvailableDeviceInfo::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.AvailableDeviceInfo.type)
  return _impl_.type_.Release();
}
inline void AvailableDeviceInfo::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AvailableDeviceInfo.type)
}

// int64 memory_limit = 3;
inline void AvailableDeviceInfo::clear_memory_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_limit_ = ::int64_t{0};
}
inline ::int64_t AvailableDeviceInfo::memory_limit() const {
  // @@protoc_insertion_point(field_get:tensorflow.AvailableDeviceInfo.memory_limit)
  return _internal_memory_limit();
}
inline void AvailableDeviceInfo::set_memory_limit(::int64_t value) {
  _internal_set_memory_limit(value);
  // @@protoc_insertion_point(field_set:tensorflow.AvailableDeviceInfo.memory_limit)
}
inline ::int64_t AvailableDeviceInfo::_internal_memory_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memory_limit_;
}
inline void AvailableDeviceInfo::_internal_set_memory_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_limit_ = value;
}

// string physical_description = 4;
inline void AvailableDeviceInfo::clear_physical_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.physical_description_.ClearToEmpty();
}
inline const std::string& AvailableDeviceInfo::physical_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.AvailableDeviceInfo.physical_description)
  return _internal_physical_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AvailableDeviceInfo::set_physical_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.physical_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.AvailableDeviceInfo.physical_description)
}
inline std::string* AvailableDeviceInfo::mutable_physical_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_physical_description();
  // @@protoc_insertion_point(field_mutable:tensorflow.AvailableDeviceInfo.physical_description)
  return _s;
}
inline const std::string& AvailableDeviceInfo::_internal_physical_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.physical_description_.Get();
}
inline void AvailableDeviceInfo::_internal_set_physical_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.physical_description_.Set(value, GetArena());
}
inline std::string* AvailableDeviceInfo::_internal_mutable_physical_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.physical_description_.Mutable( GetArena());
}
inline std::string* AvailableDeviceInfo::release_physical_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.AvailableDeviceInfo.physical_description)
  return _impl_.physical_description_.Release();
}
inline void AvailableDeviceInfo::set_allocated_physical_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.physical_description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.physical_description_.IsDefault()) {
          _impl_.physical_description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AvailableDeviceInfo.physical_description)
}

// -------------------------------------------------------------------

// MachineConfiguration

// string hostname = 1;
inline void MachineConfiguration::clear_hostname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& MachineConfiguration::hostname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.hostname)
  return _internal_hostname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MachineConfiguration::set_hostname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hostname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.MachineConfiguration.hostname)
}
inline std::string* MachineConfiguration::mutable_hostname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.hostname)
  return _s;
}
inline const std::string& MachineConfiguration::_internal_hostname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hostname_.Get();
}
inline void MachineConfiguration::_internal_set_hostname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hostname_.Set(value, GetArena());
}
inline std::string* MachineConfiguration::_internal_mutable_hostname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hostname_.Mutable( GetArena());
}
inline std::string* MachineConfiguration::release_hostname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.hostname)
  return _impl_.hostname_.Release();
}
inline void MachineConfiguration::set_allocated_hostname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hostname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hostname_.IsDefault()) {
          _impl_.hostname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.hostname)
}

// string serial_identifier = 7;
inline void MachineConfiguration::clear_serial_identifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_identifier_.ClearToEmpty();
}
inline const std::string& MachineConfiguration::serial_identifier() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.serial_identifier)
  return _internal_serial_identifier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MachineConfiguration::set_serial_identifier(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_identifier_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.MachineConfiguration.serial_identifier)
}
inline std::string* MachineConfiguration::mutable_serial_identifier() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serial_identifier();
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.serial_identifier)
  return _s;
}
inline const std::string& MachineConfiguration::_internal_serial_identifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.serial_identifier_.Get();
}
inline void MachineConfiguration::_internal_set_serial_identifier(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_identifier_.Set(value, GetArena());
}
inline std::string* MachineConfiguration::_internal_mutable_serial_identifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.serial_identifier_.Mutable( GetArena());
}
inline std::string* MachineConfiguration::release_serial_identifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.serial_identifier)
  return _impl_.serial_identifier_.Release();
}
inline void MachineConfiguration::set_allocated_serial_identifier(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_identifier_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serial_identifier_.IsDefault()) {
          _impl_.serial_identifier_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.serial_identifier)
}

// .tensorflow.PlatformInfo platform_info = 2;
inline bool MachineConfiguration::has_platform_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.platform_info_ != nullptr);
  return value;
}
inline void MachineConfiguration::clear_platform_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.platform_info_ != nullptr) _impl_.platform_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::PlatformInfo& MachineConfiguration::_internal_platform_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::PlatformInfo* p = _impl_.platform_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::PlatformInfo&>(::tensorflow::_PlatformInfo_default_instance_);
}
inline const ::tensorflow::PlatformInfo& MachineConfiguration::platform_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.platform_info)
  return _internal_platform_info();
}
inline void MachineConfiguration::unsafe_arena_set_allocated_platform_info(::tensorflow::PlatformInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.platform_info_);
  }
  _impl_.platform_info_ = reinterpret_cast<::tensorflow::PlatformInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MachineConfiguration.platform_info)
}
inline ::tensorflow::PlatformInfo* MachineConfiguration::release_platform_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::PlatformInfo* released = _impl_.platform_info_;
  _impl_.platform_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::PlatformInfo* MachineConfiguration::unsafe_arena_release_platform_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.platform_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::PlatformInfo* temp = _impl_.platform_info_;
  _impl_.platform_info_ = nullptr;
  return temp;
}
inline ::tensorflow::PlatformInfo* MachineConfiguration::_internal_mutable_platform_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.platform_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::PlatformInfo>(GetArena());
    _impl_.platform_info_ = reinterpret_cast<::tensorflow::PlatformInfo*>(p);
  }
  return _impl_.platform_info_;
}
inline ::tensorflow::PlatformInfo* MachineConfiguration::mutable_platform_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::PlatformInfo* _msg = _internal_mutable_platform_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.platform_info)
  return _msg;
}
inline void MachineConfiguration::set_allocated_platform_info(::tensorflow::PlatformInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.platform_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.platform_info_ = reinterpret_cast<::tensorflow::PlatformInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.platform_info)
}

// .tensorflow.CPUInfo cpu_info = 3;
inline bool MachineConfiguration::has_cpu_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cpu_info_ != nullptr);
  return value;
}
inline void MachineConfiguration::clear_cpu_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cpu_info_ != nullptr) _impl_.cpu_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tensorflow::CPUInfo& MachineConfiguration::_internal_cpu_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CPUInfo* p = _impl_.cpu_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CPUInfo&>(::tensorflow::_CPUInfo_default_instance_);
}
inline const ::tensorflow::CPUInfo& MachineConfiguration::cpu_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.cpu_info)
  return _internal_cpu_info();
}
inline void MachineConfiguration::unsafe_arena_set_allocated_cpu_info(::tensorflow::CPUInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cpu_info_);
  }
  _impl_.cpu_info_ = reinterpret_cast<::tensorflow::CPUInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MachineConfiguration.cpu_info)
}
inline ::tensorflow::CPUInfo* MachineConfiguration::release_cpu_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::CPUInfo* released = _impl_.cpu_info_;
  _impl_.cpu_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CPUInfo* MachineConfiguration::unsafe_arena_release_cpu_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.cpu_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::CPUInfo* temp = _impl_.cpu_info_;
  _impl_.cpu_info_ = nullptr;
  return temp;
}
inline ::tensorflow::CPUInfo* MachineConfiguration::_internal_mutable_cpu_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cpu_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CPUInfo>(GetArena());
    _impl_.cpu_info_ = reinterpret_cast<::tensorflow::CPUInfo*>(p);
  }
  return _impl_.cpu_info_;
}
inline ::tensorflow::CPUInfo* MachineConfiguration::mutable_cpu_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::CPUInfo* _msg = _internal_mutable_cpu_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.cpu_info)
  return _msg;
}
inline void MachineConfiguration::set_allocated_cpu_info(::tensorflow::CPUInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.cpu_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cpu_info_ = reinterpret_cast<::tensorflow::CPUInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.cpu_info)
}

// repeated .google.protobuf.Any device_info = 4;
inline int MachineConfiguration::_internal_device_info_size() const {
  return _internal_device_info().size();
}
inline int MachineConfiguration::device_info_size() const {
  return _internal_device_info_size();
}
inline ::google::protobuf::Any* MachineConfiguration::mutable_device_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.device_info)
  return _internal_mutable_device_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* MachineConfiguration::mutable_device_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.MachineConfiguration.device_info)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_info();
}
inline const ::google::protobuf::Any& MachineConfiguration::device_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.device_info)
  return _internal_device_info().Get(index);
}
inline ::google::protobuf::Any* MachineConfiguration::add_device_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_device_info()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.MachineConfiguration.device_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& MachineConfiguration::device_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.MachineConfiguration.device_info)
  return _internal_device_info();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
MachineConfiguration::_internal_device_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_info_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
MachineConfiguration::_internal_mutable_device_info() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_info_;
}

// repeated .tensorflow.AvailableDeviceInfo available_device_info = 5;
inline int MachineConfiguration::_internal_available_device_info_size() const {
  return _internal_available_device_info().size();
}
inline int MachineConfiguration::available_device_info_size() const {
  return _internal_available_device_info_size();
}
inline void MachineConfiguration::clear_available_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_device_info_.Clear();
}
inline ::tensorflow::AvailableDeviceInfo* MachineConfiguration::mutable_available_device_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.available_device_info)
  return _internal_mutable_available_device_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::AvailableDeviceInfo>* MachineConfiguration::mutable_available_device_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.MachineConfiguration.available_device_info)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available_device_info();
}
inline const ::tensorflow::AvailableDeviceInfo& MachineConfiguration::available_device_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.available_device_info)
  return _internal_available_device_info().Get(index);
}
inline ::tensorflow::AvailableDeviceInfo* MachineConfiguration::add_available_device_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tensorflow::AvailableDeviceInfo* _add = _internal_mutable_available_device_info()->Add();
  // @@protoc_insertion_point(field_add:tensorflow.MachineConfiguration.available_device_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::AvailableDeviceInfo>& MachineConfiguration::available_device_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.MachineConfiguration.available_device_info)
  return _internal_available_device_info();
}
inline const ::google::protobuf::RepeatedPtrField<::tensorflow::AvailableDeviceInfo>&
MachineConfiguration::_internal_available_device_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_device_info_;
}
inline ::google::protobuf::RepeatedPtrField<::tensorflow::AvailableDeviceInfo>*
MachineConfiguration::_internal_mutable_available_device_info() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_device_info_;
}

// .tensorflow.MemoryInfo memory_info = 6;
inline bool MachineConfiguration::has_memory_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.memory_info_ != nullptr);
  return value;
}
inline void MachineConfiguration::clear_memory_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_info_ != nullptr) _impl_.memory_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::tensorflow::MemoryInfo& MachineConfiguration::_internal_memory_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::MemoryInfo* p = _impl_.memory_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::MemoryInfo&>(::tensorflow::_MemoryInfo_default_instance_);
}
inline const ::tensorflow::MemoryInfo& MachineConfiguration::memory_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.MachineConfiguration.memory_info)
  return _internal_memory_info();
}
inline void MachineConfiguration::unsafe_arena_set_allocated_memory_info(::tensorflow::MemoryInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_info_);
  }
  _impl_.memory_info_ = reinterpret_cast<::tensorflow::MemoryInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MachineConfiguration.memory_info)
}
inline ::tensorflow::MemoryInfo* MachineConfiguration::release_memory_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::MemoryInfo* released = _impl_.memory_info_;
  _impl_.memory_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::MemoryInfo* MachineConfiguration::unsafe_arena_release_memory_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.MachineConfiguration.memory_info)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::MemoryInfo* temp = _impl_.memory_info_;
  _impl_.memory_info_ = nullptr;
  return temp;
}
inline ::tensorflow::MemoryInfo* MachineConfiguration::_internal_mutable_memory_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::MemoryInfo>(GetArena());
    _impl_.memory_info_ = reinterpret_cast<::tensorflow::MemoryInfo*>(p);
  }
  return _impl_.memory_info_;
}
inline ::tensorflow::MemoryInfo* MachineConfiguration::mutable_memory_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tensorflow::MemoryInfo* _msg = _internal_mutable_memory_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.MachineConfiguration.memory_info)
  return _msg;
}
inline void MachineConfiguration::set_allocated_memory_info(::tensorflow::MemoryInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.memory_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.memory_info_ = reinterpret_cast<::tensorflow::MemoryInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MachineConfiguration.memory_info)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RunConfiguration

// repeated string argument = 1;
inline int RunConfiguration::_internal_argument_size() const {
  return _internal_argument().size();
}
inline int RunConfiguration::argument_size() const {
  return _internal_argument_size();
}
inline void RunConfiguration::clear_argument() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.argument_.Clear();
}
inline std::string* RunConfiguration::add_argument() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_argument()->Add();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunConfiguration.argument)
  return _s;
}
inline const std::string& RunConfiguration::argument(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.RunConfiguration.argument)
  return _internal_argument().Get(index);
}
inline std::string* RunConfiguration::mutable_argument(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunConfiguration.argument)
  return _internal_mutable_argument()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RunConfiguration::set_argument(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_argument()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:tensorflow.RunConfiguration.argument)
}
template <typename Arg_, typename... Args_>
inline void RunConfiguration::add_argument(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_argument(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:tensorflow.RunConfiguration.argument)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RunConfiguration::argument() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tensorflow.RunConfiguration.argument)
  return _internal_argument();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RunConfiguration::mutable_argument() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunConfiguration.argument)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_argument();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RunConfiguration::_internal_argument() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.argument_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RunConfiguration::_internal_mutable_argument() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.argument_;
}

// map<string, string> env_vars = 2;
inline int RunConfiguration::_internal_env_vars_size() const {
  return _internal_env_vars().size();
}
inline int RunConfiguration::env_vars_size() const {
  return _internal_env_vars_size();
}
inline void RunConfiguration::clear_env_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.env_vars_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RunConfiguration::_internal_env_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.env_vars_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RunConfiguration::env_vars() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:tensorflow.RunConfiguration.env_vars)
  return _internal_env_vars();
}
inline ::google::protobuf::Map<std::string, std::string>* RunConfiguration::_internal_mutable_env_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.env_vars_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RunConfiguration::mutable_env_vars() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.RunConfiguration.env_vars)
  return _internal_mutable_env_vars();
}

// -------------------------------------------------------------------

// TestResults

// string target = 1;
inline void TestResults::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& TestResults::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestResults::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.target)
}
inline std::string* TestResults::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.target)
  return _s;
}
inline const std::string& TestResults::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void TestResults::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* TestResults::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* TestResults::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.target)
  return _impl_.target_.Release();
}
inline void TestResults::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_.IsDefault()) {
          _impl_.target_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.target)
}

// .tensorflow.BenchmarkEntries entries = 2;
inline bool TestResults::has_entries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entries_ != nullptr);
  return value;
}
inline void TestResults::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entries_ != nullptr) _impl_.entries_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tensorflow::BenchmarkEntries& TestResults::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::BenchmarkEntries* p = _impl_.entries_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::BenchmarkEntries&>(::tensorflow::_BenchmarkEntries_default_instance_);
}
inline const ::tensorflow::BenchmarkEntries& TestResults::entries() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.entries)
  return _internal_entries();
}
inline void TestResults::unsafe_arena_set_allocated_entries(::tensorflow::BenchmarkEntries* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entries_);
  }
  _impl_.entries_ = reinterpret_cast<::tensorflow::BenchmarkEntries*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TestResults.entries)
}
inline ::tensorflow::BenchmarkEntries* TestResults::release_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::BenchmarkEntries* released = _impl_.entries_;
  _impl_.entries_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::BenchmarkEntries* TestResults::unsafe_arena_release_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.entries)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::BenchmarkEntries* temp = _impl_.entries_;
  _impl_.entries_ = nullptr;
  return temp;
}
inline ::tensorflow::BenchmarkEntries* TestResults::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entries_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::BenchmarkEntries>(GetArena());
    _impl_.entries_ = reinterpret_cast<::tensorflow::BenchmarkEntries*>(p);
  }
  return _impl_.entries_;
}
inline ::tensorflow::BenchmarkEntries* TestResults::mutable_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::BenchmarkEntries* _msg = _internal_mutable_entries();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.entries)
  return _msg;
}
inline void TestResults::set_allocated_entries(::tensorflow::BenchmarkEntries* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.entries_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.entries_ = reinterpret_cast<::tensorflow::BenchmarkEntries*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.entries)
}

// .tensorflow.BuildConfiguration build_configuration = 3;
inline bool TestResults::has_build_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.build_configuration_ != nullptr);
  return value;
}
inline void TestResults::clear_build_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.build_configuration_ != nullptr) _impl_.build_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tensorflow::BuildConfiguration& TestResults::_internal_build_configuration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::BuildConfiguration* p = _impl_.build_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::BuildConfiguration&>(::tensorflow::_BuildConfiguration_default_instance_);
}
inline const ::tensorflow::BuildConfiguration& TestResults::build_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.build_configuration)
  return _internal_build_configuration();
}
inline void TestResults::unsafe_arena_set_allocated_build_configuration(::tensorflow::BuildConfiguration* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.build_configuration_);
  }
  _impl_.build_configuration_ = reinterpret_cast<::tensorflow::BuildConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TestResults.build_configuration)
}
inline ::tensorflow::BuildConfiguration* TestResults::release_build_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::BuildConfiguration* released = _impl_.build_configuration_;
  _impl_.build_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::BuildConfiguration* TestResults::unsafe_arena_release_build_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.build_configuration)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::BuildConfiguration* temp = _impl_.build_configuration_;
  _impl_.build_configuration_ = nullptr;
  return temp;
}
inline ::tensorflow::BuildConfiguration* TestResults::_internal_mutable_build_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.build_configuration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::BuildConfiguration>(GetArena());
    _impl_.build_configuration_ = reinterpret_cast<::tensorflow::BuildConfiguration*>(p);
  }
  return _impl_.build_configuration_;
}
inline ::tensorflow::BuildConfiguration* TestResults::mutable_build_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::BuildConfiguration* _msg = _internal_mutable_build_configuration();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.build_configuration)
  return _msg;
}
inline void TestResults::set_allocated_build_configuration(::tensorflow::BuildConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.build_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.build_configuration_ = reinterpret_cast<::tensorflow::BuildConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.build_configuration)
}

// .tensorflow.CommitId commit_id = 4;
inline bool TestResults::has_commit_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commit_id_ != nullptr);
  return value;
}
inline void TestResults::clear_commit_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.commit_id_ != nullptr) _impl_.commit_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::tensorflow::CommitId& TestResults::_internal_commit_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::CommitId* p = _impl_.commit_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::CommitId&>(::tensorflow::_CommitId_default_instance_);
}
inline const ::tensorflow::CommitId& TestResults::commit_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.commit_id)
  return _internal_commit_id();
}
inline void TestResults::unsafe_arena_set_allocated_commit_id(::tensorflow::CommitId* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.commit_id_);
  }
  _impl_.commit_id_ = reinterpret_cast<::tensorflow::CommitId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TestResults.commit_id)
}
inline ::tensorflow::CommitId* TestResults::release_commit_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::CommitId* released = _impl_.commit_id_;
  _impl_.commit_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::CommitId* TestResults::unsafe_arena_release_commit_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.commit_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tensorflow::CommitId* temp = _impl_.commit_id_;
  _impl_.commit_id_ = nullptr;
  return temp;
}
inline ::tensorflow::CommitId* TestResults::_internal_mutable_commit_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.commit_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::CommitId>(GetArena());
    _impl_.commit_id_ = reinterpret_cast<::tensorflow::CommitId*>(p);
  }
  return _impl_.commit_id_;
}
inline ::tensorflow::CommitId* TestResults::mutable_commit_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tensorflow::CommitId* _msg = _internal_mutable_commit_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.commit_id)
  return _msg;
}
inline void TestResults::set_allocated_commit_id(::tensorflow::CommitId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.commit_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.commit_id_ = reinterpret_cast<::tensorflow::CommitId*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.commit_id)
}

// int64 start_time = 5;
inline void TestResults::clear_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t TestResults::start_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.start_time)
  return _internal_start_time();
}
inline void TestResults::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.start_time)
}
inline ::int64_t TestResults::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_time_;
}
inline void TestResults::_internal_set_start_time(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_ = value;
}

// double run_time = 6;
inline void TestResults::clear_run_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.run_time_ = 0;
}
inline double TestResults::run_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.run_time)
  return _internal_run_time();
}
inline void TestResults::set_run_time(double value) {
  _internal_set_run_time(value);
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.run_time)
}
inline double TestResults::_internal_run_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.run_time_;
}
inline void TestResults::_internal_set_run_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.run_time_ = value;
}

// .tensorflow.MachineConfiguration machine_configuration = 7;
inline bool TestResults::has_machine_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.machine_configuration_ != nullptr);
  return value;
}
inline void TestResults::clear_machine_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.machine_configuration_ != nullptr) _impl_.machine_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::tensorflow::MachineConfiguration& TestResults::_internal_machine_configuration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::MachineConfiguration* p = _impl_.machine_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::MachineConfiguration&>(::tensorflow::_MachineConfiguration_default_instance_);
}
inline const ::tensorflow::MachineConfiguration& TestResults::machine_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.machine_configuration)
  return _internal_machine_configuration();
}
inline void TestResults::unsafe_arena_set_allocated_machine_configuration(::tensorflow::MachineConfiguration* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.machine_configuration_);
  }
  _impl_.machine_configuration_ = reinterpret_cast<::tensorflow::MachineConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TestResults.machine_configuration)
}
inline ::tensorflow::MachineConfiguration* TestResults::release_machine_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tensorflow::MachineConfiguration* released = _impl_.machine_configuration_;
  _impl_.machine_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::MachineConfiguration* TestResults::unsafe_arena_release_machine_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.machine_configuration)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tensorflow::MachineConfiguration* temp = _impl_.machine_configuration_;
  _impl_.machine_configuration_ = nullptr;
  return temp;
}
inline ::tensorflow::MachineConfiguration* TestResults::_internal_mutable_machine_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.machine_configuration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::MachineConfiguration>(GetArena());
    _impl_.machine_configuration_ = reinterpret_cast<::tensorflow::MachineConfiguration*>(p);
  }
  return _impl_.machine_configuration_;
}
inline ::tensorflow::MachineConfiguration* TestResults::mutable_machine_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::tensorflow::MachineConfiguration* _msg = _internal_mutable_machine_configuration();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.machine_configuration)
  return _msg;
}
inline void TestResults::set_allocated_machine_configuration(::tensorflow::MachineConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.machine_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.machine_configuration_ = reinterpret_cast<::tensorflow::MachineConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.machine_configuration)
}

// .tensorflow.RunConfiguration run_configuration = 8;
inline bool TestResults::has_run_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.run_configuration_ != nullptr);
  return value;
}
inline void TestResults::clear_run_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.run_configuration_ != nullptr) _impl_.run_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::tensorflow::RunConfiguration& TestResults::_internal_run_configuration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::RunConfiguration* p = _impl_.run_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::RunConfiguration&>(::tensorflow::_RunConfiguration_default_instance_);
}
inline const ::tensorflow::RunConfiguration& TestResults::run_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.run_configuration)
  return _internal_run_configuration();
}
inline void TestResults::unsafe_arena_set_allocated_run_configuration(::tensorflow::RunConfiguration* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.run_configuration_);
  }
  _impl_.run_configuration_ = reinterpret_cast<::tensorflow::RunConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TestResults.run_configuration)
}
inline ::tensorflow::RunConfiguration* TestResults::release_run_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::tensorflow::RunConfiguration* released = _impl_.run_configuration_;
  _impl_.run_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tensorflow::RunConfiguration* TestResults::unsafe_arena_release_run_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.run_configuration)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::tensorflow::RunConfiguration* temp = _impl_.run_configuration_;
  _impl_.run_configuration_ = nullptr;
  return temp;
}
inline ::tensorflow::RunConfiguration* TestResults::_internal_mutable_run_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.run_configuration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::RunConfiguration>(GetArena());
    _impl_.run_configuration_ = reinterpret_cast<::tensorflow::RunConfiguration*>(p);
  }
  return _impl_.run_configuration_;
}
inline ::tensorflow::RunConfiguration* TestResults::mutable_run_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::tensorflow::RunConfiguration* _msg = _internal_mutable_run_configuration();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.run_configuration)
  return _msg;
}
inline void TestResults::set_allocated_run_configuration(::tensorflow::RunConfiguration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.run_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.run_configuration_ = reinterpret_cast<::tensorflow::RunConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.run_configuration)
}

// string name = 9;
inline void TestResults::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TestResults::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestResults::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.name)
}
inline std::string* TestResults::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.name)
  return _s;
}
inline const std::string& TestResults::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void TestResults::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TestResults::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TestResults::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.name)
  return _impl_.name_.Release();
}
inline void TestResults::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.name)
}

// .tensorflow.TestResults.BenchmarkType benchmark_type = 10;
inline void TestResults::clear_benchmark_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.benchmark_type_ = 0;
}
inline ::tensorflow::TestResults_BenchmarkType TestResults::benchmark_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.benchmark_type)
  return _internal_benchmark_type();
}
inline void TestResults::set_benchmark_type(::tensorflow::TestResults_BenchmarkType value) {
  _internal_set_benchmark_type(value);
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.benchmark_type)
}
inline ::tensorflow::TestResults_BenchmarkType TestResults::_internal_benchmark_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tensorflow::TestResults_BenchmarkType>(_impl_.benchmark_type_);
}
inline void TestResults::_internal_set_benchmark_type(::tensorflow::TestResults_BenchmarkType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.benchmark_type_ = value;
}

// string run_mode = 11;
inline void TestResults::clear_run_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.run_mode_.ClearToEmpty();
}
inline const std::string& TestResults::run_mode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.run_mode)
  return _internal_run_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestResults::set_run_mode(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.run_mode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.run_mode)
}
inline std::string* TestResults::mutable_run_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_run_mode();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.run_mode)
  return _s;
}
inline const std::string& TestResults::_internal_run_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.run_mode_.Get();
}
inline void TestResults::_internal_set_run_mode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.run_mode_.Set(value, GetArena());
}
inline std::string* TestResults::_internal_mutable_run_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.run_mode_.Mutable( GetArena());
}
inline std::string* TestResults::release_run_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.run_mode)
  return _impl_.run_mode_.Release();
}
inline void TestResults::set_allocated_run_mode(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.run_mode_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.run_mode_.IsDefault()) {
          _impl_.run_mode_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.run_mode)
}

// string tf_version = 12;
inline void TestResults::clear_tf_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tf_version_.ClearToEmpty();
}
inline const std::string& TestResults::tf_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.TestResults.tf_version)
  return _internal_tf_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestResults::set_tf_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tf_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tensorflow.TestResults.tf_version)
}
inline std::string* TestResults::mutable_tf_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tf_version();
  // @@protoc_insertion_point(field_mutable:tensorflow.TestResults.tf_version)
  return _s;
}
inline const std::string& TestResults::_internal_tf_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tf_version_.Get();
}
inline void TestResults::_internal_set_tf_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tf_version_.Set(value, GetArena());
}
inline std::string* TestResults::_internal_mutable_tf_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tf_version_.Mutable( GetArena());
}
inline std::string* TestResults::release_tf_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.TestResults.tf_version)
  return _impl_.tf_version_.Release();
}
inline void TestResults::set_allocated_tf_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tf_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tf_version_.IsDefault()) {
          _impl_.tf_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TestResults.tf_version)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tensorflow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tensorflow::TestResults_BenchmarkType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::TestResults_BenchmarkType>() {
  return ::tensorflow::TestResults_BenchmarkType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_xla_2ftsl_2fprotobuf_2ftest_5flog_2eproto_2epb_2eh
